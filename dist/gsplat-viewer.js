import * as Cn from "react";
import Fe, { useReducer as dP, useRef as Sn, useDebugValue as I8, useEffect as tr, useLayoutEffect as M0, useState as Ni, useMemo as Rl, useCallback as Ir, createElement as ca, Fragment as yI, forwardRef as Cu, Children as G1, isValidElement as ER, cloneElement as hP, createContext as vx, useContext as Tx, useImperativeHandle as pP } from "react";
function rw(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var HL = { exports: {} }, tT = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bN;
function B8() {
  if (bN)
    return tT;
  bN = 1;
  var n = Fe, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(c, h, p) {
    var y, x = {}, b = null, w = null;
    p !== void 0 && (b = "" + p), h.key !== void 0 && (b = "" + h.key), h.ref !== void 0 && (w = h.ref);
    for (y in h)
      r.call(h, y) && !o.hasOwnProperty(y) && (x[y] = h[y]);
    if (c && c.defaultProps)
      for (y in h = c.defaultProps, h)
        x[y] === void 0 && (x[y] = h[y]);
    return { $$typeof: e, type: c, key: b, ref: w, props: x, _owner: i.current };
  }
  return tT.Fragment = t, tT.jsx = l, tT.jsxs = l, tT;
}
var nT = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TN;
function H8() {
  return TN || (TN = 1, process.env.NODE_ENV !== "production" && function() {
    var n = Fe, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), c = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), b = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), R = Symbol.iterator, U = "@@iterator";
    function L(De) {
      if (De === null || typeof De != "object")
        return null;
      var Ft = R && De[R] || De[U];
      return typeof Ft == "function" ? Ft : null;
    }
    var A = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function F(De) {
      {
        for (var Ft = arguments.length, qt = new Array(Ft > 1 ? Ft - 1 : 0), En = 1; En < Ft; En++)
          qt[En - 1] = arguments[En];
        k("error", De, qt);
      }
    }
    function k(De, Ft, qt) {
      {
        var En = A.ReactDebugCurrentFrame, ye = En.getStackAddendum();
        ye !== "" && (Ft += "%s", qt = qt.concat([ye]));
        var qe = qt.map(function(tt) {
          return String(tt);
        });
        qe.unshift("Warning: " + Ft), Function.prototype.apply.call(console[De], console, qe);
      }
    }
    var H = !1, B = !1, $ = !1, Y = !1, J = !1, K;
    K = Symbol.for("react.module.reference");
    function X(De) {
      return !!(typeof De == "string" || typeof De == "function" || De === r || De === o || J || De === i || De === p || De === y || Y || De === w || H || B || $ || typeof De == "object" && De !== null && (De.$$typeof === b || De.$$typeof === x || De.$$typeof === l || De.$$typeof === c || De.$$typeof === h || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      De.$$typeof === K || De.getModuleId !== void 0));
    }
    function le(De, Ft, qt) {
      var En = De.displayName;
      if (En)
        return En;
      var ye = Ft.displayName || Ft.name || "";
      return ye !== "" ? qt + "(" + ye + ")" : qt;
    }
    function oe(De) {
      return De.displayName || "Context";
    }
    function fe(De) {
      if (De == null)
        return null;
      if (typeof De.tag == "number" && F("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof De == "function")
        return De.displayName || De.name || null;
      if (typeof De == "string")
        return De;
      switch (De) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case p:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof De == "object")
        switch (De.$$typeof) {
          case c:
            var Ft = De;
            return oe(Ft) + ".Consumer";
          case l:
            var qt = De;
            return oe(qt._context) + ".Provider";
          case h:
            return le(De, De.render, "ForwardRef");
          case x:
            var En = De.displayName || null;
            return En !== null ? En : fe(De.type) || "Memo";
          case b: {
            var ye = De, qe = ye._payload, tt = ye._init;
            try {
              return fe(tt(qe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var de = Object.assign, xe = 0, _e, Pe, ce, ve, re, ee, he;
    function Me() {
    }
    Me.__reactDisabledLog = !0;
    function Le() {
      {
        if (xe === 0) {
          _e = console.log, Pe = console.info, ce = console.warn, ve = console.error, re = console.group, ee = console.groupCollapsed, he = console.groupEnd;
          var De = {
            configurable: !0,
            enumerable: !0,
            value: Me,
            writable: !0
          };
          Object.defineProperties(console, {
            info: De,
            log: De,
            warn: De,
            error: De,
            group: De,
            groupCollapsed: De,
            groupEnd: De
          });
        }
        xe++;
      }
    }
    function Ae() {
      {
        if (xe--, xe === 0) {
          var De = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: de({}, De, {
              value: _e
            }),
            info: de({}, De, {
              value: Pe
            }),
            warn: de({}, De, {
              value: ce
            }),
            error: de({}, De, {
              value: ve
            }),
            group: de({}, De, {
              value: re
            }),
            groupCollapsed: de({}, De, {
              value: ee
            }),
            groupEnd: de({}, De, {
              value: he
            })
          });
        }
        xe < 0 && F("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ue = A.ReactCurrentDispatcher, Ne;
    function ke(De, Ft, qt) {
      {
        if (Ne === void 0)
          try {
            throw Error();
          } catch (ye) {
            var En = ye.stack.trim().match(/\n( *(at )?)/);
            Ne = En && En[1] || "";
          }
        return `
` + Ne + De;
      }
    }
    var it = !1, At;
    {
      var rt = typeof WeakMap == "function" ? WeakMap : Map;
      At = new rt();
    }
    function ae(De, Ft) {
      if (!De || it)
        return "";
      {
        var qt = At.get(De);
        if (qt !== void 0)
          return qt;
      }
      var En;
      it = !0;
      var ye = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var qe;
      qe = Ue.current, Ue.current = null, Le();
      try {
        if (Ft) {
          var tt = function() {
            throw Error();
          };
          if (Object.defineProperty(tt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(tt, []);
            } catch (bt) {
              En = bt;
            }
            Reflect.construct(De, [], tt);
          } else {
            try {
              tt.call();
            } catch (bt) {
              En = bt;
            }
            De.call(tt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (bt) {
            En = bt;
          }
          De();
        }
      } catch (bt) {
        if (bt && En && typeof bt.stack == "string") {
          for (var Ve = bt.stack.split(`
`), pt = En.stack.split(`
`), en = Ve.length - 1, cn = pt.length - 1; en >= 1 && cn >= 0 && Ve[en] !== pt[cn]; )
            cn--;
          for (; en >= 1 && cn >= 0; en--, cn--)
            if (Ve[en] !== pt[cn]) {
              if (en !== 1 || cn !== 1)
                do
                  if (en--, cn--, cn < 0 || Ve[en] !== pt[cn]) {
                    var xn = `
` + Ve[en].replace(" at new ", " at ");
                    return De.displayName && xn.includes("<anonymous>") && (xn = xn.replace("<anonymous>", De.displayName)), typeof De == "function" && At.set(De, xn), xn;
                  }
                while (en >= 1 && cn >= 0);
              break;
            }
        }
      } finally {
        it = !1, Ue.current = qe, Ae(), Error.prepareStackTrace = ye;
      }
      var Nn = De ? De.displayName || De.name : "", lr = Nn ? ke(Nn) : "";
      return typeof De == "function" && At.set(De, lr), lr;
    }
    function et(De, Ft, qt) {
      return ae(De, !1);
    }
    function Ye(De) {
      var Ft = De.prototype;
      return !!(Ft && Ft.isReactComponent);
    }
    function Ge(De, Ft, qt) {
      if (De == null)
        return "";
      if (typeof De == "function")
        return ae(De, Ye(De));
      if (typeof De == "string")
        return ke(De);
      switch (De) {
        case p:
          return ke("Suspense");
        case y:
          return ke("SuspenseList");
      }
      if (typeof De == "object")
        switch (De.$$typeof) {
          case h:
            return et(De.render);
          case x:
            return Ge(De.type, Ft, qt);
          case b: {
            var En = De, ye = En._payload, qe = En._init;
            try {
              return Ge(qe(ye), Ft, qt);
            } catch {
            }
          }
        }
      return "";
    }
    var $e = Object.prototype.hasOwnProperty, Ut = {}, nt = A.ReactDebugCurrentFrame;
    function Ct(De) {
      if (De) {
        var Ft = De._owner, qt = Ge(De.type, De._source, Ft ? Ft.type : null);
        nt.setExtraStackFrame(qt);
      } else
        nt.setExtraStackFrame(null);
    }
    function Pt(De, Ft, qt, En, ye) {
      {
        var qe = Function.call.bind($e);
        for (var tt in De)
          if (qe(De, tt)) {
            var Ve = void 0;
            try {
              if (typeof De[tt] != "function") {
                var pt = Error((En || "React class") + ": " + qt + " type `" + tt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof De[tt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              Ve = De[tt](Ft, tt, En, qt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (en) {
              Ve = en;
            }
            Ve && !(Ve instanceof Error) && (Ct(ye), F("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", En || "React class", qt, tt, typeof Ve), Ct(null)), Ve instanceof Error && !(Ve.message in Ut) && (Ut[Ve.message] = !0, Ct(ye), F("Failed %s type: %s", qt, Ve.message), Ct(null));
          }
      }
    }
    var vt = Array.isArray;
    function Zt(De) {
      return vt(De);
    }
    function ie(De) {
      {
        var Ft = typeof Symbol == "function" && Symbol.toStringTag, qt = Ft && De[Symbol.toStringTag] || De.constructor.name || "Object";
        return qt;
      }
    }
    function ne(De) {
      try {
        return Oe(De), !1;
      } catch {
        return !0;
      }
    }
    function Oe(De) {
      return "" + De;
    }
    function _t(De) {
      if (ne(De))
        return F("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ie(De)), Oe(De);
    }
    var ot = A.ReactCurrentOwner, at = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Wt, Dt, Se;
    Se = {};
    function He(De) {
      if ($e.call(De, "ref")) {
        var Ft = Object.getOwnPropertyDescriptor(De, "ref").get;
        if (Ft && Ft.isReactWarning)
          return !1;
      }
      return De.ref !== void 0;
    }
    function lt(De) {
      if ($e.call(De, "key")) {
        var Ft = Object.getOwnPropertyDescriptor(De, "key").get;
        if (Ft && Ft.isReactWarning)
          return !1;
      }
      return De.key !== void 0;
    }
    function St(De, Ft) {
      if (typeof De.ref == "string" && ot.current && Ft && ot.current.stateNode !== Ft) {
        var qt = fe(ot.current.type);
        Se[qt] || (F('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', fe(ot.current.type), De.ref), Se[qt] = !0);
      }
    }
    function Je(De, Ft) {
      {
        var qt = function() {
          Wt || (Wt = !0, F("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ft));
        };
        qt.isReactWarning = !0, Object.defineProperty(De, "key", {
          get: qt,
          configurable: !0
        });
      }
    }
    function be(De, Ft) {
      {
        var qt = function() {
          Dt || (Dt = !0, F("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ft));
        };
        qt.isReactWarning = !0, Object.defineProperty(De, "ref", {
          get: qt,
          configurable: !0
        });
      }
    }
    var Ze = function(De, Ft, qt, En, ye, qe, tt) {
      var Ve = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: De,
        key: Ft,
        ref: qt,
        props: tt,
        // Record the component responsible for creating this element.
        _owner: qe
      };
      return Ve._store = {}, Object.defineProperty(Ve._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ve, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: En
      }), Object.defineProperty(Ve, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ye
      }), Object.freeze && (Object.freeze(Ve.props), Object.freeze(Ve)), Ve;
    };
    function ct(De, Ft, qt, En, ye) {
      {
        var qe, tt = {}, Ve = null, pt = null;
        qt !== void 0 && (_t(qt), Ve = "" + qt), lt(Ft) && (_t(Ft.key), Ve = "" + Ft.key), He(Ft) && (pt = Ft.ref, St(Ft, ye));
        for (qe in Ft)
          $e.call(Ft, qe) && !at.hasOwnProperty(qe) && (tt[qe] = Ft[qe]);
        if (De && De.defaultProps) {
          var en = De.defaultProps;
          for (qe in en)
            tt[qe] === void 0 && (tt[qe] = en[qe]);
        }
        if (Ve || pt) {
          var cn = typeof De == "function" ? De.displayName || De.name || "Unknown" : De;
          Ve && Je(tt, cn), pt && be(tt, cn);
        }
        return Ze(De, Ve, pt, ye, En, ot.current, tt);
      }
    }
    var pe = A.ReactCurrentOwner, Rt = A.ReactDebugCurrentFrame;
    function Be(De) {
      if (De) {
        var Ft = De._owner, qt = Ge(De.type, De._source, Ft ? Ft.type : null);
        Rt.setExtraStackFrame(qt);
      } else
        Rt.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function on(De) {
      return typeof De == "object" && De !== null && De.$$typeof === e;
    }
    function zn() {
      {
        if (pe.current) {
          var De = fe(pe.current.type);
          if (De)
            return `

Check the render method of \`` + De + "`.";
        }
        return "";
      }
    }
    function Gn(De) {
      {
        if (De !== void 0) {
          var Ft = De.fileName.replace(/^.*[\\\/]/, ""), qt = De.lineNumber;
          return `

Check your code at ` + Ft + ":" + qt + ".";
        }
        return "";
      }
    }
    var rr = {};
    function mn(De) {
      {
        var Ft = zn();
        if (!Ft) {
          var qt = typeof De == "string" ? De : De.displayName || De.name;
          qt && (Ft = `

Check the top-level render call using <` + qt + ">.");
        }
        return Ft;
      }
    }
    function er(De, Ft) {
      {
        if (!De._store || De._store.validated || De.key != null)
          return;
        De._store.validated = !0;
        var qt = mn(Ft);
        if (rr[qt])
          return;
        rr[qt] = !0;
        var En = "";
        De && De._owner && De._owner !== pe.current && (En = " It was passed a child from " + fe(De._owner.type) + "."), Be(De), F('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', qt, En), Be(null);
      }
    }
    function ir(De, Ft) {
      {
        if (typeof De != "object")
          return;
        if (Zt(De))
          for (var qt = 0; qt < De.length; qt++) {
            var En = De[qt];
            on(En) && er(En, Ft);
          }
        else if (on(De))
          De._store && (De._store.validated = !0);
        else if (De) {
          var ye = L(De);
          if (typeof ye == "function" && ye !== De.entries)
            for (var qe = ye.call(De), tt; !(tt = qe.next()).done; )
              on(tt.value) && er(tt.value, Ft);
        }
      }
    }
    function Wn(De) {
      {
        var Ft = De.type;
        if (Ft == null || typeof Ft == "string")
          return;
        var qt;
        if (typeof Ft == "function")
          qt = Ft.propTypes;
        else if (typeof Ft == "object" && (Ft.$$typeof === h || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ft.$$typeof === x))
          qt = Ft.propTypes;
        else
          return;
        if (qt) {
          var En = fe(Ft);
          Pt(qt, De.props, "prop", En, De);
        } else if (Ft.PropTypes !== void 0 && !ut) {
          ut = !0;
          var ye = fe(Ft);
          F("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ye || "Unknown");
        }
        typeof Ft.getDefaultProps == "function" && !Ft.getDefaultProps.isReactClassApproved && F("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ei(De) {
      {
        for (var Ft = Object.keys(De.props), qt = 0; qt < Ft.length; qt++) {
          var En = Ft[qt];
          if (En !== "children" && En !== "key") {
            Be(De), F("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", En), Be(null);
            break;
          }
        }
        De.ref !== null && (Be(De), F("Invalid attribute `ref` supplied to `React.Fragment`."), Be(null));
      }
    }
    function Wr(De, Ft, qt, En, ye, qe) {
      {
        var tt = X(De);
        if (!tt) {
          var Ve = "";
          (De === void 0 || typeof De == "object" && De !== null && Object.keys(De).length === 0) && (Ve += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = Gn(ye);
          pt ? Ve += pt : Ve += zn();
          var en;
          De === null ? en = "null" : Zt(De) ? en = "array" : De !== void 0 && De.$$typeof === e ? (en = "<" + (fe(De.type) || "Unknown") + " />", Ve = " Did you accidentally export a JSX literal instead of a component?") : en = typeof De, F("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", en, Ve);
        }
        var cn = ct(De, Ft, qt, ye, qe);
        if (cn == null)
          return cn;
        if (tt) {
          var xn = Ft.children;
          if (xn !== void 0)
            if (En)
              if (Zt(xn)) {
                for (var Nn = 0; Nn < xn.length; Nn++)
                  ir(xn[Nn], De);
                Object.freeze && Object.freeze(xn);
              } else
                F("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ir(xn, De);
        }
        return De === r ? Ei(cn) : Wn(cn), cn;
      }
    }
    function Br(De, Ft, qt) {
      return Wr(De, Ft, qt, !0);
    }
    function Mr(De, Ft, qt) {
      return Wr(De, Ft, qt, !1);
    }
    var Ri = Mr, si = Br;
    nT.Fragment = r, nT.jsx = Ri, nT.jsxs = si;
  }()), nT;
}
process.env.NODE_ENV === "production" ? HL.exports = B8() : HL.exports = H8();
var Vo = HL.exports;
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const jR = "156", JS = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, ex = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, SI = 0, VL = 1, xI = 2, V8 = 3, _I = 0, $R = 1, bT = 2, um = 3, wv = 0, Ic = 1, dp = 2, G8 = 2, Gg = 0, ux = 1, GL = 2, WL = 3, jL = 4, EI = 5, nx = 100, bI = 101, TI = 102, $L = 103, YL = 104, wI = 200, MI = 201, CI = 202, RI = 203, mP = 204, vP = 205, AI = 206, DI = 207, LI = 208, OI = 209, PI = 210, UI = 0, NI = 1, FI = 2, bR = 3, kI = 4, zI = 5, II = 6, BI = 7, iw = 0, HI = 1, VI = 2, Ev = 0, GI = 1, WI = 2, jI = 3, gP = 4, $I = 5, YR = 300, jg = 301, S0 = 302, UT = 303, NT = 304, tE = 306, FT = 1e3, kc = 1001, kT = 1002, ol = 1003, TR = 1004, W8 = 1004, TT = 1005, j8 = 1005, ss = 1006, yP = 1007, $8 = 1007, x0 = 1008, Y8 = 1008, bv = 1009, YI = 1010, XI = 1011, XR = 1012, SP = 1013, Hg = 1014, xv = 1015, X1 = 1016, xP = 1017, _P = 1018, m0 = 1020, qI = 1021, Td = 1023, KI = 1024, QI = 1025, v0 = 1026, gx = 1027, ZI = 1028, EP = 1029, JI = 1030, bP = 1031, TP = 1033, cR = 33776, fR = 33777, dR = 33778, hR = 33779, XL = 35840, qL = 35841, KL = 35842, QL = 35843, e4 = 36196, ZL = 37492, JL = 37496, eO = 37808, tO = 37809, nO = 37810, rO = 37811, iO = 37812, aO = 37813, oO = 37814, sO = 37815, lO = 37816, uO = 37817, cO = 37818, fO = 37819, dO = 37820, hO = 37821, pR = 36492, pO = 36494, mO = 36495, t4 = 36283, vO = 36284, gO = 36285, yO = 36286, n4 = 2200, r4 = 2201, i4 = 2202, zT = 2300, IT = 2301, mR = 2302, ix = 2400, ax = 2401, BT = 2402, qR = 2500, wP = 2501, X8 = 0, q8 = 1, K8 = 2, MP = 3e3, g0 = 3001, a4 = 3200, CP = 3201, C0 = 0, o4 = 1, y0 = "", go = "srgb", dm = "srgb-linear", aw = "display-p3", Q8 = "display-p3-linear", Z8 = 0, vR = 7680, J8 = 7681, eG = 7682, tG = 7683, nG = 34055, rG = 34056, iG = 5386, aG = 512, oG = 513, sG = 514, lG = 515, uG = 516, cG = 517, fG = 518, s4 = 519, l4 = 512, u4 = 513, c4 = 514, f4 = 515, d4 = 516, h4 = 517, p4 = 518, m4 = 519, HT = 35044, dG = 35048, hG = 35040, pG = 35045, mG = 35049, vG = 35041, gG = 35046, yG = 35050, SG = 35042, xG = "100", SO = "300 es", wR = 1035, _v = 2e3, VT = 2001;
class Av {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
}
const Nc = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let wN = 1234567;
const cx = Math.PI / 180, q1 = 180 / Math.PI;
function yh() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Nc[n & 255] + Nc[n >> 8 & 255] + Nc[n >> 16 & 255] + Nc[n >> 24 & 255] + "-" + Nc[e & 255] + Nc[e >> 8 & 255] + "-" + Nc[e >> 16 & 15 | 64] + Nc[e >> 24 & 255] + "-" + Nc[t & 63 | 128] + Nc[t >> 8 & 255] + "-" + Nc[t >> 16 & 255] + Nc[t >> 24 & 255] + Nc[r & 255] + Nc[r >> 8 & 255] + Nc[r >> 16 & 255] + Nc[r >> 24 & 255]).toLowerCase();
}
function Os(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function RP(n, e) {
  return (n % e + e) % e;
}
function _G(n, e, t, r, i) {
  return r + (n - e) * (i - r) / (t - e);
}
function EG(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function wT(n, e, t) {
  return (1 - t) * n + t * e;
}
function bG(n, e, t, r) {
  return wT(n, e, 1 - Math.exp(-t * r));
}
function TG(n, e = 1) {
  return e - Math.abs(RP(n, e * 2) - e);
}
function wG(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function MG(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function CG(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function RG(n, e) {
  return n + Math.random() * (e - n);
}
function AG(n) {
  return n * (0.5 - Math.random());
}
function DG(n) {
  n !== void 0 && (wN = n);
  let e = wN += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function LG(n) {
  return n * cx;
}
function OG(n) {
  return n * q1;
}
function xO(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function v4(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function MR(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function PG(n, e, t, r, i) {
  const o = Math.cos, l = Math.sin, c = o(t / 2), h = l(t / 2), p = o((e + r) / 2), y = l((e + r) / 2), x = o((e - r) / 2), b = l((e - r) / 2), w = o((r - e) / 2), R = l((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(c * y, h * x, h * b, c * p);
      break;
    case "YZY":
      n.set(h * b, c * y, h * x, c * p);
      break;
    case "ZXZ":
      n.set(h * x, h * b, c * y, c * p);
      break;
    case "XZX":
      n.set(c * y, h * R, h * w, c * p);
      break;
    case "YXY":
      n.set(h * w, c * y, h * R, c * p);
      break;
    case "ZYZ":
      n.set(h * R, h * w, c * y, c * p);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function wd(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ai(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const g4 = {
  DEG2RAD: cx,
  RAD2DEG: q1,
  generateUUID: yh,
  clamp: Os,
  euclideanModulo: RP,
  mapLinear: _G,
  inverseLerp: EG,
  lerp: wT,
  damp: bG,
  pingpong: TG,
  smoothstep: wG,
  smootherstep: MG,
  randInt: CG,
  randFloat: RG,
  randFloatSpread: AG,
  seededRandom: DG,
  degToRad: LG,
  radToDeg: OG,
  isPowerOfTwo: xO,
  ceilPowerOfTwo: v4,
  floorPowerOfTwo: MR,
  setQuaternionFromProperEuler: PG,
  normalize: ai,
  denormalize: wd
};
class Ht {
  constructor(e = 0, t = 0) {
    Ht.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Os(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), i = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * r - l * i + e.x, this.y = o * i + l * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ii {
  constructor(e, t, r, i, o, l, c, h, p) {
    ii.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, i, o, l, c, h, p);
  }
  set(e, t, r, i, o, l, c, h, p) {
    const y = this.elements;
    return y[0] = e, y[1] = i, y[2] = c, y[3] = t, y[4] = o, y[5] = h, y[6] = r, y[7] = l, y[8] = p, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, o = this.elements, l = r[0], c = r[3], h = r[6], p = r[1], y = r[4], x = r[7], b = r[2], w = r[5], R = r[8], U = i[0], L = i[3], A = i[6], F = i[1], k = i[4], H = i[7], B = i[2], $ = i[5], Y = i[8];
    return o[0] = l * U + c * F + h * B, o[3] = l * L + c * k + h * $, o[6] = l * A + c * H + h * Y, o[1] = p * U + y * F + x * B, o[4] = p * L + y * k + x * $, o[7] = p * A + y * H + x * Y, o[2] = b * U + w * F + R * B, o[5] = b * L + w * k + R * $, o[8] = b * A + w * H + R * Y, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], c = e[5], h = e[6], p = e[7], y = e[8];
    return t * l * y - t * c * p - r * o * y + r * c * h + i * o * p - i * l * h;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], c = e[5], h = e[6], p = e[7], y = e[8], x = y * l - c * p, b = c * h - y * o, w = p * o - l * h, R = t * x + r * b + i * w;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const U = 1 / R;
    return e[0] = x * U, e[1] = (i * p - y * r) * U, e[2] = (c * r - i * l) * U, e[3] = b * U, e[4] = (y * t - i * h) * U, e[5] = (i * o - c * t) * U, e[6] = w * U, e[7] = (r * h - p * t) * U, e[8] = (l * t - r * o) * U, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, i, o, l, c) {
    const h = Math.cos(o), p = Math.sin(o);
    return this.set(
      r * h,
      r * p,
      -r * (h * l + p * c) + l + e,
      -i * p,
      i * h,
      -i * (-p * l + h * c) + c + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(CD.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(CD.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(CD.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const CD = /* @__PURE__ */ new ii();
function y4(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535)
      return !0;
  return !1;
}
const UG = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function F1(n, e) {
  return new UG[n](e);
}
function GT(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function S4() {
  const n = GT("canvas");
  return n.style.display = "block", n;
}
const MN = {};
function MT(n) {
  n in MN || (MN[n] = !0, console.warn(n));
}
function W1(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function RD(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const NG = /* @__PURE__ */ new ii().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]), FG = /* @__PURE__ */ new ii().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function kG(n) {
  return n.convertSRGBToLinear().applyMatrix3(FG);
}
function zG(n) {
  return n.applyMatrix3(NG).convertLinearToSRGB();
}
const IG = {
  [dm]: (n) => n,
  [go]: (n) => n.convertSRGBToLinear(),
  [aw]: kG
}, BG = {
  [dm]: (n) => n,
  [go]: (n) => n.convertLinearToSRGB(),
  [aw]: zG
}, up = {
  enabled: !0,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(n) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n;
  },
  get workingColorSpace() {
    return dm;
  },
  set workingColorSpace(n) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(n, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return n;
    const r = IG[e], i = BG[t];
    if (r === void 0 || i === void 0)
      throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
    return i(r(n));
  },
  fromWorkingColorSpace: function(n, e) {
    return this.convert(n, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(n, e) {
    return this.convert(n, e, this.workingColorSpace);
  }
};
let o1;
class AP {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      o1 === void 0 && (o1 = GT("canvas")), o1.width = e.width, o1.height = e.height;
      const r = o1.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = o1;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = GT("canvas");
      t.width = e.width, t.height = e.height;
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height), o = i.data;
      for (let l = 0; l < o.length; l++)
        o[l] = W1(o[l] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(W1(t[r] / 255) * 255) : t[r] = W1(t[r]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let HG = 0;
class ox {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: HG++ }), this.uuid = yh(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const r = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let l = 0, c = i.length; l < c; l++)
          i[l].isDataTexture ? o.push(AD(i[l].image)) : o.push(AD(i[l]));
      } else
        o = AD(i);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function AD(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? AP.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let VG = 0;
class cs extends Av {
  constructor(e = cs.DEFAULT_IMAGE, t = cs.DEFAULT_MAPPING, r = kc, i = kc, o = ss, l = x0, c = Td, h = bv, p = cs.DEFAULT_ANISOTROPY, y = y0) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: VG++ }), this.uuid = yh(), this.name = "", this.source = new ox(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = o, this.minFilter = l, this.anisotropy = p, this.format = c, this.internalFormat = null, this.type = h, this.offset = new Ht(0, 0), this.repeat = new Ht(1, 1), this.center = new Ht(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ii(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof y == "string" ? this.colorSpace = y : (MT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = y === g0 ? go : y0), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const r = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== YR)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case FT:
          e.x = e.x - Math.floor(e.x);
          break;
        case kc:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case kT:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case FT:
          e.y = e.y - Math.floor(e.y);
          break;
        case kc:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case kT:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return MT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === go ? g0 : MP;
  }
  set encoding(e) {
    MT("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === g0 ? go : y0;
  }
}
cs.DEFAULT_IMAGE = null;
cs.DEFAULT_MAPPING = YR;
cs.DEFAULT_ANISOTROPY = 1;
class ua {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    ua.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * r + l[8] * i + l[12] * o, this.y = l[1] * t + l[5] * r + l[9] * i + l[13] * o, this.z = l[2] * t + l[6] * r + l[10] * i + l[14] * o, this.w = l[3] * t + l[7] * r + l[11] * i + l[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, o;
    const h = e.elements, p = h[0], y = h[4], x = h[8], b = h[1], w = h[5], R = h[9], U = h[2], L = h[6], A = h[10];
    if (Math.abs(y - b) < 0.01 && Math.abs(x - U) < 0.01 && Math.abs(R - L) < 0.01) {
      if (Math.abs(y + b) < 0.1 && Math.abs(x + U) < 0.1 && Math.abs(R + L) < 0.1 && Math.abs(p + w + A - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const k = (p + 1) / 2, H = (w + 1) / 2, B = (A + 1) / 2, $ = (y + b) / 4, Y = (x + U) / 4, J = (R + L) / 4;
      return k > H && k > B ? k < 0.01 ? (r = 0, i = 0.707106781, o = 0.707106781) : (r = Math.sqrt(k), i = $ / r, o = Y / r) : H > B ? H < 0.01 ? (r = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(H), r = $ / i, o = J / i) : B < 0.01 ? (r = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(B), r = Y / o, i = J / o), this.set(r, i, o, t), this;
    }
    let F = Math.sqrt((L - R) * (L - R) + (x - U) * (x - U) + (b - y) * (b - y));
    return Math.abs(F) < 1e-3 && (F = 1), this.x = (L - R) / F, this.y = (x - U) / F, this.z = (b - y) / F, this.w = Math.acos((p + w + A - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class x4 extends Av {
  constructor(e = 1, t = 1, r = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ua(0, 0, e, t), this.scissorTest = !1, this.viewport = new ua(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    r.encoding !== void 0 && (MT("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), r.colorSpace = r.encoding === g0 ? go : y0), this.texture = new cs(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : ss, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0;
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ox(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class hm extends x4 {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), this.isWebGLRenderTarget = !0;
  }
}
class KR extends cs {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = ol, this.minFilter = ol, this.wrapR = kc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class GG extends hm {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new KR(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class DP extends cs {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = ol, this.minFilter = ol, this.wrapR = kc, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class WG extends hm {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new DP(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class jG extends hm {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const o = this.texture;
    this.texture = [];
    for (let l = 0; l < r; l++)
      this.texture[l] = o.clone(), this.texture[l].isRenderTargetTexture = !0;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      this.width = e, this.height = t, this.depth = r;
      for (let i = 0, o = this.texture.length; i < o; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = r;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, r = e.texture.length; t < r; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Bc {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i;
  }
  static slerpFlat(e, t, r, i, o, l, c) {
    let h = r[i + 0], p = r[i + 1], y = r[i + 2], x = r[i + 3];
    const b = o[l + 0], w = o[l + 1], R = o[l + 2], U = o[l + 3];
    if (c === 0) {
      e[t + 0] = h, e[t + 1] = p, e[t + 2] = y, e[t + 3] = x;
      return;
    }
    if (c === 1) {
      e[t + 0] = b, e[t + 1] = w, e[t + 2] = R, e[t + 3] = U;
      return;
    }
    if (x !== U || h !== b || p !== w || y !== R) {
      let L = 1 - c;
      const A = h * b + p * w + y * R + x * U, F = A >= 0 ? 1 : -1, k = 1 - A * A;
      if (k > Number.EPSILON) {
        const B = Math.sqrt(k), $ = Math.atan2(B, A * F);
        L = Math.sin(L * $) / B, c = Math.sin(c * $) / B;
      }
      const H = c * F;
      if (h = h * L + b * H, p = p * L + w * H, y = y * L + R * H, x = x * L + U * H, L === 1 - c) {
        const B = 1 / Math.sqrt(h * h + p * p + y * y + x * x);
        h *= B, p *= B, y *= B, x *= B;
      }
    }
    e[t] = h, e[t + 1] = p, e[t + 2] = y, e[t + 3] = x;
  }
  static multiplyQuaternionsFlat(e, t, r, i, o, l) {
    const c = r[i], h = r[i + 1], p = r[i + 2], y = r[i + 3], x = o[l], b = o[l + 1], w = o[l + 2], R = o[l + 3];
    return e[t] = c * R + y * x + h * w - p * b, e[t + 1] = h * R + y * b + p * x - c * w, e[t + 2] = p * R + y * w + c * b - h * x, e[t + 3] = y * R - c * x - h * b - p * w, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, i) {
    return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const r = e._x, i = e._y, o = e._z, l = e._order, c = Math.cos, h = Math.sin, p = c(r / 2), y = c(i / 2), x = c(o / 2), b = h(r / 2), w = h(i / 2), R = h(o / 2);
    switch (l) {
      case "XYZ":
        this._x = b * y * x + p * w * R, this._y = p * w * x - b * y * R, this._z = p * y * R + b * w * x, this._w = p * y * x - b * w * R;
        break;
      case "YXZ":
        this._x = b * y * x + p * w * R, this._y = p * w * x - b * y * R, this._z = p * y * R - b * w * x, this._w = p * y * x + b * w * R;
        break;
      case "ZXY":
        this._x = b * y * x - p * w * R, this._y = p * w * x + b * y * R, this._z = p * y * R + b * w * x, this._w = p * y * x - b * w * R;
        break;
      case "ZYX":
        this._x = b * y * x - p * w * R, this._y = p * w * x + b * y * R, this._z = p * y * R - b * w * x, this._w = p * y * x + b * w * R;
        break;
      case "YZX":
        this._x = b * y * x + p * w * R, this._y = p * w * x + b * y * R, this._z = p * y * R - b * w * x, this._w = p * y * x - b * w * R;
        break;
      case "XZY":
        this._x = b * y * x - p * w * R, this._y = p * w * x - b * y * R, this._z = p * y * R + b * w * x, this._w = p * y * x + b * w * R;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, i = Math.sin(r);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], i = t[4], o = t[8], l = t[1], c = t[5], h = t[9], p = t[2], y = t[6], x = t[10], b = r + c + x;
    if (b > 0) {
      const w = 0.5 / Math.sqrt(b + 1);
      this._w = 0.25 / w, this._x = (y - h) * w, this._y = (o - p) * w, this._z = (l - i) * w;
    } else if (r > c && r > x) {
      const w = 2 * Math.sqrt(1 + r - c - x);
      this._w = (y - h) / w, this._x = 0.25 * w, this._y = (i + l) / w, this._z = (o + p) / w;
    } else if (c > x) {
      const w = 2 * Math.sqrt(1 + c - r - x);
      this._w = (o - p) / w, this._x = (i + l) / w, this._y = 0.25 * w, this._z = (h + y) / w;
    } else {
      const w = 2 * Math.sqrt(1 + x - r - c);
      this._w = (l - i) / w, this._x = (o + p) / w, this._y = (h + y) / w, this._z = 0.25 * w;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Os(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, i = e._y, o = e._z, l = e._w, c = t._x, h = t._y, p = t._z, y = t._w;
    return this._x = r * y + l * c + i * p - o * h, this._y = i * y + l * h + o * c - r * p, this._z = o * y + l * p + r * h - i * c, this._w = l * y - r * c - i * h - o * p, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, i = this._y, o = this._z, l = this._w;
    let c = l * e._w + r * e._x + i * e._y + o * e._z;
    if (c < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, c = -c) : this.copy(e), c >= 1)
      return this._w = l, this._x = r, this._y = i, this._z = o, this;
    const h = 1 - c * c;
    if (h <= Number.EPSILON) {
      const w = 1 - t;
      return this._w = w * l + t * this._w, this._x = w * r + t * this._x, this._y = w * i + t * this._y, this._z = w * o + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const p = Math.sqrt(h), y = Math.atan2(p, c), x = Math.sin((1 - t) * y) / p, b = Math.sin(t * y) / p;
    return this._w = l * x + this._w * b, this._x = r * x + this._x * b, this._y = i * x + this._y * b, this._z = o * x + this._z * b, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), i = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      r * Math.sin(o),
      r * Math.cos(o),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Te {
  constructor(e = 0, t = 0, r = 0) {
    Te.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(CN.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(CN.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * r + o[6] * i, this.y = o[1] * t + o[4] * r + o[7] * i, this.z = o[2] * t + o[5] * r + o[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]);
    return this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * l, this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * l, this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, i = this.z, o = e.x, l = e.y, c = e.z, h = e.w, p = h * t + l * i - c * r, y = h * r + c * t - o * i, x = h * i + o * r - l * t, b = -o * t - l * r - c * i;
    return this.x = p * h + b * -o + y * -c - x * -l, this.y = y * h + b * -l + x * -o - p * -c, this.z = x * h + b * -c + p * -l - y * -o, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * r + o[8] * i, this.y = o[1] * t + o[5] * r + o[9] * i, this.z = o[2] * t + o[6] * r + o[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, i = e.y, o = e.z, l = t.x, c = t.y, h = t.z;
    return this.x = i * h - o * c, this.y = o * l - r * h, this.z = r * c - i * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return DD.copy(this).projectOnVector(e), this.sub(DD);
  }
  reflect(e) {
    return this.sub(DD.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Os(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const DD = /* @__PURE__ */ new Te(), CN = /* @__PURE__ */ new Bc();
class mm {
  constructor(e = new Te(1 / 0, 1 / 0, 1 / 0), t = new Te(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Dg.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Dg.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Dg.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0)
      e.boundingBox === null && e.computeBoundingBox(), s1.copy(e.boundingBox), s1.applyMatrix4(e.matrixWorld), this.union(s1);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const o = i.attributes.position;
          for (let l = 0, c = o.count; l < c; l++)
            Dg.fromBufferAttribute(o, l).applyMatrix4(e.matrixWorld), this.expandByPoint(Dg);
        } else
          i.boundingBox === null && i.computeBoundingBox(), s1.copy(i.boundingBox), s1.applyMatrix4(e.matrixWorld), this.union(s1);
    }
    const r = e.children;
    for (let i = 0, o = r.length; i < o; i++)
      this.expandByObject(r[i], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Dg), Dg.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(rT), lC.subVectors(this.max, rT), l1.subVectors(e.a, rT), u1.subVectors(e.b, rT), c1.subVectors(e.c, rT), s0.subVectors(u1, l1), l0.subVectors(c1, u1), GS.subVectors(l1, c1);
    let t = [
      0,
      -s0.z,
      s0.y,
      0,
      -l0.z,
      l0.y,
      0,
      -GS.z,
      GS.y,
      s0.z,
      0,
      -s0.x,
      l0.z,
      0,
      -l0.x,
      GS.z,
      0,
      -GS.x,
      -s0.y,
      s0.x,
      0,
      -l0.y,
      l0.x,
      0,
      -GS.y,
      GS.x,
      0
    ];
    return !LD(t, l1, u1, c1, lC) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !LD(t, l1, u1, c1, lC)) ? !1 : (uC.crossVectors(s0, l0), t = [uC.x, uC.y, uC.z], LD(t, l1, u1, c1, lC));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Dg).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Dg).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ag[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ag[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ag[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ag[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ag[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ag[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ag[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ag[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ag), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ag = [
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te(),
  /* @__PURE__ */ new Te()
], Dg = /* @__PURE__ */ new Te(), s1 = /* @__PURE__ */ new mm(), l1 = /* @__PURE__ */ new Te(), u1 = /* @__PURE__ */ new Te(), c1 = /* @__PURE__ */ new Te(), s0 = /* @__PURE__ */ new Te(), l0 = /* @__PURE__ */ new Te(), GS = /* @__PURE__ */ new Te(), rT = /* @__PURE__ */ new Te(), lC = /* @__PURE__ */ new Te(), uC = /* @__PURE__ */ new Te(), WS = /* @__PURE__ */ new Te();
function LD(n, e, t, r, i) {
  for (let o = 0, l = n.length - 3; o <= l; o += 3) {
    WS.fromArray(n, o);
    const c = i.x * Math.abs(WS.x) + i.y * Math.abs(WS.y) + i.z * Math.abs(WS.z), h = e.dot(WS), p = t.dot(WS), y = r.dot(WS);
    if (Math.max(-Math.max(h, p, y), Math.min(h, p, y)) > c)
      return !1;
  }
  return !0;
}
const $G = /* @__PURE__ */ new mm(), iT = /* @__PURE__ */ new Te(), OD = /* @__PURE__ */ new Te();
class vp {
  constructor(e = new Te(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : $G.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, l = e.length; o < l; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    iT.subVectors(e, this.center);
    const t = iT.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), i = (r - this.radius) * 0.5;
      this.center.addScaledVector(iT, i / r), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (OD.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(iT.copy(e.center).add(OD)), this.expandByPoint(iT.copy(e.center).sub(OD))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Lg = /* @__PURE__ */ new Te(), PD = /* @__PURE__ */ new Te(), cC = /* @__PURE__ */ new Te(), u0 = /* @__PURE__ */ new Te(), UD = /* @__PURE__ */ new Te(), fC = /* @__PURE__ */ new Te(), ND = /* @__PURE__ */ new Te();
class wx {
  constructor(e = new Te(), t = new Te(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Lg)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Lg.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Lg.copy(this.origin).addScaledVector(this.direction, t), Lg.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    PD.copy(e).add(t).multiplyScalar(0.5), cC.copy(t).sub(e).normalize(), u0.copy(this.origin).sub(PD);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(cC), c = u0.dot(this.direction), h = -u0.dot(cC), p = u0.lengthSq(), y = Math.abs(1 - l * l);
    let x, b, w, R;
    if (y > 0)
      if (x = l * h - c, b = l * c - h, R = o * y, x >= 0)
        if (b >= -R)
          if (b <= R) {
            const U = 1 / y;
            x *= U, b *= U, w = x * (x + l * b + 2 * c) + b * (l * x + b + 2 * h) + p;
          } else
            b = o, x = Math.max(0, -(l * b + c)), w = -x * x + b * (b + 2 * h) + p;
        else
          b = -o, x = Math.max(0, -(l * b + c)), w = -x * x + b * (b + 2 * h) + p;
      else
        b <= -R ? (x = Math.max(0, -(-l * o + c)), b = x > 0 ? -o : Math.min(Math.max(-o, -h), o), w = -x * x + b * (b + 2 * h) + p) : b <= R ? (x = 0, b = Math.min(Math.max(-o, -h), o), w = b * (b + 2 * h) + p) : (x = Math.max(0, -(l * o + c)), b = x > 0 ? o : Math.min(Math.max(-o, -h), o), w = -x * x + b * (b + 2 * h) + p);
    else
      b = l > 0 ? -o : o, x = Math.max(0, -(l * b + c)), w = -x * x + b * (b + 2 * h) + p;
    return r && r.copy(this.origin).addScaledVector(this.direction, x), i && i.copy(PD).addScaledVector(cC, b), w;
  }
  intersectSphere(e, t) {
    Lg.subVectors(e.center, this.origin);
    const r = Lg.dot(this.direction), i = Lg.dot(Lg) - r * r, o = e.radius * e.radius;
    if (i > o)
      return null;
    const l = Math.sqrt(o - i), c = r - l, h = r + l;
    return h < 0 ? null : c < 0 ? this.at(h, t) : this.at(c, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, o, l, c, h;
    const p = 1 / this.direction.x, y = 1 / this.direction.y, x = 1 / this.direction.z, b = this.origin;
    return p >= 0 ? (r = (e.min.x - b.x) * p, i = (e.max.x - b.x) * p) : (r = (e.max.x - b.x) * p, i = (e.min.x - b.x) * p), y >= 0 ? (o = (e.min.y - b.y) * y, l = (e.max.y - b.y) * y) : (o = (e.max.y - b.y) * y, l = (e.min.y - b.y) * y), r > l || o > i || ((o > r || isNaN(r)) && (r = o), (l < i || isNaN(i)) && (i = l), x >= 0 ? (c = (e.min.z - b.z) * x, h = (e.max.z - b.z) * x) : (c = (e.max.z - b.z) * x, h = (e.min.z - b.z) * x), r > h || c > i) || ((c > r || r !== r) && (r = c), (h < i || i !== i) && (i = h), i < 0) ? null : this.at(r >= 0 ? r : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Lg) !== null;
  }
  intersectTriangle(e, t, r, i, o) {
    UD.subVectors(t, e), fC.subVectors(r, e), ND.crossVectors(UD, fC);
    let l = this.direction.dot(ND), c;
    if (l > 0) {
      if (i)
        return null;
      c = 1;
    } else if (l < 0)
      c = -1, l = -l;
    else
      return null;
    u0.subVectors(this.origin, e);
    const h = c * this.direction.dot(fC.crossVectors(u0, fC));
    if (h < 0)
      return null;
    const p = c * this.direction.dot(UD.cross(u0));
    if (p < 0 || h + p > l)
      return null;
    const y = -c * u0.dot(ND);
    return y < 0 ? null : this.at(y / l, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Gr {
  constructor(e, t, r, i, o, l, c, h, p, y, x, b, w, R, U, L) {
    Gr.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, i, o, l, c, h, p, y, x, b, w, R, U, L);
  }
  set(e, t, r, i, o, l, c, h, p, y, x, b, w, R, U, L) {
    const A = this.elements;
    return A[0] = e, A[4] = t, A[8] = r, A[12] = i, A[1] = o, A[5] = l, A[9] = c, A[13] = h, A[2] = p, A[6] = y, A[10] = x, A[14] = b, A[3] = w, A[7] = R, A[11] = U, A[15] = L, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Gr().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, i = 1 / f1.setFromMatrixColumn(e, 0).length(), o = 1 / f1.setFromMatrixColumn(e, 1).length(), l = 1 / f1.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * o, t[5] = r[5] * o, t[6] = r[6] * o, t[7] = 0, t[8] = r[8] * l, t[9] = r[9] * l, t[10] = r[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, i = e.y, o = e.z, l = Math.cos(r), c = Math.sin(r), h = Math.cos(i), p = Math.sin(i), y = Math.cos(o), x = Math.sin(o);
    if (e.order === "XYZ") {
      const b = l * y, w = l * x, R = c * y, U = c * x;
      t[0] = h * y, t[4] = -h * x, t[8] = p, t[1] = w + R * p, t[5] = b - U * p, t[9] = -c * h, t[2] = U - b * p, t[6] = R + w * p, t[10] = l * h;
    } else if (e.order === "YXZ") {
      const b = h * y, w = h * x, R = p * y, U = p * x;
      t[0] = b + U * c, t[4] = R * c - w, t[8] = l * p, t[1] = l * x, t[5] = l * y, t[9] = -c, t[2] = w * c - R, t[6] = U + b * c, t[10] = l * h;
    } else if (e.order === "ZXY") {
      const b = h * y, w = h * x, R = p * y, U = p * x;
      t[0] = b - U * c, t[4] = -l * x, t[8] = R + w * c, t[1] = w + R * c, t[5] = l * y, t[9] = U - b * c, t[2] = -l * p, t[6] = c, t[10] = l * h;
    } else if (e.order === "ZYX") {
      const b = l * y, w = l * x, R = c * y, U = c * x;
      t[0] = h * y, t[4] = R * p - w, t[8] = b * p + U, t[1] = h * x, t[5] = U * p + b, t[9] = w * p - R, t[2] = -p, t[6] = c * h, t[10] = l * h;
    } else if (e.order === "YZX") {
      const b = l * h, w = l * p, R = c * h, U = c * p;
      t[0] = h * y, t[4] = U - b * x, t[8] = R * x + w, t[1] = x, t[5] = l * y, t[9] = -c * y, t[2] = -p * y, t[6] = w * x + R, t[10] = b - U * x;
    } else if (e.order === "XZY") {
      const b = l * h, w = l * p, R = c * h, U = c * p;
      t[0] = h * y, t[4] = -x, t[8] = p * y, t[1] = b * x + U, t[5] = l * y, t[9] = w * x - R, t[2] = R * x - w, t[6] = c * y, t[10] = U * x + b;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(YG, e, XG);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return mh.subVectors(e, t), mh.lengthSq() === 0 && (mh.z = 1), mh.normalize(), c0.crossVectors(r, mh), c0.lengthSq() === 0 && (Math.abs(r.z) === 1 ? mh.x += 1e-4 : mh.z += 1e-4, mh.normalize(), c0.crossVectors(r, mh)), c0.normalize(), dC.crossVectors(mh, c0), i[0] = c0.x, i[4] = dC.x, i[8] = mh.x, i[1] = c0.y, i[5] = dC.y, i[9] = mh.y, i[2] = c0.z, i[6] = dC.z, i[10] = mh.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, o = this.elements, l = r[0], c = r[4], h = r[8], p = r[12], y = r[1], x = r[5], b = r[9], w = r[13], R = r[2], U = r[6], L = r[10], A = r[14], F = r[3], k = r[7], H = r[11], B = r[15], $ = i[0], Y = i[4], J = i[8], K = i[12], X = i[1], le = i[5], oe = i[9], fe = i[13], de = i[2], xe = i[6], _e = i[10], Pe = i[14], ce = i[3], ve = i[7], re = i[11], ee = i[15];
    return o[0] = l * $ + c * X + h * de + p * ce, o[4] = l * Y + c * le + h * xe + p * ve, o[8] = l * J + c * oe + h * _e + p * re, o[12] = l * K + c * fe + h * Pe + p * ee, o[1] = y * $ + x * X + b * de + w * ce, o[5] = y * Y + x * le + b * xe + w * ve, o[9] = y * J + x * oe + b * _e + w * re, o[13] = y * K + x * fe + b * Pe + w * ee, o[2] = R * $ + U * X + L * de + A * ce, o[6] = R * Y + U * le + L * xe + A * ve, o[10] = R * J + U * oe + L * _e + A * re, o[14] = R * K + U * fe + L * Pe + A * ee, o[3] = F * $ + k * X + H * de + B * ce, o[7] = F * Y + k * le + H * xe + B * ve, o[11] = F * J + k * oe + H * _e + B * re, o[15] = F * K + k * fe + H * Pe + B * ee, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], i = e[8], o = e[12], l = e[1], c = e[5], h = e[9], p = e[13], y = e[2], x = e[6], b = e[10], w = e[14], R = e[3], U = e[7], L = e[11], A = e[15];
    return R * (+o * h * x - i * p * x - o * c * b + r * p * b + i * c * w - r * h * w) + U * (+t * h * w - t * p * b + o * l * b - i * l * w + i * p * y - o * h * y) + L * (+t * p * x - t * c * w - o * l * x + r * l * w + o * c * y - r * p * y) + A * (-i * c * y - t * h * x + t * c * b + i * l * x - r * l * b + r * h * y);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], c = e[5], h = e[6], p = e[7], y = e[8], x = e[9], b = e[10], w = e[11], R = e[12], U = e[13], L = e[14], A = e[15], F = x * L * p - U * b * p + U * h * w - c * L * w - x * h * A + c * b * A, k = R * b * p - y * L * p - R * h * w + l * L * w + y * h * A - l * b * A, H = y * U * p - R * x * p + R * c * w - l * U * w - y * c * A + l * x * A, B = R * x * h - y * U * h - R * c * b + l * U * b + y * c * L - l * x * L, $ = t * F + r * k + i * H + o * B;
    if ($ === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const Y = 1 / $;
    return e[0] = F * Y, e[1] = (U * b * o - x * L * o - U * i * w + r * L * w + x * i * A - r * b * A) * Y, e[2] = (c * L * o - U * h * o + U * i * p - r * L * p - c * i * A + r * h * A) * Y, e[3] = (x * h * o - c * b * o - x * i * p + r * b * p + c * i * w - r * h * w) * Y, e[4] = k * Y, e[5] = (y * L * o - R * b * o + R * i * w - t * L * w - y * i * A + t * b * A) * Y, e[6] = (R * h * o - l * L * o - R * i * p + t * L * p + l * i * A - t * h * A) * Y, e[7] = (l * b * o - y * h * o + y * i * p - t * b * p - l * i * w + t * h * w) * Y, e[8] = H * Y, e[9] = (R * x * o - y * U * o - R * r * w + t * U * w + y * r * A - t * x * A) * Y, e[10] = (l * U * o - R * c * o + R * r * p - t * U * p - l * r * A + t * c * A) * Y, e[11] = (y * c * o - l * x * o - y * r * p + t * x * p + l * r * w - t * c * w) * Y, e[12] = B * Y, e[13] = (y * U * i - R * x * i + R * r * b - t * U * b - y * r * L + t * x * L) * Y, e[14] = (R * c * i - l * U * i - R * r * h + t * U * h + l * r * L - t * c * L) * Y, e[15] = (l * x * i - y * c * i + y * r * h - t * x * h - l * r * b + t * c * b) * Y, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, i = e.y, o = e.z;
    return t[0] *= r, t[4] *= i, t[8] *= o, t[1] *= r, t[5] *= i, t[9] *= o, t[2] *= r, t[6] *= i, t[10] *= o, t[3] *= r, t[7] *= i, t[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), i = Math.sin(t), o = 1 - r, l = e.x, c = e.y, h = e.z, p = o * l, y = o * c;
    return this.set(
      p * l + r,
      p * c - i * h,
      p * h + i * c,
      0,
      p * c + i * h,
      y * c + r,
      y * h - i * l,
      0,
      p * h - i * c,
      y * h + i * l,
      o * h * h + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, i, o, l) {
    return this.set(
      1,
      r,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const i = this.elements, o = t._x, l = t._y, c = t._z, h = t._w, p = o + o, y = l + l, x = c + c, b = o * p, w = o * y, R = o * x, U = l * y, L = l * x, A = c * x, F = h * p, k = h * y, H = h * x, B = r.x, $ = r.y, Y = r.z;
    return i[0] = (1 - (U + A)) * B, i[1] = (w + H) * B, i[2] = (R - k) * B, i[3] = 0, i[4] = (w - H) * $, i[5] = (1 - (b + A)) * $, i[6] = (L + F) * $, i[7] = 0, i[8] = (R + k) * Y, i[9] = (L - F) * Y, i[10] = (1 - (b + U)) * Y, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, r) {
    const i = this.elements;
    let o = f1.set(i[0], i[1], i[2]).length();
    const l = f1.set(i[4], i[5], i[6]).length(), c = f1.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], om.copy(this);
    const p = 1 / o, y = 1 / l, x = 1 / c;
    return om.elements[0] *= p, om.elements[1] *= p, om.elements[2] *= p, om.elements[4] *= y, om.elements[5] *= y, om.elements[6] *= y, om.elements[8] *= x, om.elements[9] *= x, om.elements[10] *= x, t.setFromRotationMatrix(om), r.x = o, r.y = l, r.z = c, this;
  }
  makePerspective(e, t, r, i, o, l, c = _v) {
    const h = this.elements, p = 2 * o / (t - e), y = 2 * o / (r - i), x = (t + e) / (t - e), b = (r + i) / (r - i);
    let w, R;
    if (c === _v)
      w = -(l + o) / (l - o), R = -2 * l * o / (l - o);
    else if (c === VT)
      w = -l / (l - o), R = -l * o / (l - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + c);
    return h[0] = p, h[4] = 0, h[8] = x, h[12] = 0, h[1] = 0, h[5] = y, h[9] = b, h[13] = 0, h[2] = 0, h[6] = 0, h[10] = w, h[14] = R, h[3] = 0, h[7] = 0, h[11] = -1, h[15] = 0, this;
  }
  makeOrthographic(e, t, r, i, o, l, c = _v) {
    const h = this.elements, p = 1 / (t - e), y = 1 / (r - i), x = 1 / (l - o), b = (t + e) * p, w = (r + i) * y;
    let R, U;
    if (c === _v)
      R = (l + o) * x, U = -2 * x;
    else if (c === VT)
      R = o * x, U = -1 * x;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + c);
    return h[0] = 2 * p, h[4] = 0, h[8] = 0, h[12] = -b, h[1] = 0, h[5] = 2 * y, h[9] = 0, h[13] = -w, h[2] = 0, h[6] = 0, h[10] = U, h[14] = -R, h[3] = 0, h[7] = 0, h[11] = 0, h[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const f1 = /* @__PURE__ */ new Te(), om = /* @__PURE__ */ new Gr(), YG = /* @__PURE__ */ new Te(0, 0, 0), XG = /* @__PURE__ */ new Te(1, 1, 1), c0 = /* @__PURE__ */ new Te(), dC = /* @__PURE__ */ new Te(), mh = /* @__PURE__ */ new Te(), RN = /* @__PURE__ */ new Gr(), AN = /* @__PURE__ */ new Bc();
class ow {
  constructor(e = 0, t = 0, r = 0, i = ow.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements, o = i[0], l = i[4], c = i[8], h = i[1], p = i[5], y = i[9], x = i[2], b = i[6], w = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Os(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-y, w), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(b, p), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Os(y, -1, 1)), Math.abs(y) < 0.9999999 ? (this._y = Math.atan2(c, w), this._z = Math.atan2(h, p)) : (this._y = Math.atan2(-x, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Os(b, -1, 1)), Math.abs(b) < 0.9999999 ? (this._y = Math.atan2(-x, w), this._z = Math.atan2(-l, p)) : (this._y = 0, this._z = Math.atan2(h, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Os(x, -1, 1)), Math.abs(x) < 0.9999999 ? (this._x = Math.atan2(b, w), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-l, p));
        break;
      case "YZX":
        this._z = Math.asin(Os(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-y, p), this._y = Math.atan2(-x, o)) : (this._x = 0, this._y = Math.atan2(c, w));
        break;
      case "XZY":
        this._z = Math.asin(-Os(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(b, p), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-y, w), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return RN.makeRotationFromQuaternion(e), this.setFromRotationMatrix(RN, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return AN.setFromEuler(this), this.setFromQuaternion(AN, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ow.DEFAULT_ORDER = "XYZ";
class fx {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let qG = 0;
const DN = /* @__PURE__ */ new Te(), d1 = /* @__PURE__ */ new Bc(), Og = /* @__PURE__ */ new Gr(), hC = /* @__PURE__ */ new Te(), aT = /* @__PURE__ */ new Te(), KG = /* @__PURE__ */ new Te(), QG = /* @__PURE__ */ new Bc(), LN = /* @__PURE__ */ new Te(1, 0, 0), ON = /* @__PURE__ */ new Te(0, 1, 0), PN = /* @__PURE__ */ new Te(0, 0, 1), ZG = { type: "added" }, JG = { type: "removed" };
class aa extends Av {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: qG++ }), this.uuid = yh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = aa.DEFAULT_UP.clone();
    const e = new Te(), t = new ow(), r = new Bc(), i = new Te(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o), r._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Gr()
      },
      normalMatrix: {
        value: new ii()
      }
    }), this.matrix = new Gr(), this.matrixWorld = new Gr(), this.matrixAutoUpdate = aa.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = aa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new fx(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return d1.setFromAxisAngle(e, t), this.quaternion.multiply(d1), this;
  }
  rotateOnWorldAxis(e, t) {
    return d1.setFromAxisAngle(e, t), this.quaternion.premultiply(d1), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(LN, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(ON, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(PN, e);
  }
  translateOnAxis(e, t) {
    return DN.copy(e).applyQuaternion(this.quaternion), this.position.add(DN.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(LN, e);
  }
  translateY(e) {
    return this.translateOnAxis(ON, e);
  }
  translateZ(e) {
    return this.translateOnAxis(PN, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Og.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? hC.copy(e) : hC.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), aT.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Og.lookAt(aT, hC, this.up) : Og.lookAt(hC, aT, this.up), this.quaternion.setFromRotationMatrix(Og), i && (Og.extractRotation(i.matrixWorld), d1.setFromRotationMatrix(Og), this.quaternion.premultiply(d1.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(ZG)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(JG)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Og.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Og.multiply(e.parent.matrixWorld)), e.applyMatrix4(Og), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const l = this.children[r].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let i = 0, o = this.children.length; i < o; i++) {
      const l = this.children[i].getObjectsByProperty(e, t);
      l.length > 0 && (r = r.concat(l));
    }
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(aT, e, KG), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(aT, QG, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let o = 0, l = i.length; o < l; o++) {
        const c = i[o];
        c.matrixWorldAutoUpdate === !0 && c.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
    function o(c, h) {
      return c[h.uuid] === void 0 && (c[h.uuid] = h.toJSON(e)), h.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const c = this.geometry.parameters;
      if (c !== void 0 && c.shapes !== void 0) {
        const h = c.shapes;
        if (Array.isArray(h))
          for (let p = 0, y = h.length; p < y; p++) {
            const x = h[p];
            o(e.shapes, x);
          }
        else
          o(e.shapes, h);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const c = [];
        for (let h = 0, p = this.material.length; h < p; h++)
          c.push(o(e.materials, this.material[h]));
        i.material = c;
      } else
        i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let c = 0; c < this.children.length; c++)
        i.children.push(this.children[c].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let c = 0; c < this.animations.length; c++) {
        const h = this.animations[c];
        i.animations.push(o(e.animations, h));
      }
    }
    if (t) {
      const c = l(e.geometries), h = l(e.materials), p = l(e.textures), y = l(e.images), x = l(e.shapes), b = l(e.skeletons), w = l(e.animations), R = l(e.nodes);
      c.length > 0 && (r.geometries = c), h.length > 0 && (r.materials = h), p.length > 0 && (r.textures = p), y.length > 0 && (r.images = y), x.length > 0 && (r.shapes = x), b.length > 0 && (r.skeletons = b), w.length > 0 && (r.animations = w), R.length > 0 && (r.nodes = R);
    }
    return r.object = i, r;
    function l(c) {
      const h = [];
      for (const p in c) {
        const y = c[p];
        delete y.metadata, h.push(y);
      }
      return h;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
aa.DEFAULT_UP = /* @__PURE__ */ new Te(0, 1, 0);
aa.DEFAULT_MATRIX_AUTO_UPDATE = !0;
aa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const sm = /* @__PURE__ */ new Te(), Pg = /* @__PURE__ */ new Te(), FD = /* @__PURE__ */ new Te(), Ug = /* @__PURE__ */ new Te(), h1 = /* @__PURE__ */ new Te(), p1 = /* @__PURE__ */ new Te(), UN = /* @__PURE__ */ new Te(), kD = /* @__PURE__ */ new Te(), zD = /* @__PURE__ */ new Te(), ID = /* @__PURE__ */ new Te();
let pC = !1;
class bd {
  constructor(e = new Te(), t = new Te(), r = new Te()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), sm.subVectors(e, t), i.cross(sm);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, i, o) {
    sm.subVectors(i, t), Pg.subVectors(r, t), FD.subVectors(e, t);
    const l = sm.dot(sm), c = sm.dot(Pg), h = sm.dot(FD), p = Pg.dot(Pg), y = Pg.dot(FD), x = l * p - c * c;
    if (x === 0)
      return o.set(-2, -1, -1);
    const b = 1 / x, w = (p * h - c * y) * b, R = (l * y - c * h) * b;
    return o.set(1 - w - R, R, w);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, Ug), Ug.x >= 0 && Ug.y >= 0 && Ug.x + Ug.y <= 1;
  }
  static getUV(e, t, r, i, o, l, c, h) {
    return pC === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), pC = !0), this.getInterpolation(e, t, r, i, o, l, c, h);
  }
  static getInterpolation(e, t, r, i, o, l, c, h) {
    return this.getBarycoord(e, t, r, i, Ug), h.setScalar(0), h.addScaledVector(o, Ug.x), h.addScaledVector(l, Ug.y), h.addScaledVector(c, Ug.z), h;
  }
  static isFrontFacing(e, t, r, i) {
    return sm.subVectors(r, t), Pg.subVectors(e, t), sm.cross(Pg).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return sm.subVectors(this.c, this.b), Pg.subVectors(this.a, this.b), sm.cross(Pg).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return bd.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return bd.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, i, o) {
    return pC === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), pC = !0), bd.getInterpolation(e, this.a, this.b, this.c, t, r, i, o);
  }
  getInterpolation(e, t, r, i, o) {
    return bd.getInterpolation(e, this.a, this.b, this.c, t, r, i, o);
  }
  containsPoint(e) {
    return bd.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return bd.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, i = this.b, o = this.c;
    let l, c;
    h1.subVectors(i, r), p1.subVectors(o, r), kD.subVectors(e, r);
    const h = h1.dot(kD), p = p1.dot(kD);
    if (h <= 0 && p <= 0)
      return t.copy(r);
    zD.subVectors(e, i);
    const y = h1.dot(zD), x = p1.dot(zD);
    if (y >= 0 && x <= y)
      return t.copy(i);
    const b = h * x - y * p;
    if (b <= 0 && h >= 0 && y <= 0)
      return l = h / (h - y), t.copy(r).addScaledVector(h1, l);
    ID.subVectors(e, o);
    const w = h1.dot(ID), R = p1.dot(ID);
    if (R >= 0 && w <= R)
      return t.copy(o);
    const U = w * p - h * R;
    if (U <= 0 && p >= 0 && R <= 0)
      return c = p / (p - R), t.copy(r).addScaledVector(p1, c);
    const L = y * R - w * x;
    if (L <= 0 && x - y >= 0 && w - R >= 0)
      return UN.subVectors(o, i), c = (x - y) / (x - y + (w - R)), t.copy(i).addScaledVector(UN, c);
    const A = 1 / (L + U + b);
    return l = U * A, c = b * A, t.copy(r).addScaledVector(h1, l).addScaledVector(p1, c);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let eW = 0;
class ic extends Av {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: eW++ }), this.uuid = yh(), this.name = "", this.type = "Material", this.blending = ux, this.side = wv, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = mP, this.blendDst = vP, this.blendEquation = nx, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = bR, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = s4, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = vR, this.stencilZFail = vR, this.stencilZPass = vR, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== ux && (r.blending = this.blending), this.side !== wv && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
    if (t) {
      const o = i(e.textures), l = i(e.images);
      o.length > 0 && (r.textures = o), l.length > 0 && (r.images = l);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o)
        r[o] = t[o].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const _4 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, lm = { h: 0, s: 0, l: 0 }, mC = { h: 0, s: 0, l: 0 };
function BD(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
}
let Rn = class {
  constructor(e, t, r) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, r);
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = go) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, up.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, r, i = up.workingColorSpace) {
    return this.r = e, this.g = t, this.b = r, up.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, r, i = up.workingColorSpace) {
    if (e = RP(e, 1), t = Os(t, 0, 1), r = Os(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t, l = 2 * r - o;
      this.r = BD(l, o, e + 1 / 3), this.g = BD(l, o, e), this.b = BD(l, o, e - 1 / 3);
    }
    return up.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = go) {
    function r(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = i[1], c = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))
            return r(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              t
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))
            return r(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(c))
            return r(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = i[1], l = o.length;
      if (l === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (l === 6)
        return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = go) {
    const r = _4[e.toLowerCase()];
    return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = W1(e.r), this.g = W1(e.g), this.b = W1(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = RD(e.r), this.g = RD(e.g), this.b = RD(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = go) {
    return up.fromWorkingColorSpace(Fc.copy(this), e), Math.round(Os(Fc.r * 255, 0, 255)) * 65536 + Math.round(Os(Fc.g * 255, 0, 255)) * 256 + Math.round(Os(Fc.b * 255, 0, 255));
  }
  getHexString(e = go) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = up.workingColorSpace) {
    up.fromWorkingColorSpace(Fc.copy(this), t);
    const r = Fc.r, i = Fc.g, o = Fc.b, l = Math.max(r, i, o), c = Math.min(r, i, o);
    let h, p;
    const y = (c + l) / 2;
    if (c === l)
      h = 0, p = 0;
    else {
      const x = l - c;
      switch (p = y <= 0.5 ? x / (l + c) : x / (2 - l - c), l) {
        case r:
          h = (i - o) / x + (i < o ? 6 : 0);
          break;
        case i:
          h = (o - r) / x + 2;
          break;
        case o:
          h = (r - i) / x + 4;
          break;
      }
      h /= 6;
    }
    return e.h = h, e.s = p, e.l = y, e;
  }
  getRGB(e, t = up.workingColorSpace) {
    return up.fromWorkingColorSpace(Fc.copy(this), t), e.r = Fc.r, e.g = Fc.g, e.b = Fc.b, e;
  }
  getStyle(e = go) {
    up.fromWorkingColorSpace(Fc.copy(this), e);
    const t = Fc.r, r = Fc.g, i = Fc.b;
    return e !== go ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(lm), lm.h += e, lm.s += t, lm.l += r, this.setHSL(lm.h, lm.s, lm.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
  }
  lerpHSL(e, t) {
    this.getHSL(lm), e.getHSL(mC);
    const r = wT(lm.h, mC.h, t), i = wT(lm.s, mC.s, t), o = wT(lm.l, mC.l, t);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, r = this.g, i = this.b, o = e.elements;
    return this.r = o[0] * t + o[3] * r + o[6] * i, this.g = o[1] * t + o[4] * r + o[7] * i, this.b = o[2] * t + o[5] * r + o[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Fc = /* @__PURE__ */ new Rn();
Rn.NAMES = _4;
class Qg extends ic {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Rn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = iw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ig = /* @__PURE__ */ tW();
function tW() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), r = new Uint32Array(512), i = new Uint32Array(512);
  for (let h = 0; h < 256; ++h) {
    const p = h - 127;
    p < -27 ? (r[h] = 0, r[h | 256] = 32768, i[h] = 24, i[h | 256] = 24) : p < -14 ? (r[h] = 1024 >> -p - 14, r[h | 256] = 1024 >> -p - 14 | 32768, i[h] = -p - 1, i[h | 256] = -p - 1) : p <= 15 ? (r[h] = p + 15 << 10, r[h | 256] = p + 15 << 10 | 32768, i[h] = 13, i[h | 256] = 13) : p < 128 ? (r[h] = 31744, r[h | 256] = 64512, i[h] = 24, i[h | 256] = 24) : (r[h] = 31744, r[h | 256] = 64512, i[h] = 13, i[h | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), c = new Uint32Array(64);
  for (let h = 1; h < 1024; ++h) {
    let p = h << 13, y = 0;
    for (; !(p & 8388608); )
      p <<= 1, y -= 8388608;
    p &= -8388609, y += 947912704, o[h] = p | y;
  }
  for (let h = 1024; h < 2048; ++h)
    o[h] = 939524096 + (h - 1024 << 13);
  for (let h = 1; h < 31; ++h)
    l[h] = h << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let h = 33; h < 63; ++h)
    l[h] = 2147483648 + (h - 32 << 23);
  l[63] = 3347054592;
  for (let h = 1; h < 64; ++h)
    h !== 32 && (c[h] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: c
  };
}
function _d(n) {
  Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = Os(n, -65504, 65504), Ig.floatView[0] = n;
  const e = Ig.uint32View[0], t = e >> 23 & 511;
  return Ig.baseTable[t] + ((e & 8388607) >> Ig.shiftTable[t]);
}
function ST(n) {
  const e = n >> 10;
  return Ig.uint32View[0] = Ig.mantissaTable[Ig.offsetTable[e] + (n & 1023)] + Ig.exponentTable[e], Ig.floatView[0];
}
const nW = {
  toHalfFloat: _d,
  fromHalfFloat: ST
}, Cl = /* @__PURE__ */ new Te(), vC = /* @__PURE__ */ new Ht();
class io {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = HT, this.updateRange = { offset: 0, count: -1 }, this.gpuType = xv, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        vC.fromBufferAttribute(this, t), vC.applyMatrix3(e), this.setXY(t, vC.x, vC.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Cl.fromBufferAttribute(this, t), Cl.applyMatrix3(e), this.setXYZ(t, Cl.x, Cl.y, Cl.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Cl.fromBufferAttribute(this, t), Cl.applyMatrix4(e), this.setXYZ(t, Cl.x, Cl.y, Cl.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Cl.fromBufferAttribute(this, t), Cl.applyNormalMatrix(e), this.setXYZ(t, Cl.x, Cl.y, Cl.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Cl.fromBufferAttribute(this, t), Cl.transformDirection(e), this.setXYZ(t, Cl.x, Cl.y, Cl.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = wd(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = ai(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, o) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array), o = ai(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== HT && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class rW extends io {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class iW extends io {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class aW extends io {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class oW extends io {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class LP extends io {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class sW extends io {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class OP extends io {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class lW extends io {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = ST(this.array[e * this.itemSize]);
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize] = _d(t), this;
  }
  getY(e) {
    let t = ST(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 1] = _d(t), this;
  }
  getZ(e) {
    let t = ST(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 2] = _d(t), this;
  }
  getW(e) {
    let t = ST(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.array[e * this.itemSize + 3] = _d(t), this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array)), this.array[e + 0] = _d(t), this.array[e + 1] = _d(r), this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array)), this.array[e + 0] = _d(t), this.array[e + 1] = _d(r), this.array[e + 2] = _d(i), this;
  }
  setXYZW(e, t, r, i, o) {
    return e *= this.itemSize, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array), o = ai(o, this.array)), this.array[e + 0] = _d(t), this.array[e + 1] = _d(r), this.array[e + 2] = _d(i), this.array[e + 3] = _d(o), this;
  }
}
class Yn extends io {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
class uW extends io {
  constructor(e, t, r) {
    super(new Float64Array(e), t, r);
  }
}
let cW = 0;
const lp = /* @__PURE__ */ new Gr(), HD = /* @__PURE__ */ new aa(), m1 = /* @__PURE__ */ new Te(), vh = /* @__PURE__ */ new mm(), oT = /* @__PURE__ */ new mm(), wu = /* @__PURE__ */ new Te();
class oi extends Av {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: cW++ }), this.uuid = yh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (y4(e) ? OP : LP)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new ii().getNormalMatrix(e);
      r.applyNormalMatrix(o), r.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return lp.makeRotationFromQuaternion(e), this.applyMatrix4(lp), this;
  }
  rotateX(e) {
    return lp.makeRotationX(e), this.applyMatrix4(lp), this;
  }
  rotateY(e) {
    return lp.makeRotationY(e), this.applyMatrix4(lp), this;
  }
  rotateZ(e) {
    return lp.makeRotationZ(e), this.applyMatrix4(lp), this;
  }
  translate(e, t, r) {
    return lp.makeTranslation(e, t, r), this.applyMatrix4(lp), this;
  }
  scale(e, t, r) {
    return lp.makeScale(e, t, r), this.applyMatrix4(lp), this;
  }
  lookAt(e) {
    return HD.lookAt(e), HD.updateMatrix(), this.applyMatrix4(HD.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(m1).negate(), this.translate(m1.x, m1.y, m1.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new Yn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new mm());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new Te(-1 / 0, -1 / 0, -1 / 0),
        new Te(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, i = t.length; r < i; r++) {
          const o = t[r];
          vh.setFromBufferAttribute(o), this.morphTargetsRelative ? (wu.addVectors(this.boundingBox.min, vh.min), this.boundingBox.expandByPoint(wu), wu.addVectors(this.boundingBox.max, vh.max), this.boundingBox.expandByPoint(wu)) : (this.boundingBox.expandByPoint(vh.min), this.boundingBox.expandByPoint(vh.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new vp());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Te(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (vh.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const c = t[o];
          oT.setFromBufferAttribute(c), this.morphTargetsRelative ? (wu.addVectors(vh.min, oT.min), vh.expandByPoint(wu), wu.addVectors(vh.max, oT.max), vh.expandByPoint(wu)) : (vh.expandByPoint(oT.min), vh.expandByPoint(oT.max));
        }
      vh.getCenter(r);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        wu.fromBufferAttribute(e, o), i = Math.max(i, r.distanceToSquared(wu));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const c = t[o], h = this.morphTargetsRelative;
          for (let p = 0, y = c.count; p < y; p++)
            wu.fromBufferAttribute(c, p), h && (m1.fromBufferAttribute(e, p), wu.add(m1)), i = Math.max(i, r.distanceToSquared(wu));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, i = t.position.array, o = t.normal.array, l = t.uv.array, c = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new io(new Float32Array(4 * c), 4));
    const h = this.getAttribute("tangent").array, p = [], y = [];
    for (let X = 0; X < c; X++)
      p[X] = new Te(), y[X] = new Te();
    const x = new Te(), b = new Te(), w = new Te(), R = new Ht(), U = new Ht(), L = new Ht(), A = new Te(), F = new Te();
    function k(X, le, oe) {
      x.fromArray(i, X * 3), b.fromArray(i, le * 3), w.fromArray(i, oe * 3), R.fromArray(l, X * 2), U.fromArray(l, le * 2), L.fromArray(l, oe * 2), b.sub(x), w.sub(x), U.sub(R), L.sub(R);
      const fe = 1 / (U.x * L.y - L.x * U.y);
      isFinite(fe) && (A.copy(b).multiplyScalar(L.y).addScaledVector(w, -U.y).multiplyScalar(fe), F.copy(w).multiplyScalar(U.x).addScaledVector(b, -L.x).multiplyScalar(fe), p[X].add(A), p[le].add(A), p[oe].add(A), y[X].add(F), y[le].add(F), y[oe].add(F));
    }
    let H = this.groups;
    H.length === 0 && (H = [{
      start: 0,
      count: r.length
    }]);
    for (let X = 0, le = H.length; X < le; ++X) {
      const oe = H[X], fe = oe.start, de = oe.count;
      for (let xe = fe, _e = fe + de; xe < _e; xe += 3)
        k(
          r[xe + 0],
          r[xe + 1],
          r[xe + 2]
        );
    }
    const B = new Te(), $ = new Te(), Y = new Te(), J = new Te();
    function K(X) {
      Y.fromArray(o, X * 3), J.copy(Y);
      const le = p[X];
      B.copy(le), B.sub(Y.multiplyScalar(Y.dot(le))).normalize(), $.crossVectors(J, le);
      const fe = $.dot(y[X]) < 0 ? -1 : 1;
      h[X * 4] = B.x, h[X * 4 + 1] = B.y, h[X * 4 + 2] = B.z, h[X * 4 + 3] = fe;
    }
    for (let X = 0, le = H.length; X < le; ++X) {
      const oe = H[X], fe = oe.start, de = oe.count;
      for (let xe = fe, _e = fe + de; xe < _e; xe += 3)
        K(r[xe + 0]), K(r[xe + 1]), K(r[xe + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new io(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let b = 0, w = r.count; b < w; b++)
          r.setXYZ(b, 0, 0, 0);
      const i = new Te(), o = new Te(), l = new Te(), c = new Te(), h = new Te(), p = new Te(), y = new Te(), x = new Te();
      if (e)
        for (let b = 0, w = e.count; b < w; b += 3) {
          const R = e.getX(b + 0), U = e.getX(b + 1), L = e.getX(b + 2);
          i.fromBufferAttribute(t, R), o.fromBufferAttribute(t, U), l.fromBufferAttribute(t, L), y.subVectors(l, o), x.subVectors(i, o), y.cross(x), c.fromBufferAttribute(r, R), h.fromBufferAttribute(r, U), p.fromBufferAttribute(r, L), c.add(y), h.add(y), p.add(y), r.setXYZ(R, c.x, c.y, c.z), r.setXYZ(U, h.x, h.y, h.z), r.setXYZ(L, p.x, p.y, p.z);
        }
      else
        for (let b = 0, w = t.count; b < w; b += 3)
          i.fromBufferAttribute(t, b + 0), o.fromBufferAttribute(t, b + 1), l.fromBufferAttribute(t, b + 2), y.subVectors(l, o), x.subVectors(i, o), y.cross(x), r.setXYZ(b + 0, y.x, y.y, y.z), r.setXYZ(b + 1, y.x, y.y, y.z), r.setXYZ(b + 2, y.x, y.y, y.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      wu.fromBufferAttribute(e, t), wu.normalize(), e.setXYZ(t, wu.x, wu.y, wu.z);
  }
  toNonIndexed() {
    function e(c, h) {
      const p = c.array, y = c.itemSize, x = c.normalized, b = new p.constructor(h.length * y);
      let w = 0, R = 0;
      for (let U = 0, L = h.length; U < L; U++) {
        c.isInterleavedBufferAttribute ? w = h[U] * c.data.stride + c.offset : w = h[U] * y;
        for (let A = 0; A < y; A++)
          b[R++] = p[w++];
      }
      return new io(b, y, x);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new oi(), r = this.index.array, i = this.attributes;
    for (const c in i) {
      const h = i[c], p = e(h, r);
      t.setAttribute(c, p);
    }
    const o = this.morphAttributes;
    for (const c in o) {
      const h = [], p = o[c];
      for (let y = 0, x = p.length; y < x; y++) {
        const b = p[y], w = e(b, r);
        h.push(w);
      }
      t.morphAttributes[c] = h;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let c = 0, h = l.length; c < h; c++) {
      const p = l[c];
      t.addGroup(p.start, p.count, p.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const h = this.parameters;
      for (const p in h)
        h[p] !== void 0 && (e[p] = h[p]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const h in r) {
      const p = r[h];
      e.data.attributes[h] = p.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const h in this.morphAttributes) {
      const p = this.morphAttributes[h], y = [];
      for (let x = 0, b = p.length; x < b; x++) {
        const w = p[x];
        y.push(w.toJSON(e.data));
      }
      y.length > 0 && (i[h] = y, o = !0);
    }
    o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const c = this.boundingSphere;
    return c !== null && (e.data.boundingSphere = {
      center: c.center.toArray(),
      radius: c.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const p in i) {
      const y = i[p];
      this.setAttribute(p, y.clone(t));
    }
    const o = e.morphAttributes;
    for (const p in o) {
      const y = [], x = o[p];
      for (let b = 0, w = x.length; b < w; b++)
        y.push(x[b].clone(t));
      this.morphAttributes[p] = y;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let p = 0, y = l.length; p < y; p++) {
      const x = l[p];
      this.addGroup(x.start, x.count, x.materialIndex);
    }
    const c = e.boundingBox;
    c !== null && (this.boundingBox = c.clone());
    const h = e.boundingSphere;
    return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const NN = /* @__PURE__ */ new Gr(), jS = /* @__PURE__ */ new wx(), gC = /* @__PURE__ */ new vp(), FN = /* @__PURE__ */ new Te(), v1 = /* @__PURE__ */ new Te(), g1 = /* @__PURE__ */ new Te(), y1 = /* @__PURE__ */ new Te(), VD = /* @__PURE__ */ new Te(), yC = /* @__PURE__ */ new Te(), SC = /* @__PURE__ */ new Ht(), xC = /* @__PURE__ */ new Ht(), _C = /* @__PURE__ */ new Ht(), kN = /* @__PURE__ */ new Te(), zN = /* @__PURE__ */ new Te(), IN = /* @__PURE__ */ new Te(), EC = /* @__PURE__ */ new Te(), bC = /* @__PURE__ */ new Te();
class Al extends aa {
  constructor(e = new oi(), t = new Qg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const c = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry, i = r.attributes.position, o = r.morphAttributes.position, l = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const c = this.morphTargetInfluences;
    if (o && c) {
      yC.set(0, 0, 0);
      for (let h = 0, p = o.length; h < p; h++) {
        const y = c[h], x = o[h];
        y !== 0 && (VD.fromBufferAttribute(x, e), l ? yC.addScaledVector(VD, y) : yC.addScaledVector(VD.sub(t), y));
      }
      t.add(yC);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.material, o = this.matrixWorld;
    i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), gC.copy(r.boundingSphere), gC.applyMatrix4(o), jS.copy(e.ray).recast(e.near), !(gC.containsPoint(jS.origin) === !1 && (jS.intersectSphere(gC, FN) === null || jS.origin.distanceToSquared(FN) > (e.far - e.near) ** 2)) && (NN.copy(o).invert(), jS.copy(e.ray).applyMatrix4(NN), !(r.boundingBox !== null && jS.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, jS)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const o = this.geometry, l = this.material, c = o.index, h = o.attributes.position, p = o.attributes.uv, y = o.attributes.uv1, x = o.attributes.normal, b = o.groups, w = o.drawRange;
    if (c !== null)
      if (Array.isArray(l))
        for (let R = 0, U = b.length; R < U; R++) {
          const L = b[R], A = l[L.materialIndex], F = Math.max(L.start, w.start), k = Math.min(c.count, Math.min(L.start + L.count, w.start + w.count));
          for (let H = F, B = k; H < B; H += 3) {
            const $ = c.getX(H), Y = c.getX(H + 1), J = c.getX(H + 2);
            i = TC(this, A, e, r, p, y, x, $, Y, J), i && (i.faceIndex = Math.floor(H / 3), i.face.materialIndex = L.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, w.start), U = Math.min(c.count, w.start + w.count);
        for (let L = R, A = U; L < A; L += 3) {
          const F = c.getX(L), k = c.getX(L + 1), H = c.getX(L + 2);
          i = TC(this, l, e, r, p, y, x, F, k, H), i && (i.faceIndex = Math.floor(L / 3), t.push(i));
        }
      }
    else if (h !== void 0)
      if (Array.isArray(l))
        for (let R = 0, U = b.length; R < U; R++) {
          const L = b[R], A = l[L.materialIndex], F = Math.max(L.start, w.start), k = Math.min(h.count, Math.min(L.start + L.count, w.start + w.count));
          for (let H = F, B = k; H < B; H += 3) {
            const $ = H, Y = H + 1, J = H + 2;
            i = TC(this, A, e, r, p, y, x, $, Y, J), i && (i.faceIndex = Math.floor(H / 3), i.face.materialIndex = L.materialIndex, t.push(i));
          }
        }
      else {
        const R = Math.max(0, w.start), U = Math.min(h.count, w.start + w.count);
        for (let L = R, A = U; L < A; L += 3) {
          const F = L, k = L + 1, H = L + 2;
          i = TC(this, l, e, r, p, y, x, F, k, H), i && (i.faceIndex = Math.floor(L / 3), t.push(i));
        }
      }
  }
}
function fW(n, e, t, r, i, o, l, c) {
  let h;
  if (e.side === Ic ? h = r.intersectTriangle(l, o, i, !0, c) : h = r.intersectTriangle(i, o, l, e.side === wv, c), h === null)
    return null;
  bC.copy(c), bC.applyMatrix4(n.matrixWorld);
  const p = t.ray.origin.distanceTo(bC);
  return p < t.near || p > t.far ? null : {
    distance: p,
    point: bC.clone(),
    object: n
  };
}
function TC(n, e, t, r, i, o, l, c, h, p) {
  n.getVertexPosition(c, v1), n.getVertexPosition(h, g1), n.getVertexPosition(p, y1);
  const y = fW(n, e, t, r, v1, g1, y1, EC);
  if (y) {
    i && (SC.fromBufferAttribute(i, c), xC.fromBufferAttribute(i, h), _C.fromBufferAttribute(i, p), y.uv = bd.getInterpolation(EC, v1, g1, y1, SC, xC, _C, new Ht())), o && (SC.fromBufferAttribute(o, c), xC.fromBufferAttribute(o, h), _C.fromBufferAttribute(o, p), y.uv1 = bd.getInterpolation(EC, v1, g1, y1, SC, xC, _C, new Ht()), y.uv2 = y.uv1), l && (kN.fromBufferAttribute(l, c), zN.fromBufferAttribute(l, h), IN.fromBufferAttribute(l, p), y.normal = bd.getInterpolation(EC, v1, g1, y1, kN, zN, IN, new Te()), y.normal.dot(r.direction) > 0 && y.normal.multiplyScalar(-1));
    const x = {
      a: c,
      b: h,
      c: p,
      normal: new Te(),
      materialIndex: 0
    };
    bd.getNormal(v1, g1, y1, x.normal), y.face = x;
  }
  return y;
}
class Mx extends oi {
  constructor(e = 1, t = 1, r = 1, i = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: i,
      heightSegments: o,
      depthSegments: l
    };
    const c = this;
    i = Math.floor(i), o = Math.floor(o), l = Math.floor(l);
    const h = [], p = [], y = [], x = [];
    let b = 0, w = 0;
    R("z", "y", "x", -1, -1, r, t, e, l, o, 0), R("z", "y", "x", 1, -1, r, t, -e, l, o, 1), R("x", "z", "y", 1, 1, e, r, t, i, l, 2), R("x", "z", "y", 1, -1, e, r, -t, i, l, 3), R("x", "y", "z", 1, -1, e, t, r, i, o, 4), R("x", "y", "z", -1, -1, e, t, -r, i, o, 5), this.setIndex(h), this.setAttribute("position", new Yn(p, 3)), this.setAttribute("normal", new Yn(y, 3)), this.setAttribute("uv", new Yn(x, 2));
    function R(U, L, A, F, k, H, B, $, Y, J, K) {
      const X = H / Y, le = B / J, oe = H / 2, fe = B / 2, de = $ / 2, xe = Y + 1, _e = J + 1;
      let Pe = 0, ce = 0;
      const ve = new Te();
      for (let re = 0; re < _e; re++) {
        const ee = re * le - fe;
        for (let he = 0; he < xe; he++) {
          const Me = he * X - oe;
          ve[U] = Me * F, ve[L] = ee * k, ve[A] = de, p.push(ve.x, ve.y, ve.z), ve[U] = 0, ve[L] = 0, ve[A] = $ > 0 ? 1 : -1, y.push(ve.x, ve.y, ve.z), x.push(he / Y), x.push(1 - re / J), Pe += 1;
        }
      }
      for (let re = 0; re < J; re++)
        for (let ee = 0; ee < Y; ee++) {
          const he = b + ee + xe * re, Me = b + ee + xe * (re + 1), Le = b + (ee + 1) + xe * (re + 1), Ae = b + (ee + 1) + xe * re;
          h.push(he, Me, Ae), h.push(Me, Le, Ae), ce += 6;
        }
      c.addGroup(w, ce, K), w += ce, b += Pe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mx(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function K1(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][r] = null) : e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i;
    }
  }
  return e;
}
function Pf(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = K1(n[t]);
    for (const i in r)
      e[i] = r[i];
  }
  return e;
}
function dW(n) {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t].clone());
  return e;
}
function E4(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : dm;
}
const PP = { clone: K1, merge: Pf };
var hW = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, pW = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Mv extends ic {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = hW, this.fragmentShader = pW, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = K1(e.uniforms), this.uniformsGroups = dW(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const r = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class sw extends aa {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Gr(), this.projectionMatrix = new Gr(), this.projectionMatrixInverse = new Gr(), this.coordinateSystem = _v;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ps extends sw {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = q1 * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(cx * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return q1 * 2 * Math.atan(
      Math.tan(cx * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, r, i, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(cx * 0.5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, o = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const h = l.fullWidth, p = l.fullHeight;
      o += l.offsetX * i / h, t -= l.offsetY * r / p, i *= l.width / h, r *= l.height / p;
    }
    const c = this.filmOffset;
    c !== 0 && (o += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const S1 = -90, x1 = 1;
class b4 extends aa {
  constructor(e, t, r) {
    super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null;
    const i = new Ps(S1, x1, e, t);
    i.layers = this.layers, this.add(i);
    const o = new Ps(S1, x1, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Ps(S1, x1, e, t);
    l.layers = this.layers, this.add(l);
    const c = new Ps(S1, x1, e, t);
    c.layers = this.layers, this.add(c);
    const h = new Ps(S1, x1, e, t);
    h.layers = this.layers, this.add(h);
    const p = new Ps(S1, x1, e, t);
    p.layers = this.layers, this.add(p);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [r, i, o, l, c, h] = t;
    for (const p of t)
      this.remove(p);
    if (e === _v)
      r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), c.up.set(0, 1, 0), c.lookAt(0, 0, 1), h.up.set(0, 1, 0), h.lookAt(0, 0, -1);
    else if (e === VT)
      r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), c.up.set(0, -1, 0), c.lookAt(0, 0, 1), h.up.set(0, -1, 0), h.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const p of t)
      this.add(p), p.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [i, o, l, c, h, p] = this.children, y = e.getRenderTarget(), x = e.xr.enabled;
    e.xr.enabled = !1;
    const b = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, i), e.setRenderTarget(r, 1), e.render(t, o), e.setRenderTarget(r, 2), e.render(t, l), e.setRenderTarget(r, 3), e.render(t, c), e.setRenderTarget(r, 4), e.render(t, h), r.texture.generateMipmaps = b, e.setRenderTarget(r, 5), e.render(t, p), e.setRenderTarget(y), e.xr.enabled = x, r.texture.needsPMREMUpdate = !0;
  }
}
class lw extends cs {
  constructor(e, t, r, i, o, l, c, h, p, y) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : jg, super(e, t, r, i, o, l, c, h, p, y), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class T4 extends hm {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r];
    t.encoding !== void 0 && (MT("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === g0 ? go : y0), this.texture = new lw(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ss;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const r = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Mx(5, 5, 5), o = new Mv({
      name: "CubemapFromEquirect",
      uniforms: K1(r.uniforms),
      vertexShader: r.vertexShader,
      fragmentShader: r.fragmentShader,
      side: Ic,
      blending: Gg
    });
    o.uniforms.tEquirect.value = t;
    const l = new Al(i, o), c = t.minFilter;
    return t.minFilter === x0 && (t.minFilter = ss), new b4(1, 10, this).update(e, l), t.minFilter = c, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, r, i) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, r, i);
    e.setRenderTarget(o);
  }
}
const GD = /* @__PURE__ */ new Te(), mW = /* @__PURE__ */ new Te(), vW = /* @__PURE__ */ new ii();
class kg {
  constructor(e = new Te(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = GD.subVectors(r, t).cross(mW.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(GD), i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || vW.getNormalMatrix(e), i = this.coplanarPoint(GD).applyMatrix4(e), o = this.normal.applyMatrix3(r).normalize();
    return this.constant = -i.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $S = /* @__PURE__ */ new vp(), wC = /* @__PURE__ */ new Te();
class QR {
  constructor(e = new kg(), t = new kg(), r = new kg(), i = new kg(), o = new kg(), l = new kg()) {
    this.planes = [e, t, r, i, o, l];
  }
  set(e, t, r, i, o, l) {
    const c = this.planes;
    return c[0].copy(e), c[1].copy(t), c[2].copy(r), c[3].copy(i), c[4].copy(o), c[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = _v) {
    const r = this.planes, i = e.elements, o = i[0], l = i[1], c = i[2], h = i[3], p = i[4], y = i[5], x = i[6], b = i[7], w = i[8], R = i[9], U = i[10], L = i[11], A = i[12], F = i[13], k = i[14], H = i[15];
    if (r[0].setComponents(h - o, b - p, L - w, H - A).normalize(), r[1].setComponents(h + o, b + p, L + w, H + A).normalize(), r[2].setComponents(h + l, b + y, L + R, H + F).normalize(), r[3].setComponents(h - l, b - y, L - R, H - F).normalize(), r[4].setComponents(h - c, b - x, L - U, H - k).normalize(), t === _v)
      r[5].setComponents(h + c, b + x, L + U, H + k).normalize();
    else if (t === VT)
      r[5].setComponents(c, x, U, k).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), $S.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), $S.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere($S);
  }
  intersectsSprite(e) {
    return $S.center.set(0, 0, 0), $S.radius = 0.7071067811865476, $S.applyMatrix4(e.matrixWorld), this.intersectsSphere($S);
  }
  intersectsSphere(e) {
    const t = this.planes, r = e.center, i = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(r) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (wC.x = i.normal.x > 0 ? e.max.x : e.min.x, wC.y = i.normal.y > 0 ? e.max.y : e.min.y, wC.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(wC) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function w4() {
  let n = null, e = !1, t = null, r = null;
  function i(o, l) {
    t(o, l), r = n.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (r = n.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(o) {
      t = o;
    },
    setContext: function(o) {
      n = o;
    }
  };
}
function gW(n, e) {
  const t = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function i(p, y) {
    const x = p.array, b = p.usage, w = n.createBuffer();
    n.bindBuffer(y, w), n.bufferData(y, x, b), p.onUploadCallback();
    let R;
    if (x instanceof Float32Array)
      R = n.FLOAT;
    else if (x instanceof Uint16Array)
      if (p.isFloat16BufferAttribute)
        if (t)
          R = n.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        R = n.UNSIGNED_SHORT;
    else if (x instanceof Int16Array)
      R = n.SHORT;
    else if (x instanceof Uint32Array)
      R = n.UNSIGNED_INT;
    else if (x instanceof Int32Array)
      R = n.INT;
    else if (x instanceof Int8Array)
      R = n.BYTE;
    else if (x instanceof Uint8Array)
      R = n.UNSIGNED_BYTE;
    else if (x instanceof Uint8ClampedArray)
      R = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + x);
    return {
      buffer: w,
      type: R,
      bytesPerElement: x.BYTES_PER_ELEMENT,
      version: p.version
    };
  }
  function o(p, y, x) {
    const b = y.array, w = y.updateRange;
    n.bindBuffer(x, p), w.count === -1 ? n.bufferSubData(x, 0, b) : (t ? n.bufferSubData(
      x,
      w.offset * b.BYTES_PER_ELEMENT,
      b,
      w.offset,
      w.count
    ) : n.bufferSubData(
      x,
      w.offset * b.BYTES_PER_ELEMENT,
      b.subarray(w.offset, w.offset + w.count)
    ), w.count = -1), y.onUploadCallback();
  }
  function l(p) {
    return p.isInterleavedBufferAttribute && (p = p.data), r.get(p);
  }
  function c(p) {
    p.isInterleavedBufferAttribute && (p = p.data);
    const y = r.get(p);
    y && (n.deleteBuffer(y.buffer), r.delete(p));
  }
  function h(p, y) {
    if (p.isGLBufferAttribute) {
      const b = r.get(p);
      (!b || b.version < p.version) && r.set(p, {
        buffer: p.buffer,
        type: p.type,
        bytesPerElement: p.elementSize,
        version: p.version
      });
      return;
    }
    p.isInterleavedBufferAttribute && (p = p.data);
    const x = r.get(p);
    x === void 0 ? r.set(p, i(p, y)) : x.version < p.version && (o(x.buffer, p, y), x.version = p.version);
  }
  return {
    get: l,
    remove: c,
    update: h
  };
}
class R0 extends oi {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: i
    };
    const o = e / 2, l = t / 2, c = Math.floor(r), h = Math.floor(i), p = c + 1, y = h + 1, x = e / c, b = t / h, w = [], R = [], U = [], L = [];
    for (let A = 0; A < y; A++) {
      const F = A * b - l;
      for (let k = 0; k < p; k++) {
        const H = k * x - o;
        R.push(H, -F, 0), U.push(0, 0, 1), L.push(k / c), L.push(1 - A / h);
      }
    }
    for (let A = 0; A < h; A++)
      for (let F = 0; F < c; F++) {
        const k = F + p * A, H = F + p * (A + 1), B = F + 1 + p * (A + 1), $ = F + 1 + p * A;
        w.push(k, H, $), w.push(H, B, $);
      }
    this.setIndex(w), this.setAttribute("position", new Yn(R, 3)), this.setAttribute("normal", new Yn(U, 3)), this.setAttribute("uv", new Yn(L, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new R0(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var yW = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, SW = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, xW = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, _W = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, EW = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, bW = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, TW = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, wW = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, MW = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, CW = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, RW = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, AW = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, DW = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, LW = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, OW = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, PW = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, UW = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, NW = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, FW = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, kW = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, zW = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, IW = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, BW = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, HW = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, VW = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, GW = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, WW = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, jW = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, $W = "gl_FragColor = linearToOutputTexel( gl_FragColor );", YW = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, XW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, qW = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, KW = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, QW = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, ZW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, JW = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, e9 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, t9 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, n9 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, r9 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, i9 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, a9 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, o9 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, s9 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, l9 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, u9 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, c9 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, f9 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, d9 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, h9 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, p9 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, m9 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, v9 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, g9 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, y9 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, S9 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, x9 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, _9 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, E9 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, b9 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, T9 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, w9 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, M9 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, C9 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, R9 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, A9 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, D9 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, L9 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, O9 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, P9 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, U9 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, N9 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, F9 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, k9 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, z9 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, I9 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, B9 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, H9 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, V9 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, G9 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, W9 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, j9 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, $9 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Y9 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, X9 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, q9 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, K9 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Q9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, Z9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, J9 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, e7 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, t7 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, n7 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, r7 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, i7 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, a7 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, o7 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, s7 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, l7 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, u7 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, c7 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, f7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, d7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, h7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, p7 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const m7 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, v7 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, g7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, y7 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, S7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, x7 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, _7 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, E7 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, b7 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, T7 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, w7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, M7 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, C7 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, R7 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, A7 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, D7 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, L7 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, O7 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, P7 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, U7 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, N7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, F7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, k7 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, z7 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, I7 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, B7 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, H7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, V7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, G7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, W7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, j7 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, $7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Y7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, X7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Jr = {
  alphahash_fragment: yW,
  alphahash_pars_fragment: SW,
  alphamap_fragment: xW,
  alphamap_pars_fragment: _W,
  alphatest_fragment: EW,
  alphatest_pars_fragment: bW,
  aomap_fragment: TW,
  aomap_pars_fragment: wW,
  begin_vertex: MW,
  beginnormal_vertex: CW,
  bsdfs: RW,
  iridescence_fragment: AW,
  bumpmap_pars_fragment: DW,
  clipping_planes_fragment: LW,
  clipping_planes_pars_fragment: OW,
  clipping_planes_pars_vertex: PW,
  clipping_planes_vertex: UW,
  color_fragment: NW,
  color_pars_fragment: FW,
  color_pars_vertex: kW,
  color_vertex: zW,
  common: IW,
  cube_uv_reflection_fragment: BW,
  defaultnormal_vertex: HW,
  displacementmap_pars_vertex: VW,
  displacementmap_vertex: GW,
  emissivemap_fragment: WW,
  emissivemap_pars_fragment: jW,
  colorspace_fragment: $W,
  colorspace_pars_fragment: YW,
  envmap_fragment: XW,
  envmap_common_pars_fragment: qW,
  envmap_pars_fragment: KW,
  envmap_pars_vertex: QW,
  envmap_physical_pars_fragment: u9,
  envmap_vertex: ZW,
  fog_vertex: JW,
  fog_pars_vertex: e9,
  fog_fragment: t9,
  fog_pars_fragment: n9,
  gradientmap_pars_fragment: r9,
  lightmap_fragment: i9,
  lightmap_pars_fragment: a9,
  lights_lambert_fragment: o9,
  lights_lambert_pars_fragment: s9,
  lights_pars_begin: l9,
  lights_toon_fragment: c9,
  lights_toon_pars_fragment: f9,
  lights_phong_fragment: d9,
  lights_phong_pars_fragment: h9,
  lights_physical_fragment: p9,
  lights_physical_pars_fragment: m9,
  lights_fragment_begin: v9,
  lights_fragment_maps: g9,
  lights_fragment_end: y9,
  logdepthbuf_fragment: S9,
  logdepthbuf_pars_fragment: x9,
  logdepthbuf_pars_vertex: _9,
  logdepthbuf_vertex: E9,
  map_fragment: b9,
  map_pars_fragment: T9,
  map_particle_fragment: w9,
  map_particle_pars_fragment: M9,
  metalnessmap_fragment: C9,
  metalnessmap_pars_fragment: R9,
  morphcolor_vertex: A9,
  morphnormal_vertex: D9,
  morphtarget_pars_vertex: L9,
  morphtarget_vertex: O9,
  normal_fragment_begin: P9,
  normal_fragment_maps: U9,
  normal_pars_fragment: N9,
  normal_pars_vertex: F9,
  normal_vertex: k9,
  normalmap_pars_fragment: z9,
  clearcoat_normal_fragment_begin: I9,
  clearcoat_normal_fragment_maps: B9,
  clearcoat_pars_fragment: H9,
  iridescence_pars_fragment: V9,
  opaque_fragment: G9,
  packing: W9,
  premultiplied_alpha_fragment: j9,
  project_vertex: $9,
  dithering_fragment: Y9,
  dithering_pars_fragment: X9,
  roughnessmap_fragment: q9,
  roughnessmap_pars_fragment: K9,
  shadowmap_pars_fragment: Q9,
  shadowmap_pars_vertex: Z9,
  shadowmap_vertex: J9,
  shadowmask_pars_fragment: e7,
  skinbase_vertex: t7,
  skinning_pars_vertex: n7,
  skinning_vertex: r7,
  skinnormal_vertex: i7,
  specularmap_fragment: a7,
  specularmap_pars_fragment: o7,
  tonemapping_fragment: s7,
  tonemapping_pars_fragment: l7,
  transmission_fragment: u7,
  transmission_pars_fragment: c7,
  uv_pars_fragment: f7,
  uv_pars_vertex: d7,
  uv_vertex: h7,
  worldpos_vertex: p7,
  background_vert: m7,
  background_frag: v7,
  backgroundCube_vert: g7,
  backgroundCube_frag: y7,
  cube_vert: S7,
  cube_frag: x7,
  depth_vert: _7,
  depth_frag: E7,
  distanceRGBA_vert: b7,
  distanceRGBA_frag: T7,
  equirect_vert: w7,
  equirect_frag: M7,
  linedashed_vert: C7,
  linedashed_frag: R7,
  meshbasic_vert: A7,
  meshbasic_frag: D7,
  meshlambert_vert: L7,
  meshlambert_frag: O7,
  meshmatcap_vert: P7,
  meshmatcap_frag: U7,
  meshnormal_vert: N7,
  meshnormal_frag: F7,
  meshphong_vert: k7,
  meshphong_frag: z7,
  meshphysical_vert: I7,
  meshphysical_frag: B7,
  meshtoon_vert: H7,
  meshtoon_frag: V7,
  points_vert: G7,
  points_frag: W7,
  shadow_vert: j7,
  shadow_frag: $7,
  sprite_vert: Y7,
  sprite_frag: X7
}, yn = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Rn(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ii() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ii() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new ii() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new ii() },
    normalScale: { value: /* @__PURE__ */ new Ht(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new ii() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new ii() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Rn(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Rn(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ii() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ii() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Rn(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ht(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ii() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ii() },
    alphaTest: { value: 0 }
  }
}, fm = {
  basic: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.specularmap,
      yn.envmap,
      yn.aomap,
      yn.lightmap,
      yn.fog
    ]),
    vertexShader: Jr.meshbasic_vert,
    fragmentShader: Jr.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.specularmap,
      yn.envmap,
      yn.aomap,
      yn.lightmap,
      yn.emissivemap,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      yn.fog,
      yn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Rn(0) }
      }
    ]),
    vertexShader: Jr.meshlambert_vert,
    fragmentShader: Jr.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.specularmap,
      yn.envmap,
      yn.aomap,
      yn.lightmap,
      yn.emissivemap,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      yn.fog,
      yn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Rn(0) },
        specular: { value: /* @__PURE__ */ new Rn(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Jr.meshphong_vert,
    fragmentShader: Jr.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.envmap,
      yn.aomap,
      yn.lightmap,
      yn.emissivemap,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      yn.roughnessmap,
      yn.metalnessmap,
      yn.fog,
      yn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Rn(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Jr.meshphysical_vert,
    fragmentShader: Jr.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.aomap,
      yn.lightmap,
      yn.emissivemap,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      yn.gradientmap,
      yn.fog,
      yn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Rn(0) }
      }
    ]),
    vertexShader: Jr.meshtoon_vert,
    fragmentShader: Jr.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      yn.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Jr.meshmatcap_vert,
    fragmentShader: Jr.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Pf([
      yn.points,
      yn.fog
    ]),
    vertexShader: Jr.points_vert,
    fragmentShader: Jr.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Jr.linedashed_vert,
    fragmentShader: Jr.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.displacementmap
    ]),
    vertexShader: Jr.depth_vert,
    fragmentShader: Jr.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.bumpmap,
      yn.normalmap,
      yn.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Jr.meshnormal_vert,
    fragmentShader: Jr.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Pf([
      yn.sprite,
      yn.fog
    ]),
    vertexShader: Jr.sprite_vert,
    fragmentShader: Jr.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ii() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Jr.background_vert,
    fragmentShader: Jr.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Jr.backgroundCube_vert,
    fragmentShader: Jr.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Jr.cube_vert,
    fragmentShader: Jr.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Jr.equirect_vert,
    fragmentShader: Jr.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Pf([
      yn.common,
      yn.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Te() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Jr.distanceRGBA_vert,
    fragmentShader: Jr.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Pf([
      yn.lights,
      yn.fog,
      {
        color: { value: /* @__PURE__ */ new Rn(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Jr.shadow_vert,
    fragmentShader: Jr.shadow_frag
  }
};
fm.physical = {
  uniforms: /* @__PURE__ */ Pf([
    fm.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new ii() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new ii() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ht(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new ii() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new ii() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new ii() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Rn(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new ii() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new ii() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new ii() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ht() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new ii() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Rn(0) },
      specularColor: { value: /* @__PURE__ */ new Rn(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new ii() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new ii() },
      anisotropyVector: { value: /* @__PURE__ */ new Ht() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new ii() }
    }
  ]),
  vertexShader: Jr.meshphysical_vert,
  fragmentShader: Jr.meshphysical_frag
};
const MC = { r: 0, b: 0, g: 0 };
function q7(n, e, t, r, i, o, l) {
  const c = new Rn(0);
  let h = o === !0 ? 0 : 1, p, y, x = null, b = 0, w = null;
  function R(L, A) {
    let F = !1, k = A.isScene === !0 ? A.background : null;
    k && k.isTexture && (k = (A.backgroundBlurriness > 0 ? t : e).get(k)), k === null ? U(c, h) : k && k.isColor && (U(k, 1), F = !0);
    const H = n.xr.getEnvironmentBlendMode();
    H === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, l) : H === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, l), (n.autoClear || F) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), k && (k.isCubeTexture || k.mapping === tE) ? (y === void 0 && (y = new Al(
      new Mx(1, 1, 1),
      new Mv({
        name: "BackgroundCubeMaterial",
        uniforms: K1(fm.backgroundCube.uniforms),
        vertexShader: fm.backgroundCube.vertexShader,
        fragmentShader: fm.backgroundCube.fragmentShader,
        side: Ic,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), y.geometry.deleteAttribute("normal"), y.geometry.deleteAttribute("uv"), y.onBeforeRender = function(B, $, Y) {
      this.matrixWorld.copyPosition(Y.matrixWorld);
    }, Object.defineProperty(y.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(y)), y.material.uniforms.envMap.value = k, y.material.uniforms.flipEnvMap.value = k.isCubeTexture && k.isRenderTargetTexture === !1 ? -1 : 1, y.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, y.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, y.material.toneMapped = k.colorSpace !== go, (x !== k || b !== k.version || w !== n.toneMapping) && (y.material.needsUpdate = !0, x = k, b = k.version, w = n.toneMapping), y.layers.enableAll(), L.unshift(y, y.geometry, y.material, 0, 0, null)) : k && k.isTexture && (p === void 0 && (p = new Al(
      new R0(2, 2),
      new Mv({
        name: "BackgroundMaterial",
        uniforms: K1(fm.background.uniforms),
        vertexShader: fm.background.vertexShader,
        fragmentShader: fm.background.fragmentShader,
        side: wv,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), p.geometry.deleteAttribute("normal"), Object.defineProperty(p.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(p)), p.material.uniforms.t2D.value = k, p.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, p.material.toneMapped = k.colorSpace !== go, k.matrixAutoUpdate === !0 && k.updateMatrix(), p.material.uniforms.uvTransform.value.copy(k.matrix), (x !== k || b !== k.version || w !== n.toneMapping) && (p.material.needsUpdate = !0, x = k, b = k.version, w = n.toneMapping), p.layers.enableAll(), L.unshift(p, p.geometry, p.material, 0, 0, null));
  }
  function U(L, A) {
    L.getRGB(MC, E4(n)), r.buffers.color.setClear(MC.r, MC.g, MC.b, A, l);
  }
  return {
    getClearColor: function() {
      return c;
    },
    setClearColor: function(L, A = 1) {
      c.set(L), h = A, U(c, h);
    },
    getClearAlpha: function() {
      return h;
    },
    setClearAlpha: function(L) {
      h = L, U(c, h);
    },
    render: R
  };
}
function K7(n, e, t, r) {
  const i = n.getParameter(n.MAX_VERTEX_ATTRIBS), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), l = r.isWebGL2 || o !== null, c = {}, h = L(null);
  let p = h, y = !1;
  function x(de, xe, _e, Pe, ce) {
    let ve = !1;
    if (l) {
      const re = U(Pe, _e, xe);
      p !== re && (p = re, w(p.object)), ve = A(de, Pe, _e, ce), ve && F(de, Pe, _e, ce);
    } else {
      const re = xe.wireframe === !0;
      (p.geometry !== Pe.id || p.program !== _e.id || p.wireframe !== re) && (p.geometry = Pe.id, p.program = _e.id, p.wireframe = re, ve = !0);
    }
    ce !== null && t.update(ce, n.ELEMENT_ARRAY_BUFFER), (ve || y) && (y = !1, J(de, xe, _e, Pe), ce !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(ce).buffer));
  }
  function b() {
    return r.isWebGL2 ? n.createVertexArray() : o.createVertexArrayOES();
  }
  function w(de) {
    return r.isWebGL2 ? n.bindVertexArray(de) : o.bindVertexArrayOES(de);
  }
  function R(de) {
    return r.isWebGL2 ? n.deleteVertexArray(de) : o.deleteVertexArrayOES(de);
  }
  function U(de, xe, _e) {
    const Pe = _e.wireframe === !0;
    let ce = c[de.id];
    ce === void 0 && (ce = {}, c[de.id] = ce);
    let ve = ce[xe.id];
    ve === void 0 && (ve = {}, ce[xe.id] = ve);
    let re = ve[Pe];
    return re === void 0 && (re = L(b()), ve[Pe] = re), re;
  }
  function L(de) {
    const xe = [], _e = [], Pe = [];
    for (let ce = 0; ce < i; ce++)
      xe[ce] = 0, _e[ce] = 0, Pe[ce] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: xe,
      enabledAttributes: _e,
      attributeDivisors: Pe,
      object: de,
      attributes: {},
      index: null
    };
  }
  function A(de, xe, _e, Pe) {
    const ce = p.attributes, ve = xe.attributes;
    let re = 0;
    const ee = _e.getAttributes();
    for (const he in ee)
      if (ee[he].location >= 0) {
        const Le = ce[he];
        let Ae = ve[he];
        if (Ae === void 0 && (he === "instanceMatrix" && de.instanceMatrix && (Ae = de.instanceMatrix), he === "instanceColor" && de.instanceColor && (Ae = de.instanceColor)), Le === void 0 || Le.attribute !== Ae || Ae && Le.data !== Ae.data)
          return !0;
        re++;
      }
    return p.attributesNum !== re || p.index !== Pe;
  }
  function F(de, xe, _e, Pe) {
    const ce = {}, ve = xe.attributes;
    let re = 0;
    const ee = _e.getAttributes();
    for (const he in ee)
      if (ee[he].location >= 0) {
        let Le = ve[he];
        Le === void 0 && (he === "instanceMatrix" && de.instanceMatrix && (Le = de.instanceMatrix), he === "instanceColor" && de.instanceColor && (Le = de.instanceColor));
        const Ae = {};
        Ae.attribute = Le, Le && Le.data && (Ae.data = Le.data), ce[he] = Ae, re++;
      }
    p.attributes = ce, p.attributesNum = re, p.index = Pe;
  }
  function k() {
    const de = p.newAttributes;
    for (let xe = 0, _e = de.length; xe < _e; xe++)
      de[xe] = 0;
  }
  function H(de) {
    B(de, 0);
  }
  function B(de, xe) {
    const _e = p.newAttributes, Pe = p.enabledAttributes, ce = p.attributeDivisors;
    _e[de] = 1, Pe[de] === 0 && (n.enableVertexAttribArray(de), Pe[de] = 1), ce[de] !== xe && ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](de, xe), ce[de] = xe);
  }
  function $() {
    const de = p.newAttributes, xe = p.enabledAttributes;
    for (let _e = 0, Pe = xe.length; _e < Pe; _e++)
      xe[_e] !== de[_e] && (n.disableVertexAttribArray(_e), xe[_e] = 0);
  }
  function Y(de, xe, _e, Pe, ce, ve, re) {
    re === !0 ? n.vertexAttribIPointer(de, xe, _e, ce, ve) : n.vertexAttribPointer(de, xe, _e, Pe, ce, ve);
  }
  function J(de, xe, _e, Pe) {
    if (r.isWebGL2 === !1 && (de.isInstancedMesh || Pe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    k();
    const ce = Pe.attributes, ve = _e.getAttributes(), re = xe.defaultAttributeValues;
    for (const ee in ve) {
      const he = ve[ee];
      if (he.location >= 0) {
        let Me = ce[ee];
        if (Me === void 0 && (ee === "instanceMatrix" && de.instanceMatrix && (Me = de.instanceMatrix), ee === "instanceColor" && de.instanceColor && (Me = de.instanceColor)), Me !== void 0) {
          const Le = Me.normalized, Ae = Me.itemSize, Ue = t.get(Me);
          if (Ue === void 0)
            continue;
          const Ne = Ue.buffer, ke = Ue.type, it = Ue.bytesPerElement, At = r.isWebGL2 === !0 && (ke === n.INT || ke === n.UNSIGNED_INT || Me.gpuType === SP);
          if (Me.isInterleavedBufferAttribute) {
            const rt = Me.data, ae = rt.stride, et = Me.offset;
            if (rt.isInstancedInterleavedBuffer) {
              for (let Ye = 0; Ye < he.locationSize; Ye++)
                B(he.location + Ye, rt.meshPerAttribute);
              de.isInstancedMesh !== !0 && Pe._maxInstanceCount === void 0 && (Pe._maxInstanceCount = rt.meshPerAttribute * rt.count);
            } else
              for (let Ye = 0; Ye < he.locationSize; Ye++)
                H(he.location + Ye);
            n.bindBuffer(n.ARRAY_BUFFER, Ne);
            for (let Ye = 0; Ye < he.locationSize; Ye++)
              Y(
                he.location + Ye,
                Ae / he.locationSize,
                ke,
                Le,
                ae * it,
                (et + Ae / he.locationSize * Ye) * it,
                At
              );
          } else {
            if (Me.isInstancedBufferAttribute) {
              for (let rt = 0; rt < he.locationSize; rt++)
                B(he.location + rt, Me.meshPerAttribute);
              de.isInstancedMesh !== !0 && Pe._maxInstanceCount === void 0 && (Pe._maxInstanceCount = Me.meshPerAttribute * Me.count);
            } else
              for (let rt = 0; rt < he.locationSize; rt++)
                H(he.location + rt);
            n.bindBuffer(n.ARRAY_BUFFER, Ne);
            for (let rt = 0; rt < he.locationSize; rt++)
              Y(
                he.location + rt,
                Ae / he.locationSize,
                ke,
                Le,
                Ae * it,
                Ae / he.locationSize * rt * it,
                At
              );
          }
        } else if (re !== void 0) {
          const Le = re[ee];
          if (Le !== void 0)
            switch (Le.length) {
              case 2:
                n.vertexAttrib2fv(he.location, Le);
                break;
              case 3:
                n.vertexAttrib3fv(he.location, Le);
                break;
              case 4:
                n.vertexAttrib4fv(he.location, Le);
                break;
              default:
                n.vertexAttrib1fv(he.location, Le);
            }
        }
      }
    }
    $();
  }
  function K() {
    oe();
    for (const de in c) {
      const xe = c[de];
      for (const _e in xe) {
        const Pe = xe[_e];
        for (const ce in Pe)
          R(Pe[ce].object), delete Pe[ce];
        delete xe[_e];
      }
      delete c[de];
    }
  }
  function X(de) {
    if (c[de.id] === void 0)
      return;
    const xe = c[de.id];
    for (const _e in xe) {
      const Pe = xe[_e];
      for (const ce in Pe)
        R(Pe[ce].object), delete Pe[ce];
      delete xe[_e];
    }
    delete c[de.id];
  }
  function le(de) {
    for (const xe in c) {
      const _e = c[xe];
      if (_e[de.id] === void 0)
        continue;
      const Pe = _e[de.id];
      for (const ce in Pe)
        R(Pe[ce].object), delete Pe[ce];
      delete _e[de.id];
    }
  }
  function oe() {
    fe(), y = !0, p !== h && (p = h, w(p.object));
  }
  function fe() {
    h.geometry = null, h.program = null, h.wireframe = !1;
  }
  return {
    setup: x,
    reset: oe,
    resetDefaultState: fe,
    dispose: K,
    releaseStatesOfGeometry: X,
    releaseStatesOfProgram: le,
    initAttributes: k,
    enableAttribute: H,
    disableUnusedAttributes: $
  };
}
function Q7(n, e, t, r) {
  const i = r.isWebGL2;
  let o;
  function l(p) {
    o = p;
  }
  function c(p, y) {
    n.drawArrays(o, p, y), t.update(y, o, 1);
  }
  function h(p, y, x) {
    if (x === 0)
      return;
    let b, w;
    if (i)
      b = n, w = "drawArraysInstanced";
    else if (b = e.get("ANGLE_instanced_arrays"), w = "drawArraysInstancedANGLE", b === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    b[w](o, p, y, x), t.update(y, o, x);
  }
  this.setMode = l, this.render = c, this.renderInstances = h;
}
function Z7(n, e, t) {
  let r;
  function i() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const Y = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(Y.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function o(Y) {
    if (Y === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      Y = "mediump";
    }
    return Y === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const l = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
  let c = t.precision !== void 0 ? t.precision : "highp";
  const h = o(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const p = l || e.has("WEBGL_draw_buffers"), y = t.logarithmicDepthBuffer === !0, x = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), b = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), w = n.getParameter(n.MAX_TEXTURE_SIZE), R = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), U = n.getParameter(n.MAX_VERTEX_ATTRIBS), L = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), A = n.getParameter(n.MAX_VARYING_VECTORS), F = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), k = b > 0, H = l || e.has("OES_texture_float"), B = k && H, $ = l ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: l,
    drawBuffers: p,
    getMaxAnisotropy: i,
    getMaxPrecision: o,
    precision: c,
    logarithmicDepthBuffer: y,
    maxTextures: x,
    maxVertexTextures: b,
    maxTextureSize: w,
    maxCubemapSize: R,
    maxAttributes: U,
    maxVertexUniforms: L,
    maxVaryings: A,
    maxFragmentUniforms: F,
    vertexTextures: k,
    floatFragmentTextures: H,
    floatVertexTextures: B,
    maxSamples: $
  };
}
function J7(n) {
  const e = this;
  let t = null, r = 0, i = !1, o = !1;
  const l = new kg(), c = new ii(), h = { value: null, needsUpdate: !1 };
  this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function(x, b) {
    const w = x.length !== 0 || b || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || i;
    return i = b, r = x.length, w;
  }, this.beginShadows = function() {
    o = !0, y(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(x, b) {
    t = y(x, b, 0);
  }, this.setState = function(x, b, w) {
    const R = x.clippingPlanes, U = x.clipIntersection, L = x.clipShadows, A = n.get(x);
    if (!i || R === null || R.length === 0 || o && !L)
      o ? y(null) : p();
    else {
      const F = o ? 0 : r, k = F * 4;
      let H = A.clippingState || null;
      h.value = H, H = y(R, b, k, w);
      for (let B = 0; B !== k; ++B)
        H[B] = t[B];
      A.clippingState = H, this.numIntersection = U ? this.numPlanes : 0, this.numPlanes += F;
    }
  };
  function p() {
    h.value !== t && (h.value = t, h.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function y(x, b, w, R) {
    const U = x !== null ? x.length : 0;
    let L = null;
    if (U !== 0) {
      if (L = h.value, R !== !0 || L === null) {
        const A = w + U * 4, F = b.matrixWorldInverse;
        c.getNormalMatrix(F), (L === null || L.length < A) && (L = new Float32Array(A));
        for (let k = 0, H = w; k !== U; ++k, H += 4)
          l.copy(x[k]).applyMatrix4(F, c), l.normal.toArray(L, H), L[H + 3] = l.constant;
      }
      h.value = L, h.needsUpdate = !0;
    }
    return e.numPlanes = U, e.numIntersection = 0, L;
  }
}
function ej(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, c) {
    return c === UT ? l.mapping = jg : c === NT && (l.mapping = S0), l;
  }
  function r(l) {
    if (l && l.isTexture && l.isRenderTargetTexture === !1) {
      const c = l.mapping;
      if (c === UT || c === NT)
        if (e.has(l)) {
          const h = e.get(l).texture;
          return t(h, l.mapping);
        } else {
          const h = l.image;
          if (h && h.height > 0) {
            const p = new T4(h.height / 2);
            return p.fromEquirectangularTexture(n, l), e.set(l, p), l.addEventListener("dispose", i), t(p.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function i(l) {
    const c = l.target;
    c.removeEventListener("dispose", i);
    const h = e.get(c);
    h !== void 0 && (e.delete(c), h.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: o
  };
}
class Vg extends sw {
  constructor(e = -1, t = 1, r = 1, i = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, r, i, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = r - e, l = r + e, c = i + t, h = i - t;
    if (this.view !== null && this.view.enabled) {
      const p = (this.right - this.left) / this.view.fullWidth / this.zoom, y = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += p * this.view.offsetX, l = o + p * this.view.width, c -= y * this.view.offsetY, h = c - y * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, c, h, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const k1 = 4, BN = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], rx = 20, WD = /* @__PURE__ */ new Vg(), HN = /* @__PURE__ */ new Rn();
let jD = null;
const tx = (1 + Math.sqrt(5)) / 2, _1 = 1 / tx, VN = [
  /* @__PURE__ */ new Te(1, 1, 1),
  /* @__PURE__ */ new Te(-1, 1, 1),
  /* @__PURE__ */ new Te(1, 1, -1),
  /* @__PURE__ */ new Te(-1, 1, -1),
  /* @__PURE__ */ new Te(0, tx, _1),
  /* @__PURE__ */ new Te(0, tx, -_1),
  /* @__PURE__ */ new Te(_1, 0, tx),
  /* @__PURE__ */ new Te(-_1, 0, tx),
  /* @__PURE__ */ new Te(tx, _1, 0),
  /* @__PURE__ */ new Te(-tx, _1, 0)
];
class _O {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, r = 0.1, i = 100) {
    jD = this._renderer.getRenderTarget(), this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, r, i, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = jN(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = WN(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(jD), e.scissorTest = !1, CC(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === jg || e.mapping === S0 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), jD = this._renderer.getRenderTarget();
    const r = t || this._allocateTargets();
    return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
      magFilter: ss,
      minFilter: ss,
      generateMipmaps: !1,
      type: X1,
      format: Td,
      colorSpace: dm,
      depthBuffer: !1
    }, i = GN(e, t, r);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = GN(e, t, r);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = tj(o)), this._blurMaterial = nj(o, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Al(this._lodPlanes[0], e);
    this._renderer.compile(t, WD);
  }
  _sceneToCubeUV(e, t, r, i) {
    const c = new Ps(90, 1, t, r), h = [1, -1, 1, 1, 1, 1], p = [1, 1, 1, -1, -1, -1], y = this._renderer, x = y.autoClear, b = y.toneMapping;
    y.getClearColor(HN), y.toneMapping = Ev, y.autoClear = !1;
    const w = new Qg({
      name: "PMREM.Background",
      side: Ic,
      depthWrite: !1,
      depthTest: !1
    }), R = new Al(new Mx(), w);
    let U = !1;
    const L = e.background;
    L ? L.isColor && (w.color.copy(L), e.background = null, U = !0) : (w.color.copy(HN), U = !0);
    for (let A = 0; A < 6; A++) {
      const F = A % 3;
      F === 0 ? (c.up.set(0, h[A], 0), c.lookAt(p[A], 0, 0)) : F === 1 ? (c.up.set(0, 0, h[A]), c.lookAt(0, p[A], 0)) : (c.up.set(0, h[A], 0), c.lookAt(0, 0, p[A]));
      const k = this._cubeSize;
      CC(i, F * k, A > 2 ? k : 0, k, k), y.setRenderTarget(i), U && y.render(R, c), y.render(e, c);
    }
    R.geometry.dispose(), R.material.dispose(), y.toneMapping = b, y.autoClear = x, e.background = L;
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer, i = e.mapping === jg || e.mapping === S0;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = jN()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = WN());
    const o = i ? this._cubemapMaterial : this._equirectMaterial, l = new Al(this._lodPlanes[0], o), c = o.uniforms;
    c.envMap.value = e;
    const h = this._cubeSize;
    CC(t, 0, 0, 3 * h, 2 * h), r.setRenderTarget(t), r.render(l, WD);
  }
  _applyPMREM(e) {
    const t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const o = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), l = VN[(i - 1) % VN.length];
      this._blur(e, i - 1, i, o, l);
    }
    t.autoClear = r;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, r, i, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      r,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      r,
      r,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, r, i, o, l, c) {
    const h = this._renderer, p = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const y = 3, x = new Al(this._lodPlanes[i], p), b = p.uniforms, w = this._sizeLods[r] - 1, R = isFinite(o) ? Math.PI / (2 * w) : 2 * Math.PI / (2 * rx - 1), U = o / R, L = isFinite(o) ? 1 + Math.floor(y * U) : rx;
    L > rx && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${L} samples when the maximum is set to ${rx}`);
    const A = [];
    let F = 0;
    for (let Y = 0; Y < rx; ++Y) {
      const J = Y / U, K = Math.exp(-J * J / 2);
      A.push(K), Y === 0 ? F += K : Y < L && (F += 2 * K);
    }
    for (let Y = 0; Y < A.length; Y++)
      A[Y] = A[Y] / F;
    b.envMap.value = e.texture, b.samples.value = L, b.weights.value = A, b.latitudinal.value = l === "latitudinal", c && (b.poleAxis.value = c);
    const { _lodMax: k } = this;
    b.dTheta.value = R, b.mipInt.value = k - r;
    const H = this._sizeLods[i], B = 3 * H * (i > k - k1 ? i - k + k1 : 0), $ = 4 * (this._cubeSize - H);
    CC(t, B, $, 3 * H, 2 * H), h.setRenderTarget(t), h.render(x, WD);
  }
}
function tj(n) {
  const e = [], t = [], r = [];
  let i = n;
  const o = n - k1 + 1 + BN.length;
  for (let l = 0; l < o; l++) {
    const c = Math.pow(2, i);
    t.push(c);
    let h = 1 / c;
    l > n - k1 ? h = BN[l - n + k1 - 1] : l === 0 && (h = 0), r.push(h);
    const p = 1 / (c - 2), y = -p, x = 1 + p, b = [y, y, x, y, x, x, y, y, x, x, y, x], w = 6, R = 6, U = 3, L = 2, A = 1, F = new Float32Array(U * R * w), k = new Float32Array(L * R * w), H = new Float32Array(A * R * w);
    for (let $ = 0; $ < w; $++) {
      const Y = $ % 3 * 2 / 3 - 1, J = $ > 2 ? 0 : -1, K = [
        Y,
        J,
        0,
        Y + 2 / 3,
        J,
        0,
        Y + 2 / 3,
        J + 1,
        0,
        Y,
        J,
        0,
        Y + 2 / 3,
        J + 1,
        0,
        Y,
        J + 1,
        0
      ];
      F.set(K, U * R * $), k.set(b, L * R * $);
      const X = [$, $, $, $, $, $];
      H.set(X, A * R * $);
    }
    const B = new oi();
    B.setAttribute("position", new io(F, U)), B.setAttribute("uv", new io(k, L)), B.setAttribute("faceIndex", new io(H, A)), e.push(B), i > k1 && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function GN(n, e, t) {
  const r = new hm(n, e, t);
  return r.texture.mapping = tE, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function CC(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function nj(n, e, t) {
  const r = new Float32Array(rx), i = new Te(0, 1, 0);
  return new Mv({
    name: "SphericalGaussianBlur",
    defines: {
      n: rx,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: UP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Gg,
    depthTest: !1,
    depthWrite: !1
  });
}
function WN() {
  return new Mv({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: UP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Gg,
    depthTest: !1,
    depthWrite: !1
  });
}
function jN() {
  return new Mv({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: UP(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Gg,
    depthTest: !1,
    depthWrite: !1
  });
}
function UP() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function rj(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function r(c) {
    if (c && c.isTexture) {
      const h = c.mapping, p = h === UT || h === NT, y = h === jg || h === S0;
      if (p || y)
        if (c.isRenderTargetTexture && c.needsPMREMUpdate === !0) {
          c.needsPMREMUpdate = !1;
          let x = e.get(c);
          return t === null && (t = new _O(n)), x = p ? t.fromEquirectangular(c, x) : t.fromCubemap(c, x), e.set(c, x), x.texture;
        } else {
          if (e.has(c))
            return e.get(c).texture;
          {
            const x = c.image;
            if (p && x && x.height > 0 || y && x && i(x)) {
              t === null && (t = new _O(n));
              const b = p ? t.fromEquirectangular(c) : t.fromCubemap(c);
              return e.set(c, b), c.addEventListener("dispose", o), b.texture;
            } else
              return null;
          }
        }
    }
    return c;
  }
  function i(c) {
    let h = 0;
    const p = 6;
    for (let y = 0; y < p; y++)
      c[y] !== void 0 && h++;
    return h === p;
  }
  function o(c) {
    const h = c.target;
    h.removeEventListener("dispose", o);
    const p = e.get(h);
    p !== void 0 && (e.delete(h), p.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: r,
    dispose: l
  };
}
function ij(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0)
      return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return e[r] = i, i;
  }
  return {
    has: function(r) {
      return t(r) !== null;
    },
    init: function(r) {
      r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(r) {
      const i = t(r);
      return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i;
    }
  };
}
function aj(n, e, t, r) {
  const i = {}, o = /* @__PURE__ */ new WeakMap();
  function l(x) {
    const b = x.target;
    b.index !== null && e.remove(b.index);
    for (const R in b.attributes)
      e.remove(b.attributes[R]);
    for (const R in b.morphAttributes) {
      const U = b.morphAttributes[R];
      for (let L = 0, A = U.length; L < A; L++)
        e.remove(U[L]);
    }
    b.removeEventListener("dispose", l), delete i[b.id];
    const w = o.get(b);
    w && (e.remove(w), o.delete(b)), r.releaseStatesOfGeometry(b), b.isInstancedBufferGeometry === !0 && delete b._maxInstanceCount, t.memory.geometries--;
  }
  function c(x, b) {
    return i[b.id] === !0 || (b.addEventListener("dispose", l), i[b.id] = !0, t.memory.geometries++), b;
  }
  function h(x) {
    const b = x.attributes;
    for (const R in b)
      e.update(b[R], n.ARRAY_BUFFER);
    const w = x.morphAttributes;
    for (const R in w) {
      const U = w[R];
      for (let L = 0, A = U.length; L < A; L++)
        e.update(U[L], n.ARRAY_BUFFER);
    }
  }
  function p(x) {
    const b = [], w = x.index, R = x.attributes.position;
    let U = 0;
    if (w !== null) {
      const F = w.array;
      U = w.version;
      for (let k = 0, H = F.length; k < H; k += 3) {
        const B = F[k + 0], $ = F[k + 1], Y = F[k + 2];
        b.push(B, $, $, Y, Y, B);
      }
    } else if (R !== void 0) {
      const F = R.array;
      U = R.version;
      for (let k = 0, H = F.length / 3 - 1; k < H; k += 3) {
        const B = k + 0, $ = k + 1, Y = k + 2;
        b.push(B, $, $, Y, Y, B);
      }
    } else
      return;
    const L = new (y4(b) ? OP : LP)(b, 1);
    L.version = U;
    const A = o.get(x);
    A && e.remove(A), o.set(x, L);
  }
  function y(x) {
    const b = o.get(x);
    if (b) {
      const w = x.index;
      w !== null && b.version < w.version && p(x);
    } else
      p(x);
    return o.get(x);
  }
  return {
    get: c,
    update: h,
    getWireframeAttribute: y
  };
}
function oj(n, e, t, r) {
  const i = r.isWebGL2;
  let o;
  function l(b) {
    o = b;
  }
  let c, h;
  function p(b) {
    c = b.type, h = b.bytesPerElement;
  }
  function y(b, w) {
    n.drawElements(o, w, c, b * h), t.update(w, o, 1);
  }
  function x(b, w, R) {
    if (R === 0)
      return;
    let U, L;
    if (i)
      U = n, L = "drawElementsInstanced";
    else if (U = e.get("ANGLE_instanced_arrays"), L = "drawElementsInstancedANGLE", U === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    U[L](o, w, c, b * h, R), t.update(w, o, R);
  }
  this.setMode = l, this.setIndex = p, this.render = y, this.renderInstances = x;
}
function sj(n) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(o, l, c) {
    switch (t.calls++, l) {
      case n.TRIANGLES:
        t.triangles += c * (o / 3);
        break;
      case n.LINES:
        t.lines += c * (o / 2);
        break;
      case n.LINE_STRIP:
        t.lines += c * (o - 1);
        break;
      case n.LINE_LOOP:
        t.lines += c * o;
        break;
      case n.POINTS:
        t.points += c * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r
  };
}
function lj(n, e) {
  return n[0] - e[0];
}
function uj(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function cj(n, e, t) {
  const r = {}, i = new Float32Array(8), o = /* @__PURE__ */ new WeakMap(), l = new ua(), c = [];
  for (let p = 0; p < 8; p++)
    c[p] = [p, 0];
  function h(p, y, x) {
    const b = p.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const w = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color, R = w !== void 0 ? w.length : 0;
      let U = o.get(y);
      if (U === void 0 || U.count !== R) {
        let de = function() {
          oe.dispose(), o.delete(y), y.removeEventListener("dispose", de);
        };
        U !== void 0 && U.texture.dispose();
        const F = y.morphAttributes.position !== void 0, k = y.morphAttributes.normal !== void 0, H = y.morphAttributes.color !== void 0, B = y.morphAttributes.position || [], $ = y.morphAttributes.normal || [], Y = y.morphAttributes.color || [];
        let J = 0;
        F === !0 && (J = 1), k === !0 && (J = 2), H === !0 && (J = 3);
        let K = y.attributes.position.count * J, X = 1;
        K > e.maxTextureSize && (X = Math.ceil(K / e.maxTextureSize), K = e.maxTextureSize);
        const le = new Float32Array(K * X * 4 * R), oe = new KR(le, K, X, R);
        oe.type = xv, oe.needsUpdate = !0;
        const fe = J * 4;
        for (let xe = 0; xe < R; xe++) {
          const _e = B[xe], Pe = $[xe], ce = Y[xe], ve = K * X * 4 * xe;
          for (let re = 0; re < _e.count; re++) {
            const ee = re * fe;
            F === !0 && (l.fromBufferAttribute(_e, re), le[ve + ee + 0] = l.x, le[ve + ee + 1] = l.y, le[ve + ee + 2] = l.z, le[ve + ee + 3] = 0), k === !0 && (l.fromBufferAttribute(Pe, re), le[ve + ee + 4] = l.x, le[ve + ee + 5] = l.y, le[ve + ee + 6] = l.z, le[ve + ee + 7] = 0), H === !0 && (l.fromBufferAttribute(ce, re), le[ve + ee + 8] = l.x, le[ve + ee + 9] = l.y, le[ve + ee + 10] = l.z, le[ve + ee + 11] = ce.itemSize === 4 ? l.w : 1);
          }
        }
        U = {
          count: R,
          texture: oe,
          size: new Ht(K, X)
        }, o.set(y, U), y.addEventListener("dispose", de);
      }
      let L = 0;
      for (let F = 0; F < b.length; F++)
        L += b[F];
      const A = y.morphTargetsRelative ? 1 : 1 - L;
      x.getUniforms().setValue(n, "morphTargetBaseInfluence", A), x.getUniforms().setValue(n, "morphTargetInfluences", b), x.getUniforms().setValue(n, "morphTargetsTexture", U.texture, t), x.getUniforms().setValue(n, "morphTargetsTextureSize", U.size);
    } else {
      const w = b === void 0 ? 0 : b.length;
      let R = r[y.id];
      if (R === void 0 || R.length !== w) {
        R = [];
        for (let k = 0; k < w; k++)
          R[k] = [k, 0];
        r[y.id] = R;
      }
      for (let k = 0; k < w; k++) {
        const H = R[k];
        H[0] = k, H[1] = b[k];
      }
      R.sort(uj);
      for (let k = 0; k < 8; k++)
        k < w && R[k][1] ? (c[k][0] = R[k][0], c[k][1] = R[k][1]) : (c[k][0] = Number.MAX_SAFE_INTEGER, c[k][1] = 0);
      c.sort(lj);
      const U = y.morphAttributes.position, L = y.morphAttributes.normal;
      let A = 0;
      for (let k = 0; k < 8; k++) {
        const H = c[k], B = H[0], $ = H[1];
        B !== Number.MAX_SAFE_INTEGER && $ ? (U && y.getAttribute("morphTarget" + k) !== U[B] && y.setAttribute("morphTarget" + k, U[B]), L && y.getAttribute("morphNormal" + k) !== L[B] && y.setAttribute("morphNormal" + k, L[B]), i[k] = $, A += $) : (U && y.hasAttribute("morphTarget" + k) === !0 && y.deleteAttribute("morphTarget" + k), L && y.hasAttribute("morphNormal" + k) === !0 && y.deleteAttribute("morphNormal" + k), i[k] = 0);
      }
      const F = y.morphTargetsRelative ? 1 : 1 - A;
      x.getUniforms().setValue(n, "morphTargetBaseInfluence", F), x.getUniforms().setValue(n, "morphTargetInfluences", i);
    }
  }
  return {
    update: h
  };
}
function fj(n, e, t, r) {
  let i = /* @__PURE__ */ new WeakMap();
  function o(h) {
    const p = r.render.frame, y = h.geometry, x = e.get(h, y);
    if (i.get(x) !== p && (e.update(x), i.set(x, p)), h.isInstancedMesh && (h.hasEventListener("dispose", c) === !1 && h.addEventListener("dispose", c), i.get(h) !== p && (t.update(h.instanceMatrix, n.ARRAY_BUFFER), h.instanceColor !== null && t.update(h.instanceColor, n.ARRAY_BUFFER), i.set(h, p))), h.isSkinnedMesh) {
      const b = h.skeleton;
      i.get(b) !== p && (b.update(), i.set(b, p));
    }
    return x;
  }
  function l() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function c(h) {
    const p = h.target;
    p.removeEventListener("dispose", c), t.remove(p.instanceMatrix), p.instanceColor !== null && t.remove(p.instanceColor);
  }
  return {
    update: o,
    dispose: l
  };
}
const M4 = /* @__PURE__ */ new cs(), C4 = /* @__PURE__ */ new KR(), R4 = /* @__PURE__ */ new DP(), A4 = /* @__PURE__ */ new lw(), $N = [], YN = [], XN = new Float32Array(16), qN = new Float32Array(9), KN = new Float32Array(4);
function nE(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0)
    return n;
  const i = e * t;
  let o = $N[i];
  if (o === void 0 && (o = new Float32Array(i), $N[i] = o), e !== 0) {
    r.toArray(o, 0);
    for (let l = 1, c = 0; l !== e; ++l)
      c += t, n[l].toArray(o, c);
  }
  return o;
}
function tu(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0, r = n.length; t < r; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function nu(n, e) {
  for (let t = 0, r = e.length; t < r; t++)
    n[t] = e[t];
}
function ZR(n, e) {
  let t = YN[e];
  t === void 0 && (t = new Int32Array(e), YN[e] = t);
  for (let r = 0; r !== e; ++r)
    t[r] = n.allocateTextureUnit();
  return t;
}
function dj(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function hj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tu(t, e))
      return;
    n.uniform2fv(this.addr, e), nu(t, e);
  }
}
function pj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (tu(t, e))
      return;
    n.uniform3fv(this.addr, e), nu(t, e);
  }
}
function mj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tu(t, e))
      return;
    n.uniform4fv(this.addr, e), nu(t, e);
  }
}
function vj(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (tu(t, e))
      return;
    n.uniformMatrix2fv(this.addr, !1, e), nu(t, e);
  } else {
    if (tu(t, r))
      return;
    KN.set(r), n.uniformMatrix2fv(this.addr, !1, KN), nu(t, r);
  }
}
function gj(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (tu(t, e))
      return;
    n.uniformMatrix3fv(this.addr, !1, e), nu(t, e);
  } else {
    if (tu(t, r))
      return;
    qN.set(r), n.uniformMatrix3fv(this.addr, !1, qN), nu(t, r);
  }
}
function yj(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (tu(t, e))
      return;
    n.uniformMatrix4fv(this.addr, !1, e), nu(t, e);
  } else {
    if (tu(t, r))
      return;
    XN.set(r), n.uniformMatrix4fv(this.addr, !1, XN), nu(t, r);
  }
}
function Sj(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function xj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tu(t, e))
      return;
    n.uniform2iv(this.addr, e), nu(t, e);
  }
}
function _j(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (tu(t, e))
      return;
    n.uniform3iv(this.addr, e), nu(t, e);
  }
}
function Ej(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tu(t, e))
      return;
    n.uniform4iv(this.addr, e), nu(t, e);
  }
}
function bj(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function Tj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (tu(t, e))
      return;
    n.uniform2uiv(this.addr, e), nu(t, e);
  }
}
function wj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (tu(t, e))
      return;
    n.uniform3uiv(this.addr, e), nu(t, e);
  }
}
function Mj(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (tu(t, e))
      return;
    n.uniform4uiv(this.addr, e), nu(t, e);
  }
}
function Cj(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2D(e || M4, i);
}
function Rj(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || R4, i);
}
function Aj(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || A4, i);
}
function Dj(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || C4, i);
}
function Lj(n) {
  switch (n) {
    case 5126:
      return dj;
    case 35664:
      return hj;
    case 35665:
      return pj;
    case 35666:
      return mj;
    case 35674:
      return vj;
    case 35675:
      return gj;
    case 35676:
      return yj;
    case 5124:
    case 35670:
      return Sj;
    case 35667:
    case 35671:
      return xj;
    case 35668:
    case 35672:
      return _j;
    case 35669:
    case 35673:
      return Ej;
    case 5125:
      return bj;
    case 36294:
      return Tj;
    case 36295:
      return wj;
    case 36296:
      return Mj;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Cj;
    case 35679:
    case 36299:
    case 36307:
      return Rj;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Aj;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Dj;
  }
}
function Oj(n, e) {
  n.uniform1fv(this.addr, e);
}
function Pj(n, e) {
  const t = nE(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Uj(n, e) {
  const t = nE(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Nj(n, e) {
  const t = nE(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function Fj(n, e) {
  const t = nE(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function kj(n, e) {
  const t = nE(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function zj(n, e) {
  const t = nE(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Ij(n, e) {
  n.uniform1iv(this.addr, e);
}
function Bj(n, e) {
  n.uniform2iv(this.addr, e);
}
function Hj(n, e) {
  n.uniform3iv(this.addr, e);
}
function Vj(n, e) {
  n.uniform4iv(this.addr, e);
}
function Gj(n, e) {
  n.uniform1uiv(this.addr, e);
}
function Wj(n, e) {
  n.uniform2uiv(this.addr, e);
}
function jj(n, e) {
  n.uniform3uiv(this.addr, e);
}
function $j(n, e) {
  n.uniform4uiv(this.addr, e);
}
function Yj(n, e, t) {
  const r = this.cache, i = e.length, o = ZR(t, i);
  tu(r, o) || (n.uniform1iv(this.addr, o), nu(r, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2D(e[l] || M4, o[l]);
}
function Xj(n, e, t) {
  const r = this.cache, i = e.length, o = ZR(t, i);
  tu(r, o) || (n.uniform1iv(this.addr, o), nu(r, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture3D(e[l] || R4, o[l]);
}
function qj(n, e, t) {
  const r = this.cache, i = e.length, o = ZR(t, i);
  tu(r, o) || (n.uniform1iv(this.addr, o), nu(r, o));
  for (let l = 0; l !== i; ++l)
    t.setTextureCube(e[l] || A4, o[l]);
}
function Kj(n, e, t) {
  const r = this.cache, i = e.length, o = ZR(t, i);
  tu(r, o) || (n.uniform1iv(this.addr, o), nu(r, o));
  for (let l = 0; l !== i; ++l)
    t.setTexture2DArray(e[l] || C4, o[l]);
}
function Qj(n) {
  switch (n) {
    case 5126:
      return Oj;
    case 35664:
      return Pj;
    case 35665:
      return Uj;
    case 35666:
      return Nj;
    case 35674:
      return Fj;
    case 35675:
      return kj;
    case 35676:
      return zj;
    case 5124:
    case 35670:
      return Ij;
    case 35667:
    case 35671:
      return Bj;
    case 35668:
    case 35672:
      return Hj;
    case 35669:
    case 35673:
      return Vj;
    case 5125:
      return Gj;
    case 36294:
      return Wj;
    case 36295:
      return jj;
    case 36296:
      return $j;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Yj;
    case 35679:
    case 36299:
    case 36307:
      return Xj;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return qj;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Kj;
  }
}
class Zj {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.setValue = Lj(t.type);
  }
}
class Jj {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = Qj(t.type);
  }
}
class e$ {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let o = 0, l = i.length; o !== l; ++o) {
      const c = i[o];
      c.setValue(e, t[c.id], r);
    }
  }
}
const $D = /(\w+)(\])?(\[|\.)?/g;
function QN(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function t$(n, e, t) {
  const r = n.name, i = r.length;
  for ($D.lastIndex = 0; ; ) {
    const o = $D.exec(r), l = $D.lastIndex;
    let c = o[1];
    const h = o[2] === "]", p = o[3];
    if (h && (c = c | 0), p === void 0 || p === "[" && l + 2 === i) {
      QN(t, p === void 0 ? new Zj(c, n, e) : new Jj(c, n, e));
      break;
    } else {
      let x = t.map[c];
      x === void 0 && (x = new e$(c), QN(t, x)), t = x;
    }
  }
}
class gR {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(t, i), l = e.getUniformLocation(t, o.name);
      t$(o, l, this);
    }
  }
  setValue(e, t, r, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let o = 0, l = t.length; o !== l; ++o) {
      const c = t[o], h = r[c.id];
      h.needsUpdate !== !1 && c.setValue(e, h.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const l = e[i];
      l.id in t && r.push(l);
    }
    return r;
  }
}
function ZN(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
let n$ = 0;
function r$(n, e) {
  const t = n.split(`
`), r = [], i = Math.max(e - 6, 0), o = Math.min(e + 6, t.length);
  for (let l = i; l < o; l++) {
    const c = l + 1;
    r.push(`${c === e ? ">" : " "} ${c}: ${t[l]}`);
  }
  return r.join(`
`);
}
function i$(n) {
  switch (n) {
    case dm:
      return ["Linear", "( value )"];
    case go:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n), ["Linear", "( value )"];
  }
}
function JN(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS), i = n.getShaderInfoLog(e).trim();
  if (r && i === "")
    return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const l = parseInt(o[1]);
    return t.toUpperCase() + `

` + i + `

` + r$(n.getShaderSource(e), l);
  } else
    return i;
}
function a$(n, e) {
  const t = i$(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function o$(n, e) {
  let t;
  switch (e) {
    case GI:
      t = "Linear";
      break;
    case WI:
      t = "Reinhard";
      break;
    case jI:
      t = "OptimizedCineon";
      break;
    case gP:
      t = "ACESFilmic";
      break;
    case $I:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function s$(n) {
  return [
    n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(xT).join(`
`);
}
function l$(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function u$(n, e) {
  const t = {}, r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = n.getActiveAttrib(e, i), l = o.name;
    let c = 1;
    o.type === n.FLOAT_MAT2 && (c = 2), o.type === n.FLOAT_MAT3 && (c = 3), o.type === n.FLOAT_MAT4 && (c = 4), t[l] = {
      type: o.type,
      location: n.getAttribLocation(e, l),
      locationSize: c
    };
  }
  return t;
}
function xT(n) {
  return n !== "";
}
function eF(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function tF(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const c$ = /^[ \t]*#include +<([\w\d./]+)>/gm;
function EO(n) {
  return n.replace(c$, d$);
}
const f$ = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function d$(n, e) {
  let t = Jr[e];
  if (t === void 0) {
    const r = f$.get(e);
    if (r !== void 0)
      t = Jr[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return EO(t);
}
const h$ = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function nF(n) {
  return n.replace(h$, p$);
}
function p$(n, e, t, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function rF(n) {
  let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function m$(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === $R ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === bT ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === um && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function v$(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case jg:
      case S0:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case tE:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function g$(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case S0:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function y$(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case iw:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case HI:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case VI:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function S$(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, r = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t };
}
function x$(n, e, t, r) {
  const i = n.getContext(), o = t.defines;
  let l = t.vertexShader, c = t.fragmentShader;
  const h = m$(t), p = v$(t), y = g$(t), x = y$(t), b = S$(t), w = t.isWebGL2 ? "" : s$(t), R = l$(o), U = i.createProgram();
  let L, A, F = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (L = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(xT).join(`
`), L.length > 0 && (L += `
`), A = [
    w,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R
  ].filter(xT).join(`
`), A.length > 0 && (A += `
`)) : (L = [
    rF(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + y : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(xT).join(`
`), A = [
    w,
    rF(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    R,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + p : "",
    t.envMap ? "#define " + y : "",
    t.envMap ? "#define " + x : "",
    b ? "#define CUBEUV_TEXEL_WIDTH " + b.texelWidth : "",
    b ? "#define CUBEUV_TEXEL_HEIGHT " + b.texelHeight : "",
    b ? "#define CUBEUV_MAX_MIP " + b.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Ev ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Ev ? Jr.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Ev ? o$("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Jr.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    a$("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(xT).join(`
`)), l = EO(l), l = eF(l, t), l = tF(l, t), c = EO(c), c = eF(c, t), c = tF(c, t), l = nF(l), c = nF(c), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (F = `#version 300 es
`, L = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + L, A = [
    "#define varying in",
    t.glslVersion === SO ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === SO ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + A);
  const k = F + L + l, H = F + A + c, B = ZN(i, i.VERTEX_SHADER, k), $ = ZN(i, i.FRAGMENT_SHADER, H);
  if (i.attachShader(U, B), i.attachShader(U, $), t.index0AttributeName !== void 0 ? i.bindAttribLocation(U, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(U, 0, "position"), i.linkProgram(U), n.debug.checkShaderErrors) {
    const K = i.getProgramInfoLog(U).trim(), X = i.getShaderInfoLog(B).trim(), le = i.getShaderInfoLog($).trim();
    let oe = !0, fe = !0;
    if (i.getProgramParameter(U, i.LINK_STATUS) === !1)
      if (oe = !1, typeof n.debug.onShaderError == "function")
        n.debug.onShaderError(i, U, B, $);
      else {
        const de = JN(i, B, "vertex"), xe = JN(i, $, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(U, i.VALIDATE_STATUS) + `

Program Info Log: ` + K + `
` + de + `
` + xe
        );
      }
    else
      K !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", K) : (X === "" || le === "") && (fe = !1);
    fe && (this.diagnostics = {
      runnable: oe,
      programLog: K,
      vertexShader: {
        log: X,
        prefix: L
      },
      fragmentShader: {
        log: le,
        prefix: A
      }
    });
  }
  i.deleteShader(B), i.deleteShader($);
  let Y;
  this.getUniforms = function() {
    return Y === void 0 && (Y = new gR(i, U)), Y;
  };
  let J;
  return this.getAttributes = function() {
    return J === void 0 && (J = u$(i, U)), J;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), i.deleteProgram(U), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = n$++, this.cacheKey = e, this.usedTimes = 1, this.program = U, this.vertexShader = B, this.fragmentShader = $, this;
}
let _$ = 0;
class E$ {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), o = this._getShaderStage(r), l = this._getShaderCacheForMaterial(e);
    return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && (r = /* @__PURE__ */ new Set(), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && (r = new b$(e), t.set(e, r)), r;
  }
}
class b$ {
  constructor(e) {
    this.id = _$++, this.code = e, this.usedTimes = 0;
  }
}
function T$(n, e, t, r, i, o, l) {
  const c = new fx(), h = new E$(), p = [], y = i.isWebGL2, x = i.logarithmicDepthBuffer, b = i.vertexTextures;
  let w = i.precision;
  const R = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function U(K) {
    return K === 0 ? "uv" : `uv${K}`;
  }
  function L(K, X, le, oe, fe) {
    const de = oe.fog, xe = fe.geometry, _e = K.isMeshStandardMaterial ? oe.environment : null, Pe = (K.isMeshStandardMaterial ? t : e).get(K.envMap || _e), ce = Pe && Pe.mapping === tE ? Pe.image.height : null, ve = R[K.type];
    K.precision !== null && (w = i.getMaxPrecision(K.precision), w !== K.precision && console.warn("THREE.WebGLProgram.getParameters:", K.precision, "not supported, using", w, "instead."));
    const re = xe.morphAttributes.position || xe.morphAttributes.normal || xe.morphAttributes.color, ee = re !== void 0 ? re.length : 0;
    let he = 0;
    xe.morphAttributes.position !== void 0 && (he = 1), xe.morphAttributes.normal !== void 0 && (he = 2), xe.morphAttributes.color !== void 0 && (he = 3);
    let Me, Le, Ae, Ue;
    if (ve) {
      const er = fm[ve];
      Me = er.vertexShader, Le = er.fragmentShader;
    } else
      Me = K.vertexShader, Le = K.fragmentShader, h.update(K), Ae = h.getVertexShaderID(K), Ue = h.getFragmentShaderID(K);
    const Ne = n.getRenderTarget(), ke = fe.isInstancedMesh === !0, it = !!K.map, At = !!K.matcap, rt = !!Pe, ae = !!K.aoMap, et = !!K.lightMap, Ye = !!K.bumpMap, Ge = !!K.normalMap, $e = !!K.displacementMap, Ut = !!K.emissiveMap, nt = !!K.metalnessMap, Ct = !!K.roughnessMap, Pt = K.anisotropy > 0, vt = K.clearcoat > 0, Zt = K.iridescence > 0, ie = K.sheen > 0, ne = K.transmission > 0, Oe = Pt && !!K.anisotropyMap, _t = vt && !!K.clearcoatMap, ot = vt && !!K.clearcoatNormalMap, at = vt && !!K.clearcoatRoughnessMap, Wt = Zt && !!K.iridescenceMap, Dt = Zt && !!K.iridescenceThicknessMap, Se = ie && !!K.sheenColorMap, He = ie && !!K.sheenRoughnessMap, lt = !!K.specularMap, St = !!K.specularColorMap, Je = !!K.specularIntensityMap, be = ne && !!K.transmissionMap, Ze = ne && !!K.thicknessMap, ct = !!K.gradientMap, pe = !!K.alphaMap, Rt = K.alphaTest > 0, Be = !!K.alphaHash, ut = !!K.extensions, on = !!xe.attributes.uv1, zn = !!xe.attributes.uv2, Gn = !!xe.attributes.uv3;
    let rr = Ev;
    return K.toneMapped && (Ne === null || Ne.isXRRenderTarget === !0) && (rr = n.toneMapping), {
      isWebGL2: y,
      shaderID: ve,
      shaderType: K.type,
      shaderName: K.name,
      vertexShader: Me,
      fragmentShader: Le,
      defines: K.defines,
      customVertexShaderID: Ae,
      customFragmentShaderID: Ue,
      isRawShaderMaterial: K.isRawShaderMaterial === !0,
      glslVersion: K.glslVersion,
      precision: w,
      instancing: ke,
      instancingColor: ke && fe.instanceColor !== null,
      supportsVertexTextures: b,
      outputColorSpace: Ne === null ? n.outputColorSpace : Ne.isXRRenderTarget === !0 ? Ne.texture.colorSpace : dm,
      map: it,
      matcap: At,
      envMap: rt,
      envMapMode: rt && Pe.mapping,
      envMapCubeUVHeight: ce,
      aoMap: ae,
      lightMap: et,
      bumpMap: Ye,
      normalMap: Ge,
      displacementMap: b && $e,
      emissiveMap: Ut,
      normalMapObjectSpace: Ge && K.normalMapType === o4,
      normalMapTangentSpace: Ge && K.normalMapType === C0,
      metalnessMap: nt,
      roughnessMap: Ct,
      anisotropy: Pt,
      anisotropyMap: Oe,
      clearcoat: vt,
      clearcoatMap: _t,
      clearcoatNormalMap: ot,
      clearcoatRoughnessMap: at,
      iridescence: Zt,
      iridescenceMap: Wt,
      iridescenceThicknessMap: Dt,
      sheen: ie,
      sheenColorMap: Se,
      sheenRoughnessMap: He,
      specularMap: lt,
      specularColorMap: St,
      specularIntensityMap: Je,
      transmission: ne,
      transmissionMap: be,
      thicknessMap: Ze,
      gradientMap: ct,
      opaque: K.transparent === !1 && K.blending === ux,
      alphaMap: pe,
      alphaTest: Rt,
      alphaHash: Be,
      combine: K.combine,
      //
      mapUv: it && U(K.map.channel),
      aoMapUv: ae && U(K.aoMap.channel),
      lightMapUv: et && U(K.lightMap.channel),
      bumpMapUv: Ye && U(K.bumpMap.channel),
      normalMapUv: Ge && U(K.normalMap.channel),
      displacementMapUv: $e && U(K.displacementMap.channel),
      emissiveMapUv: Ut && U(K.emissiveMap.channel),
      metalnessMapUv: nt && U(K.metalnessMap.channel),
      roughnessMapUv: Ct && U(K.roughnessMap.channel),
      anisotropyMapUv: Oe && U(K.anisotropyMap.channel),
      clearcoatMapUv: _t && U(K.clearcoatMap.channel),
      clearcoatNormalMapUv: ot && U(K.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: at && U(K.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Wt && U(K.iridescenceMap.channel),
      iridescenceThicknessMapUv: Dt && U(K.iridescenceThicknessMap.channel),
      sheenColorMapUv: Se && U(K.sheenColorMap.channel),
      sheenRoughnessMapUv: He && U(K.sheenRoughnessMap.channel),
      specularMapUv: lt && U(K.specularMap.channel),
      specularColorMapUv: St && U(K.specularColorMap.channel),
      specularIntensityMapUv: Je && U(K.specularIntensityMap.channel),
      transmissionMapUv: be && U(K.transmissionMap.channel),
      thicknessMapUv: Ze && U(K.thicknessMap.channel),
      alphaMapUv: pe && U(K.alphaMap.channel),
      //
      vertexTangents: !!xe.attributes.tangent && (Ge || Pt),
      vertexColors: K.vertexColors,
      vertexAlphas: K.vertexColors === !0 && !!xe.attributes.color && xe.attributes.color.itemSize === 4,
      vertexUv1s: on,
      vertexUv2s: zn,
      vertexUv3s: Gn,
      pointsUvs: fe.isPoints === !0 && !!xe.attributes.uv && (it || pe),
      fog: !!de,
      useFog: K.fog === !0,
      fogExp2: de && de.isFogExp2,
      flatShading: K.flatShading === !0,
      sizeAttenuation: K.sizeAttenuation === !0,
      logarithmicDepthBuffer: x,
      skinning: fe.isSkinnedMesh === !0,
      morphTargets: xe.morphAttributes.position !== void 0,
      morphNormals: xe.morphAttributes.normal !== void 0,
      morphColors: xe.morphAttributes.color !== void 0,
      morphTargetsCount: ee,
      morphTextureStride: he,
      numDirLights: X.directional.length,
      numPointLights: X.point.length,
      numSpotLights: X.spot.length,
      numSpotLightMaps: X.spotLightMap.length,
      numRectAreaLights: X.rectArea.length,
      numHemiLights: X.hemi.length,
      numDirLightShadows: X.directionalShadowMap.length,
      numPointLightShadows: X.pointShadowMap.length,
      numSpotLightShadows: X.spotShadowMap.length,
      numSpotLightShadowsWithMaps: X.numSpotLightShadowsWithMaps,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: K.dithering,
      shadowMapEnabled: n.shadowMap.enabled && le.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: rr,
      useLegacyLights: n._useLegacyLights,
      decodeVideoTexture: it && K.map.isVideoTexture === !0 && K.map.colorSpace === go,
      premultipliedAlpha: K.premultipliedAlpha,
      doubleSided: K.side === dp,
      flipSided: K.side === Ic,
      useDepthPacking: K.depthPacking >= 0,
      depthPacking: K.depthPacking || 0,
      index0AttributeName: K.index0AttributeName,
      extensionDerivatives: ut && K.extensions.derivatives === !0,
      extensionFragDepth: ut && K.extensions.fragDepth === !0,
      extensionDrawBuffers: ut && K.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: ut && K.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: y || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: y || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: y || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: K.customProgramCacheKey()
    };
  }
  function A(K) {
    const X = [];
    if (K.shaderID ? X.push(K.shaderID) : (X.push(K.customVertexShaderID), X.push(K.customFragmentShaderID)), K.defines !== void 0)
      for (const le in K.defines)
        X.push(le), X.push(K.defines[le]);
    return K.isRawShaderMaterial === !1 && (F(X, K), k(X, K), X.push(n.outputColorSpace)), X.push(K.customProgramCacheKey), X.join();
  }
  function F(K, X) {
    K.push(X.precision), K.push(X.outputColorSpace), K.push(X.envMapMode), K.push(X.envMapCubeUVHeight), K.push(X.mapUv), K.push(X.alphaMapUv), K.push(X.lightMapUv), K.push(X.aoMapUv), K.push(X.bumpMapUv), K.push(X.normalMapUv), K.push(X.displacementMapUv), K.push(X.emissiveMapUv), K.push(X.metalnessMapUv), K.push(X.roughnessMapUv), K.push(X.anisotropyMapUv), K.push(X.clearcoatMapUv), K.push(X.clearcoatNormalMapUv), K.push(X.clearcoatRoughnessMapUv), K.push(X.iridescenceMapUv), K.push(X.iridescenceThicknessMapUv), K.push(X.sheenColorMapUv), K.push(X.sheenRoughnessMapUv), K.push(X.specularMapUv), K.push(X.specularColorMapUv), K.push(X.specularIntensityMapUv), K.push(X.transmissionMapUv), K.push(X.thicknessMapUv), K.push(X.combine), K.push(X.fogExp2), K.push(X.sizeAttenuation), K.push(X.morphTargetsCount), K.push(X.morphAttributeCount), K.push(X.numDirLights), K.push(X.numPointLights), K.push(X.numSpotLights), K.push(X.numSpotLightMaps), K.push(X.numHemiLights), K.push(X.numRectAreaLights), K.push(X.numDirLightShadows), K.push(X.numPointLightShadows), K.push(X.numSpotLightShadows), K.push(X.numSpotLightShadowsWithMaps), K.push(X.shadowMapType), K.push(X.toneMapping), K.push(X.numClippingPlanes), K.push(X.numClipIntersection), K.push(X.depthPacking);
  }
  function k(K, X) {
    c.disableAll(), X.isWebGL2 && c.enable(0), X.supportsVertexTextures && c.enable(1), X.instancing && c.enable(2), X.instancingColor && c.enable(3), X.matcap && c.enable(4), X.envMap && c.enable(5), X.normalMapObjectSpace && c.enable(6), X.normalMapTangentSpace && c.enable(7), X.clearcoat && c.enable(8), X.iridescence && c.enable(9), X.alphaTest && c.enable(10), X.vertexColors && c.enable(11), X.vertexAlphas && c.enable(12), X.vertexUv1s && c.enable(13), X.vertexUv2s && c.enable(14), X.vertexUv3s && c.enable(15), X.vertexTangents && c.enable(16), X.anisotropy && c.enable(17), K.push(c.mask), c.disableAll(), X.fog && c.enable(0), X.useFog && c.enable(1), X.flatShading && c.enable(2), X.logarithmicDepthBuffer && c.enable(3), X.skinning && c.enable(4), X.morphTargets && c.enable(5), X.morphNormals && c.enable(6), X.morphColors && c.enable(7), X.premultipliedAlpha && c.enable(8), X.shadowMapEnabled && c.enable(9), X.useLegacyLights && c.enable(10), X.doubleSided && c.enable(11), X.flipSided && c.enable(12), X.useDepthPacking && c.enable(13), X.dithering && c.enable(14), X.transmission && c.enable(15), X.sheen && c.enable(16), X.opaque && c.enable(17), X.pointsUvs && c.enable(18), X.decodeVideoTexture && c.enable(19), K.push(c.mask);
  }
  function H(K) {
    const X = R[K.type];
    let le;
    if (X) {
      const oe = fm[X];
      le = PP.clone(oe.uniforms);
    } else
      le = K.uniforms;
    return le;
  }
  function B(K, X) {
    let le;
    for (let oe = 0, fe = p.length; oe < fe; oe++) {
      const de = p[oe];
      if (de.cacheKey === X) {
        le = de, ++le.usedTimes;
        break;
      }
    }
    return le === void 0 && (le = new x$(n, X, K, o), p.push(le)), le;
  }
  function $(K) {
    if (--K.usedTimes === 0) {
      const X = p.indexOf(K);
      p[X] = p[p.length - 1], p.pop(), K.destroy();
    }
  }
  function Y(K) {
    h.remove(K);
  }
  function J() {
    h.dispose();
  }
  return {
    getParameters: L,
    getProgramCacheKey: A,
    getUniforms: H,
    acquireProgram: B,
    releaseProgram: $,
    releaseShaderCache: Y,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: p,
    dispose: J
  };
}
function w$() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let l = n.get(o);
    return l === void 0 && (l = {}, n.set(o, l)), l;
  }
  function t(o) {
    n.delete(o);
  }
  function r(o, l, c) {
    n.get(o)[l] = c;
  }
  function i() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: r,
    dispose: i
  };
}
function M$(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function iF(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function aF() {
  const n = [];
  let e = 0;
  const t = [], r = [], i = [];
  function o() {
    e = 0, t.length = 0, r.length = 0, i.length = 0;
  }
  function l(x, b, w, R, U, L) {
    let A = n[e];
    return A === void 0 ? (A = {
      id: x.id,
      object: x,
      geometry: b,
      material: w,
      groupOrder: R,
      renderOrder: x.renderOrder,
      z: U,
      group: L
    }, n[e] = A) : (A.id = x.id, A.object = x, A.geometry = b, A.material = w, A.groupOrder = R, A.renderOrder = x.renderOrder, A.z = U, A.group = L), e++, A;
  }
  function c(x, b, w, R, U, L) {
    const A = l(x, b, w, R, U, L);
    w.transmission > 0 ? r.push(A) : w.transparent === !0 ? i.push(A) : t.push(A);
  }
  function h(x, b, w, R, U, L) {
    const A = l(x, b, w, R, U, L);
    w.transmission > 0 ? r.unshift(A) : w.transparent === !0 ? i.unshift(A) : t.unshift(A);
  }
  function p(x, b) {
    t.length > 1 && t.sort(x || M$), r.length > 1 && r.sort(b || iF), i.length > 1 && i.sort(b || iF);
  }
  function y() {
    for (let x = e, b = n.length; x < b; x++) {
      const w = n[x];
      if (w.id === null)
        break;
      w.id = null, w.object = null, w.geometry = null, w.material = null, w.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: o,
    push: c,
    unshift: h,
    finish: y,
    sort: p
  };
}
function C$() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(r, i) {
    const o = n.get(r);
    let l;
    return o === void 0 ? (l = new aF(), n.set(r, [l])) : i >= o.length ? (l = new aF(), o.push(l)) : l = o[i], l;
  }
  function t() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function R$() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new Te(),
            color: new Rn()
          };
          break;
        case "SpotLight":
          t = {
            position: new Te(),
            direction: new Te(),
            color: new Rn(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new Te(),
            color: new Rn(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new Te(),
            skyColor: new Rn(),
            groundColor: new Rn()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Rn(),
            position: new Te(),
            halfWidth: new Te(),
            halfHeight: new Te()
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
function A$() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ht()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ht()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ht(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
let D$ = 0;
function L$(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function O$(n, e) {
  const t = new R$(), r = A$(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let y = 0; y < 9; y++)
    i.probe.push(new Te());
  const o = new Te(), l = new Gr(), c = new Gr();
  function h(y, x) {
    let b = 0, w = 0, R = 0;
    for (let le = 0; le < 9; le++)
      i.probe[le].set(0, 0, 0);
    let U = 0, L = 0, A = 0, F = 0, k = 0, H = 0, B = 0, $ = 0, Y = 0, J = 0;
    y.sort(L$);
    const K = x === !0 ? Math.PI : 1;
    for (let le = 0, oe = y.length; le < oe; le++) {
      const fe = y[le], de = fe.color, xe = fe.intensity, _e = fe.distance, Pe = fe.shadow && fe.shadow.map ? fe.shadow.map.texture : null;
      if (fe.isAmbientLight)
        b += de.r * xe * K, w += de.g * xe * K, R += de.b * xe * K;
      else if (fe.isLightProbe)
        for (let ce = 0; ce < 9; ce++)
          i.probe[ce].addScaledVector(fe.sh.coefficients[ce], xe);
      else if (fe.isDirectionalLight) {
        const ce = t.get(fe);
        if (ce.color.copy(fe.color).multiplyScalar(fe.intensity * K), fe.castShadow) {
          const ve = fe.shadow, re = r.get(fe);
          re.shadowBias = ve.bias, re.shadowNormalBias = ve.normalBias, re.shadowRadius = ve.radius, re.shadowMapSize = ve.mapSize, i.directionalShadow[U] = re, i.directionalShadowMap[U] = Pe, i.directionalShadowMatrix[U] = fe.shadow.matrix, H++;
        }
        i.directional[U] = ce, U++;
      } else if (fe.isSpotLight) {
        const ce = t.get(fe);
        ce.position.setFromMatrixPosition(fe.matrixWorld), ce.color.copy(de).multiplyScalar(xe * K), ce.distance = _e, ce.coneCos = Math.cos(fe.angle), ce.penumbraCos = Math.cos(fe.angle * (1 - fe.penumbra)), ce.decay = fe.decay, i.spot[A] = ce;
        const ve = fe.shadow;
        if (fe.map && (i.spotLightMap[Y] = fe.map, Y++, ve.updateMatrices(fe), fe.castShadow && J++), i.spotLightMatrix[A] = ve.matrix, fe.castShadow) {
          const re = r.get(fe);
          re.shadowBias = ve.bias, re.shadowNormalBias = ve.normalBias, re.shadowRadius = ve.radius, re.shadowMapSize = ve.mapSize, i.spotShadow[A] = re, i.spotShadowMap[A] = Pe, $++;
        }
        A++;
      } else if (fe.isRectAreaLight) {
        const ce = t.get(fe);
        ce.color.copy(de).multiplyScalar(xe), ce.halfWidth.set(fe.width * 0.5, 0, 0), ce.halfHeight.set(0, fe.height * 0.5, 0), i.rectArea[F] = ce, F++;
      } else if (fe.isPointLight) {
        const ce = t.get(fe);
        if (ce.color.copy(fe.color).multiplyScalar(fe.intensity * K), ce.distance = fe.distance, ce.decay = fe.decay, fe.castShadow) {
          const ve = fe.shadow, re = r.get(fe);
          re.shadowBias = ve.bias, re.shadowNormalBias = ve.normalBias, re.shadowRadius = ve.radius, re.shadowMapSize = ve.mapSize, re.shadowCameraNear = ve.camera.near, re.shadowCameraFar = ve.camera.far, i.pointShadow[L] = re, i.pointShadowMap[L] = Pe, i.pointShadowMatrix[L] = fe.shadow.matrix, B++;
        }
        i.point[L] = ce, L++;
      } else if (fe.isHemisphereLight) {
        const ce = t.get(fe);
        ce.skyColor.copy(fe.color).multiplyScalar(xe * K), ce.groundColor.copy(fe.groundColor).multiplyScalar(xe * K), i.hemi[k] = ce, k++;
      }
    }
    F > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = yn.LTC_FLOAT_1, i.rectAreaLTC2 = yn.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = yn.LTC_HALF_1, i.rectAreaLTC2 = yn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = b, i.ambient[1] = w, i.ambient[2] = R;
    const X = i.hash;
    (X.directionalLength !== U || X.pointLength !== L || X.spotLength !== A || X.rectAreaLength !== F || X.hemiLength !== k || X.numDirectionalShadows !== H || X.numPointShadows !== B || X.numSpotShadows !== $ || X.numSpotMaps !== Y) && (i.directional.length = U, i.spot.length = A, i.rectArea.length = F, i.point.length = L, i.hemi.length = k, i.directionalShadow.length = H, i.directionalShadowMap.length = H, i.pointShadow.length = B, i.pointShadowMap.length = B, i.spotShadow.length = $, i.spotShadowMap.length = $, i.directionalShadowMatrix.length = H, i.pointShadowMatrix.length = B, i.spotLightMatrix.length = $ + Y - J, i.spotLightMap.length = Y, i.numSpotLightShadowsWithMaps = J, X.directionalLength = U, X.pointLength = L, X.spotLength = A, X.rectAreaLength = F, X.hemiLength = k, X.numDirectionalShadows = H, X.numPointShadows = B, X.numSpotShadows = $, X.numSpotMaps = Y, i.version = D$++);
  }
  function p(y, x) {
    let b = 0, w = 0, R = 0, U = 0, L = 0;
    const A = x.matrixWorldInverse;
    for (let F = 0, k = y.length; F < k; F++) {
      const H = y[F];
      if (H.isDirectionalLight) {
        const B = i.directional[b];
        B.direction.setFromMatrixPosition(H.matrixWorld), o.setFromMatrixPosition(H.target.matrixWorld), B.direction.sub(o), B.direction.transformDirection(A), b++;
      } else if (H.isSpotLight) {
        const B = i.spot[R];
        B.position.setFromMatrixPosition(H.matrixWorld), B.position.applyMatrix4(A), B.direction.setFromMatrixPosition(H.matrixWorld), o.setFromMatrixPosition(H.target.matrixWorld), B.direction.sub(o), B.direction.transformDirection(A), R++;
      } else if (H.isRectAreaLight) {
        const B = i.rectArea[U];
        B.position.setFromMatrixPosition(H.matrixWorld), B.position.applyMatrix4(A), c.identity(), l.copy(H.matrixWorld), l.premultiply(A), c.extractRotation(l), B.halfWidth.set(H.width * 0.5, 0, 0), B.halfHeight.set(0, H.height * 0.5, 0), B.halfWidth.applyMatrix4(c), B.halfHeight.applyMatrix4(c), U++;
      } else if (H.isPointLight) {
        const B = i.point[w];
        B.position.setFromMatrixPosition(H.matrixWorld), B.position.applyMatrix4(A), w++;
      } else if (H.isHemisphereLight) {
        const B = i.hemi[L];
        B.direction.setFromMatrixPosition(H.matrixWorld), B.direction.transformDirection(A), L++;
      }
    }
  }
  return {
    setup: h,
    setupView: p,
    state: i
  };
}
function oF(n, e) {
  const t = new O$(n, e), r = [], i = [];
  function o() {
    r.length = 0, i.length = 0;
  }
  function l(x) {
    r.push(x);
  }
  function c(x) {
    i.push(x);
  }
  function h(x) {
    t.setup(r, x);
  }
  function p(x) {
    t.setupView(r, x);
  }
  return {
    init: o,
    state: {
      lightsArray: r,
      shadowsArray: i,
      lights: t
    },
    setupLights: h,
    setupLightsView: p,
    pushLight: l,
    pushShadow: c
  };
}
function P$(n, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function r(o, l = 0) {
    const c = t.get(o);
    let h;
    return c === void 0 ? (h = new oF(n, e), t.set(o, [h])) : l >= c.length ? (h = new oF(n, e), c.push(h)) : h = c[l], h;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: i
  };
}
class JR extends ic {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = a4, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class e2 extends ic {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const U$ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, N$ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function F$(n, e, t) {
  let r = new QR();
  const i = new Ht(), o = new Ht(), l = new ua(), c = new JR({ depthPacking: CP }), h = new e2(), p = {}, y = t.maxTextureSize, x = { [wv]: Ic, [Ic]: wv, [dp]: dp }, b = new Mv({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ht() },
      radius: { value: 4 }
    },
    vertexShader: U$,
    fragmentShader: N$
  }), w = b.clone();
  w.defines.HORIZONTAL_PASS = 1;
  const R = new oi();
  R.setAttribute(
    "position",
    new io(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const U = new Al(R, b), L = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = $R;
  let A = this.type;
  this.render = function(B, $, Y) {
    if (L.enabled === !1 || L.autoUpdate === !1 && L.needsUpdate === !1 || B.length === 0)
      return;
    const J = n.getRenderTarget(), K = n.getActiveCubeFace(), X = n.getActiveMipmapLevel(), le = n.state;
    le.setBlending(Gg), le.buffers.color.setClear(1, 1, 1, 1), le.buffers.depth.setTest(!0), le.setScissorTest(!1);
    const oe = A !== um && this.type === um, fe = A === um && this.type !== um;
    for (let de = 0, xe = B.length; de < xe; de++) {
      const _e = B[de], Pe = _e.shadow;
      if (Pe === void 0) {
        console.warn("THREE.WebGLShadowMap:", _e, "has no shadow.");
        continue;
      }
      if (Pe.autoUpdate === !1 && Pe.needsUpdate === !1)
        continue;
      i.copy(Pe.mapSize);
      const ce = Pe.getFrameExtents();
      if (i.multiply(ce), o.copy(Pe.mapSize), (i.x > y || i.y > y) && (i.x > y && (o.x = Math.floor(y / ce.x), i.x = o.x * ce.x, Pe.mapSize.x = o.x), i.y > y && (o.y = Math.floor(y / ce.y), i.y = o.y * ce.y, Pe.mapSize.y = o.y)), Pe.map === null || oe === !0 || fe === !0) {
        const re = this.type !== um ? { minFilter: ol, magFilter: ol } : {};
        Pe.map !== null && Pe.map.dispose(), Pe.map = new hm(i.x, i.y, re), Pe.map.texture.name = _e.name + ".shadowMap", Pe.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(Pe.map), n.clear();
      const ve = Pe.getViewportCount();
      for (let re = 0; re < ve; re++) {
        const ee = Pe.getViewport(re);
        l.set(
          o.x * ee.x,
          o.y * ee.y,
          o.x * ee.z,
          o.y * ee.w
        ), le.viewport(l), Pe.updateMatrices(_e, re), r = Pe.getFrustum(), H($, Y, Pe.camera, _e, this.type);
      }
      Pe.isPointLightShadow !== !0 && this.type === um && F(Pe, Y), Pe.needsUpdate = !1;
    }
    A = this.type, L.needsUpdate = !1, n.setRenderTarget(J, K, X);
  };
  function F(B, $) {
    const Y = e.update(U);
    b.defines.VSM_SAMPLES !== B.blurSamples && (b.defines.VSM_SAMPLES = B.blurSamples, w.defines.VSM_SAMPLES = B.blurSamples, b.needsUpdate = !0, w.needsUpdate = !0), B.mapPass === null && (B.mapPass = new hm(i.x, i.y)), b.uniforms.shadow_pass.value = B.map.texture, b.uniforms.resolution.value = B.mapSize, b.uniforms.radius.value = B.radius, n.setRenderTarget(B.mapPass), n.clear(), n.renderBufferDirect($, null, Y, b, U, null), w.uniforms.shadow_pass.value = B.mapPass.texture, w.uniforms.resolution.value = B.mapSize, w.uniforms.radius.value = B.radius, n.setRenderTarget(B.map), n.clear(), n.renderBufferDirect($, null, Y, w, U, null);
  }
  function k(B, $, Y, J) {
    let K = null;
    const X = Y.isPointLight === !0 ? B.customDistanceMaterial : B.customDepthMaterial;
    if (X !== void 0)
      K = X;
    else if (K = Y.isPointLight === !0 ? h : c, n.localClippingEnabled && $.clipShadows === !0 && Array.isArray($.clippingPlanes) && $.clippingPlanes.length !== 0 || $.displacementMap && $.displacementScale !== 0 || $.alphaMap && $.alphaTest > 0 || $.map && $.alphaTest > 0) {
      const le = K.uuid, oe = $.uuid;
      let fe = p[le];
      fe === void 0 && (fe = {}, p[le] = fe);
      let de = fe[oe];
      de === void 0 && (de = K.clone(), fe[oe] = de), K = de;
    }
    if (K.visible = $.visible, K.wireframe = $.wireframe, J === um ? K.side = $.shadowSide !== null ? $.shadowSide : $.side : K.side = $.shadowSide !== null ? $.shadowSide : x[$.side], K.alphaMap = $.alphaMap, K.alphaTest = $.alphaTest, K.map = $.map, K.clipShadows = $.clipShadows, K.clippingPlanes = $.clippingPlanes, K.clipIntersection = $.clipIntersection, K.displacementMap = $.displacementMap, K.displacementScale = $.displacementScale, K.displacementBias = $.displacementBias, K.wireframeLinewidth = $.wireframeLinewidth, K.linewidth = $.linewidth, Y.isPointLight === !0 && K.isMeshDistanceMaterial === !0) {
      const le = n.properties.get(K);
      le.light = Y;
    }
    return K;
  }
  function H(B, $, Y, J, K) {
    if (B.visible === !1)
      return;
    if (B.layers.test($.layers) && (B.isMesh || B.isLine || B.isPoints) && (B.castShadow || B.receiveShadow && K === um) && (!B.frustumCulled || r.intersectsObject(B))) {
      B.modelViewMatrix.multiplyMatrices(Y.matrixWorldInverse, B.matrixWorld);
      const oe = e.update(B), fe = B.material;
      if (Array.isArray(fe)) {
        const de = oe.groups;
        for (let xe = 0, _e = de.length; xe < _e; xe++) {
          const Pe = de[xe], ce = fe[Pe.materialIndex];
          if (ce && ce.visible) {
            const ve = k(B, ce, J, K);
            n.renderBufferDirect(Y, null, oe, ve, B, Pe);
          }
        }
      } else if (fe.visible) {
        const de = k(B, fe, J, K);
        n.renderBufferDirect(Y, null, oe, de, B, null);
      }
    }
    const le = B.children;
    for (let oe = 0, fe = le.length; oe < fe; oe++)
      H(le[oe], $, Y, J, K);
  }
}
function k$(n, e, t) {
  const r = t.isWebGL2;
  function i() {
    let pe = !1;
    const Rt = new ua();
    let Be = null;
    const ut = new ua(0, 0, 0, 0);
    return {
      setMask: function(on) {
        Be !== on && !pe && (n.colorMask(on, on, on, on), Be = on);
      },
      setLocked: function(on) {
        pe = on;
      },
      setClear: function(on, zn, Gn, rr, mn) {
        mn === !0 && (on *= rr, zn *= rr, Gn *= rr), Rt.set(on, zn, Gn, rr), ut.equals(Rt) === !1 && (n.clearColor(on, zn, Gn, rr), ut.copy(Rt));
      },
      reset: function() {
        pe = !1, Be = null, ut.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    let pe = !1, Rt = null, Be = null, ut = null;
    return {
      setTest: function(on) {
        on ? Ne(n.DEPTH_TEST) : ke(n.DEPTH_TEST);
      },
      setMask: function(on) {
        Rt !== on && !pe && (n.depthMask(on), Rt = on);
      },
      setFunc: function(on) {
        if (Be !== on) {
          switch (on) {
            case UI:
              n.depthFunc(n.NEVER);
              break;
            case NI:
              n.depthFunc(n.ALWAYS);
              break;
            case FI:
              n.depthFunc(n.LESS);
              break;
            case bR:
              n.depthFunc(n.LEQUAL);
              break;
            case kI:
              n.depthFunc(n.EQUAL);
              break;
            case zI:
              n.depthFunc(n.GEQUAL);
              break;
            case II:
              n.depthFunc(n.GREATER);
              break;
            case BI:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Be = on;
        }
      },
      setLocked: function(on) {
        pe = on;
      },
      setClear: function(on) {
        ut !== on && (n.clearDepth(on), ut = on);
      },
      reset: function() {
        pe = !1, Rt = null, Be = null, ut = null;
      }
    };
  }
  function l() {
    let pe = !1, Rt = null, Be = null, ut = null, on = null, zn = null, Gn = null, rr = null, mn = null;
    return {
      setTest: function(er) {
        pe || (er ? Ne(n.STENCIL_TEST) : ke(n.STENCIL_TEST));
      },
      setMask: function(er) {
        Rt !== er && !pe && (n.stencilMask(er), Rt = er);
      },
      setFunc: function(er, ir, Wn) {
        (Be !== er || ut !== ir || on !== Wn) && (n.stencilFunc(er, ir, Wn), Be = er, ut = ir, on = Wn);
      },
      setOp: function(er, ir, Wn) {
        (zn !== er || Gn !== ir || rr !== Wn) && (n.stencilOp(er, ir, Wn), zn = er, Gn = ir, rr = Wn);
      },
      setLocked: function(er) {
        pe = er;
      },
      setClear: function(er) {
        mn !== er && (n.clearStencil(er), mn = er);
      },
      reset: function() {
        pe = !1, Rt = null, Be = null, ut = null, on = null, zn = null, Gn = null, rr = null, mn = null;
      }
    };
  }
  const c = new i(), h = new o(), p = new l(), y = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap();
  let b = {}, w = {}, R = /* @__PURE__ */ new WeakMap(), U = [], L = null, A = !1, F = null, k = null, H = null, B = null, $ = null, Y = null, J = null, K = !1, X = null, le = null, oe = null, fe = null, de = null;
  const xe = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let _e = !1, Pe = 0;
  const ce = n.getParameter(n.VERSION);
  ce.indexOf("WebGL") !== -1 ? (Pe = parseFloat(/^WebGL (\d)/.exec(ce)[1]), _e = Pe >= 1) : ce.indexOf("OpenGL ES") !== -1 && (Pe = parseFloat(/^OpenGL ES (\d)/.exec(ce)[1]), _e = Pe >= 2);
  let ve = null, re = {};
  const ee = n.getParameter(n.SCISSOR_BOX), he = n.getParameter(n.VIEWPORT), Me = new ua().fromArray(ee), Le = new ua().fromArray(he);
  function Ae(pe, Rt, Be, ut) {
    const on = new Uint8Array(4), zn = n.createTexture();
    n.bindTexture(pe, zn), n.texParameteri(pe, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(pe, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Gn = 0; Gn < Be; Gn++)
      r && (pe === n.TEXTURE_3D || pe === n.TEXTURE_2D_ARRAY) ? n.texImage3D(Rt, 0, n.RGBA, 1, 1, ut, 0, n.RGBA, n.UNSIGNED_BYTE, on) : n.texImage2D(Rt + Gn, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, on);
    return zn;
  }
  const Ue = {};
  Ue[n.TEXTURE_2D] = Ae(n.TEXTURE_2D, n.TEXTURE_2D, 1), Ue[n.TEXTURE_CUBE_MAP] = Ae(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (Ue[n.TEXTURE_2D_ARRAY] = Ae(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), Ue[n.TEXTURE_3D] = Ae(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), c.setClear(0, 0, 0, 1), h.setClear(1), p.setClear(0), Ne(n.DEPTH_TEST), h.setFunc(bR), $e(!1), Ut(VL), Ne(n.CULL_FACE), Ye(Gg);
  function Ne(pe) {
    b[pe] !== !0 && (n.enable(pe), b[pe] = !0);
  }
  function ke(pe) {
    b[pe] !== !1 && (n.disable(pe), b[pe] = !1);
  }
  function it(pe, Rt) {
    return w[pe] !== Rt ? (n.bindFramebuffer(pe, Rt), w[pe] = Rt, r && (pe === n.DRAW_FRAMEBUFFER && (w[n.FRAMEBUFFER] = Rt), pe === n.FRAMEBUFFER && (w[n.DRAW_FRAMEBUFFER] = Rt)), !0) : !1;
  }
  function At(pe, Rt) {
    let Be = U, ut = !1;
    if (pe)
      if (Be = R.get(Rt), Be === void 0 && (Be = [], R.set(Rt, Be)), pe.isWebGLMultipleRenderTargets) {
        const on = pe.texture;
        if (Be.length !== on.length || Be[0] !== n.COLOR_ATTACHMENT0) {
          for (let zn = 0, Gn = on.length; zn < Gn; zn++)
            Be[zn] = n.COLOR_ATTACHMENT0 + zn;
          Be.length = on.length, ut = !0;
        }
      } else
        Be[0] !== n.COLOR_ATTACHMENT0 && (Be[0] = n.COLOR_ATTACHMENT0, ut = !0);
    else
      Be[0] !== n.BACK && (Be[0] = n.BACK, ut = !0);
    ut && (t.isWebGL2 ? n.drawBuffers(Be) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Be));
  }
  function rt(pe) {
    return L !== pe ? (n.useProgram(pe), L = pe, !0) : !1;
  }
  const ae = {
    [nx]: n.FUNC_ADD,
    [bI]: n.FUNC_SUBTRACT,
    [TI]: n.FUNC_REVERSE_SUBTRACT
  };
  if (r)
    ae[$L] = n.MIN, ae[YL] = n.MAX;
  else {
    const pe = e.get("EXT_blend_minmax");
    pe !== null && (ae[$L] = pe.MIN_EXT, ae[YL] = pe.MAX_EXT);
  }
  const et = {
    [wI]: n.ZERO,
    [MI]: n.ONE,
    [CI]: n.SRC_COLOR,
    [mP]: n.SRC_ALPHA,
    [PI]: n.SRC_ALPHA_SATURATE,
    [LI]: n.DST_COLOR,
    [AI]: n.DST_ALPHA,
    [RI]: n.ONE_MINUS_SRC_COLOR,
    [vP]: n.ONE_MINUS_SRC_ALPHA,
    [OI]: n.ONE_MINUS_DST_COLOR,
    [DI]: n.ONE_MINUS_DST_ALPHA
  };
  function Ye(pe, Rt, Be, ut, on, zn, Gn, rr) {
    if (pe === Gg) {
      A === !0 && (ke(n.BLEND), A = !1);
      return;
    }
    if (A === !1 && (Ne(n.BLEND), A = !0), pe !== EI) {
      if (pe !== F || rr !== K) {
        if ((k !== nx || $ !== nx) && (n.blendEquation(n.FUNC_ADD), k = nx, $ = nx), rr)
          switch (pe) {
            case ux:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case GL:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case WL:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case jL:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", pe);
              break;
          }
        else
          switch (pe) {
            case ux:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case GL:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case WL:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case jL:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", pe);
              break;
          }
        H = null, B = null, Y = null, J = null, F = pe, K = rr;
      }
      return;
    }
    on = on || Rt, zn = zn || Be, Gn = Gn || ut, (Rt !== k || on !== $) && (n.blendEquationSeparate(ae[Rt], ae[on]), k = Rt, $ = on), (Be !== H || ut !== B || zn !== Y || Gn !== J) && (n.blendFuncSeparate(et[Be], et[ut], et[zn], et[Gn]), H = Be, B = ut, Y = zn, J = Gn), F = pe, K = !1;
  }
  function Ge(pe, Rt) {
    pe.side === dp ? ke(n.CULL_FACE) : Ne(n.CULL_FACE);
    let Be = pe.side === Ic;
    Rt && (Be = !Be), $e(Be), pe.blending === ux && pe.transparent === !1 ? Ye(Gg) : Ye(pe.blending, pe.blendEquation, pe.blendSrc, pe.blendDst, pe.blendEquationAlpha, pe.blendSrcAlpha, pe.blendDstAlpha, pe.premultipliedAlpha), h.setFunc(pe.depthFunc), h.setTest(pe.depthTest), h.setMask(pe.depthWrite), c.setMask(pe.colorWrite);
    const ut = pe.stencilWrite;
    p.setTest(ut), ut && (p.setMask(pe.stencilWriteMask), p.setFunc(pe.stencilFunc, pe.stencilRef, pe.stencilFuncMask), p.setOp(pe.stencilFail, pe.stencilZFail, pe.stencilZPass)), Ct(pe.polygonOffset, pe.polygonOffsetFactor, pe.polygonOffsetUnits), pe.alphaToCoverage === !0 ? Ne(n.SAMPLE_ALPHA_TO_COVERAGE) : ke(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function $e(pe) {
    X !== pe && (pe ? n.frontFace(n.CW) : n.frontFace(n.CCW), X = pe);
  }
  function Ut(pe) {
    pe !== SI ? (Ne(n.CULL_FACE), pe !== le && (pe === VL ? n.cullFace(n.BACK) : pe === xI ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ke(n.CULL_FACE), le = pe;
  }
  function nt(pe) {
    pe !== oe && (_e && n.lineWidth(pe), oe = pe);
  }
  function Ct(pe, Rt, Be) {
    pe ? (Ne(n.POLYGON_OFFSET_FILL), (fe !== Rt || de !== Be) && (n.polygonOffset(Rt, Be), fe = Rt, de = Be)) : ke(n.POLYGON_OFFSET_FILL);
  }
  function Pt(pe) {
    pe ? Ne(n.SCISSOR_TEST) : ke(n.SCISSOR_TEST);
  }
  function vt(pe) {
    pe === void 0 && (pe = n.TEXTURE0 + xe - 1), ve !== pe && (n.activeTexture(pe), ve = pe);
  }
  function Zt(pe, Rt, Be) {
    Be === void 0 && (ve === null ? Be = n.TEXTURE0 + xe - 1 : Be = ve);
    let ut = re[Be];
    ut === void 0 && (ut = { type: void 0, texture: void 0 }, re[Be] = ut), (ut.type !== pe || ut.texture !== Rt) && (ve !== Be && (n.activeTexture(Be), ve = Be), n.bindTexture(pe, Rt || Ue[pe]), ut.type = pe, ut.texture = Rt);
  }
  function ie() {
    const pe = re[ve];
    pe !== void 0 && pe.type !== void 0 && (n.bindTexture(pe.type, null), pe.type = void 0, pe.texture = void 0);
  }
  function ne() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Oe() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function _t() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function ot() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function at() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Wt() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Dt() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Se() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function He() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function lt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function St(pe) {
    Me.equals(pe) === !1 && (n.scissor(pe.x, pe.y, pe.z, pe.w), Me.copy(pe));
  }
  function Je(pe) {
    Le.equals(pe) === !1 && (n.viewport(pe.x, pe.y, pe.z, pe.w), Le.copy(pe));
  }
  function be(pe, Rt) {
    let Be = x.get(Rt);
    Be === void 0 && (Be = /* @__PURE__ */ new WeakMap(), x.set(Rt, Be));
    let ut = Be.get(pe);
    ut === void 0 && (ut = n.getUniformBlockIndex(Rt, pe.name), Be.set(pe, ut));
  }
  function Ze(pe, Rt) {
    const ut = x.get(Rt).get(pe);
    y.get(Rt) !== ut && (n.uniformBlockBinding(Rt, ut, pe.__bindingPointIndex), y.set(Rt, ut));
  }
  function ct() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), r === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), b = {}, ve = null, re = {}, w = {}, R = /* @__PURE__ */ new WeakMap(), U = [], L = null, A = !1, F = null, k = null, H = null, B = null, $ = null, Y = null, J = null, K = !1, X = null, le = null, oe = null, fe = null, de = null, Me.set(0, 0, n.canvas.width, n.canvas.height), Le.set(0, 0, n.canvas.width, n.canvas.height), c.reset(), h.reset(), p.reset();
  }
  return {
    buffers: {
      color: c,
      depth: h,
      stencil: p
    },
    enable: Ne,
    disable: ke,
    bindFramebuffer: it,
    drawBuffers: At,
    useProgram: rt,
    setBlending: Ye,
    setMaterial: Ge,
    setFlipSided: $e,
    setCullFace: Ut,
    setLineWidth: nt,
    setPolygonOffset: Ct,
    setScissorTest: Pt,
    activeTexture: vt,
    bindTexture: Zt,
    unbindTexture: ie,
    compressedTexImage2D: ne,
    compressedTexImage3D: Oe,
    texImage2D: He,
    texImage3D: lt,
    updateUBOMapping: be,
    uniformBlockBinding: Ze,
    texStorage2D: Dt,
    texStorage3D: Se,
    texSubImage2D: _t,
    texSubImage3D: ot,
    compressedTexSubImage2D: at,
    compressedTexSubImage3D: Wt,
    scissor: St,
    viewport: Je,
    reset: ct
  };
}
function z$(n, e, t, r, i, o, l) {
  const c = i.isWebGL2, h = i.maxTextures, p = i.maxCubemapSize, y = i.maxTextureSize, x = i.maxSamples, b = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, w = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), R = /* @__PURE__ */ new WeakMap();
  let U;
  const L = /* @__PURE__ */ new WeakMap();
  let A = !1;
  try {
    A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function F(ie, ne) {
    return A ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(ie, ne)
    ) : GT("canvas");
  }
  function k(ie, ne, Oe, _t) {
    let ot = 1;
    if ((ie.width > _t || ie.height > _t) && (ot = _t / Math.max(ie.width, ie.height)), ot < 1 || ne === !0)
      if (typeof HTMLImageElement < "u" && ie instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ie instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ie instanceof ImageBitmap) {
        const at = ne ? MR : Math.floor, Wt = at(ot * ie.width), Dt = at(ot * ie.height);
        U === void 0 && (U = F(Wt, Dt));
        const Se = Oe ? F(Wt, Dt) : U;
        return Se.width = Wt, Se.height = Dt, Se.getContext("2d").drawImage(ie, 0, 0, Wt, Dt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + Wt + "x" + Dt + ")."), Se;
      } else
        return "data" in ie && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), ie;
    return ie;
  }
  function H(ie) {
    return xO(ie.width) && xO(ie.height);
  }
  function B(ie) {
    return c ? !1 : ie.wrapS !== kc || ie.wrapT !== kc || ie.minFilter !== ol && ie.minFilter !== ss;
  }
  function $(ie, ne) {
    return ie.generateMipmaps && ne && ie.minFilter !== ol && ie.minFilter !== ss;
  }
  function Y(ie) {
    n.generateMipmap(ie);
  }
  function J(ie, ne, Oe, _t, ot = !1) {
    if (c === !1)
      return ne;
    if (ie !== null) {
      if (n[ie] !== void 0)
        return n[ie];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ie + "'");
    }
    let at = ne;
    return ne === n.RED && (Oe === n.FLOAT && (at = n.R32F), Oe === n.HALF_FLOAT && (at = n.R16F), Oe === n.UNSIGNED_BYTE && (at = n.R8)), ne === n.RED_INTEGER && (Oe === n.UNSIGNED_BYTE && (at = n.R8UI), Oe === n.UNSIGNED_SHORT && (at = n.R16UI), Oe === n.UNSIGNED_INT && (at = n.R32UI), Oe === n.BYTE && (at = n.R8I), Oe === n.SHORT && (at = n.R16I), Oe === n.INT && (at = n.R32I)), ne === n.RG && (Oe === n.FLOAT && (at = n.RG32F), Oe === n.HALF_FLOAT && (at = n.RG16F), Oe === n.UNSIGNED_BYTE && (at = n.RG8)), ne === n.RGBA && (Oe === n.FLOAT && (at = n.RGBA32F), Oe === n.HALF_FLOAT && (at = n.RGBA16F), Oe === n.UNSIGNED_BYTE && (at = _t === go && ot === !1 ? n.SRGB8_ALPHA8 : n.RGBA8), Oe === n.UNSIGNED_SHORT_4_4_4_4 && (at = n.RGBA4), Oe === n.UNSIGNED_SHORT_5_5_5_1 && (at = n.RGB5_A1)), (at === n.R16F || at === n.R32F || at === n.RG16F || at === n.RG32F || at === n.RGBA16F || at === n.RGBA32F) && e.get("EXT_color_buffer_float"), at;
  }
  function K(ie, ne, Oe) {
    return $(ie, Oe) === !0 || ie.isFramebufferTexture && ie.minFilter !== ol && ie.minFilter !== ss ? Math.log2(Math.max(ne.width, ne.height)) + 1 : ie.mipmaps !== void 0 && ie.mipmaps.length > 0 ? ie.mipmaps.length : ie.isCompressedTexture && Array.isArray(ie.image) ? ne.mipmaps.length : 1;
  }
  function X(ie) {
    return ie === ol || ie === TR || ie === TT ? n.NEAREST : n.LINEAR;
  }
  function le(ie) {
    const ne = ie.target;
    ne.removeEventListener("dispose", le), fe(ne), ne.isVideoTexture && R.delete(ne);
  }
  function oe(ie) {
    const ne = ie.target;
    ne.removeEventListener("dispose", oe), xe(ne);
  }
  function fe(ie) {
    const ne = r.get(ie);
    if (ne.__webglInit === void 0)
      return;
    const Oe = ie.source, _t = L.get(Oe);
    if (_t) {
      const ot = _t[ne.__cacheKey];
      ot.usedTimes--, ot.usedTimes === 0 && de(ie), Object.keys(_t).length === 0 && L.delete(Oe);
    }
    r.remove(ie);
  }
  function de(ie) {
    const ne = r.get(ie);
    n.deleteTexture(ne.__webglTexture);
    const Oe = ie.source, _t = L.get(Oe);
    delete _t[ne.__cacheKey], l.memory.textures--;
  }
  function xe(ie) {
    const ne = ie.texture, Oe = r.get(ie), _t = r.get(ne);
    if (_t.__webglTexture !== void 0 && (n.deleteTexture(_t.__webglTexture), l.memory.textures--), ie.depthTexture && ie.depthTexture.dispose(), ie.isWebGLCubeRenderTarget)
      for (let ot = 0; ot < 6; ot++) {
        if (Array.isArray(Oe.__webglFramebuffer[ot]))
          for (let at = 0; at < Oe.__webglFramebuffer[ot].length; at++)
            n.deleteFramebuffer(Oe.__webglFramebuffer[ot][at]);
        else
          n.deleteFramebuffer(Oe.__webglFramebuffer[ot]);
        Oe.__webglDepthbuffer && n.deleteRenderbuffer(Oe.__webglDepthbuffer[ot]);
      }
    else {
      if (Array.isArray(Oe.__webglFramebuffer))
        for (let ot = 0; ot < Oe.__webglFramebuffer.length; ot++)
          n.deleteFramebuffer(Oe.__webglFramebuffer[ot]);
      else
        n.deleteFramebuffer(Oe.__webglFramebuffer);
      if (Oe.__webglDepthbuffer && n.deleteRenderbuffer(Oe.__webglDepthbuffer), Oe.__webglMultisampledFramebuffer && n.deleteFramebuffer(Oe.__webglMultisampledFramebuffer), Oe.__webglColorRenderbuffer)
        for (let ot = 0; ot < Oe.__webglColorRenderbuffer.length; ot++)
          Oe.__webglColorRenderbuffer[ot] && n.deleteRenderbuffer(Oe.__webglColorRenderbuffer[ot]);
      Oe.__webglDepthRenderbuffer && n.deleteRenderbuffer(Oe.__webglDepthRenderbuffer);
    }
    if (ie.isWebGLMultipleRenderTargets)
      for (let ot = 0, at = ne.length; ot < at; ot++) {
        const Wt = r.get(ne[ot]);
        Wt.__webglTexture && (n.deleteTexture(Wt.__webglTexture), l.memory.textures--), r.remove(ne[ot]);
      }
    r.remove(ne), r.remove(ie);
  }
  let _e = 0;
  function Pe() {
    _e = 0;
  }
  function ce() {
    const ie = _e;
    return ie >= h && console.warn("THREE.WebGLTextures: Trying to use " + ie + " texture units while this GPU supports only " + h), _e += 1, ie;
  }
  function ve(ie) {
    const ne = [];
    return ne.push(ie.wrapS), ne.push(ie.wrapT), ne.push(ie.wrapR || 0), ne.push(ie.magFilter), ne.push(ie.minFilter), ne.push(ie.anisotropy), ne.push(ie.internalFormat), ne.push(ie.format), ne.push(ie.type), ne.push(ie.generateMipmaps), ne.push(ie.premultiplyAlpha), ne.push(ie.flipY), ne.push(ie.unpackAlignment), ne.push(ie.colorSpace), ne.join();
  }
  function re(ie, ne) {
    const Oe = r.get(ie);
    if (ie.isVideoTexture && vt(ie), ie.isRenderTargetTexture === !1 && ie.version > 0 && Oe.__version !== ie.version) {
      const _t = ie.image;
      if (_t === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (_t.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        it(Oe, ie, ne);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, Oe.__webglTexture, n.TEXTURE0 + ne);
  }
  function ee(ie, ne) {
    const Oe = r.get(ie);
    if (ie.version > 0 && Oe.__version !== ie.version) {
      it(Oe, ie, ne);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, Oe.__webglTexture, n.TEXTURE0 + ne);
  }
  function he(ie, ne) {
    const Oe = r.get(ie);
    if (ie.version > 0 && Oe.__version !== ie.version) {
      it(Oe, ie, ne);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, Oe.__webglTexture, n.TEXTURE0 + ne);
  }
  function Me(ie, ne) {
    const Oe = r.get(ie);
    if (ie.version > 0 && Oe.__version !== ie.version) {
      At(Oe, ie, ne);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Oe.__webglTexture, n.TEXTURE0 + ne);
  }
  const Le = {
    [FT]: n.REPEAT,
    [kc]: n.CLAMP_TO_EDGE,
    [kT]: n.MIRRORED_REPEAT
  }, Ae = {
    [ol]: n.NEAREST,
    [TR]: n.NEAREST_MIPMAP_NEAREST,
    [TT]: n.NEAREST_MIPMAP_LINEAR,
    [ss]: n.LINEAR,
    [yP]: n.LINEAR_MIPMAP_NEAREST,
    [x0]: n.LINEAR_MIPMAP_LINEAR
  }, Ue = {
    [l4]: n.NEVER,
    [m4]: n.ALWAYS,
    [u4]: n.LESS,
    [f4]: n.LEQUAL,
    [c4]: n.EQUAL,
    [p4]: n.GEQUAL,
    [d4]: n.GREATER,
    [h4]: n.NOTEQUAL
  };
  function Ne(ie, ne, Oe) {
    if (Oe ? (n.texParameteri(ie, n.TEXTURE_WRAP_S, Le[ne.wrapS]), n.texParameteri(ie, n.TEXTURE_WRAP_T, Le[ne.wrapT]), (ie === n.TEXTURE_3D || ie === n.TEXTURE_2D_ARRAY) && n.texParameteri(ie, n.TEXTURE_WRAP_R, Le[ne.wrapR]), n.texParameteri(ie, n.TEXTURE_MAG_FILTER, Ae[ne.magFilter]), n.texParameteri(ie, n.TEXTURE_MIN_FILTER, Ae[ne.minFilter])) : (n.texParameteri(ie, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(ie, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (ie === n.TEXTURE_3D || ie === n.TEXTURE_2D_ARRAY) && n.texParameteri(ie, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (ne.wrapS !== kc || ne.wrapT !== kc) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(ie, n.TEXTURE_MAG_FILTER, X(ne.magFilter)), n.texParameteri(ie, n.TEXTURE_MIN_FILTER, X(ne.minFilter)), ne.minFilter !== ol && ne.minFilter !== ss && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), ne.compareFunction && (n.texParameteri(ie, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(ie, n.TEXTURE_COMPARE_FUNC, Ue[ne.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const _t = e.get("EXT_texture_filter_anisotropic");
      if (ne.magFilter === ol || ne.minFilter !== TT && ne.minFilter !== x0 || ne.type === xv && e.has("OES_texture_float_linear") === !1 || c === !1 && ne.type === X1 && e.has("OES_texture_half_float_linear") === !1)
        return;
      (ne.anisotropy > 1 || r.get(ne).__currentAnisotropy) && (n.texParameterf(ie, _t.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ne.anisotropy, i.getMaxAnisotropy())), r.get(ne).__currentAnisotropy = ne.anisotropy);
    }
  }
  function ke(ie, ne) {
    let Oe = !1;
    ie.__webglInit === void 0 && (ie.__webglInit = !0, ne.addEventListener("dispose", le));
    const _t = ne.source;
    let ot = L.get(_t);
    ot === void 0 && (ot = {}, L.set(_t, ot));
    const at = ve(ne);
    if (at !== ie.__cacheKey) {
      ot[at] === void 0 && (ot[at] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, Oe = !0), ot[at].usedTimes++;
      const Wt = ot[ie.__cacheKey];
      Wt !== void 0 && (ot[ie.__cacheKey].usedTimes--, Wt.usedTimes === 0 && de(ne)), ie.__cacheKey = at, ie.__webglTexture = ot[at].texture;
    }
    return Oe;
  }
  function it(ie, ne, Oe) {
    let _t = n.TEXTURE_2D;
    (ne.isDataArrayTexture || ne.isCompressedArrayTexture) && (_t = n.TEXTURE_2D_ARRAY), ne.isData3DTexture && (_t = n.TEXTURE_3D);
    const ot = ke(ie, ne), at = ne.source;
    t.bindTexture(_t, ie.__webglTexture, n.TEXTURE0 + Oe);
    const Wt = r.get(at);
    if (at.version !== Wt.__version || ot === !0) {
      t.activeTexture(n.TEXTURE0 + Oe), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, ne.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, ne.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Dt = B(ne) && H(ne.image) === !1;
      let Se = k(ne.image, Dt, !1, y);
      Se = Zt(ne, Se);
      const He = H(Se) || c, lt = o.convert(ne.format, ne.colorSpace);
      let St = o.convert(ne.type), Je = J(ne.internalFormat, lt, St, ne.colorSpace, ne.isVideoTexture);
      Ne(_t, ne, He);
      let be;
      const Ze = ne.mipmaps, ct = c && ne.isVideoTexture !== !0, pe = Wt.__version === void 0 || ot === !0, Rt = K(ne, Se, He);
      if (ne.isDepthTexture)
        Je = n.DEPTH_COMPONENT, c ? ne.type === xv ? Je = n.DEPTH_COMPONENT32F : ne.type === Hg ? Je = n.DEPTH_COMPONENT24 : ne.type === m0 ? Je = n.DEPTH24_STENCIL8 : Je = n.DEPTH_COMPONENT16 : ne.type === xv && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), ne.format === v0 && Je === n.DEPTH_COMPONENT && ne.type !== XR && ne.type !== Hg && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), ne.type = Hg, St = o.convert(ne.type)), ne.format === gx && Je === n.DEPTH_COMPONENT && (Je = n.DEPTH_STENCIL, ne.type !== m0 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), ne.type = m0, St = o.convert(ne.type))), pe && (ct ? t.texStorage2D(n.TEXTURE_2D, 1, Je, Se.width, Se.height) : t.texImage2D(n.TEXTURE_2D, 0, Je, Se.width, Se.height, 0, lt, St, null));
      else if (ne.isDataTexture)
        if (Ze.length > 0 && He) {
          ct && pe && t.texStorage2D(n.TEXTURE_2D, Rt, Je, Ze[0].width, Ze[0].height);
          for (let Be = 0, ut = Ze.length; Be < ut; Be++)
            be = Ze[Be], ct ? t.texSubImage2D(n.TEXTURE_2D, Be, 0, 0, be.width, be.height, lt, St, be.data) : t.texImage2D(n.TEXTURE_2D, Be, Je, be.width, be.height, 0, lt, St, be.data);
          ne.generateMipmaps = !1;
        } else
          ct ? (pe && t.texStorage2D(n.TEXTURE_2D, Rt, Je, Se.width, Se.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Se.width, Se.height, lt, St, Se.data)) : t.texImage2D(n.TEXTURE_2D, 0, Je, Se.width, Se.height, 0, lt, St, Se.data);
      else if (ne.isCompressedTexture)
        if (ne.isCompressedArrayTexture) {
          ct && pe && t.texStorage3D(n.TEXTURE_2D_ARRAY, Rt, Je, Ze[0].width, Ze[0].height, Se.depth);
          for (let Be = 0, ut = Ze.length; Be < ut; Be++)
            be = Ze[Be], ne.format !== Td ? lt !== null ? ct ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Be, 0, 0, 0, be.width, be.height, Se.depth, lt, be.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Be, Je, be.width, be.height, Se.depth, 0, be.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ct ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, Be, 0, 0, 0, be.width, be.height, Se.depth, lt, St, be.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Be, Je, be.width, be.height, Se.depth, 0, lt, St, be.data);
        } else {
          ct && pe && t.texStorage2D(n.TEXTURE_2D, Rt, Je, Ze[0].width, Ze[0].height);
          for (let Be = 0, ut = Ze.length; Be < ut; Be++)
            be = Ze[Be], ne.format !== Td ? lt !== null ? ct ? t.compressedTexSubImage2D(n.TEXTURE_2D, Be, 0, 0, be.width, be.height, lt, be.data) : t.compressedTexImage2D(n.TEXTURE_2D, Be, Je, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ct ? t.texSubImage2D(n.TEXTURE_2D, Be, 0, 0, be.width, be.height, lt, St, be.data) : t.texImage2D(n.TEXTURE_2D, Be, Je, be.width, be.height, 0, lt, St, be.data);
        }
      else if (ne.isDataArrayTexture)
        ct ? (pe && t.texStorage3D(n.TEXTURE_2D_ARRAY, Rt, Je, Se.width, Se.height, Se.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Se.width, Se.height, Se.depth, lt, St, Se.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Je, Se.width, Se.height, Se.depth, 0, lt, St, Se.data);
      else if (ne.isData3DTexture)
        ct ? (pe && t.texStorage3D(n.TEXTURE_3D, Rt, Je, Se.width, Se.height, Se.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Se.width, Se.height, Se.depth, lt, St, Se.data)) : t.texImage3D(n.TEXTURE_3D, 0, Je, Se.width, Se.height, Se.depth, 0, lt, St, Se.data);
      else if (ne.isFramebufferTexture) {
        if (pe)
          if (ct)
            t.texStorage2D(n.TEXTURE_2D, Rt, Je, Se.width, Se.height);
          else {
            let Be = Se.width, ut = Se.height;
            for (let on = 0; on < Rt; on++)
              t.texImage2D(n.TEXTURE_2D, on, Je, Be, ut, 0, lt, St, null), Be >>= 1, ut >>= 1;
          }
      } else if (Ze.length > 0 && He) {
        ct && pe && t.texStorage2D(n.TEXTURE_2D, Rt, Je, Ze[0].width, Ze[0].height);
        for (let Be = 0, ut = Ze.length; Be < ut; Be++)
          be = Ze[Be], ct ? t.texSubImage2D(n.TEXTURE_2D, Be, 0, 0, lt, St, be) : t.texImage2D(n.TEXTURE_2D, Be, Je, lt, St, be);
        ne.generateMipmaps = !1;
      } else
        ct ? (pe && t.texStorage2D(n.TEXTURE_2D, Rt, Je, Se.width, Se.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, lt, St, Se)) : t.texImage2D(n.TEXTURE_2D, 0, Je, lt, St, Se);
      $(ne, He) && Y(_t), Wt.__version = at.version, ne.onUpdate && ne.onUpdate(ne);
    }
    ie.__version = ne.version;
  }
  function At(ie, ne, Oe) {
    if (ne.image.length !== 6)
      return;
    const _t = ke(ie, ne), ot = ne.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, ie.__webglTexture, n.TEXTURE0 + Oe);
    const at = r.get(ot);
    if (ot.version !== at.__version || _t === !0) {
      t.activeTexture(n.TEXTURE0 + Oe), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, ne.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, ne.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Wt = ne.isCompressedTexture || ne.image[0].isCompressedTexture, Dt = ne.image[0] && ne.image[0].isDataTexture, Se = [];
      for (let Be = 0; Be < 6; Be++)
        !Wt && !Dt ? Se[Be] = k(ne.image[Be], !1, !0, p) : Se[Be] = Dt ? ne.image[Be].image : ne.image[Be], Se[Be] = Zt(ne, Se[Be]);
      const He = Se[0], lt = H(He) || c, St = o.convert(ne.format, ne.colorSpace), Je = o.convert(ne.type), be = J(ne.internalFormat, St, Je, ne.colorSpace), Ze = c && ne.isVideoTexture !== !0, ct = at.__version === void 0 || _t === !0;
      let pe = K(ne, He, lt);
      Ne(n.TEXTURE_CUBE_MAP, ne, lt);
      let Rt;
      if (Wt) {
        Ze && ct && t.texStorage2D(n.TEXTURE_CUBE_MAP, pe, be, He.width, He.height);
        for (let Be = 0; Be < 6; Be++) {
          Rt = Se[Be].mipmaps;
          for (let ut = 0; ut < Rt.length; ut++) {
            const on = Rt[ut];
            ne.format !== Td ? St !== null ? Ze ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut, 0, 0, on.width, on.height, St, on.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut, be, on.width, on.height, 0, on.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ze ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut, 0, 0, on.width, on.height, St, Je, on.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut, be, on.width, on.height, 0, St, Je, on.data);
          }
        }
      } else {
        Rt = ne.mipmaps, Ze && ct && (Rt.length > 0 && pe++, t.texStorage2D(n.TEXTURE_CUBE_MAP, pe, be, Se[0].width, Se[0].height));
        for (let Be = 0; Be < 6; Be++)
          if (Dt) {
            Ze ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, Se[Be].width, Se[Be].height, St, Je, Se[Be].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, be, Se[Be].width, Se[Be].height, 0, St, Je, Se[Be].data);
            for (let ut = 0; ut < Rt.length; ut++) {
              const zn = Rt[ut].image[Be].image;
              Ze ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut + 1, 0, 0, zn.width, zn.height, St, Je, zn.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut + 1, be, zn.width, zn.height, 0, St, Je, zn.data);
            }
          } else {
            Ze ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, St, Je, Se[Be]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, be, St, Je, Se[Be]);
            for (let ut = 0; ut < Rt.length; ut++) {
              const on = Rt[ut];
              Ze ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut + 1, 0, 0, St, Je, on.image[Be]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Be, ut + 1, be, St, Je, on.image[Be]);
            }
          }
      }
      $(ne, lt) && Y(n.TEXTURE_CUBE_MAP), at.__version = ot.version, ne.onUpdate && ne.onUpdate(ne);
    }
    ie.__version = ne.version;
  }
  function rt(ie, ne, Oe, _t, ot, at) {
    const Wt = o.convert(Oe.format, Oe.colorSpace), Dt = o.convert(Oe.type), Se = J(Oe.internalFormat, Wt, Dt, Oe.colorSpace);
    if (!r.get(ne).__hasExternalTextures) {
      const lt = Math.max(1, ne.width >> at), St = Math.max(1, ne.height >> at);
      ot === n.TEXTURE_3D || ot === n.TEXTURE_2D_ARRAY ? t.texImage3D(ot, at, Se, lt, St, ne.depth, 0, Wt, Dt, null) : t.texImage2D(ot, at, Se, lt, St, 0, Wt, Dt, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, ie), Pt(ne) ? b.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, _t, ot, r.get(Oe).__webglTexture, 0, Ct(ne)) : (ot === n.TEXTURE_2D || ot >= n.TEXTURE_CUBE_MAP_POSITIVE_X && ot <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, _t, ot, r.get(Oe).__webglTexture, at), t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function ae(ie, ne, Oe) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, ie), ne.depthBuffer && !ne.stencilBuffer) {
      let _t = n.DEPTH_COMPONENT16;
      if (Oe || Pt(ne)) {
        const ot = ne.depthTexture;
        ot && ot.isDepthTexture && (ot.type === xv ? _t = n.DEPTH_COMPONENT32F : ot.type === Hg && (_t = n.DEPTH_COMPONENT24));
        const at = Ct(ne);
        Pt(ne) ? b.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, at, _t, ne.width, ne.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, at, _t, ne.width, ne.height);
      } else
        n.renderbufferStorage(n.RENDERBUFFER, _t, ne.width, ne.height);
      n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, ie);
    } else if (ne.depthBuffer && ne.stencilBuffer) {
      const _t = Ct(ne);
      Oe && Pt(ne) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, _t, n.DEPTH24_STENCIL8, ne.width, ne.height) : Pt(ne) ? b.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, _t, n.DEPTH24_STENCIL8, ne.width, ne.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, ne.width, ne.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, ie);
    } else {
      const _t = ne.isWebGLMultipleRenderTargets === !0 ? ne.texture : [ne.texture];
      for (let ot = 0; ot < _t.length; ot++) {
        const at = _t[ot], Wt = o.convert(at.format, at.colorSpace), Dt = o.convert(at.type), Se = J(at.internalFormat, Wt, Dt, at.colorSpace), He = Ct(ne);
        Oe && Pt(ne) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, He, Se, ne.width, ne.height) : Pt(ne) ? b.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, He, Se, ne.width, ne.height) : n.renderbufferStorage(n.RENDERBUFFER, Se, ne.width, ne.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function et(ie, ne) {
    if (ne && ne.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n.FRAMEBUFFER, ie), !(ne.depthTexture && ne.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(ne.depthTexture).__webglTexture || ne.depthTexture.image.width !== ne.width || ne.depthTexture.image.height !== ne.height) && (ne.depthTexture.image.width = ne.width, ne.depthTexture.image.height = ne.height, ne.depthTexture.needsUpdate = !0), re(ne.depthTexture, 0);
    const _t = r.get(ne.depthTexture).__webglTexture, ot = Ct(ne);
    if (ne.depthTexture.format === v0)
      Pt(ne) ? b.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, _t, 0, ot) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, _t, 0);
    else if (ne.depthTexture.format === gx)
      Pt(ne) ? b.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, _t, 0, ot) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, _t, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Ye(ie) {
    const ne = r.get(ie), Oe = ie.isWebGLCubeRenderTarget === !0;
    if (ie.depthTexture && !ne.__autoAllocateDepthBuffer) {
      if (Oe)
        throw new Error("target.depthTexture not supported in Cube render targets");
      et(ne.__webglFramebuffer, ie);
    } else if (Oe) {
      ne.__webglDepthbuffer = [];
      for (let _t = 0; _t < 6; _t++)
        t.bindFramebuffer(n.FRAMEBUFFER, ne.__webglFramebuffer[_t]), ne.__webglDepthbuffer[_t] = n.createRenderbuffer(), ae(ne.__webglDepthbuffer[_t], ie, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, ne.__webglFramebuffer), ne.__webglDepthbuffer = n.createRenderbuffer(), ae(ne.__webglDepthbuffer, ie, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ge(ie, ne, Oe) {
    const _t = r.get(ie);
    ne !== void 0 && rt(_t.__webglFramebuffer, ie, ie.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), Oe !== void 0 && Ye(ie);
  }
  function $e(ie) {
    const ne = ie.texture, Oe = r.get(ie), _t = r.get(ne);
    ie.addEventListener("dispose", oe), ie.isWebGLMultipleRenderTargets !== !0 && (_t.__webglTexture === void 0 && (_t.__webglTexture = n.createTexture()), _t.__version = ne.version, l.memory.textures++);
    const ot = ie.isWebGLCubeRenderTarget === !0, at = ie.isWebGLMultipleRenderTargets === !0, Wt = H(ie) || c;
    if (ot) {
      Oe.__webglFramebuffer = [];
      for (let Dt = 0; Dt < 6; Dt++)
        if (c && ne.mipmaps && ne.mipmaps.length > 0) {
          Oe.__webglFramebuffer[Dt] = [];
          for (let Se = 0; Se < ne.mipmaps.length; Se++)
            Oe.__webglFramebuffer[Dt][Se] = n.createFramebuffer();
        } else
          Oe.__webglFramebuffer[Dt] = n.createFramebuffer();
    } else {
      if (c && ne.mipmaps && ne.mipmaps.length > 0) {
        Oe.__webglFramebuffer = [];
        for (let Dt = 0; Dt < ne.mipmaps.length; Dt++)
          Oe.__webglFramebuffer[Dt] = n.createFramebuffer();
      } else
        Oe.__webglFramebuffer = n.createFramebuffer();
      if (at)
        if (i.drawBuffers) {
          const Dt = ie.texture;
          for (let Se = 0, He = Dt.length; Se < He; Se++) {
            const lt = r.get(Dt[Se]);
            lt.__webglTexture === void 0 && (lt.__webglTexture = n.createTexture(), l.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (c && ie.samples > 0 && Pt(ie) === !1) {
        const Dt = at ? ne : [ne];
        Oe.__webglMultisampledFramebuffer = n.createFramebuffer(), Oe.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, Oe.__webglMultisampledFramebuffer);
        for (let Se = 0; Se < Dt.length; Se++) {
          const He = Dt[Se];
          Oe.__webglColorRenderbuffer[Se] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, Oe.__webglColorRenderbuffer[Se]);
          const lt = o.convert(He.format, He.colorSpace), St = o.convert(He.type), Je = J(He.internalFormat, lt, St, He.colorSpace, ie.isXRRenderTarget === !0), be = Ct(ie);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, be, Je, ie.width, ie.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Se, n.RENDERBUFFER, Oe.__webglColorRenderbuffer[Se]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), ie.depthBuffer && (Oe.__webglDepthRenderbuffer = n.createRenderbuffer(), ae(Oe.__webglDepthRenderbuffer, ie, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (ot) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, _t.__webglTexture), Ne(n.TEXTURE_CUBE_MAP, ne, Wt);
      for (let Dt = 0; Dt < 6; Dt++)
        if (c && ne.mipmaps && ne.mipmaps.length > 0)
          for (let Se = 0; Se < ne.mipmaps.length; Se++)
            rt(Oe.__webglFramebuffer[Dt][Se], ie, ne, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Dt, Se);
        else
          rt(Oe.__webglFramebuffer[Dt], ie, ne, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Dt, 0);
      $(ne, Wt) && Y(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (at) {
      const Dt = ie.texture;
      for (let Se = 0, He = Dt.length; Se < He; Se++) {
        const lt = Dt[Se], St = r.get(lt);
        t.bindTexture(n.TEXTURE_2D, St.__webglTexture), Ne(n.TEXTURE_2D, lt, Wt), rt(Oe.__webglFramebuffer, ie, lt, n.COLOR_ATTACHMENT0 + Se, n.TEXTURE_2D, 0), $(lt, Wt) && Y(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Dt = n.TEXTURE_2D;
      if ((ie.isWebGL3DRenderTarget || ie.isWebGLArrayRenderTarget) && (c ? Dt = ie.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Dt, _t.__webglTexture), Ne(Dt, ne, Wt), c && ne.mipmaps && ne.mipmaps.length > 0)
        for (let Se = 0; Se < ne.mipmaps.length; Se++)
          rt(Oe.__webglFramebuffer[Se], ie, ne, n.COLOR_ATTACHMENT0, Dt, Se);
      else
        rt(Oe.__webglFramebuffer, ie, ne, n.COLOR_ATTACHMENT0, Dt, 0);
      $(ne, Wt) && Y(Dt), t.unbindTexture();
    }
    ie.depthBuffer && Ye(ie);
  }
  function Ut(ie) {
    const ne = H(ie) || c, Oe = ie.isWebGLMultipleRenderTargets === !0 ? ie.texture : [ie.texture];
    for (let _t = 0, ot = Oe.length; _t < ot; _t++) {
      const at = Oe[_t];
      if ($(at, ne)) {
        const Wt = ie.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, Dt = r.get(at).__webglTexture;
        t.bindTexture(Wt, Dt), Y(Wt), t.unbindTexture();
      }
    }
  }
  function nt(ie) {
    if (c && ie.samples > 0 && Pt(ie) === !1) {
      const ne = ie.isWebGLMultipleRenderTargets ? ie.texture : [ie.texture], Oe = ie.width, _t = ie.height;
      let ot = n.COLOR_BUFFER_BIT;
      const at = [], Wt = ie.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Dt = r.get(ie), Se = ie.isWebGLMultipleRenderTargets === !0;
      if (Se)
        for (let He = 0; He < ne.length; He++)
          t.bindFramebuffer(n.FRAMEBUFFER, Dt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Dt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.TEXTURE_2D, null, 0);
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Dt.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Dt.__webglFramebuffer);
      for (let He = 0; He < ne.length; He++) {
        at.push(n.COLOR_ATTACHMENT0 + He), ie.depthBuffer && at.push(Wt);
        const lt = Dt.__ignoreDepthValues !== void 0 ? Dt.__ignoreDepthValues : !1;
        if (lt === !1 && (ie.depthBuffer && (ot |= n.DEPTH_BUFFER_BIT), ie.stencilBuffer && (ot |= n.STENCIL_BUFFER_BIT)), Se && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Dt.__webglColorRenderbuffer[He]), lt === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Wt]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Wt])), Se) {
          const St = r.get(ne[He]).__webglTexture;
          n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, St, 0);
        }
        n.blitFramebuffer(0, 0, Oe, _t, 0, 0, Oe, _t, ot, n.NEAREST), w && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, at);
      }
      if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), Se)
        for (let He = 0; He < ne.length; He++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Dt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.RENDERBUFFER, Dt.__webglColorRenderbuffer[He]);
          const lt = r.get(ne[He]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Dt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + He, n.TEXTURE_2D, lt, 0);
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Dt.__webglMultisampledFramebuffer);
    }
  }
  function Ct(ie) {
    return Math.min(x, ie.samples);
  }
  function Pt(ie) {
    const ne = r.get(ie);
    return c && ie.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && ne.__useRenderToTexture !== !1;
  }
  function vt(ie) {
    const ne = l.render.frame;
    R.get(ie) !== ne && (R.set(ie, ne), ie.update());
  }
  function Zt(ie, ne) {
    const Oe = ie.colorSpace, _t = ie.format, ot = ie.type;
    return ie.isCompressedTexture === !0 || ie.isVideoTexture === !0 || ie.format === wR || Oe !== dm && Oe !== y0 && (Oe === go || Oe === aw ? c === !1 ? e.has("EXT_sRGB") === !0 && _t === Td ? (ie.format = wR, ie.minFilter = ss, ie.generateMipmaps = !1) : ne = AP.sRGBToLinear(ne) : (_t !== Td || ot !== bv) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Oe)), ne;
  }
  this.allocateTextureUnit = ce, this.resetTextureUnits = Pe, this.setTexture2D = re, this.setTexture2DArray = ee, this.setTexture3D = he, this.setTextureCube = Me, this.rebindTextures = Ge, this.setupRenderTarget = $e, this.updateRenderTargetMipmap = Ut, this.updateMultisampleRenderTarget = nt, this.setupDepthRenderbuffer = Ye, this.setupFrameBufferTexture = rt, this.useMultisampledRTT = Pt;
}
const I$ = 0, eu = 1;
function D4(n, e, t) {
  const r = t.isWebGL2;
  function i(o, l = y0) {
    let c;
    const h = l === go || l === aw ? eu : I$;
    if (o === bv)
      return n.UNSIGNED_BYTE;
    if (o === xP)
      return n.UNSIGNED_SHORT_4_4_4_4;
    if (o === _P)
      return n.UNSIGNED_SHORT_5_5_5_1;
    if (o === YI)
      return n.BYTE;
    if (o === XI)
      return n.SHORT;
    if (o === XR)
      return n.UNSIGNED_SHORT;
    if (o === SP)
      return n.INT;
    if (o === Hg)
      return n.UNSIGNED_INT;
    if (o === xv)
      return n.FLOAT;
    if (o === X1)
      return r ? n.HALF_FLOAT : (c = e.get("OES_texture_half_float"), c !== null ? c.HALF_FLOAT_OES : null);
    if (o === qI)
      return n.ALPHA;
    if (o === Td)
      return n.RGBA;
    if (o === KI)
      return n.LUMINANCE;
    if (o === QI)
      return n.LUMINANCE_ALPHA;
    if (o === v0)
      return n.DEPTH_COMPONENT;
    if (o === gx)
      return n.DEPTH_STENCIL;
    if (o === wR)
      return c = e.get("EXT_sRGB"), c !== null ? c.SRGB_ALPHA_EXT : null;
    if (o === ZI)
      return n.RED;
    if (o === EP)
      return n.RED_INTEGER;
    if (o === JI)
      return n.RG;
    if (o === bP)
      return n.RG_INTEGER;
    if (o === TP)
      return n.RGBA_INTEGER;
    if (o === cR || o === fR || o === dR || o === hR)
      if (h === eu)
        if (c = e.get("WEBGL_compressed_texture_s3tc_srgb"), c !== null) {
          if (o === cR)
            return c.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (o === fR)
            return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (o === dR)
            return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (o === hR)
            return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (c = e.get("WEBGL_compressed_texture_s3tc"), c !== null) {
        if (o === cR)
          return c.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === fR)
          return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === dR)
          return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === hR)
          return c.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === XL || o === qL || o === KL || o === QL)
      if (c = e.get("WEBGL_compressed_texture_pvrtc"), c !== null) {
        if (o === XL)
          return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === qL)
          return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === KL)
          return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === QL)
          return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === e4)
      return c = e.get("WEBGL_compressed_texture_etc1"), c !== null ? c.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (o === ZL || o === JL)
      if (c = e.get("WEBGL_compressed_texture_etc"), c !== null) {
        if (o === ZL)
          return h === eu ? c.COMPRESSED_SRGB8_ETC2 : c.COMPRESSED_RGB8_ETC2;
        if (o === JL)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : c.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (o === eO || o === tO || o === nO || o === rO || o === iO || o === aO || o === oO || o === sO || o === lO || o === uO || o === cO || o === fO || o === dO || o === hO)
      if (c = e.get("WEBGL_compressed_texture_astc"), c !== null) {
        if (o === eO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : c.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (o === tO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : c.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (o === nO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : c.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (o === rO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : c.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (o === iO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : c.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (o === aO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : c.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (o === oO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : c.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (o === sO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : c.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (o === lO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : c.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (o === uO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : c.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (o === cO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : c.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (o === fO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : c.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (o === dO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : c.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (o === hO)
          return h === eu ? c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : c.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (o === pR || o === pO || o === mO)
      if (c = e.get("EXT_texture_compression_bptc"), c !== null) {
        if (o === pR)
          return h === eu ? c.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : c.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (o === pO)
          return c.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (o === mO)
          return c.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (o === t4 || o === vO || o === gO || o === yO)
      if (c = e.get("EXT_texture_compression_rgtc"), c !== null) {
        if (o === pR)
          return c.COMPRESSED_RED_RGTC1_EXT;
        if (o === vO)
          return c.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (o === gO)
          return c.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (o === yO)
          return c.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return o === m0 ? r ? n.UNSIGNED_INT_24_8 : (c = e.get("WEBGL_depth_texture"), c !== null ? c.UNSIGNED_INT_24_8_WEBGL : null) : n[o] !== void 0 ? n[o] : null;
  }
  return { convert: i };
}
class L4 extends Ps {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class z1 extends aa {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const B$ = { type: "move" };
class YD {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new z1(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new z1(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Te(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Te()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new z1(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Te(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Te()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const r of e.hand.values())
          this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, r) {
    let i = null, o = null, l = null;
    const c = this._targetRay, h = this._grip, p = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (p && e.hand) {
        l = !0;
        for (const U of e.hand.values()) {
          const L = t.getJointPose(U, r), A = this._getHandJoint(p, U);
          L !== null && (A.matrix.fromArray(L.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.matrixWorldNeedsUpdate = !0, A.jointRadius = L.radius), A.visible = L !== null;
        }
        const y = p.joints["index-finger-tip"], x = p.joints["thumb-tip"], b = y.position.distanceTo(x.position), w = 0.02, R = 5e-3;
        p.inputState.pinching && b > w + R ? (p.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !p.inputState.pinching && b <= w - R && (p.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        h !== null && e.gripSpace && (o = t.getPose(e.gripSpace, r), o !== null && (h.matrix.fromArray(o.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(o.linearVelocity)) : h.hasLinearVelocity = !1, o.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(o.angularVelocity)) : h.hasAngularVelocity = !1));
      c !== null && (i = t.getPose(e.targetRaySpace, r), i === null && o !== null && (i = o), i !== null && (c.matrix.fromArray(i.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(i.linearVelocity)) : c.hasLinearVelocity = !1, i.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(i.angularVelocity)) : c.hasAngularVelocity = !1, this.dispatchEvent(B$)));
    }
    return c !== null && (c.visible = i !== null), h !== null && (h.visible = o !== null), p !== null && (p.visible = l !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new z1();
      r.matrixAutoUpdate = !1, r.visible = !1, e.joints[t.jointName] = r, e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class O4 extends cs {
  constructor(e, t, r, i, o, l, c, h, p, y) {
    if (y = y !== void 0 ? y : v0, y !== v0 && y !== gx)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    r === void 0 && y === v0 && (r = Hg), r === void 0 && y === gx && (r = m0), super(null, i, o, l, c, h, y, r, p), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = c !== void 0 ? c : ol, this.minFilter = h !== void 0 ? h : ol, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class H$ extends Av {
  constructor(e, t) {
    super();
    const r = this;
    let i = null, o = 1, l = null, c = "local-floor", h = 1, p = null, y = null, x = null, b = null, w = null, R = null;
    const U = t.getContextAttributes();
    let L = null, A = null;
    const F = [], k = [], H = new Ps();
    H.layers.enable(1), H.viewport = new ua();
    const B = new Ps();
    B.layers.enable(2), B.viewport = new ua();
    const $ = [H, B], Y = new L4();
    Y.layers.enable(1), Y.layers.enable(2);
    let J = null, K = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ee) {
      let he = F[ee];
      return he === void 0 && (he = new YD(), F[ee] = he), he.getTargetRaySpace();
    }, this.getControllerGrip = function(ee) {
      let he = F[ee];
      return he === void 0 && (he = new YD(), F[ee] = he), he.getGripSpace();
    }, this.getHand = function(ee) {
      let he = F[ee];
      return he === void 0 && (he = new YD(), F[ee] = he), he.getHandSpace();
    };
    function X(ee) {
      const he = k.indexOf(ee.inputSource);
      if (he === -1)
        return;
      const Me = F[he];
      Me !== void 0 && (Me.update(ee.inputSource, ee.frame, p || l), Me.dispatchEvent({ type: ee.type, data: ee.inputSource }));
    }
    function le() {
      i.removeEventListener("select", X), i.removeEventListener("selectstart", X), i.removeEventListener("selectend", X), i.removeEventListener("squeeze", X), i.removeEventListener("squeezestart", X), i.removeEventListener("squeezeend", X), i.removeEventListener("end", le), i.removeEventListener("inputsourceschange", oe);
      for (let ee = 0; ee < F.length; ee++) {
        const he = k[ee];
        he !== null && (k[ee] = null, F[ee].disconnect(he));
      }
      J = null, K = null, e.setRenderTarget(L), w = null, b = null, x = null, i = null, A = null, re.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ee) {
      o = ee, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ee) {
      c = ee, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return p || l;
    }, this.setReferenceSpace = function(ee) {
      p = ee;
    }, this.getBaseLayer = function() {
      return b !== null ? b : w;
    }, this.getBinding = function() {
      return x;
    }, this.getFrame = function() {
      return R;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(ee) {
      if (i = ee, i !== null) {
        if (L = e.getRenderTarget(), i.addEventListener("select", X), i.addEventListener("selectstart", X), i.addEventListener("selectend", X), i.addEventListener("squeeze", X), i.addEventListener("squeezestart", X), i.addEventListener("squeezeend", X), i.addEventListener("end", le), i.addEventListener("inputsourceschange", oe), U.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const he = {
            antialias: i.renderState.layers === void 0 ? U.antialias : !0,
            alpha: !0,
            depth: U.depth,
            stencil: U.stencil,
            framebufferScaleFactor: o
          };
          w = new XRWebGLLayer(i, t, he), i.updateRenderState({ baseLayer: w }), A = new hm(
            w.framebufferWidth,
            w.framebufferHeight,
            {
              format: Td,
              type: bv,
              colorSpace: e.outputColorSpace,
              stencilBuffer: U.stencil
            }
          );
        } else {
          let he = null, Me = null, Le = null;
          U.depth && (Le = U.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, he = U.stencil ? gx : v0, Me = U.stencil ? m0 : Hg);
          const Ae = {
            colorFormat: t.RGBA8,
            depthFormat: Le,
            scaleFactor: o
          };
          x = new XRWebGLBinding(i, t), b = x.createProjectionLayer(Ae), i.updateRenderState({ layers: [b] }), A = new hm(
            b.textureWidth,
            b.textureHeight,
            {
              format: Td,
              type: bv,
              depthTexture: new O4(b.textureWidth, b.textureHeight, Me, void 0, void 0, void 0, void 0, void 0, void 0, he),
              stencilBuffer: U.stencil,
              colorSpace: e.outputColorSpace,
              samples: U.antialias ? 4 : 0
            }
          );
          const Ue = e.properties.get(A);
          Ue.__ignoreDepthValues = b.ignoreDepthValues;
        }
        A.isXRRenderTarget = !0, this.setFoveation(h), p = null, l = await i.requestReferenceSpace(c), re.setContext(i), re.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function oe(ee) {
      for (let he = 0; he < ee.removed.length; he++) {
        const Me = ee.removed[he], Le = k.indexOf(Me);
        Le >= 0 && (k[Le] = null, F[Le].disconnect(Me));
      }
      for (let he = 0; he < ee.added.length; he++) {
        const Me = ee.added[he];
        let Le = k.indexOf(Me);
        if (Le === -1) {
          for (let Ue = 0; Ue < F.length; Ue++)
            if (Ue >= k.length) {
              k.push(Me), Le = Ue;
              break;
            } else if (k[Ue] === null) {
              k[Ue] = Me, Le = Ue;
              break;
            }
          if (Le === -1)
            break;
        }
        const Ae = F[Le];
        Ae && Ae.connect(Me);
      }
    }
    const fe = new Te(), de = new Te();
    function xe(ee, he, Me) {
      fe.setFromMatrixPosition(he.matrixWorld), de.setFromMatrixPosition(Me.matrixWorld);
      const Le = fe.distanceTo(de), Ae = he.projectionMatrix.elements, Ue = Me.projectionMatrix.elements, Ne = Ae[14] / (Ae[10] - 1), ke = Ae[14] / (Ae[10] + 1), it = (Ae[9] + 1) / Ae[5], At = (Ae[9] - 1) / Ae[5], rt = (Ae[8] - 1) / Ae[0], ae = (Ue[8] + 1) / Ue[0], et = Ne * rt, Ye = Ne * ae, Ge = Le / (-rt + ae), $e = Ge * -rt;
      he.matrixWorld.decompose(ee.position, ee.quaternion, ee.scale), ee.translateX($e), ee.translateZ(Ge), ee.matrixWorld.compose(ee.position, ee.quaternion, ee.scale), ee.matrixWorldInverse.copy(ee.matrixWorld).invert();
      const Ut = Ne + Ge, nt = ke + Ge, Ct = et - $e, Pt = Ye + (Le - $e), vt = it * ke / nt * Ut, Zt = At * ke / nt * Ut;
      ee.projectionMatrix.makePerspective(Ct, Pt, vt, Zt, Ut, nt), ee.projectionMatrixInverse.copy(ee.projectionMatrix).invert();
    }
    function _e(ee, he) {
      he === null ? ee.matrixWorld.copy(ee.matrix) : ee.matrixWorld.multiplyMatrices(he.matrixWorld, ee.matrix), ee.matrixWorldInverse.copy(ee.matrixWorld).invert();
    }
    this.updateCamera = function(ee) {
      if (i === null)
        return;
      Y.near = B.near = H.near = ee.near, Y.far = B.far = H.far = ee.far, (J !== Y.near || K !== Y.far) && (i.updateRenderState({
        depthNear: Y.near,
        depthFar: Y.far
      }), J = Y.near, K = Y.far);
      const he = ee.parent, Me = Y.cameras;
      _e(Y, he);
      for (let Le = 0; Le < Me.length; Le++)
        _e(Me[Le], he);
      Me.length === 2 ? xe(Y, H, B) : Y.projectionMatrix.copy(H.projectionMatrix), Pe(ee, Y, he);
    };
    function Pe(ee, he, Me) {
      Me === null ? ee.matrix.copy(he.matrixWorld) : (ee.matrix.copy(Me.matrixWorld), ee.matrix.invert(), ee.matrix.multiply(he.matrixWorld)), ee.matrix.decompose(ee.position, ee.quaternion, ee.scale), ee.updateMatrixWorld(!0), ee.projectionMatrix.copy(he.projectionMatrix), ee.projectionMatrixInverse.copy(he.projectionMatrixInverse), ee.isPerspectiveCamera && (ee.fov = q1 * 2 * Math.atan(1 / ee.projectionMatrix.elements[5]), ee.zoom = 1);
    }
    this.getCamera = function() {
      return Y;
    }, this.getFoveation = function() {
      if (!(b === null && w === null))
        return h;
    }, this.setFoveation = function(ee) {
      h = ee, b !== null && (b.fixedFoveation = ee), w !== null && w.fixedFoveation !== void 0 && (w.fixedFoveation = ee);
    };
    let ce = null;
    function ve(ee, he) {
      if (y = he.getViewerPose(p || l), R = he, y !== null) {
        const Me = y.views;
        w !== null && (e.setRenderTargetFramebuffer(A, w.framebuffer), e.setRenderTarget(A));
        let Le = !1;
        Me.length !== Y.cameras.length && (Y.cameras.length = 0, Le = !0);
        for (let Ae = 0; Ae < Me.length; Ae++) {
          const Ue = Me[Ae];
          let Ne = null;
          if (w !== null)
            Ne = w.getViewport(Ue);
          else {
            const it = x.getViewSubImage(b, Ue);
            Ne = it.viewport, Ae === 0 && (e.setRenderTargetTextures(
              A,
              it.colorTexture,
              b.ignoreDepthValues ? void 0 : it.depthStencilTexture
            ), e.setRenderTarget(A));
          }
          let ke = $[Ae];
          ke === void 0 && (ke = new Ps(), ke.layers.enable(Ae), ke.viewport = new ua(), $[Ae] = ke), ke.matrix.fromArray(Ue.transform.matrix), ke.matrix.decompose(ke.position, ke.quaternion, ke.scale), ke.projectionMatrix.fromArray(Ue.projectionMatrix), ke.projectionMatrixInverse.copy(ke.projectionMatrix).invert(), ke.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height), Ae === 0 && (Y.matrix.copy(ke.matrix), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale)), Le === !0 && Y.cameras.push(ke);
        }
      }
      for (let Me = 0; Me < F.length; Me++) {
        const Le = k[Me], Ae = F[Me];
        Le !== null && Ae !== void 0 && Ae.update(Le, he, p || l);
      }
      ce && ce(ee, he), he.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: he }), R = null;
    }
    const re = new w4();
    re.setAnimationLoop(ve), this.setAnimationLoop = function(ee) {
      ce = ee;
    }, this.dispose = function() {
    };
  }
}
function V$(n, e) {
  function t(L, A) {
    L.matrixAutoUpdate === !0 && L.updateMatrix(), A.value.copy(L.matrix);
  }
  function r(L, A) {
    A.color.getRGB(L.fogColor.value, E4(n)), A.isFog ? (L.fogNear.value = A.near, L.fogFar.value = A.far) : A.isFogExp2 && (L.fogDensity.value = A.density);
  }
  function i(L, A, F, k, H) {
    A.isMeshBasicMaterial || A.isMeshLambertMaterial ? o(L, A) : A.isMeshToonMaterial ? (o(L, A), x(L, A)) : A.isMeshPhongMaterial ? (o(L, A), y(L, A)) : A.isMeshStandardMaterial ? (o(L, A), b(L, A), A.isMeshPhysicalMaterial && w(L, A, H)) : A.isMeshMatcapMaterial ? (o(L, A), R(L, A)) : A.isMeshDepthMaterial ? o(L, A) : A.isMeshDistanceMaterial ? (o(L, A), U(L, A)) : A.isMeshNormalMaterial ? o(L, A) : A.isLineBasicMaterial ? (l(L, A), A.isLineDashedMaterial && c(L, A)) : A.isPointsMaterial ? h(L, A, F, k) : A.isSpriteMaterial ? p(L, A) : A.isShadowMaterial ? (L.color.value.copy(A.color), L.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = !1);
  }
  function o(L, A) {
    L.opacity.value = A.opacity, A.color && L.diffuse.value.copy(A.color), A.emissive && L.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (L.map.value = A.map, t(A.map, L.mapTransform)), A.alphaMap && (L.alphaMap.value = A.alphaMap, t(A.alphaMap, L.alphaMapTransform)), A.bumpMap && (L.bumpMap.value = A.bumpMap, t(A.bumpMap, L.bumpMapTransform), L.bumpScale.value = A.bumpScale, A.side === Ic && (L.bumpScale.value *= -1)), A.normalMap && (L.normalMap.value = A.normalMap, t(A.normalMap, L.normalMapTransform), L.normalScale.value.copy(A.normalScale), A.side === Ic && L.normalScale.value.negate()), A.displacementMap && (L.displacementMap.value = A.displacementMap, t(A.displacementMap, L.displacementMapTransform), L.displacementScale.value = A.displacementScale, L.displacementBias.value = A.displacementBias), A.emissiveMap && (L.emissiveMap.value = A.emissiveMap, t(A.emissiveMap, L.emissiveMapTransform)), A.specularMap && (L.specularMap.value = A.specularMap, t(A.specularMap, L.specularMapTransform)), A.alphaTest > 0 && (L.alphaTest.value = A.alphaTest);
    const F = e.get(A).envMap;
    if (F && (L.envMap.value = F, L.flipEnvMap.value = F.isCubeTexture && F.isRenderTargetTexture === !1 ? -1 : 1, L.reflectivity.value = A.reflectivity, L.ior.value = A.ior, L.refractionRatio.value = A.refractionRatio), A.lightMap) {
      L.lightMap.value = A.lightMap;
      const k = n._useLegacyLights === !0 ? Math.PI : 1;
      L.lightMapIntensity.value = A.lightMapIntensity * k, t(A.lightMap, L.lightMapTransform);
    }
    A.aoMap && (L.aoMap.value = A.aoMap, L.aoMapIntensity.value = A.aoMapIntensity, t(A.aoMap, L.aoMapTransform));
  }
  function l(L, A) {
    L.diffuse.value.copy(A.color), L.opacity.value = A.opacity, A.map && (L.map.value = A.map, t(A.map, L.mapTransform));
  }
  function c(L, A) {
    L.dashSize.value = A.dashSize, L.totalSize.value = A.dashSize + A.gapSize, L.scale.value = A.scale;
  }
  function h(L, A, F, k) {
    L.diffuse.value.copy(A.color), L.opacity.value = A.opacity, L.size.value = A.size * F, L.scale.value = k * 0.5, A.map && (L.map.value = A.map, t(A.map, L.uvTransform)), A.alphaMap && (L.alphaMap.value = A.alphaMap, t(A.alphaMap, L.alphaMapTransform)), A.alphaTest > 0 && (L.alphaTest.value = A.alphaTest);
  }
  function p(L, A) {
    L.diffuse.value.copy(A.color), L.opacity.value = A.opacity, L.rotation.value = A.rotation, A.map && (L.map.value = A.map, t(A.map, L.mapTransform)), A.alphaMap && (L.alphaMap.value = A.alphaMap, t(A.alphaMap, L.alphaMapTransform)), A.alphaTest > 0 && (L.alphaTest.value = A.alphaTest);
  }
  function y(L, A) {
    L.specular.value.copy(A.specular), L.shininess.value = Math.max(A.shininess, 1e-4);
  }
  function x(L, A) {
    A.gradientMap && (L.gradientMap.value = A.gradientMap);
  }
  function b(L, A) {
    L.metalness.value = A.metalness, A.metalnessMap && (L.metalnessMap.value = A.metalnessMap, t(A.metalnessMap, L.metalnessMapTransform)), L.roughness.value = A.roughness, A.roughnessMap && (L.roughnessMap.value = A.roughnessMap, t(A.roughnessMap, L.roughnessMapTransform)), e.get(A).envMap && (L.envMapIntensity.value = A.envMapIntensity);
  }
  function w(L, A, F) {
    L.ior.value = A.ior, A.sheen > 0 && (L.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), L.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (L.sheenColorMap.value = A.sheenColorMap, t(A.sheenColorMap, L.sheenColorMapTransform)), A.sheenRoughnessMap && (L.sheenRoughnessMap.value = A.sheenRoughnessMap, t(A.sheenRoughnessMap, L.sheenRoughnessMapTransform))), A.clearcoat > 0 && (L.clearcoat.value = A.clearcoat, L.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (L.clearcoatMap.value = A.clearcoatMap, t(A.clearcoatMap, L.clearcoatMapTransform)), A.clearcoatRoughnessMap && (L.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, t(A.clearcoatRoughnessMap, L.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (L.clearcoatNormalMap.value = A.clearcoatNormalMap, t(A.clearcoatNormalMap, L.clearcoatNormalMapTransform), L.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A.side === Ic && L.clearcoatNormalScale.value.negate())), A.iridescence > 0 && (L.iridescence.value = A.iridescence, L.iridescenceIOR.value = A.iridescenceIOR, L.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], L.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (L.iridescenceMap.value = A.iridescenceMap, t(A.iridescenceMap, L.iridescenceMapTransform)), A.iridescenceThicknessMap && (L.iridescenceThicknessMap.value = A.iridescenceThicknessMap, t(A.iridescenceThicknessMap, L.iridescenceThicknessMapTransform))), A.transmission > 0 && (L.transmission.value = A.transmission, L.transmissionSamplerMap.value = F.texture, L.transmissionSamplerSize.value.set(F.width, F.height), A.transmissionMap && (L.transmissionMap.value = A.transmissionMap, t(A.transmissionMap, L.transmissionMapTransform)), L.thickness.value = A.thickness, A.thicknessMap && (L.thicknessMap.value = A.thicknessMap, t(A.thicknessMap, L.thicknessMapTransform)), L.attenuationDistance.value = A.attenuationDistance, L.attenuationColor.value.copy(A.attenuationColor)), A.anisotropy > 0 && (L.anisotropyVector.value.set(A.anisotropy * Math.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (L.anisotropyMap.value = A.anisotropyMap, t(A.anisotropyMap, L.anisotropyMapTransform))), L.specularIntensity.value = A.specularIntensity, L.specularColor.value.copy(A.specularColor), A.specularColorMap && (L.specularColorMap.value = A.specularColorMap, t(A.specularColorMap, L.specularColorMapTransform)), A.specularIntensityMap && (L.specularIntensityMap.value = A.specularIntensityMap, t(A.specularIntensityMap, L.specularIntensityMapTransform));
  }
  function R(L, A) {
    A.matcap && (L.matcap.value = A.matcap);
  }
  function U(L, A) {
    const F = e.get(A).light;
    L.referencePosition.value.setFromMatrixPosition(F.matrixWorld), L.nearDistance.value = F.shadow.camera.near, L.farDistance.value = F.shadow.camera.far;
  }
  return {
    refreshFogUniforms: r,
    refreshMaterialUniforms: i
  };
}
function G$(n, e, t, r) {
  let i = {}, o = {}, l = [];
  const c = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function h(F, k) {
    const H = k.program;
    r.uniformBlockBinding(F, H);
  }
  function p(F, k) {
    let H = i[F.id];
    H === void 0 && (R(F), H = y(F), i[F.id] = H, F.addEventListener("dispose", L));
    const B = k.program;
    r.updateUBOMapping(F, B);
    const $ = e.render.frame;
    o[F.id] !== $ && (b(F), o[F.id] = $);
  }
  function y(F) {
    const k = x();
    F.__bindingPointIndex = k;
    const H = n.createBuffer(), B = F.__size, $ = F.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, H), n.bufferData(n.UNIFORM_BUFFER, B, $), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, k, H), H;
  }
  function x() {
    for (let F = 0; F < c; F++)
      if (l.indexOf(F) === -1)
        return l.push(F), F;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function b(F) {
    const k = i[F.id], H = F.uniforms, B = F.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, k);
    for (let $ = 0, Y = H.length; $ < Y; $++) {
      const J = H[$];
      if (w(J, $, B) === !0) {
        const K = J.__offset, X = Array.isArray(J.value) ? J.value : [J.value];
        let le = 0;
        for (let oe = 0; oe < X.length; oe++) {
          const fe = X[oe], de = U(fe);
          typeof fe == "number" ? (J.__data[0] = fe, n.bufferSubData(n.UNIFORM_BUFFER, K + le, J.__data)) : fe.isMatrix3 ? (J.__data[0] = fe.elements[0], J.__data[1] = fe.elements[1], J.__data[2] = fe.elements[2], J.__data[3] = fe.elements[0], J.__data[4] = fe.elements[3], J.__data[5] = fe.elements[4], J.__data[6] = fe.elements[5], J.__data[7] = fe.elements[0], J.__data[8] = fe.elements[6], J.__data[9] = fe.elements[7], J.__data[10] = fe.elements[8], J.__data[11] = fe.elements[0]) : (fe.toArray(J.__data, le), le += de.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        n.bufferSubData(n.UNIFORM_BUFFER, K, J.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function w(F, k, H) {
    const B = F.value;
    if (H[k] === void 0) {
      if (typeof B == "number")
        H[k] = B;
      else {
        const $ = Array.isArray(B) ? B : [B], Y = [];
        for (let J = 0; J < $.length; J++)
          Y.push($[J].clone());
        H[k] = Y;
      }
      return !0;
    } else if (typeof B == "number") {
      if (H[k] !== B)
        return H[k] = B, !0;
    } else {
      const $ = Array.isArray(H[k]) ? H[k] : [H[k]], Y = Array.isArray(B) ? B : [B];
      for (let J = 0; J < $.length; J++) {
        const K = $[J];
        if (K.equals(Y[J]) === !1)
          return K.copy(Y[J]), !0;
      }
    }
    return !1;
  }
  function R(F) {
    const k = F.uniforms;
    let H = 0;
    const B = 16;
    let $ = 0;
    for (let Y = 0, J = k.length; Y < J; Y++) {
      const K = k[Y], X = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, le = Array.isArray(K.value) ? K.value : [K.value];
      for (let oe = 0, fe = le.length; oe < fe; oe++) {
        const de = le[oe], xe = U(de);
        X.boundary += xe.boundary, X.storage += xe.storage;
      }
      if (K.__data = new Float32Array(X.storage / Float32Array.BYTES_PER_ELEMENT), K.__offset = H, Y > 0) {
        $ = H % B;
        const oe = B - $;
        $ !== 0 && oe - X.boundary < 0 && (H += B - $, K.__offset = H);
      }
      H += X.storage;
    }
    return $ = H % B, $ > 0 && (H += B - $), F.__size = H, F.__cache = {}, this;
  }
  function U(F) {
    const k = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof F == "number" ? (k.boundary = 4, k.storage = 4) : F.isVector2 ? (k.boundary = 8, k.storage = 8) : F.isVector3 || F.isColor ? (k.boundary = 16, k.storage = 12) : F.isVector4 ? (k.boundary = 16, k.storage = 16) : F.isMatrix3 ? (k.boundary = 48, k.storage = 48) : F.isMatrix4 ? (k.boundary = 64, k.storage = 64) : F.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", F), k;
  }
  function L(F) {
    const k = F.target;
    k.removeEventListener("dispose", L);
    const H = l.indexOf(k.__bindingPointIndex);
    l.splice(H, 1), n.deleteBuffer(i[k.id]), delete i[k.id], delete o[k.id];
  }
  function A() {
    for (const F in i)
      n.deleteBuffer(i[F]);
    l = [], i = {}, o = {};
  }
  return {
    bind: h,
    update: p,
    dispose: A
  };
}
class NP {
  constructor(e = {}) {
    const {
      canvas: t = S4(),
      context: r = null,
      depth: i = !0,
      stencil: o = !0,
      alpha: l = !1,
      antialias: c = !1,
      premultipliedAlpha: h = !0,
      preserveDrawingBuffer: p = !1,
      powerPreference: y = "default",
      failIfMajorPerformanceCaveat: x = !1
    } = e;
    this.isWebGLRenderer = !0;
    let b;
    r !== null ? b = r.getContextAttributes().alpha : b = l;
    const w = new Uint32Array(4), R = new Int32Array(4);
    let U = null, L = null;
    const A = [], F = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = go, this._useLegacyLights = !1, this.toneMapping = Ev, this.toneMappingExposure = 1;
    const k = this;
    let H = !1, B = 0, $ = 0, Y = null, J = -1, K = null;
    const X = new ua(), le = new ua();
    let oe = null;
    const fe = new Rn(0);
    let de = 0, xe = t.width, _e = t.height, Pe = 1, ce = null, ve = null;
    const re = new ua(0, 0, xe, _e), ee = new ua(0, 0, xe, _e);
    let he = !1;
    const Me = new QR();
    let Le = !1, Ae = !1, Ue = null;
    const Ne = new Gr(), ke = new Ht(), it = new Te(), At = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function rt() {
      return Y === null ? Pe : 1;
    }
    let ae = r;
    function et(ye, qe) {
      for (let tt = 0; tt < ye.length; tt++) {
        const Ve = ye[tt], pt = t.getContext(Ve, qe);
        if (pt !== null)
          return pt;
      }
      return null;
    }
    try {
      const ye = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: c,
        premultipliedAlpha: h,
        preserveDrawingBuffer: p,
        powerPreference: y,
        failIfMajorPerformanceCaveat: x
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${jR}`), t.addEventListener("webglcontextlost", Rt, !1), t.addEventListener("webglcontextrestored", Be, !1), t.addEventListener("webglcontextcreationerror", ut, !1), ae === null) {
        const qe = ["webgl2", "webgl", "experimental-webgl"];
        if (k.isWebGL1Renderer === !0 && qe.shift(), ae = et(qe, ye), ae === null)
          throw et(qe) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && ae instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), ae.getShaderPrecisionFormat === void 0 && (ae.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ye) {
      throw console.error("THREE.WebGLRenderer: " + ye.message), ye;
    }
    let Ye, Ge, $e, Ut, nt, Ct, Pt, vt, Zt, ie, ne, Oe, _t, ot, at, Wt, Dt, Se, He, lt, St, Je, be, Ze;
    function ct() {
      Ye = new ij(ae), Ge = new Z7(ae, Ye, e), Ye.init(Ge), Je = new D4(ae, Ye, Ge), $e = new k$(ae, Ye, Ge), Ut = new sj(ae), nt = new w$(), Ct = new z$(ae, Ye, $e, nt, Ge, Je, Ut), Pt = new ej(k), vt = new rj(k), Zt = new gW(ae, Ge), be = new K7(ae, Ye, Zt, Ge), ie = new aj(ae, Zt, Ut, be), ne = new fj(ae, ie, Zt, Ut), He = new cj(ae, Ge, Ct), Wt = new J7(nt), Oe = new T$(k, Pt, vt, Ye, Ge, be, Wt), _t = new V$(k, nt), ot = new C$(), at = new P$(Ye, Ge), Se = new q7(k, Pt, vt, $e, ne, b, h), Dt = new F$(k, ne, Ge), Ze = new G$(ae, Ut, Ge, $e), lt = new Q7(ae, Ye, Ut, Ge), St = new oj(ae, Ye, Ut, Ge), Ut.programs = Oe.programs, k.capabilities = Ge, k.extensions = Ye, k.properties = nt, k.renderLists = ot, k.shadowMap = Dt, k.state = $e, k.info = Ut;
    }
    ct();
    const pe = new H$(k, ae);
    this.xr = pe, this.getContext = function() {
      return ae;
    }, this.getContextAttributes = function() {
      return ae.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ye = Ye.get("WEBGL_lose_context");
      ye && ye.loseContext();
    }, this.forceContextRestore = function() {
      const ye = Ye.get("WEBGL_lose_context");
      ye && ye.restoreContext();
    }, this.getPixelRatio = function() {
      return Pe;
    }, this.setPixelRatio = function(ye) {
      ye !== void 0 && (Pe = ye, this.setSize(xe, _e, !1));
    }, this.getSize = function(ye) {
      return ye.set(xe, _e);
    }, this.setSize = function(ye, qe, tt = !0) {
      if (pe.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      xe = ye, _e = qe, t.width = Math.floor(ye * Pe), t.height = Math.floor(qe * Pe), tt === !0 && (t.style.width = ye + "px", t.style.height = qe + "px"), this.setViewport(0, 0, ye, qe);
    }, this.getDrawingBufferSize = function(ye) {
      return ye.set(xe * Pe, _e * Pe).floor();
    }, this.setDrawingBufferSize = function(ye, qe, tt) {
      xe = ye, _e = qe, Pe = tt, t.width = Math.floor(ye * tt), t.height = Math.floor(qe * tt), this.setViewport(0, 0, ye, qe);
    }, this.getCurrentViewport = function(ye) {
      return ye.copy(X);
    }, this.getViewport = function(ye) {
      return ye.copy(re);
    }, this.setViewport = function(ye, qe, tt, Ve) {
      ye.isVector4 ? re.set(ye.x, ye.y, ye.z, ye.w) : re.set(ye, qe, tt, Ve), $e.viewport(X.copy(re).multiplyScalar(Pe).floor());
    }, this.getScissor = function(ye) {
      return ye.copy(ee);
    }, this.setScissor = function(ye, qe, tt, Ve) {
      ye.isVector4 ? ee.set(ye.x, ye.y, ye.z, ye.w) : ee.set(ye, qe, tt, Ve), $e.scissor(le.copy(ee).multiplyScalar(Pe).floor());
    }, this.getScissorTest = function() {
      return he;
    }, this.setScissorTest = function(ye) {
      $e.setScissorTest(he = ye);
    }, this.setOpaqueSort = function(ye) {
      ce = ye;
    }, this.setTransparentSort = function(ye) {
      ve = ye;
    }, this.getClearColor = function(ye) {
      return ye.copy(Se.getClearColor());
    }, this.setClearColor = function() {
      Se.setClearColor.apply(Se, arguments);
    }, this.getClearAlpha = function() {
      return Se.getClearAlpha();
    }, this.setClearAlpha = function() {
      Se.setClearAlpha.apply(Se, arguments);
    }, this.clear = function(ye = !0, qe = !0, tt = !0) {
      let Ve = 0;
      if (ye) {
        let pt = !1;
        if (Y !== null) {
          const en = Y.texture.format;
          pt = en === TP || en === bP || en === EP;
        }
        if (pt) {
          const en = Y.texture.type, cn = en === bv || en === Hg || en === XR || en === m0 || en === xP || en === _P, xn = Se.getClearColor(), Nn = Se.getClearAlpha(), lr = xn.r, bt = xn.g, ar = xn.b;
          cn ? (w[0] = lr, w[1] = bt, w[2] = ar, w[3] = Nn, ae.clearBufferuiv(ae.COLOR, 0, w)) : (R[0] = lr, R[1] = bt, R[2] = ar, R[3] = Nn, ae.clearBufferiv(ae.COLOR, 0, R));
        } else
          Ve |= ae.COLOR_BUFFER_BIT;
      }
      qe && (Ve |= ae.DEPTH_BUFFER_BIT), tt && (Ve |= ae.STENCIL_BUFFER_BIT), ae.clear(Ve);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Rt, !1), t.removeEventListener("webglcontextrestored", Be, !1), t.removeEventListener("webglcontextcreationerror", ut, !1), ot.dispose(), at.dispose(), nt.dispose(), Pt.dispose(), vt.dispose(), ne.dispose(), be.dispose(), Ze.dispose(), Oe.dispose(), pe.dispose(), pe.removeEventListener("sessionstart", er), pe.removeEventListener("sessionend", ir), Ue && (Ue.dispose(), Ue = null), Wn.stop();
    };
    function Rt(ye) {
      ye.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), H = !0;
    }
    function Be() {
      console.log("THREE.WebGLRenderer: Context Restored."), H = !1;
      const ye = Ut.autoReset, qe = Dt.enabled, tt = Dt.autoUpdate, Ve = Dt.needsUpdate, pt = Dt.type;
      ct(), Ut.autoReset = ye, Dt.enabled = qe, Dt.autoUpdate = tt, Dt.needsUpdate = Ve, Dt.type = pt;
    }
    function ut(ye) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ye.statusMessage);
    }
    function on(ye) {
      const qe = ye.target;
      qe.removeEventListener("dispose", on), zn(qe);
    }
    function zn(ye) {
      Gn(ye), nt.remove(ye);
    }
    function Gn(ye) {
      const qe = nt.get(ye).programs;
      qe !== void 0 && (qe.forEach(function(tt) {
        Oe.releaseProgram(tt);
      }), ye.isShaderMaterial && Oe.releaseShaderCache(ye));
    }
    this.renderBufferDirect = function(ye, qe, tt, Ve, pt, en) {
      qe === null && (qe = At);
      const cn = pt.isMesh && pt.matrixWorld.determinant() < 0, xn = Ft(ye, qe, tt, Ve, pt);
      $e.setMaterial(Ve, cn);
      let Nn = tt.index, lr = 1;
      if (Ve.wireframe === !0) {
        if (Nn = ie.getWireframeAttribute(tt), Nn === void 0)
          return;
        lr = 2;
      }
      const bt = tt.drawRange, ar = tt.attributes.position;
      let Hr = bt.start * lr, Tn = (bt.start + bt.count) * lr;
      en !== null && (Hr = Math.max(Hr, en.start * lr), Tn = Math.min(Tn, (en.start + en.count) * lr)), Nn !== null ? (Hr = Math.max(Hr, 0), Tn = Math.min(Tn, Nn.count)) : ar != null && (Hr = Math.max(Hr, 0), Tn = Math.min(Tn, ar.count));
      const Ji = Tn - Hr;
      if (Ji < 0 || Ji === 1 / 0)
        return;
      be.setup(pt, Ve, xn, tt, Nn);
      let Do, li = lt;
      if (Nn !== null && (Do = Zt.get(Nn), li = St, li.setIndex(Do)), pt.isMesh)
        Ve.wireframe === !0 ? ($e.setLineWidth(Ve.wireframeLinewidth * rt()), li.setMode(ae.LINES)) : li.setMode(ae.TRIANGLES);
      else if (pt.isLine) {
        let $n = Ve.linewidth;
        $n === void 0 && ($n = 1), $e.setLineWidth($n * rt()), pt.isLineSegments ? li.setMode(ae.LINES) : pt.isLineLoop ? li.setMode(ae.LINE_LOOP) : li.setMode(ae.LINE_STRIP);
      } else
        pt.isPoints ? li.setMode(ae.POINTS) : pt.isSprite && li.setMode(ae.TRIANGLES);
      if (pt.isInstancedMesh)
        li.renderInstances(Hr, Ji, pt.count);
      else if (tt.isInstancedBufferGeometry) {
        const $n = tt._maxInstanceCount !== void 0 ? tt._maxInstanceCount : 1 / 0, _r = Math.min(tt.instanceCount, $n);
        li.renderInstances(Hr, Ji, _r);
      } else
        li.render(Hr, Ji);
    }, this.compile = function(ye, qe) {
      function tt(Ve, pt, en) {
        Ve.transparent === !0 && Ve.side === dp && Ve.forceSinglePass === !1 ? (Ve.side = Ic, Ve.needsUpdate = !0, si(Ve, pt, en), Ve.side = wv, Ve.needsUpdate = !0, si(Ve, pt, en), Ve.side = dp) : si(Ve, pt, en);
      }
      L = at.get(ye), L.init(), F.push(L), ye.traverseVisible(function(Ve) {
        Ve.isLight && Ve.layers.test(qe.layers) && (L.pushLight(Ve), Ve.castShadow && L.pushShadow(Ve));
      }), L.setupLights(k._useLegacyLights), ye.traverse(function(Ve) {
        const pt = Ve.material;
        if (pt)
          if (Array.isArray(pt))
            for (let en = 0; en < pt.length; en++) {
              const cn = pt[en];
              tt(cn, ye, Ve);
            }
          else
            tt(pt, ye, Ve);
      }), F.pop(), L = null;
    };
    let rr = null;
    function mn(ye) {
      rr && rr(ye);
    }
    function er() {
      Wn.stop();
    }
    function ir() {
      Wn.start();
    }
    const Wn = new w4();
    Wn.setAnimationLoop(mn), typeof self < "u" && Wn.setContext(self), this.setAnimationLoop = function(ye) {
      rr = ye, pe.setAnimationLoop(ye), ye === null ? Wn.stop() : Wn.start();
    }, pe.addEventListener("sessionstart", er), pe.addEventListener("sessionend", ir), this.render = function(ye, qe) {
      if (qe !== void 0 && qe.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (H === !0)
        return;
      ye.matrixWorldAutoUpdate === !0 && ye.updateMatrixWorld(), qe.parent === null && qe.matrixWorldAutoUpdate === !0 && qe.updateMatrixWorld(), pe.enabled === !0 && pe.isPresenting === !0 && (pe.cameraAutoUpdate === !0 && pe.updateCamera(qe), qe = pe.getCamera()), ye.isScene === !0 && ye.onBeforeRender(k, ye, qe, Y), L = at.get(ye, F.length), L.init(), F.push(L), Ne.multiplyMatrices(qe.projectionMatrix, qe.matrixWorldInverse), Me.setFromProjectionMatrix(Ne), Ae = this.localClippingEnabled, Le = Wt.init(this.clippingPlanes, Ae), U = ot.get(ye, A.length), U.init(), A.push(U), Ei(ye, qe, 0, k.sortObjects), U.finish(), k.sortObjects === !0 && U.sort(ce, ve), this.info.render.frame++, Le === !0 && Wt.beginShadows();
      const tt = L.state.shadowsArray;
      if (Dt.render(tt, ye, qe), Le === !0 && Wt.endShadows(), this.info.autoReset === !0 && this.info.reset(), Se.render(U, ye), L.setupLights(k._useLegacyLights), qe.isArrayCamera) {
        const Ve = qe.cameras;
        for (let pt = 0, en = Ve.length; pt < en; pt++) {
          const cn = Ve[pt];
          Wr(U, ye, cn, cn.viewport);
        }
      } else
        Wr(U, ye, qe);
      Y !== null && (Ct.updateMultisampleRenderTarget(Y), Ct.updateRenderTargetMipmap(Y)), ye.isScene === !0 && ye.onAfterRender(k, ye, qe), be.resetDefaultState(), J = -1, K = null, F.pop(), F.length > 0 ? L = F[F.length - 1] : L = null, A.pop(), A.length > 0 ? U = A[A.length - 1] : U = null;
    };
    function Ei(ye, qe, tt, Ve) {
      if (ye.visible === !1)
        return;
      if (ye.layers.test(qe.layers)) {
        if (ye.isGroup)
          tt = ye.renderOrder;
        else if (ye.isLOD)
          ye.autoUpdate === !0 && ye.update(qe);
        else if (ye.isLight)
          L.pushLight(ye), ye.castShadow && L.pushShadow(ye);
        else if (ye.isSprite) {
          if (!ye.frustumCulled || Me.intersectsSprite(ye)) {
            Ve && it.setFromMatrixPosition(ye.matrixWorld).applyMatrix4(Ne);
            const cn = ne.update(ye), xn = ye.material;
            xn.visible && U.push(ye, cn, xn, tt, it.z, null);
          }
        } else if ((ye.isMesh || ye.isLine || ye.isPoints) && (!ye.frustumCulled || Me.intersectsObject(ye))) {
          const cn = ne.update(ye), xn = ye.material;
          if (Ve && (ye.boundingSphere !== void 0 ? (ye.boundingSphere === null && ye.computeBoundingSphere(), it.copy(ye.boundingSphere.center)) : (cn.boundingSphere === null && cn.computeBoundingSphere(), it.copy(cn.boundingSphere.center)), it.applyMatrix4(ye.matrixWorld).applyMatrix4(Ne)), Array.isArray(xn)) {
            const Nn = cn.groups;
            for (let lr = 0, bt = Nn.length; lr < bt; lr++) {
              const ar = Nn[lr], Hr = xn[ar.materialIndex];
              Hr && Hr.visible && U.push(ye, cn, Hr, tt, it.z, ar);
            }
          } else
            xn.visible && U.push(ye, cn, xn, tt, it.z, null);
        }
      }
      const en = ye.children;
      for (let cn = 0, xn = en.length; cn < xn; cn++)
        Ei(en[cn], qe, tt, Ve);
    }
    function Wr(ye, qe, tt, Ve) {
      const pt = ye.opaque, en = ye.transmissive, cn = ye.transparent;
      L.setupLightsView(tt), Le === !0 && Wt.setGlobalState(k.clippingPlanes, tt), en.length > 0 && Br(pt, en, qe, tt), Ve && $e.viewport(X.copy(Ve)), pt.length > 0 && Mr(pt, qe, tt), en.length > 0 && Mr(en, qe, tt), cn.length > 0 && Mr(cn, qe, tt), $e.buffers.depth.setTest(!0), $e.buffers.depth.setMask(!0), $e.buffers.color.setMask(!0), $e.setPolygonOffset(!1);
    }
    function Br(ye, qe, tt, Ve) {
      const pt = Ge.isWebGL2;
      Ue === null && (Ue = new hm(1, 1, {
        generateMipmaps: !0,
        type: Ye.has("EXT_color_buffer_half_float") ? X1 : bv,
        minFilter: x0,
        samples: pt ? 4 : 0
      })), k.getDrawingBufferSize(ke), pt ? Ue.setSize(ke.x, ke.y) : Ue.setSize(MR(ke.x), MR(ke.y));
      const en = k.getRenderTarget();
      k.setRenderTarget(Ue), k.getClearColor(fe), de = k.getClearAlpha(), de < 1 && k.setClearColor(16777215, 0.5), k.clear();
      const cn = k.toneMapping;
      k.toneMapping = Ev, Mr(ye, tt, Ve), Ct.updateMultisampleRenderTarget(Ue), Ct.updateRenderTargetMipmap(Ue);
      let xn = !1;
      for (let Nn = 0, lr = qe.length; Nn < lr; Nn++) {
        const bt = qe[Nn], ar = bt.object, Hr = bt.geometry, Tn = bt.material, Ji = bt.group;
        if (Tn.side === dp && ar.layers.test(Ve.layers)) {
          const Do = Tn.side;
          Tn.side = Ic, Tn.needsUpdate = !0, Ri(ar, tt, Ve, Hr, Tn, Ji), Tn.side = Do, Tn.needsUpdate = !0, xn = !0;
        }
      }
      xn === !0 && (Ct.updateMultisampleRenderTarget(Ue), Ct.updateRenderTargetMipmap(Ue)), k.setRenderTarget(en), k.setClearColor(fe, de), k.toneMapping = cn;
    }
    function Mr(ye, qe, tt) {
      const Ve = qe.isScene === !0 ? qe.overrideMaterial : null;
      for (let pt = 0, en = ye.length; pt < en; pt++) {
        const cn = ye[pt], xn = cn.object, Nn = cn.geometry, lr = Ve === null ? cn.material : Ve, bt = cn.group;
        xn.layers.test(tt.layers) && Ri(xn, qe, tt, Nn, lr, bt);
      }
    }
    function Ri(ye, qe, tt, Ve, pt, en) {
      ye.onBeforeRender(k, qe, tt, Ve, pt, en), ye.modelViewMatrix.multiplyMatrices(tt.matrixWorldInverse, ye.matrixWorld), ye.normalMatrix.getNormalMatrix(ye.modelViewMatrix), pt.onBeforeRender(k, qe, tt, Ve, ye, en), pt.transparent === !0 && pt.side === dp && pt.forceSinglePass === !1 ? (pt.side = Ic, pt.needsUpdate = !0, k.renderBufferDirect(tt, qe, Ve, pt, ye, en), pt.side = wv, pt.needsUpdate = !0, k.renderBufferDirect(tt, qe, Ve, pt, ye, en), pt.side = dp) : k.renderBufferDirect(tt, qe, Ve, pt, ye, en), ye.onAfterRender(k, qe, tt, Ve, pt, en);
    }
    function si(ye, qe, tt) {
      qe.isScene !== !0 && (qe = At);
      const Ve = nt.get(ye), pt = L.state.lights, en = L.state.shadowsArray, cn = pt.state.version, xn = Oe.getParameters(ye, pt.state, en, qe, tt), Nn = Oe.getProgramCacheKey(xn);
      let lr = Ve.programs;
      Ve.environment = ye.isMeshStandardMaterial ? qe.environment : null, Ve.fog = qe.fog, Ve.envMap = (ye.isMeshStandardMaterial ? vt : Pt).get(ye.envMap || Ve.environment), lr === void 0 && (ye.addEventListener("dispose", on), lr = /* @__PURE__ */ new Map(), Ve.programs = lr);
      let bt = lr.get(Nn);
      if (bt !== void 0) {
        if (Ve.currentProgram === bt && Ve.lightsStateVersion === cn)
          return De(ye, xn), bt;
      } else
        xn.uniforms = Oe.getUniforms(ye), ye.onBuild(tt, xn, k), ye.onBeforeCompile(xn, k), bt = Oe.acquireProgram(xn, Nn), lr.set(Nn, bt), Ve.uniforms = xn.uniforms;
      const ar = Ve.uniforms;
      (!ye.isShaderMaterial && !ye.isRawShaderMaterial || ye.clipping === !0) && (ar.clippingPlanes = Wt.uniform), De(ye, xn), Ve.needsLights = En(ye), Ve.lightsStateVersion = cn, Ve.needsLights && (ar.ambientLightColor.value = pt.state.ambient, ar.lightProbe.value = pt.state.probe, ar.directionalLights.value = pt.state.directional, ar.directionalLightShadows.value = pt.state.directionalShadow, ar.spotLights.value = pt.state.spot, ar.spotLightShadows.value = pt.state.spotShadow, ar.rectAreaLights.value = pt.state.rectArea, ar.ltc_1.value = pt.state.rectAreaLTC1, ar.ltc_2.value = pt.state.rectAreaLTC2, ar.pointLights.value = pt.state.point, ar.pointLightShadows.value = pt.state.pointShadow, ar.hemisphereLights.value = pt.state.hemi, ar.directionalShadowMap.value = pt.state.directionalShadowMap, ar.directionalShadowMatrix.value = pt.state.directionalShadowMatrix, ar.spotShadowMap.value = pt.state.spotShadowMap, ar.spotLightMatrix.value = pt.state.spotLightMatrix, ar.spotLightMap.value = pt.state.spotLightMap, ar.pointShadowMap.value = pt.state.pointShadowMap, ar.pointShadowMatrix.value = pt.state.pointShadowMatrix);
      const Hr = bt.getUniforms(), Tn = gR.seqWithValue(Hr.seq, ar);
      return Ve.currentProgram = bt, Ve.uniformsList = Tn, bt;
    }
    function De(ye, qe) {
      const tt = nt.get(ye);
      tt.outputColorSpace = qe.outputColorSpace, tt.instancing = qe.instancing, tt.instancingColor = qe.instancingColor, tt.skinning = qe.skinning, tt.morphTargets = qe.morphTargets, tt.morphNormals = qe.morphNormals, tt.morphColors = qe.morphColors, tt.morphTargetsCount = qe.morphTargetsCount, tt.numClippingPlanes = qe.numClippingPlanes, tt.numIntersection = qe.numClipIntersection, tt.vertexAlphas = qe.vertexAlphas, tt.vertexTangents = qe.vertexTangents, tt.toneMapping = qe.toneMapping;
    }
    function Ft(ye, qe, tt, Ve, pt) {
      qe.isScene !== !0 && (qe = At), Ct.resetTextureUnits();
      const en = qe.fog, cn = Ve.isMeshStandardMaterial ? qe.environment : null, xn = Y === null ? k.outputColorSpace : Y.isXRRenderTarget === !0 ? Y.texture.colorSpace : dm, Nn = (Ve.isMeshStandardMaterial ? vt : Pt).get(Ve.envMap || cn), lr = Ve.vertexColors === !0 && !!tt.attributes.color && tt.attributes.color.itemSize === 4, bt = !!tt.attributes.tangent && (!!Ve.normalMap || Ve.anisotropy > 0), ar = !!tt.morphAttributes.position, Hr = !!tt.morphAttributes.normal, Tn = !!tt.morphAttributes.color;
      let Ji = Ev;
      Ve.toneMapped && (Y === null || Y.isXRRenderTarget === !0) && (Ji = k.toneMapping);
      const Do = tt.morphAttributes.position || tt.morphAttributes.normal || tt.morphAttributes.color, li = Do !== void 0 ? Do.length : 0, $n = nt.get(Ve), _r = L.state.lights;
      if (Le === !0 && (Ae === !0 || ye !== K)) {
        const Ai = ye === K && Ve.id === J;
        Wt.setState(Ve, ye, Ai);
      }
      let ur = !1;
      Ve.version === $n.__version ? ($n.needsLights && $n.lightsStateVersion !== _r.state.version || $n.outputColorSpace !== xn || pt.isInstancedMesh && $n.instancing === !1 || !pt.isInstancedMesh && $n.instancing === !0 || pt.isSkinnedMesh && $n.skinning === !1 || !pt.isSkinnedMesh && $n.skinning === !0 || pt.isInstancedMesh && $n.instancingColor === !0 && pt.instanceColor === null || pt.isInstancedMesh && $n.instancingColor === !1 && pt.instanceColor !== null || $n.envMap !== Nn || Ve.fog === !0 && $n.fog !== en || $n.numClippingPlanes !== void 0 && ($n.numClippingPlanes !== Wt.numPlanes || $n.numIntersection !== Wt.numIntersection) || $n.vertexAlphas !== lr || $n.vertexTangents !== bt || $n.morphTargets !== ar || $n.morphNormals !== Hr || $n.morphColors !== Tn || $n.toneMapping !== Ji || Ge.isWebGL2 === !0 && $n.morphTargetsCount !== li) && (ur = !0) : (ur = !0, $n.__version = Ve.version);
      let di = $n.currentProgram;
      ur === !0 && (di = si(Ve, qe, pt));
      let xa = !1, Xr = !1, ds = !1;
      const bi = di.getUniforms(), Ti = $n.uniforms;
      if ($e.useProgram(di.program) && (xa = !0, Xr = !0, ds = !0), Ve.id !== J && (J = Ve.id, Xr = !0), xa || K !== ye) {
        bi.setValue(ae, "projectionMatrix", ye.projectionMatrix), bi.setValue(ae, "viewMatrix", ye.matrixWorldInverse);
        const Ai = bi.map.cameraPosition;
        Ai !== void 0 && Ai.setValue(ae, it.setFromMatrixPosition(ye.matrixWorld)), Ge.logarithmicDepthBuffer && bi.setValue(
          ae,
          "logDepthBufFC",
          2 / (Math.log(ye.far + 1) / Math.LN2)
        ), (Ve.isMeshPhongMaterial || Ve.isMeshToonMaterial || Ve.isMeshLambertMaterial || Ve.isMeshBasicMaterial || Ve.isMeshStandardMaterial || Ve.isShaderMaterial) && bi.setValue(ae, "isOrthographic", ye.isOrthographicCamera === !0), K !== ye && (K = ye, Xr = !0, ds = !0);
      }
      if (pt.isSkinnedMesh) {
        bi.setOptional(ae, pt, "bindMatrix"), bi.setOptional(ae, pt, "bindMatrixInverse");
        const Ai = pt.skeleton;
        Ai && (Ge.floatVertexTextures ? (Ai.boneTexture === null && Ai.computeBoneTexture(), bi.setValue(ae, "boneTexture", Ai.boneTexture, Ct), bi.setValue(ae, "boneTextureSize", Ai.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const Xa = tt.morphAttributes;
      if ((Xa.position !== void 0 || Xa.normal !== void 0 || Xa.color !== void 0 && Ge.isWebGL2 === !0) && He.update(pt, tt, di), (Xr || $n.receiveShadow !== pt.receiveShadow) && ($n.receiveShadow = pt.receiveShadow, bi.setValue(ae, "receiveShadow", pt.receiveShadow)), Ve.isMeshGouraudMaterial && Ve.envMap !== null && (Ti.envMap.value = Nn, Ti.flipEnvMap.value = Nn.isCubeTexture && Nn.isRenderTargetTexture === !1 ? -1 : 1), Xr && (bi.setValue(ae, "toneMappingExposure", k.toneMappingExposure), $n.needsLights && qt(Ti, ds), en && Ve.fog === !0 && _t.refreshFogUniforms(Ti, en), _t.refreshMaterialUniforms(Ti, Ve, Pe, _e, Ue), gR.upload(ae, $n.uniformsList, Ti, Ct)), Ve.isShaderMaterial && Ve.uniformsNeedUpdate === !0 && (gR.upload(ae, $n.uniformsList, Ti, Ct), Ve.uniformsNeedUpdate = !1), Ve.isSpriteMaterial && bi.setValue(ae, "center", pt.center), bi.setValue(ae, "modelViewMatrix", pt.modelViewMatrix), bi.setValue(ae, "normalMatrix", pt.normalMatrix), bi.setValue(ae, "modelMatrix", pt.matrixWorld), Ve.isShaderMaterial || Ve.isRawShaderMaterial) {
        const Ai = Ve.uniformsGroups;
        for (let ru = 0, Ns = Ai.length; ru < Ns; ru++)
          if (Ge.isWebGL2) {
            const yo = Ai[ru];
            Ze.update(yo, di), Ze.bind(yo, di);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return di;
    }
    function qt(ye, qe) {
      ye.ambientLightColor.needsUpdate = qe, ye.lightProbe.needsUpdate = qe, ye.directionalLights.needsUpdate = qe, ye.directionalLightShadows.needsUpdate = qe, ye.pointLights.needsUpdate = qe, ye.pointLightShadows.needsUpdate = qe, ye.spotLights.needsUpdate = qe, ye.spotLightShadows.needsUpdate = qe, ye.rectAreaLights.needsUpdate = qe, ye.hemisphereLights.needsUpdate = qe;
    }
    function En(ye) {
      return ye.isMeshLambertMaterial || ye.isMeshToonMaterial || ye.isMeshPhongMaterial || ye.isMeshStandardMaterial || ye.isShadowMaterial || ye.isShaderMaterial && ye.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return B;
    }, this.getActiveMipmapLevel = function() {
      return $;
    }, this.getRenderTarget = function() {
      return Y;
    }, this.setRenderTargetTextures = function(ye, qe, tt) {
      nt.get(ye.texture).__webglTexture = qe, nt.get(ye.depthTexture).__webglTexture = tt;
      const Ve = nt.get(ye);
      Ve.__hasExternalTextures = !0, Ve.__hasExternalTextures && (Ve.__autoAllocateDepthBuffer = tt === void 0, Ve.__autoAllocateDepthBuffer || Ye.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ve.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(ye, qe) {
      const tt = nt.get(ye);
      tt.__webglFramebuffer = qe, tt.__useDefaultFramebuffer = qe === void 0;
    }, this.setRenderTarget = function(ye, qe = 0, tt = 0) {
      Y = ye, B = qe, $ = tt;
      let Ve = !0, pt = null, en = !1, cn = !1;
      if (ye) {
        const Nn = nt.get(ye);
        Nn.__useDefaultFramebuffer !== void 0 ? ($e.bindFramebuffer(ae.FRAMEBUFFER, null), Ve = !1) : Nn.__webglFramebuffer === void 0 ? Ct.setupRenderTarget(ye) : Nn.__hasExternalTextures && Ct.rebindTextures(ye, nt.get(ye.texture).__webglTexture, nt.get(ye.depthTexture).__webglTexture);
        const lr = ye.texture;
        (lr.isData3DTexture || lr.isDataArrayTexture || lr.isCompressedArrayTexture) && (cn = !0);
        const bt = nt.get(ye).__webglFramebuffer;
        ye.isWebGLCubeRenderTarget ? (Array.isArray(bt[qe]) ? pt = bt[qe][tt] : pt = bt[qe], en = !0) : Ge.isWebGL2 && ye.samples > 0 && Ct.useMultisampledRTT(ye) === !1 ? pt = nt.get(ye).__webglMultisampledFramebuffer : Array.isArray(bt) ? pt = bt[tt] : pt = bt, X.copy(ye.viewport), le.copy(ye.scissor), oe = ye.scissorTest;
      } else
        X.copy(re).multiplyScalar(Pe).floor(), le.copy(ee).multiplyScalar(Pe).floor(), oe = he;
      if ($e.bindFramebuffer(ae.FRAMEBUFFER, pt) && Ge.drawBuffers && Ve && $e.drawBuffers(ye, pt), $e.viewport(X), $e.scissor(le), $e.setScissorTest(oe), en) {
        const Nn = nt.get(ye.texture);
        ae.framebufferTexture2D(ae.FRAMEBUFFER, ae.COLOR_ATTACHMENT0, ae.TEXTURE_CUBE_MAP_POSITIVE_X + qe, Nn.__webglTexture, tt);
      } else if (cn) {
        const Nn = nt.get(ye.texture), lr = qe || 0;
        ae.framebufferTextureLayer(ae.FRAMEBUFFER, ae.COLOR_ATTACHMENT0, Nn.__webglTexture, tt || 0, lr);
      }
      J = -1;
    }, this.readRenderTargetPixels = function(ye, qe, tt, Ve, pt, en, cn) {
      if (!(ye && ye.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let xn = nt.get(ye).__webglFramebuffer;
      if (ye.isWebGLCubeRenderTarget && cn !== void 0 && (xn = xn[cn]), xn) {
        $e.bindFramebuffer(ae.FRAMEBUFFER, xn);
        try {
          const Nn = ye.texture, lr = Nn.format, bt = Nn.type;
          if (lr !== Td && Je.convert(lr) !== ae.getParameter(ae.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const ar = bt === X1 && (Ye.has("EXT_color_buffer_half_float") || Ge.isWebGL2 && Ye.has("EXT_color_buffer_float"));
          if (bt !== bv && Je.convert(bt) !== ae.getParameter(ae.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(bt === xv && (Ge.isWebGL2 || Ye.has("OES_texture_float") || Ye.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !ar) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          qe >= 0 && qe <= ye.width - Ve && tt >= 0 && tt <= ye.height - pt && ae.readPixels(qe, tt, Ve, pt, Je.convert(lr), Je.convert(bt), en);
        } finally {
          const Nn = Y !== null ? nt.get(Y).__webglFramebuffer : null;
          $e.bindFramebuffer(ae.FRAMEBUFFER, Nn);
        }
      }
    }, this.copyFramebufferToTexture = function(ye, qe, tt = 0) {
      const Ve = Math.pow(2, -tt), pt = Math.floor(qe.image.width * Ve), en = Math.floor(qe.image.height * Ve);
      Ct.setTexture2D(qe, 0), ae.copyTexSubImage2D(ae.TEXTURE_2D, tt, 0, 0, ye.x, ye.y, pt, en), $e.unbindTexture();
    }, this.copyTextureToTexture = function(ye, qe, tt, Ve = 0) {
      const pt = qe.image.width, en = qe.image.height, cn = Je.convert(tt.format), xn = Je.convert(tt.type);
      Ct.setTexture2D(tt, 0), ae.pixelStorei(ae.UNPACK_FLIP_Y_WEBGL, tt.flipY), ae.pixelStorei(ae.UNPACK_PREMULTIPLY_ALPHA_WEBGL, tt.premultiplyAlpha), ae.pixelStorei(ae.UNPACK_ALIGNMENT, tt.unpackAlignment), qe.isDataTexture ? ae.texSubImage2D(ae.TEXTURE_2D, Ve, ye.x, ye.y, pt, en, cn, xn, qe.image.data) : qe.isCompressedTexture ? ae.compressedTexSubImage2D(ae.TEXTURE_2D, Ve, ye.x, ye.y, qe.mipmaps[0].width, qe.mipmaps[0].height, cn, qe.mipmaps[0].data) : ae.texSubImage2D(ae.TEXTURE_2D, Ve, ye.x, ye.y, cn, xn, qe.image), Ve === 0 && tt.generateMipmaps && ae.generateMipmap(ae.TEXTURE_2D), $e.unbindTexture();
    }, this.copyTextureToTexture3D = function(ye, qe, tt, Ve, pt = 0) {
      if (k.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const en = ye.max.x - ye.min.x + 1, cn = ye.max.y - ye.min.y + 1, xn = ye.max.z - ye.min.z + 1, Nn = Je.convert(Ve.format), lr = Je.convert(Ve.type);
      let bt;
      if (Ve.isData3DTexture)
        Ct.setTexture3D(Ve, 0), bt = ae.TEXTURE_3D;
      else if (Ve.isDataArrayTexture)
        Ct.setTexture2DArray(Ve, 0), bt = ae.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      ae.pixelStorei(ae.UNPACK_FLIP_Y_WEBGL, Ve.flipY), ae.pixelStorei(ae.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ve.premultiplyAlpha), ae.pixelStorei(ae.UNPACK_ALIGNMENT, Ve.unpackAlignment);
      const ar = ae.getParameter(ae.UNPACK_ROW_LENGTH), Hr = ae.getParameter(ae.UNPACK_IMAGE_HEIGHT), Tn = ae.getParameter(ae.UNPACK_SKIP_PIXELS), Ji = ae.getParameter(ae.UNPACK_SKIP_ROWS), Do = ae.getParameter(ae.UNPACK_SKIP_IMAGES), li = tt.isCompressedTexture ? tt.mipmaps[0] : tt.image;
      ae.pixelStorei(ae.UNPACK_ROW_LENGTH, li.width), ae.pixelStorei(ae.UNPACK_IMAGE_HEIGHT, li.height), ae.pixelStorei(ae.UNPACK_SKIP_PIXELS, ye.min.x), ae.pixelStorei(ae.UNPACK_SKIP_ROWS, ye.min.y), ae.pixelStorei(ae.UNPACK_SKIP_IMAGES, ye.min.z), tt.isDataTexture || tt.isData3DTexture ? ae.texSubImage3D(bt, pt, qe.x, qe.y, qe.z, en, cn, xn, Nn, lr, li.data) : tt.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ae.compressedTexSubImage3D(bt, pt, qe.x, qe.y, qe.z, en, cn, xn, Nn, li.data)) : ae.texSubImage3D(bt, pt, qe.x, qe.y, qe.z, en, cn, xn, Nn, lr, li), ae.pixelStorei(ae.UNPACK_ROW_LENGTH, ar), ae.pixelStorei(ae.UNPACK_IMAGE_HEIGHT, Hr), ae.pixelStorei(ae.UNPACK_SKIP_PIXELS, Tn), ae.pixelStorei(ae.UNPACK_SKIP_ROWS, Ji), ae.pixelStorei(ae.UNPACK_SKIP_IMAGES, Do), pt === 0 && Ve.generateMipmaps && ae.generateMipmap(bt), $e.unbindTexture();
    }, this.initTexture = function(ye) {
      ye.isCubeTexture ? Ct.setTextureCube(ye, 0) : ye.isData3DTexture ? Ct.setTexture3D(ye, 0) : ye.isDataArrayTexture || ye.isCompressedArrayTexture ? Ct.setTexture2DArray(ye, 0) : Ct.setTexture2D(ye, 0), $e.unbindTexture();
    }, this.resetState = function() {
      B = 0, $ = 0, Y = null, $e.reset(), be.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return _v;
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === go ? g0 : MP;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === g0 ? go : dm;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class P4 extends NP {
}
P4.prototype.isWebGL1Renderer = !0;
class t2 {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Rn(e), this.density = t;
  }
  clone() {
    return new t2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class n2 {
  constructor(e, t = 1, r = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Rn(e), this.near = t, this.far = r;
  }
  clone() {
    return new n2(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class CR extends aa {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class r2 {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = HT, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = yh();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yh()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yh()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Lf = /* @__PURE__ */ new Te();
class yx {
  constructor(e, t, r, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Lf.fromBufferAttribute(this, t), Lf.applyMatrix4(e), this.setXYZ(t, Lf.x, Lf.y, Lf.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Lf.fromBufferAttribute(this, t), Lf.applyNormalMatrix(e), this.setXYZ(t, Lf.x, Lf.y, Lf.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Lf.fromBufferAttribute(this, t), Lf.transformDirection(e), this.setXYZ(t, Lf.x, Lf.y, Lf.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = ai(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = wd(t, this.array)), t;
  }
  setXY(e, t, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ai(t, this.array), r = ai(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = ai(t, this.array), r = ai(r, this.array), i = ai(i, this.array), o = ai(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return new io(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new yx(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class FP extends ic {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Rn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let E1;
const sT = /* @__PURE__ */ new Te(), b1 = /* @__PURE__ */ new Te(), T1 = /* @__PURE__ */ new Te(), w1 = /* @__PURE__ */ new Ht(), lT = /* @__PURE__ */ new Ht(), U4 = /* @__PURE__ */ new Gr(), RC = /* @__PURE__ */ new Te(), uT = /* @__PURE__ */ new Te(), AC = /* @__PURE__ */ new Te(), sF = /* @__PURE__ */ new Ht(), XD = /* @__PURE__ */ new Ht(), lF = /* @__PURE__ */ new Ht();
class N4 extends aa {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", E1 === void 0) {
      E1 = new oi();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), r = new r2(t, 5);
      E1.setIndex([0, 1, 2, 0, 2, 3]), E1.setAttribute("position", new yx(r, 3, 0, !1)), E1.setAttribute("uv", new yx(r, 2, 3, !1));
    }
    this.geometry = E1, this.material = e !== void 0 ? e : new FP(), this.center = new Ht(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), b1.setFromMatrixScale(this.matrixWorld), U4.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), T1.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && b1.multiplyScalar(-T1.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && (o = Math.cos(r), i = Math.sin(r));
    const l = this.center;
    DC(RC.set(-0.5, -0.5, 0), T1, l, b1, i, o), DC(uT.set(0.5, -0.5, 0), T1, l, b1, i, o), DC(AC.set(0.5, 0.5, 0), T1, l, b1, i, o), sF.set(0, 0), XD.set(1, 0), lF.set(1, 1);
    let c = e.ray.intersectTriangle(RC, uT, AC, !1, sT);
    if (c === null && (DC(uT.set(-0.5, 0.5, 0), T1, l, b1, i, o), XD.set(0, 1), c = e.ray.intersectTriangle(RC, AC, uT, !1, sT), c === null))
      return;
    const h = e.ray.origin.distanceTo(sT);
    h < e.near || h > e.far || t.push({
      distance: h,
      point: sT.clone(),
      uv: bd.getInterpolation(sT, RC, uT, AC, sF, XD, lF, new Ht()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function DC(n, e, t, r, i, o) {
  w1.subVectors(n, t).addScalar(0.5).multiply(r), i !== void 0 ? (lT.x = o * w1.x - i * w1.y, lT.y = i * w1.x + o * w1.y) : lT.copy(w1), n.copy(e), n.x += lT.x, n.y += lT.y, n.applyMatrix4(U4);
}
const LC = /* @__PURE__ */ new Te(), uF = /* @__PURE__ */ new Te();
class F4 extends aa {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++)
      ;
    return i.splice(o, 0, { distance: t, hysteresis: r, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let o = t[r].distance;
        if (t[r].object.visible && (o -= o * t[r].hysteresis), e < o)
          break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      LC.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(LC);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      LC.setFromMatrixPosition(e.matrixWorld), uF.setFromMatrixPosition(this.matrixWorld);
      const r = LC.distanceTo(uF) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let l = t[i].distance;
        if (t[i].object.visible && (l -= l * t[i].hysteresis), r >= l)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < o; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const l = r[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance,
        hysteresis: l.hysteresis
      });
    }
    return t;
  }
}
const cF = /* @__PURE__ */ new Te(), fF = /* @__PURE__ */ new ua(), dF = /* @__PURE__ */ new ua(), W$ = /* @__PURE__ */ new Te(), hF = /* @__PURE__ */ new Gr(), M1 = /* @__PURE__ */ new Te(), qD = /* @__PURE__ */ new vp(), pF = /* @__PURE__ */ new Gr(), KD = /* @__PURE__ */ new wx();
class k4 extends Al {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Gr(), this.bindMatrixInverse = new Gr(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new mm()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      M1.fromBufferAttribute(t, r), this.applyBoneTransform(r, M1), this.boundingBox.expandByPoint(M1);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new vp()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      M1.fromBufferAttribute(t, r), this.applyBoneTransform(r, M1), this.boundingSphere.expandByPoint(M1);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const r = this.material, i = this.matrixWorld;
    r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), qD.copy(this.boundingSphere), qD.applyMatrix4(i), e.ray.intersectsSphere(qD) !== !1 && (pF.copy(i).invert(), KD.copy(e.ray).applyMatrix4(pF), !(this.boundingBox !== null && KD.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, KD)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ua(), t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton, i = this.geometry;
    fF.fromBufferAttribute(i.attributes.skinIndex, e), dF.fromBufferAttribute(i.attributes.skinWeight, e), cF.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const l = dF.getComponent(o);
      if (l !== 0) {
        const c = fF.getComponent(o);
        hF.multiplyMatrices(r.bones[c].matrixWorld, r.boneInverses[c]), t.addScaledVector(W$.copy(cF).applyMatrix4(hF), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class kP extends aa {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class j1 extends cs {
  constructor(e = null, t = 1, r = 1, i, o, l, c, h, p = ol, y = ol, x, b) {
    super(null, l, c, h, p, y, i, o, x, b), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const mF = /* @__PURE__ */ new Gr(), j$ = /* @__PURE__ */ new Gr();
class i2 {
  constructor(e = [], t = []) {
    this.uuid = yh(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Gr());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Gr();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o] ? e[o].matrixWorld : j$;
      mF.multiplyMatrices(c, t[o]), mF.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new i2(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = v4(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new j1(t, e, e, Td, xv);
    return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let l = t[o];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new kP()), this.bones.push(l), this.boneInverses.push(new Gr().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, r = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const c = r[i];
      e.boneInverses.push(c.toArray());
    }
    return e;
  }
}
class Sx extends io {
  constructor(e, t, r, i = 1) {
    super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const C1 = /* @__PURE__ */ new Gr(), vF = /* @__PURE__ */ new Gr(), OC = [], gF = /* @__PURE__ */ new mm(), $$ = /* @__PURE__ */ new Gr(), cT = /* @__PURE__ */ new Al(), fT = /* @__PURE__ */ new vp();
class z4 extends Al {
  constructor(e, t, r) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Sx(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < r; i++)
      this.setMatrixAt(i, $$);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new mm()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, C1), gF.copy(e.boundingBox).applyMatrix4(C1), this.boundingBox.union(gF);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new vp()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, C1), fT.copy(e.boundingSphere).applyMatrix4(C1), this.boundingSphere.union(fT);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld, i = this.count;
    if (cT.geometry = this.geometry, cT.material = this.material, cT.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), fT.copy(this.boundingSphere), fT.applyMatrix4(r), e.ray.intersectsSphere(fT) !== !1))
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, C1), vF.multiplyMatrices(r, C1), cT.matrixWorld = vF, cT.raycast(e, OC);
        for (let l = 0, c = OC.length; l < c; l++) {
          const h = OC[l];
          h.instanceId = o, h.object = this, t.push(h);
        }
        OC.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Sx(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ff extends ic {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Rn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const yF = /* @__PURE__ */ new Te(), SF = /* @__PURE__ */ new Te(), xF = /* @__PURE__ */ new Gr(), QD = /* @__PURE__ */ new wx(), PC = /* @__PURE__ */ new vp();
class _0 extends aa {
  constructor(e = new oi(), t = new Ff()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [0];
      for (let i = 1, o = t.count; i < o; i++)
        yF.fromBufferAttribute(t, i - 1), SF.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += yF.distanceTo(SF);
      e.setAttribute("lineDistance", new Yn(r, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, o = e.params.Line.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), PC.copy(r.boundingSphere), PC.applyMatrix4(i), PC.radius += o, e.ray.intersectsSphere(PC) === !1)
      return;
    xF.copy(i).invert(), QD.copy(e.ray).applyMatrix4(xF);
    const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, p = new Te(), y = new Te(), x = new Te(), b = new Te(), w = this.isLineSegments ? 2 : 1, R = r.index, L = r.attributes.position;
    if (R !== null) {
      const A = Math.max(0, l.start), F = Math.min(R.count, l.start + l.count);
      for (let k = A, H = F - 1; k < H; k += w) {
        const B = R.getX(k), $ = R.getX(k + 1);
        if (p.fromBufferAttribute(L, B), y.fromBufferAttribute(L, $), QD.distanceSqToSegment(p, y, b, x) > h)
          continue;
        b.applyMatrix4(this.matrixWorld);
        const J = e.ray.origin.distanceTo(b);
        J < e.near || J > e.far || t.push({
          distance: J,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: x.clone().applyMatrix4(this.matrixWorld),
          index: k,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const A = Math.max(0, l.start), F = Math.min(L.count, l.start + l.count);
      for (let k = A, H = F - 1; k < H; k += w) {
        if (p.fromBufferAttribute(L, k), y.fromBufferAttribute(L, k + 1), QD.distanceSqToSegment(p, y, b, x) > h)
          continue;
        b.applyMatrix4(this.matrixWorld);
        const $ = e.ray.origin.distanceTo(b);
        $ < e.near || $ > e.far || t.push({
          distance: $,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: x.clone().applyMatrix4(this.matrixWorld),
          index: k,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const c = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o;
        }
      }
    }
  }
}
const _F = /* @__PURE__ */ new Te(), EF = /* @__PURE__ */ new Te();
class Dv extends _0 {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        _F.fromBufferAttribute(t, i), EF.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + _F.distanceTo(EF);
      e.setAttribute("lineDistance", new Yn(r, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class I4 extends _0 {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class zP extends ic {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Rn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const bF = /* @__PURE__ */ new Gr(), bO = /* @__PURE__ */ new wx(), UC = /* @__PURE__ */ new vp(), NC = /* @__PURE__ */ new Te();
class B4 extends aa {
  constructor(e = new oi(), t = new zP()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, o = e.params.Points.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), UC.copy(r.boundingSphere), UC.applyMatrix4(i), UC.radius += o, e.ray.intersectsSphere(UC) === !1)
      return;
    bF.copy(i).invert(), bO.copy(e.ray).applyMatrix4(bF);
    const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = c * c, p = r.index, x = r.attributes.position;
    if (p !== null) {
      const b = Math.max(0, l.start), w = Math.min(p.count, l.start + l.count);
      for (let R = b, U = w; R < U; R++) {
        const L = p.getX(R);
        NC.fromBufferAttribute(x, L), TF(NC, L, h, i, e, t, this);
      }
    } else {
      const b = Math.max(0, l.start), w = Math.min(x.count, l.start + l.count);
      for (let R = b, U = w; R < U; R++)
        NC.fromBufferAttribute(x, R), TF(NC, R, h, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const c = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[c] = o;
        }
      }
    }
  }
}
function TF(n, e, t, r, i, o, l) {
  const c = bO.distanceSqToPoint(n);
  if (c < t) {
    const h = new Te();
    bO.closestPointToPoint(n, h), h.applyMatrix4(r);
    const p = i.ray.origin.distanceTo(h);
    if (p < i.near || p > i.far)
      return;
    o.push({
      distance: p,
      distanceToRay: Math.sqrt(c),
      point: h,
      index: e,
      face: null,
      object: l
    });
  }
}
class Y$ extends cs {
  constructor(e, t, r, i, o, l, c, h, p) {
    super(e, t, r, i, o, l, c, h, p), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : ss, this.magFilter = o !== void 0 ? o : ss, this.generateMipmaps = !1;
    const y = this;
    function x() {
      y.needsUpdate = !0, e.requestVideoFrameCallback(x);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(x);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class X$ extends cs {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = ol, this.minFilter = ol, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class a2 extends cs {
  constructor(e, t, r, i, o, l, c, h, p, y, x, b) {
    super(null, l, c, h, p, y, i, o, x, b), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class q$ extends a2 {
  constructor(e, t, r, i, o, l) {
    super(e, t, r, o, l), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = kc;
  }
}
class K$ extends a2 {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, jg), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class Q$ extends cs {
  constructor(e, t, r, i, o, l, c, h, p) {
    super(e, t, r, i, o, l, c, h, p), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class vm {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, i = this.getPoint(0), o = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      r = this.getPoint(l / e), o += r.distanceTo(i), t.push(o), i = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let l;
    t ? l = t : l = e * r[o - 1];
    let c = 0, h = o - 1, p;
    for (; c <= h; )
      if (i = Math.floor(c + (h - c) / 2), p = r[i] - l, p < 0)
        c = i + 1;
      else if (p > 0)
        h = i - 1;
      else {
        h = i;
        break;
      }
    if (i = h, r[i] === l)
      return i / (o - 1);
    const y = r[i], b = r[i + 1] - y, w = (l - y) / b;
    return (i + w) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const l = this.getPoint(i), c = this.getPoint(o), h = t || (l.isVector2 ? new Ht() : new Te());
    return h.copy(c).sub(l).normalize(), h;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new Te(), i = [], o = [], l = [], c = new Te(), h = new Gr();
    for (let w = 0; w <= e; w++) {
      const R = w / e;
      i[w] = this.getTangentAt(R, new Te());
    }
    o[0] = new Te(), l[0] = new Te();
    let p = Number.MAX_VALUE;
    const y = Math.abs(i[0].x), x = Math.abs(i[0].y), b = Math.abs(i[0].z);
    y <= p && (p = y, r.set(1, 0, 0)), x <= p && (p = x, r.set(0, 1, 0)), b <= p && r.set(0, 0, 1), c.crossVectors(i[0], r).normalize(), o[0].crossVectors(i[0], c), l[0].crossVectors(i[0], o[0]);
    for (let w = 1; w <= e; w++) {
      if (o[w] = o[w - 1].clone(), l[w] = l[w - 1].clone(), c.crossVectors(i[w - 1], i[w]), c.length() > Number.EPSILON) {
        c.normalize();
        const R = Math.acos(Os(i[w - 1].dot(i[w]), -1, 1));
        o[w].applyMatrix4(h.makeRotationAxis(c, R));
      }
      l[w].crossVectors(i[w], o[w]);
    }
    if (t === !0) {
      let w = Math.acos(Os(o[0].dot(o[e]), -1, 1));
      w /= e, i[0].dot(c.crossVectors(o[0], o[e])) > 0 && (w = -w);
      for (let R = 1; R <= e; R++)
        o[R].applyMatrix4(h.makeRotationAxis(i[R], w * R)), l[R].crossVectors(i[R], o[R]);
    }
    return {
      tangents: i,
      normals: o,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class o2 extends vm {
  constructor(e = 0, t = 0, r = 1, i = 1, o = 0, l = Math.PI * 2, c = !1, h = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = c, this.aRotation = h;
  }
  getPoint(e, t) {
    const r = t || new Ht(), i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(o) < Number.EPSILON;
    for (; o < 0; )
      o += i;
    for (; o > i; )
      o -= i;
    o < Number.EPSILON && (l ? o = 0 : o = i), this.aClockwise === !0 && !l && (o === i ? o = -i : o = o - i);
    const c = this.aStartAngle + e * o;
    let h = this.aX + this.xRadius * Math.cos(c), p = this.aY + this.yRadius * Math.sin(c);
    if (this.aRotation !== 0) {
      const y = Math.cos(this.aRotation), x = Math.sin(this.aRotation), b = h - this.aX, w = p - this.aY;
      h = b * y - w * x + this.aX, p = b * x + w * y + this.aY;
    }
    return r.set(h, p);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class H4 extends o2 {
  constructor(e, t, r, i, o, l) {
    super(e, t, r, r, i, o, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function IP() {
  let n = 0, e = 0, t = 0, r = 0;
  function i(o, l, c, h) {
    n = o, e = c, t = -3 * o + 3 * l - 2 * c - h, r = 2 * o - 2 * l + c + h;
  }
  return {
    initCatmullRom: function(o, l, c, h, p) {
      i(l, c, p * (c - o), p * (h - l));
    },
    initNonuniformCatmullRom: function(o, l, c, h, p, y, x) {
      let b = (l - o) / p - (c - o) / (p + y) + (c - l) / y, w = (c - l) / y - (h - l) / (y + x) + (h - c) / x;
      b *= y, w *= y, i(l, c, b, w);
    },
    calc: function(o) {
      const l = o * o, c = l * o;
      return n + e * o + t * l + r * c;
    }
  };
}
const FC = /* @__PURE__ */ new Te(), ZD = /* @__PURE__ */ new IP(), JD = /* @__PURE__ */ new IP(), eL = /* @__PURE__ */ new IP();
class V4 extends vm {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i;
  }
  getPoint(e, t = new Te()) {
    const r = t, i = this.points, o = i.length, l = (o - (this.closed ? 0 : 1)) * e;
    let c = Math.floor(l), h = l - c;
    this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o : h === 0 && c === o - 1 && (c = o - 2, h = 1);
    let p, y;
    this.closed || c > 0 ? p = i[(c - 1) % o] : (FC.subVectors(i[0], i[1]).add(i[0]), p = FC);
    const x = i[c % o], b = i[(c + 1) % o];
    if (this.closed || c + 2 < o ? y = i[(c + 2) % o] : (FC.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), y = FC), this.curveType === "centripetal" || this.curveType === "chordal") {
      const w = this.curveType === "chordal" ? 0.5 : 0.25;
      let R = Math.pow(p.distanceToSquared(x), w), U = Math.pow(x.distanceToSquared(b), w), L = Math.pow(b.distanceToSquared(y), w);
      U < 1e-4 && (U = 1), R < 1e-4 && (R = U), L < 1e-4 && (L = U), ZD.initNonuniformCatmullRom(p.x, x.x, b.x, y.x, R, U, L), JD.initNonuniformCatmullRom(p.y, x.y, b.y, y.y, R, U, L), eL.initNonuniformCatmullRom(p.z, x.z, b.z, y.z, R, U, L);
    } else
      this.curveType === "catmullrom" && (ZD.initCatmullRom(p.x, x.x, b.x, y.x, this.tension), JD.initCatmullRom(p.y, x.y, b.y, y.y, this.tension), eL.initCatmullRom(p.z, x.z, b.z, y.z, this.tension));
    return r.set(
      ZD.calc(h),
      JD.calc(h),
      eL.calc(h)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new Te().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function wF(n, e, t, r, i) {
  const o = (r - e) * 0.5, l = (i - t) * 0.5, c = n * n, h = n * c;
  return (2 * t - 2 * r + o + l) * h + (-3 * t + 3 * r - 2 * o - l) * c + o * n + t;
}
function Z$(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function J$(n, e) {
  return 2 * (1 - n) * n * e;
}
function eY(n, e) {
  return n * n * e;
}
function CT(n, e, t, r) {
  return Z$(n, e) + J$(n, t) + eY(n, r);
}
function tY(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function nY(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function rY(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function iY(n, e) {
  return n * n * n * e;
}
function RT(n, e, t, r, i) {
  return tY(n, e) + nY(n, t) + rY(n, r) + iY(n, i);
}
class BP extends vm {
  constructor(e = new Ht(), t = new Ht(), r = new Ht(), i = new Ht()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new Ht()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2, c = this.v3;
    return r.set(
      RT(e, i.x, o.x, l.x, c.x),
      RT(e, i.y, o.y, l.y, c.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class G4 extends vm {
  constructor(e = new Te(), t = new Te(), r = new Te(), i = new Te()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new Te()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2, c = this.v3;
    return r.set(
      RT(e, i.x, o.x, l.x, c.x),
      RT(e, i.y, o.y, l.y, c.y),
      RT(e, i.z, o.z, l.z, c.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class s2 extends vm {
  constructor(e = new Ht(), t = new Ht()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ht()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ht()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class W4 extends vm {
  constructor(e = new Te(), t = new Te()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Te()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Te()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class HP extends vm {
  constructor(e = new Ht(), t = new Ht(), r = new Ht()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Ht()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2;
    return r.set(
      CT(e, i.x, o.x, l.x),
      CT(e, i.y, o.y, l.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class VP extends vm {
  constructor(e = new Te(), t = new Te(), r = new Te()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Te()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2;
    return r.set(
      CT(e, i.x, o.x, l.x),
      CT(e, i.y, o.y, l.y),
      CT(e, i.z, o.z, l.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class GP extends vm {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Ht()) {
    const r = t, i = this.points, o = (i.length - 1) * e, l = Math.floor(o), c = o - l, h = i[l === 0 ? l : l - 1], p = i[l], y = i[l > i.length - 2 ? i.length - 1 : l + 1], x = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return r.set(
      wF(c, h.x, p.x, y.x, x.x),
      wF(c, h.y, p.y, y.y, x.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new Ht().fromArray(i));
    }
    return this;
  }
}
var WP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: H4,
  CatmullRomCurve3: V4,
  CubicBezierCurve: BP,
  CubicBezierCurve3: G4,
  EllipseCurve: o2,
  LineCurve: s2,
  LineCurve3: W4,
  QuadraticBezierCurve: HP,
  QuadraticBezierCurve3: VP,
  SplineCurve: GP
});
class j4 extends vm {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new s2(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const l = i[o] - r, c = this.curves[o], h = c.getLength(), p = h === 0 ? 0 : 1 - l / h;
        return c.getPointAt(p, t);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const l = o[i], c = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, h = l.getPoints(c);
      for (let p = 0; p < h.length; p++) {
        const y = h[p];
        r && r.equals(y) || (t.push(y), r = y);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new WP[i.type]().fromJSON(i));
    }
    return this;
  }
}
class WT extends j4 {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ht(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new s2(this.currentPoint.clone(), new Ht(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const o = new HP(
      this.currentPoint.clone(),
      new Ht(e, t),
      new Ht(r, i)
    );
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, l) {
    const c = new BP(
      this.currentPoint.clone(),
      new Ht(e, t),
      new Ht(r, i),
      new Ht(o, l)
    );
    return this.curves.push(c), this.currentPoint.set(o, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new GP(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, o, l) {
    const c = this.currentPoint.x, h = this.currentPoint.y;
    return this.absarc(
      e + c,
      t + h,
      r,
      i,
      o,
      l
    ), this;
  }
  absarc(e, t, r, i, o, l) {
    return this.absellipse(e, t, r, r, i, o, l), this;
  }
  ellipse(e, t, r, i, o, l, c, h) {
    const p = this.currentPoint.x, y = this.currentPoint.y;
    return this.absellipse(e + p, t + y, r, i, o, l, c, h), this;
  }
  absellipse(e, t, r, i, o, l, c, h) {
    const p = new o2(e, t, r, i, o, l, c, h);
    if (this.curves.length > 0) {
      const x = p.getPoint(0);
      x.equals(this.currentPoint) || this.lineTo(x.x, x.y);
    }
    this.curves.push(p);
    const y = p.getPoint(1);
    return this.currentPoint.copy(y), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class uw extends oi {
  constructor(e = [new Ht(0, -0.5), new Ht(0.5, 0), new Ht(0, 0.5)], t = 12, r = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: i
    }, t = Math.floor(t), i = Os(i, 0, Math.PI * 2);
    const o = [], l = [], c = [], h = [], p = [], y = 1 / t, x = new Te(), b = new Ht(), w = new Te(), R = new Te(), U = new Te();
    let L = 0, A = 0;
    for (let F = 0; F <= e.length - 1; F++)
      switch (F) {
        case 0:
          L = e[F + 1].x - e[F].x, A = e[F + 1].y - e[F].y, w.x = A * 1, w.y = -L, w.z = A * 0, U.copy(w), w.normalize(), h.push(w.x, w.y, w.z);
          break;
        case e.length - 1:
          h.push(U.x, U.y, U.z);
          break;
        default:
          L = e[F + 1].x - e[F].x, A = e[F + 1].y - e[F].y, w.x = A * 1, w.y = -L, w.z = A * 0, R.copy(w), w.x += U.x, w.y += U.y, w.z += U.z, w.normalize(), h.push(w.x, w.y, w.z), U.copy(R);
      }
    for (let F = 0; F <= t; F++) {
      const k = r + F * y * i, H = Math.sin(k), B = Math.cos(k);
      for (let $ = 0; $ <= e.length - 1; $++) {
        x.x = e[$].x * H, x.y = e[$].y, x.z = e[$].x * B, l.push(x.x, x.y, x.z), b.x = F / t, b.y = $ / (e.length - 1), c.push(b.x, b.y);
        const Y = h[3 * $ + 0] * H, J = h[3 * $ + 1], K = h[3 * $ + 0] * B;
        p.push(Y, J, K);
      }
    }
    for (let F = 0; F < t; F++)
      for (let k = 0; k < e.length - 1; k++) {
        const H = k + F * e.length, B = H, $ = H + e.length, Y = H + e.length + 1, J = H + 1;
        o.push(B, $, J), o.push(Y, J, $);
      }
    this.setIndex(o), this.setAttribute("position", new Yn(l, 3)), this.setAttribute("uv", new Yn(c, 2)), this.setAttribute("normal", new Yn(p, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uw(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class l2 extends uw {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const o = new WT();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(o.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new l2(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class u2 extends oi {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: i
    }, t = Math.max(3, t);
    const o = [], l = [], c = [], h = [], p = new Te(), y = new Ht();
    l.push(0, 0, 0), c.push(0, 0, 1), h.push(0.5, 0.5);
    for (let x = 0, b = 3; x <= t; x++, b += 3) {
      const w = r + x / t * i;
      p.x = e * Math.cos(w), p.y = e * Math.sin(w), l.push(p.x, p.y, p.z), c.push(0, 0, 1), y.x = (l[b] / e + 1) / 2, y.y = (l[b + 1] / e + 1) / 2, h.push(y.x, y.y);
    }
    for (let x = 1; x <= t; x++)
      o.push(x, x + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Yn(l, 3)), this.setAttribute("normal", new Yn(c, 3)), this.setAttribute("uv", new Yn(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new u2(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class rE extends oi {
  constructor(e = 1, t = 1, r = 1, i = 32, o = 1, l = !1, c = 0, h = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: i,
      heightSegments: o,
      openEnded: l,
      thetaStart: c,
      thetaLength: h
    };
    const p = this;
    i = Math.floor(i), o = Math.floor(o);
    const y = [], x = [], b = [], w = [];
    let R = 0;
    const U = [], L = r / 2;
    let A = 0;
    F(), l === !1 && (e > 0 && k(!0), t > 0 && k(!1)), this.setIndex(y), this.setAttribute("position", new Yn(x, 3)), this.setAttribute("normal", new Yn(b, 3)), this.setAttribute("uv", new Yn(w, 2));
    function F() {
      const H = new Te(), B = new Te();
      let $ = 0;
      const Y = (t - e) / r;
      for (let J = 0; J <= o; J++) {
        const K = [], X = J / o, le = X * (t - e) + e;
        for (let oe = 0; oe <= i; oe++) {
          const fe = oe / i, de = fe * h + c, xe = Math.sin(de), _e = Math.cos(de);
          B.x = le * xe, B.y = -X * r + L, B.z = le * _e, x.push(B.x, B.y, B.z), H.set(xe, Y, _e).normalize(), b.push(H.x, H.y, H.z), w.push(fe, 1 - X), K.push(R++);
        }
        U.push(K);
      }
      for (let J = 0; J < i; J++)
        for (let K = 0; K < o; K++) {
          const X = U[K][J], le = U[K + 1][J], oe = U[K + 1][J + 1], fe = U[K][J + 1];
          y.push(X, le, fe), y.push(le, oe, fe), $ += 6;
        }
      p.addGroup(A, $, 0), A += $;
    }
    function k(H) {
      const B = R, $ = new Ht(), Y = new Te();
      let J = 0;
      const K = H === !0 ? e : t, X = H === !0 ? 1 : -1;
      for (let oe = 1; oe <= i; oe++)
        x.push(0, L * X, 0), b.push(0, X, 0), w.push(0.5, 0.5), R++;
      const le = R;
      for (let oe = 0; oe <= i; oe++) {
        const de = oe / i * h + c, xe = Math.cos(de), _e = Math.sin(de);
        Y.x = K * _e, Y.y = L * X, Y.z = K * xe, x.push(Y.x, Y.y, Y.z), b.push(0, X, 0), $.x = xe * 0.5 + 0.5, $.y = _e * 0.5 * X + 0.5, w.push($.x, $.y), R++;
      }
      for (let oe = 0; oe < i; oe++) {
        const fe = B + oe, de = le + oe;
        H === !0 ? y.push(de, de + 1, fe) : y.push(de + 1, de, fe), J += 3;
      }
      p.addGroup(A, J, H === !0 ? 1 : 2), A += J;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new rE(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class c2 extends rE {
  constructor(e = 1, t = 1, r = 32, i = 1, o = !1, l = 0, c = Math.PI * 2) {
    super(0, e, t, r, i, o, l, c), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: i,
      openEnded: o,
      thetaStart: l,
      thetaLength: c
    };
  }
  static fromJSON(e) {
    return new c2(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class A0 extends oi {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: i
    };
    const o = [], l = [];
    c(i), p(r), y(), this.setAttribute("position", new Yn(o, 3)), this.setAttribute("normal", new Yn(o.slice(), 3)), this.setAttribute("uv", new Yn(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function c(F) {
      const k = new Te(), H = new Te(), B = new Te();
      for (let $ = 0; $ < t.length; $ += 3)
        w(t[$ + 0], k), w(t[$ + 1], H), w(t[$ + 2], B), h(k, H, B, F);
    }
    function h(F, k, H, B) {
      const $ = B + 1, Y = [];
      for (let J = 0; J <= $; J++) {
        Y[J] = [];
        const K = F.clone().lerp(H, J / $), X = k.clone().lerp(H, J / $), le = $ - J;
        for (let oe = 0; oe <= le; oe++)
          oe === 0 && J === $ ? Y[J][oe] = K : Y[J][oe] = K.clone().lerp(X, oe / le);
      }
      for (let J = 0; J < $; J++)
        for (let K = 0; K < 2 * ($ - J) - 1; K++) {
          const X = Math.floor(K / 2);
          K % 2 === 0 ? (b(Y[J][X + 1]), b(Y[J + 1][X]), b(Y[J][X])) : (b(Y[J][X + 1]), b(Y[J + 1][X + 1]), b(Y[J + 1][X]));
        }
    }
    function p(F) {
      const k = new Te();
      for (let H = 0; H < o.length; H += 3)
        k.x = o[H + 0], k.y = o[H + 1], k.z = o[H + 2], k.normalize().multiplyScalar(F), o[H + 0] = k.x, o[H + 1] = k.y, o[H + 2] = k.z;
    }
    function y() {
      const F = new Te();
      for (let k = 0; k < o.length; k += 3) {
        F.x = o[k + 0], F.y = o[k + 1], F.z = o[k + 2];
        const H = L(F) / 2 / Math.PI + 0.5, B = A(F) / Math.PI + 0.5;
        l.push(H, 1 - B);
      }
      R(), x();
    }
    function x() {
      for (let F = 0; F < l.length; F += 6) {
        const k = l[F + 0], H = l[F + 2], B = l[F + 4], $ = Math.max(k, H, B), Y = Math.min(k, H, B);
        $ > 0.9 && Y < 0.1 && (k < 0.2 && (l[F + 0] += 1), H < 0.2 && (l[F + 2] += 1), B < 0.2 && (l[F + 4] += 1));
      }
    }
    function b(F) {
      o.push(F.x, F.y, F.z);
    }
    function w(F, k) {
      const H = F * 3;
      k.x = e[H + 0], k.y = e[H + 1], k.z = e[H + 2];
    }
    function R() {
      const F = new Te(), k = new Te(), H = new Te(), B = new Te(), $ = new Ht(), Y = new Ht(), J = new Ht();
      for (let K = 0, X = 0; K < o.length; K += 9, X += 6) {
        F.set(o[K + 0], o[K + 1], o[K + 2]), k.set(o[K + 3], o[K + 4], o[K + 5]), H.set(o[K + 6], o[K + 7], o[K + 8]), $.set(l[X + 0], l[X + 1]), Y.set(l[X + 2], l[X + 3]), J.set(l[X + 4], l[X + 5]), B.copy(F).add(k).add(H).divideScalar(3);
        const le = L(B);
        U($, X + 0, F, le), U(Y, X + 2, k, le), U(J, X + 4, H, le);
      }
    }
    function U(F, k, H, B) {
      B < 0 && F.x === 1 && (l[k] = F.x - 1), H.x === 0 && H.z === 0 && (l[k] = B / 2 / Math.PI + 0.5);
    }
    function L(F) {
      return Math.atan2(F.z, -F.x);
    }
    function A(F) {
      return Math.atan2(-F.y, Math.sqrt(F.x * F.x + F.z * F.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new A0(e.vertices, e.indices, e.radius, e.details);
  }
}
class f2 extends A0 {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, o = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      // (±1/φ, ±φ, 0)
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      0,
      // (±φ, 0, ±1/φ)
      -r,
      0,
      -i,
      r,
      0,
      -i,
      -r,
      0,
      i,
      r,
      0,
      i
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new f2(e.radius, e.detail);
  }
}
const kC = /* @__PURE__ */ new Te(), zC = /* @__PURE__ */ new Te(), tL = /* @__PURE__ */ new Te(), IC = /* @__PURE__ */ new bd();
class $4 extends oi {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), o = Math.cos(cx * t), l = e.getIndex(), c = e.getAttribute("position"), h = l ? l.count : c.count, p = [0, 0, 0], y = ["a", "b", "c"], x = new Array(3), b = {}, w = [];
      for (let R = 0; R < h; R += 3) {
        l ? (p[0] = l.getX(R), p[1] = l.getX(R + 1), p[2] = l.getX(R + 2)) : (p[0] = R, p[1] = R + 1, p[2] = R + 2);
        const { a: U, b: L, c: A } = IC;
        if (U.fromBufferAttribute(c, p[0]), L.fromBufferAttribute(c, p[1]), A.fromBufferAttribute(c, p[2]), IC.getNormal(tL), x[0] = `${Math.round(U.x * i)},${Math.round(U.y * i)},${Math.round(U.z * i)}`, x[1] = `${Math.round(L.x * i)},${Math.round(L.y * i)},${Math.round(L.z * i)}`, x[2] = `${Math.round(A.x * i)},${Math.round(A.y * i)},${Math.round(A.z * i)}`, !(x[0] === x[1] || x[1] === x[2] || x[2] === x[0]))
          for (let F = 0; F < 3; F++) {
            const k = (F + 1) % 3, H = x[F], B = x[k], $ = IC[y[F]], Y = IC[y[k]], J = `${H}_${B}`, K = `${B}_${H}`;
            K in b && b[K] ? (tL.dot(b[K].normal) <= o && (w.push($.x, $.y, $.z), w.push(Y.x, Y.y, Y.z)), b[K] = null) : J in b || (b[J] = {
              index0: p[F],
              index1: p[k],
              normal: tL.clone()
            });
          }
      }
      for (const R in b)
        if (b[R]) {
          const { index0: U, index1: L } = b[R];
          kC.fromBufferAttribute(c, U), zC.fromBufferAttribute(c, L), w.push(kC.x, kC.y, kC.z), w.push(zC.x, zC.y, zC.z);
        }
      this.setAttribute("position", new Yn(w, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class dx extends WT {
  constructor(e) {
    super(e), this.uuid = yh(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new WT().fromJSON(i));
    }
    return this;
  }
}
const aY = {
  triangulate: function(n, e, t = 2) {
    const r = e && e.length, i = r ? e[0] * t : n.length;
    let o = Y4(n, 0, i, t, !0);
    const l = [];
    if (!o || o.next === o.prev)
      return l;
    let c, h, p, y, x, b, w;
    if (r && (o = cY(n, e, o, t)), n.length > 80 * t) {
      c = p = n[0], h = y = n[1];
      for (let R = t; R < i; R += t)
        x = n[R], b = n[R + 1], x < c && (c = x), b < h && (h = b), x > p && (p = x), b > y && (y = b);
      w = Math.max(p - c, y - h), w = w !== 0 ? 32767 / w : 0;
    }
    return jT(o, l, t, c, h, w, 0), l;
  }
};
function Y4(n, e, t, r, i) {
  let o, l;
  if (i === _Y(n, e, t, r) > 0)
    for (o = e; o < t; o += r)
      l = MF(o, n[o], n[o + 1], l);
  else
    for (o = t - r; o >= e; o -= r)
      l = MF(o, n[o], n[o + 1], l);
  return l && d2(l, l.next) && (YT(l), l = l.next), l;
}
function xx(n, e) {
  if (!n)
    return n;
  e || (e = n);
  let t = n, r;
  do
    if (r = !1, !t.steiner && (d2(t, t.next) || ls(t.prev, t, t.next) === 0)) {
      if (YT(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function jT(n, e, t, r, i, o, l) {
  if (!n)
    return;
  !l && o && mY(n, r, i, o);
  let c = n, h, p;
  for (; n.prev !== n.next; ) {
    if (h = n.prev, p = n.next, o ? sY(n, r, i, o) : oY(n)) {
      e.push(h.i / t | 0), e.push(n.i / t | 0), e.push(p.i / t | 0), YT(n), n = p.next, c = p.next;
      continue;
    }
    if (n = p, n === c) {
      l ? l === 1 ? (n = lY(xx(n), e, t), jT(n, e, t, r, i, o, 2)) : l === 2 && uY(n, e, t, r, i, o) : jT(xx(n), e, t, r, i, o, 1);
      break;
    }
  }
}
function oY(n) {
  const e = n.prev, t = n, r = n.next;
  if (ls(e, t, r) >= 0)
    return !1;
  const i = e.x, o = t.x, l = r.x, c = e.y, h = t.y, p = r.y, y = i < o ? i < l ? i : l : o < l ? o : l, x = c < h ? c < p ? c : p : h < p ? h : p, b = i > o ? i > l ? i : l : o > l ? o : l, w = c > h ? c > p ? c : p : h > p ? h : p;
  let R = r.next;
  for (; R !== e; ) {
    if (R.x >= y && R.x <= b && R.y >= x && R.y <= w && I1(i, c, o, h, l, p, R.x, R.y) && ls(R.prev, R, R.next) >= 0)
      return !1;
    R = R.next;
  }
  return !0;
}
function sY(n, e, t, r) {
  const i = n.prev, o = n, l = n.next;
  if (ls(i, o, l) >= 0)
    return !1;
  const c = i.x, h = o.x, p = l.x, y = i.y, x = o.y, b = l.y, w = c < h ? c < p ? c : p : h < p ? h : p, R = y < x ? y < b ? y : b : x < b ? x : b, U = c > h ? c > p ? c : p : h > p ? h : p, L = y > x ? y > b ? y : b : x > b ? x : b, A = TO(w, R, e, t, r), F = TO(U, L, e, t, r);
  let k = n.prevZ, H = n.nextZ;
  for (; k && k.z >= A && H && H.z <= F; ) {
    if (k.x >= w && k.x <= U && k.y >= R && k.y <= L && k !== i && k !== l && I1(c, y, h, x, p, b, k.x, k.y) && ls(k.prev, k, k.next) >= 0 || (k = k.prevZ, H.x >= w && H.x <= U && H.y >= R && H.y <= L && H !== i && H !== l && I1(c, y, h, x, p, b, H.x, H.y) && ls(H.prev, H, H.next) >= 0))
      return !1;
    H = H.nextZ;
  }
  for (; k && k.z >= A; ) {
    if (k.x >= w && k.x <= U && k.y >= R && k.y <= L && k !== i && k !== l && I1(c, y, h, x, p, b, k.x, k.y) && ls(k.prev, k, k.next) >= 0)
      return !1;
    k = k.prevZ;
  }
  for (; H && H.z <= F; ) {
    if (H.x >= w && H.x <= U && H.y >= R && H.y <= L && H !== i && H !== l && I1(c, y, h, x, p, b, H.x, H.y) && ls(H.prev, H, H.next) >= 0)
      return !1;
    H = H.nextZ;
  }
  return !0;
}
function lY(n, e, t) {
  let r = n;
  do {
    const i = r.prev, o = r.next.next;
    !d2(i, o) && X4(i, r, r.next, o) && $T(i, o) && $T(o, i) && (e.push(i.i / t | 0), e.push(r.i / t | 0), e.push(o.i / t | 0), YT(r), YT(r.next), r = n = o), r = r.next;
  } while (r !== n);
  return xx(r);
}
function uY(n, e, t, r, i, o) {
  let l = n;
  do {
    let c = l.next.next;
    for (; c !== l.prev; ) {
      if (l.i !== c.i && yY(l, c)) {
        let h = q4(l, c);
        l = xx(l, l.next), h = xx(h, h.next), jT(l, e, t, r, i, o, 0), jT(h, e, t, r, i, o, 0);
        return;
      }
      c = c.next;
    }
    l = l.next;
  } while (l !== n);
}
function cY(n, e, t, r) {
  const i = [];
  let o, l, c, h, p;
  for (o = 0, l = e.length; o < l; o++)
    c = e[o] * r, h = o < l - 1 ? e[o + 1] * r : n.length, p = Y4(n, c, h, r, !1), p === p.next && (p.steiner = !0), i.push(gY(p));
  for (i.sort(fY), o = 0; o < i.length; o++)
    t = dY(i[o], t);
  return t;
}
function fY(n, e) {
  return n.x - e.x;
}
function dY(n, e) {
  const t = hY(n, e);
  if (!t)
    return e;
  const r = q4(t, n);
  return xx(r, r.next), xx(t, t.next);
}
function hY(n, e) {
  let t = e, r = -1 / 0, i;
  const o = n.x, l = n.y;
  do {
    if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
      const b = t.x + (l - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (b <= o && b > r && (r = b, i = t.x < t.next.x ? t : t.next, b === o))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i)
    return null;
  const c = i, h = i.x, p = i.y;
  let y = 1 / 0, x;
  t = i;
  do
    o >= t.x && t.x >= h && o !== t.x && I1(l < p ? o : r, l, h, p, l < p ? r : o, l, t.x, t.y) && (x = Math.abs(l - t.y) / (o - t.x), $T(t, n) && (x < y || x === y && (t.x > i.x || t.x === i.x && pY(i, t))) && (i = t, y = x)), t = t.next;
  while (t !== c);
  return i;
}
function pY(n, e) {
  return ls(n.prev, n, e.prev) < 0 && ls(e.next, n, n.next) < 0;
}
function mY(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = TO(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== n);
  i.prevZ.nextZ = null, i.prevZ = null, vY(i);
}
function vY(n) {
  let e, t, r, i, o, l, c, h, p = 1;
  do {
    for (t = n, n = null, o = null, l = 0; t; ) {
      for (l++, r = t, c = 0, e = 0; e < p && (c++, r = r.nextZ, !!r); e++)
        ;
      for (h = p; c > 0 || h > 0 && r; )
        c !== 0 && (h === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, c--) : (i = r, r = r.nextZ, h--), o ? o.nextZ = i : n = i, i.prevZ = o, o = i;
      t = r;
    }
    o.nextZ = null, p *= 2;
  } while (l > 1);
  return n;
}
function TO(n, e, t, r, i) {
  return n = (n - t) * i | 0, e = (e - r) * i | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
}
function gY(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function I1(n, e, t, r, i, o, l, c) {
  return (i - l) * (e - c) >= (n - l) * (o - c) && (n - l) * (r - c) >= (t - l) * (e - c) && (t - l) * (o - c) >= (i - l) * (r - c);
}
function yY(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !SY(n, e) && // dones't intersect other edges
  ($T(n, e) && $T(e, n) && xY(n, e) && // locally visible
  (ls(n.prev, n, e.prev) || ls(n, e.prev, e)) || // does not create opposite-facing sectors
  d2(n, e) && ls(n.prev, n, n.next) > 0 && ls(e.prev, e, e.next) > 0);
}
function ls(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function d2(n, e) {
  return n.x === e.x && n.y === e.y;
}
function X4(n, e, t, r) {
  const i = HC(ls(n, e, t)), o = HC(ls(n, e, r)), l = HC(ls(t, r, n)), c = HC(ls(t, r, e));
  return !!(i !== o && l !== c || i === 0 && BC(n, t, e) || o === 0 && BC(n, r, e) || l === 0 && BC(t, n, r) || c === 0 && BC(t, e, r));
}
function BC(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function HC(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function SY(n, e) {
  let t = n;
  do {
    if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && X4(t, t.next, n, e))
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function $T(n, e) {
  return ls(n.prev, n, n.next) < 0 ? ls(n, e, n.next) >= 0 && ls(n, n.prev, e) >= 0 : ls(n, e, n.prev) < 0 || ls(n, n.next, e) < 0;
}
function xY(n, e) {
  let t = n, r = !1;
  const i = (n.x + e.x) / 2, o = (n.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && i < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== n);
  return r;
}
function q4(n, e) {
  const t = new wO(n.i, n.x, n.y), r = new wO(e.i, e.x, e.y), i = n.next, o = e.prev;
  return n.next = e, e.prev = n, t.next = i, i.prev = t, r.next = t, t.prev = r, o.next = r, r.prev = o, r;
}
function MF(n, e, t, r) {
  const i = new wO(n, e, t);
  return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
}
function YT(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function wO(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function _Y(n, e, t, r) {
  let i = 0;
  for (let o = e, l = t - r; o < t; o += r)
    i += (n[l] - n[o]) * (n[o + 1] + n[l + 1]), l = o;
  return i;
}
class Tv {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Tv.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], i = [], o = [];
    CF(e), RF(r, e);
    let l = e.length;
    t.forEach(CF);
    for (let h = 0; h < t.length; h++)
      i.push(l), l += t[h].length, RF(r, t[h]);
    const c = aY.triangulate(r, i);
    for (let h = 0; h < c.length; h += 3)
      o.push(c.slice(h, h + 3));
    return o;
  }
}
function CF(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function RF(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class h2 extends oi {
  constructor(e = new dx([new Ht(0.5, 0.5), new Ht(-0.5, 0.5), new Ht(-0.5, -0.5), new Ht(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, i = [], o = [];
    for (let c = 0, h = e.length; c < h; c++) {
      const p = e[c];
      l(p);
    }
    this.setAttribute("position", new Yn(i, 3)), this.setAttribute("uv", new Yn(o, 2)), this.computeVertexNormals();
    function l(c) {
      const h = [], p = t.curveSegments !== void 0 ? t.curveSegments : 12, y = t.steps !== void 0 ? t.steps : 1, x = t.depth !== void 0 ? t.depth : 1;
      let b = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, w = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, R = t.bevelSize !== void 0 ? t.bevelSize : w - 0.1, U = t.bevelOffset !== void 0 ? t.bevelOffset : 0, L = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const A = t.extrudePath, F = t.UVGenerator !== void 0 ? t.UVGenerator : EY;
      let k, H = !1, B, $, Y, J;
      A && (k = A.getSpacedPoints(y), H = !0, b = !1, B = A.computeFrenetFrames(y, !1), $ = new Te(), Y = new Te(), J = new Te()), b || (L = 0, w = 0, R = 0, U = 0);
      const K = c.extractPoints(p);
      let X = K.shape;
      const le = K.holes;
      if (!Tv.isClockWise(X)) {
        X = X.reverse();
        for (let ae = 0, et = le.length; ae < et; ae++) {
          const Ye = le[ae];
          Tv.isClockWise(Ye) && (le[ae] = Ye.reverse());
        }
      }
      const fe = Tv.triangulateShape(X, le), de = X;
      for (let ae = 0, et = le.length; ae < et; ae++) {
        const Ye = le[ae];
        X = X.concat(Ye);
      }
      function xe(ae, et, Ye) {
        return et || console.error("THREE.ExtrudeGeometry: vec does not exist"), ae.clone().addScaledVector(et, Ye);
      }
      const _e = X.length, Pe = fe.length;
      function ce(ae, et, Ye) {
        let Ge, $e, Ut;
        const nt = ae.x - et.x, Ct = ae.y - et.y, Pt = Ye.x - ae.x, vt = Ye.y - ae.y, Zt = nt * nt + Ct * Ct, ie = nt * vt - Ct * Pt;
        if (Math.abs(ie) > Number.EPSILON) {
          const ne = Math.sqrt(Zt), Oe = Math.sqrt(Pt * Pt + vt * vt), _t = et.x - Ct / ne, ot = et.y + nt / ne, at = Ye.x - vt / Oe, Wt = Ye.y + Pt / Oe, Dt = ((at - _t) * vt - (Wt - ot) * Pt) / (nt * vt - Ct * Pt);
          Ge = _t + nt * Dt - ae.x, $e = ot + Ct * Dt - ae.y;
          const Se = Ge * Ge + $e * $e;
          if (Se <= 2)
            return new Ht(Ge, $e);
          Ut = Math.sqrt(Se / 2);
        } else {
          let ne = !1;
          nt > Number.EPSILON ? Pt > Number.EPSILON && (ne = !0) : nt < -Number.EPSILON ? Pt < -Number.EPSILON && (ne = !0) : Math.sign(Ct) === Math.sign(vt) && (ne = !0), ne ? (Ge = -Ct, $e = nt, Ut = Math.sqrt(Zt)) : (Ge = nt, $e = Ct, Ut = Math.sqrt(Zt / 2));
        }
        return new Ht(Ge / Ut, $e / Ut);
      }
      const ve = [];
      for (let ae = 0, et = de.length, Ye = et - 1, Ge = ae + 1; ae < et; ae++, Ye++, Ge++)
        Ye === et && (Ye = 0), Ge === et && (Ge = 0), ve[ae] = ce(de[ae], de[Ye], de[Ge]);
      const re = [];
      let ee, he = ve.concat();
      for (let ae = 0, et = le.length; ae < et; ae++) {
        const Ye = le[ae];
        ee = [];
        for (let Ge = 0, $e = Ye.length, Ut = $e - 1, nt = Ge + 1; Ge < $e; Ge++, Ut++, nt++)
          Ut === $e && (Ut = 0), nt === $e && (nt = 0), ee[Ge] = ce(Ye[Ge], Ye[Ut], Ye[nt]);
        re.push(ee), he = he.concat(ee);
      }
      for (let ae = 0; ae < L; ae++) {
        const et = ae / L, Ye = w * Math.cos(et * Math.PI / 2), Ge = R * Math.sin(et * Math.PI / 2) + U;
        for (let $e = 0, Ut = de.length; $e < Ut; $e++) {
          const nt = xe(de[$e], ve[$e], Ge);
          Ne(nt.x, nt.y, -Ye);
        }
        for (let $e = 0, Ut = le.length; $e < Ut; $e++) {
          const nt = le[$e];
          ee = re[$e];
          for (let Ct = 0, Pt = nt.length; Ct < Pt; Ct++) {
            const vt = xe(nt[Ct], ee[Ct], Ge);
            Ne(vt.x, vt.y, -Ye);
          }
        }
      }
      const Me = R + U;
      for (let ae = 0; ae < _e; ae++) {
        const et = b ? xe(X[ae], he[ae], Me) : X[ae];
        H ? (Y.copy(B.normals[0]).multiplyScalar(et.x), $.copy(B.binormals[0]).multiplyScalar(et.y), J.copy(k[0]).add(Y).add($), Ne(J.x, J.y, J.z)) : Ne(et.x, et.y, 0);
      }
      for (let ae = 1; ae <= y; ae++)
        for (let et = 0; et < _e; et++) {
          const Ye = b ? xe(X[et], he[et], Me) : X[et];
          H ? (Y.copy(B.normals[ae]).multiplyScalar(Ye.x), $.copy(B.binormals[ae]).multiplyScalar(Ye.y), J.copy(k[ae]).add(Y).add($), Ne(J.x, J.y, J.z)) : Ne(Ye.x, Ye.y, x / y * ae);
        }
      for (let ae = L - 1; ae >= 0; ae--) {
        const et = ae / L, Ye = w * Math.cos(et * Math.PI / 2), Ge = R * Math.sin(et * Math.PI / 2) + U;
        for (let $e = 0, Ut = de.length; $e < Ut; $e++) {
          const nt = xe(de[$e], ve[$e], Ge);
          Ne(nt.x, nt.y, x + Ye);
        }
        for (let $e = 0, Ut = le.length; $e < Ut; $e++) {
          const nt = le[$e];
          ee = re[$e];
          for (let Ct = 0, Pt = nt.length; Ct < Pt; Ct++) {
            const vt = xe(nt[Ct], ee[Ct], Ge);
            H ? Ne(vt.x, vt.y + k[y - 1].y, k[y - 1].x + Ye) : Ne(vt.x, vt.y, x + Ye);
          }
        }
      }
      Le(), Ae();
      function Le() {
        const ae = i.length / 3;
        if (b) {
          let et = 0, Ye = _e * et;
          for (let Ge = 0; Ge < Pe; Ge++) {
            const $e = fe[Ge];
            ke($e[2] + Ye, $e[1] + Ye, $e[0] + Ye);
          }
          et = y + L * 2, Ye = _e * et;
          for (let Ge = 0; Ge < Pe; Ge++) {
            const $e = fe[Ge];
            ke($e[0] + Ye, $e[1] + Ye, $e[2] + Ye);
          }
        } else {
          for (let et = 0; et < Pe; et++) {
            const Ye = fe[et];
            ke(Ye[2], Ye[1], Ye[0]);
          }
          for (let et = 0; et < Pe; et++) {
            const Ye = fe[et];
            ke(Ye[0] + _e * y, Ye[1] + _e * y, Ye[2] + _e * y);
          }
        }
        r.addGroup(ae, i.length / 3 - ae, 0);
      }
      function Ae() {
        const ae = i.length / 3;
        let et = 0;
        Ue(de, et), et += de.length;
        for (let Ye = 0, Ge = le.length; Ye < Ge; Ye++) {
          const $e = le[Ye];
          Ue($e, et), et += $e.length;
        }
        r.addGroup(ae, i.length / 3 - ae, 1);
      }
      function Ue(ae, et) {
        let Ye = ae.length;
        for (; --Ye >= 0; ) {
          const Ge = Ye;
          let $e = Ye - 1;
          $e < 0 && ($e = ae.length - 1);
          for (let Ut = 0, nt = y + L * 2; Ut < nt; Ut++) {
            const Ct = _e * Ut, Pt = _e * (Ut + 1), vt = et + Ge + Ct, Zt = et + $e + Ct, ie = et + $e + Pt, ne = et + Ge + Pt;
            it(vt, Zt, ie, ne);
          }
        }
      }
      function Ne(ae, et, Ye) {
        h.push(ae), h.push(et), h.push(Ye);
      }
      function ke(ae, et, Ye) {
        At(ae), At(et), At(Ye);
        const Ge = i.length / 3, $e = F.generateTopUV(r, i, Ge - 3, Ge - 2, Ge - 1);
        rt($e[0]), rt($e[1]), rt($e[2]);
      }
      function it(ae, et, Ye, Ge) {
        At(ae), At(et), At(Ge), At(et), At(Ye), At(Ge);
        const $e = i.length / 3, Ut = F.generateSideWallUV(r, i, $e - 6, $e - 3, $e - 2, $e - 1);
        rt(Ut[0]), rt(Ut[1]), rt(Ut[3]), rt(Ut[1]), rt(Ut[2]), rt(Ut[3]);
      }
      function At(ae) {
        i.push(h[ae * 3 + 0]), i.push(h[ae * 3 + 1]), i.push(h[ae * 3 + 2]);
      }
      function rt(ae) {
        o.push(ae.x), o.push(ae.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return bY(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, l = e.shapes.length; o < l; o++) {
      const c = t[e.shapes[o]];
      r.push(c);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new WP[i.type]().fromJSON(i)), new h2(r, e.options);
  }
}
const EY = {
  generateTopUV: function(n, e, t, r, i) {
    const o = e[t * 3], l = e[t * 3 + 1], c = e[r * 3], h = e[r * 3 + 1], p = e[i * 3], y = e[i * 3 + 1];
    return [
      new Ht(o, l),
      new Ht(c, h),
      new Ht(p, y)
    ];
  },
  generateSideWallUV: function(n, e, t, r, i, o) {
    const l = e[t * 3], c = e[t * 3 + 1], h = e[t * 3 + 2], p = e[r * 3], y = e[r * 3 + 1], x = e[r * 3 + 2], b = e[i * 3], w = e[i * 3 + 1], R = e[i * 3 + 2], U = e[o * 3], L = e[o * 3 + 1], A = e[o * 3 + 2];
    return Math.abs(c - y) < Math.abs(l - p) ? [
      new Ht(l, 1 - h),
      new Ht(p, 1 - x),
      new Ht(b, 1 - R),
      new Ht(U, 1 - A)
    ] : [
      new Ht(c, 1 - h),
      new Ht(y, 1 - x),
      new Ht(w, 1 - R),
      new Ht(L, 1 - A)
    ];
  }
};
function bY(n, e, t) {
  if (t.shapes = [], Array.isArray(n))
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      t.shapes.push(o.uuid);
    }
  else
    t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class p2 extends A0 {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new p2(e.radius, e.detail);
  }
}
class cw extends A0 {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new cw(e.radius, e.detail);
  }
}
class m2 extends oi {
  constructor(e = 0.5, t = 1, r = 32, i = 1, o = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: i,
      thetaStart: o,
      thetaLength: l
    }, r = Math.max(3, r), i = Math.max(1, i);
    const c = [], h = [], p = [], y = [];
    let x = e;
    const b = (t - e) / i, w = new Te(), R = new Ht();
    for (let U = 0; U <= i; U++) {
      for (let L = 0; L <= r; L++) {
        const A = o + L / r * l;
        w.x = x * Math.cos(A), w.y = x * Math.sin(A), h.push(w.x, w.y, w.z), p.push(0, 0, 1), R.x = (w.x / t + 1) / 2, R.y = (w.y / t + 1) / 2, y.push(R.x, R.y);
      }
      x += b;
    }
    for (let U = 0; U < i; U++) {
      const L = U * (r + 1);
      for (let A = 0; A < r; A++) {
        const F = A + L, k = F, H = F + r + 1, B = F + r + 2, $ = F + 1;
        c.push(k, H, $), c.push(H, B, $);
      }
    }
    this.setIndex(c), this.setAttribute("position", new Yn(h, 3)), this.setAttribute("normal", new Yn(p, 3)), this.setAttribute("uv", new Yn(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new m2(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class v2 extends oi {
  constructor(e = new dx([new Ht(0, 0.5), new Ht(-0.5, -0.5), new Ht(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], i = [], o = [], l = [];
    let c = 0, h = 0;
    if (Array.isArray(e) === !1)
      p(e);
    else
      for (let y = 0; y < e.length; y++)
        p(e[y]), this.addGroup(c, h, y), c += h, h = 0;
    this.setIndex(r), this.setAttribute("position", new Yn(i, 3)), this.setAttribute("normal", new Yn(o, 3)), this.setAttribute("uv", new Yn(l, 2));
    function p(y) {
      const x = i.length / 3, b = y.extractPoints(t);
      let w = b.shape;
      const R = b.holes;
      Tv.isClockWise(w) === !1 && (w = w.reverse());
      for (let L = 0, A = R.length; L < A; L++) {
        const F = R[L];
        Tv.isClockWise(F) === !0 && (R[L] = F.reverse());
      }
      const U = Tv.triangulateShape(w, R);
      for (let L = 0, A = R.length; L < A; L++) {
        const F = R[L];
        w = w.concat(F);
      }
      for (let L = 0, A = w.length; L < A; L++) {
        const F = w[L];
        i.push(F.x, F.y, 0), o.push(0, 0, 1), l.push(F.x, F.y);
      }
      for (let L = 0, A = U.length; L < A; L++) {
        const F = U[L], k = F[0] + x, H = F[1] + x, B = F[2] + x;
        r.push(k, H, B), h += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return TY(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const l = t[e.shapes[i]];
      r.push(l);
    }
    return new v2(r, e.curveSegments);
  }
}
function TY(n, e) {
  if (e.shapes = [], Array.isArray(n))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(n.uuid);
  return e;
}
class fw extends oi {
  constructor(e = 1, t = 32, r = 16, i = 0, o = Math.PI * 2, l = 0, c = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: i,
      phiLength: o,
      thetaStart: l,
      thetaLength: c
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const h = Math.min(l + c, Math.PI);
    let p = 0;
    const y = [], x = new Te(), b = new Te(), w = [], R = [], U = [], L = [];
    for (let A = 0; A <= r; A++) {
      const F = [], k = A / r;
      let H = 0;
      A === 0 && l === 0 ? H = 0.5 / t : A === r && h === Math.PI && (H = -0.5 / t);
      for (let B = 0; B <= t; B++) {
        const $ = B / t;
        x.x = -e * Math.cos(i + $ * o) * Math.sin(l + k * c), x.y = e * Math.cos(l + k * c), x.z = e * Math.sin(i + $ * o) * Math.sin(l + k * c), R.push(x.x, x.y, x.z), b.copy(x).normalize(), U.push(b.x, b.y, b.z), L.push($ + H, 1 - k), F.push(p++);
      }
      y.push(F);
    }
    for (let A = 0; A < r; A++)
      for (let F = 0; F < t; F++) {
        const k = y[A][F + 1], H = y[A][F], B = y[A + 1][F], $ = y[A + 1][F + 1];
        (A !== 0 || l > 0) && w.push(k, H, $), (A !== r - 1 || h < Math.PI) && w.push(H, B, $);
      }
    this.setIndex(w), this.setAttribute("position", new Yn(R, 3)), this.setAttribute("normal", new Yn(U, 3)), this.setAttribute("uv", new Yn(L, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new fw(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class g2 extends A0 {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new g2(e.radius, e.detail);
  }
}
class y2 extends oi {
  constructor(e = 1, t = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: i,
      arc: o
    }, r = Math.floor(r), i = Math.floor(i);
    const l = [], c = [], h = [], p = [], y = new Te(), x = new Te(), b = new Te();
    for (let w = 0; w <= r; w++)
      for (let R = 0; R <= i; R++) {
        const U = R / i * o, L = w / r * Math.PI * 2;
        x.x = (e + t * Math.cos(L)) * Math.cos(U), x.y = (e + t * Math.cos(L)) * Math.sin(U), x.z = t * Math.sin(L), c.push(x.x, x.y, x.z), y.x = e * Math.cos(U), y.y = e * Math.sin(U), b.subVectors(x, y).normalize(), h.push(b.x, b.y, b.z), p.push(R / i), p.push(w / r);
      }
    for (let w = 1; w <= r; w++)
      for (let R = 1; R <= i; R++) {
        const U = (i + 1) * w + R - 1, L = (i + 1) * (w - 1) + R - 1, A = (i + 1) * (w - 1) + R, F = (i + 1) * w + R;
        l.push(U, L, F), l.push(L, A, F);
      }
    this.setIndex(l), this.setAttribute("position", new Yn(c, 3)), this.setAttribute("normal", new Yn(h, 3)), this.setAttribute("uv", new Yn(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new y2(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class S2 extends oi {
  constructor(e = 1, t = 0.4, r = 64, i = 8, o = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: i,
      p: o,
      q: l
    }, r = Math.floor(r), i = Math.floor(i);
    const c = [], h = [], p = [], y = [], x = new Te(), b = new Te(), w = new Te(), R = new Te(), U = new Te(), L = new Te(), A = new Te();
    for (let k = 0; k <= r; ++k) {
      const H = k / r * o * Math.PI * 2;
      F(H, o, l, e, w), F(H + 0.01, o, l, e, R), L.subVectors(R, w), A.addVectors(R, w), U.crossVectors(L, A), A.crossVectors(U, L), U.normalize(), A.normalize();
      for (let B = 0; B <= i; ++B) {
        const $ = B / i * Math.PI * 2, Y = -t * Math.cos($), J = t * Math.sin($);
        x.x = w.x + (Y * A.x + J * U.x), x.y = w.y + (Y * A.y + J * U.y), x.z = w.z + (Y * A.z + J * U.z), h.push(x.x, x.y, x.z), b.subVectors(x, w).normalize(), p.push(b.x, b.y, b.z), y.push(k / r), y.push(B / i);
      }
    }
    for (let k = 1; k <= r; k++)
      for (let H = 1; H <= i; H++) {
        const B = (i + 1) * (k - 1) + (H - 1), $ = (i + 1) * k + (H - 1), Y = (i + 1) * k + H, J = (i + 1) * (k - 1) + H;
        c.push(B, $, J), c.push($, Y, J);
      }
    this.setIndex(c), this.setAttribute("position", new Yn(h, 3)), this.setAttribute("normal", new Yn(p, 3)), this.setAttribute("uv", new Yn(y, 2));
    function F(k, H, B, $, Y) {
      const J = Math.cos(k), K = Math.sin(k), X = B / H * k, le = Math.cos(X);
      Y.x = $ * (2 + le) * 0.5 * J, Y.y = $ * (2 + le) * K * 0.5, Y.z = $ * Math.sin(X) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new S2(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class x2 extends oi {
  constructor(e = new VP(new Te(-1, -1, 0), new Te(-1, 1, 0), new Te(1, 1, 0)), t = 64, r = 1, i = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: i,
      closed: o
    };
    const l = e.computeFrenetFrames(t, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const c = new Te(), h = new Te(), p = new Ht();
    let y = new Te();
    const x = [], b = [], w = [], R = [];
    U(), this.setIndex(R), this.setAttribute("position", new Yn(x, 3)), this.setAttribute("normal", new Yn(b, 3)), this.setAttribute("uv", new Yn(w, 2));
    function U() {
      for (let k = 0; k < t; k++)
        L(k);
      L(o === !1 ? t : 0), F(), A();
    }
    function L(k) {
      y = e.getPointAt(k / t, y);
      const H = l.normals[k], B = l.binormals[k];
      for (let $ = 0; $ <= i; $++) {
        const Y = $ / i * Math.PI * 2, J = Math.sin(Y), K = -Math.cos(Y);
        h.x = K * H.x + J * B.x, h.y = K * H.y + J * B.y, h.z = K * H.z + J * B.z, h.normalize(), b.push(h.x, h.y, h.z), c.x = y.x + r * h.x, c.y = y.y + r * h.y, c.z = y.z + r * h.z, x.push(c.x, c.y, c.z);
      }
    }
    function A() {
      for (let k = 1; k <= t; k++)
        for (let H = 1; H <= i; H++) {
          const B = (i + 1) * (k - 1) + (H - 1), $ = (i + 1) * k + (H - 1), Y = (i + 1) * k + H, J = (i + 1) * (k - 1) + H;
          R.push(B, $, J), R.push($, Y, J);
        }
    }
    function F() {
      for (let k = 0; k <= t; k++)
        for (let H = 0; H <= i; H++)
          p.x = k / t, p.y = H / i, w.push(p.x, p.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new x2(
      new WP[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class K4 extends oi {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), i = new Te(), o = new Te();
      if (e.index !== null) {
        const l = e.attributes.position, c = e.index;
        let h = e.groups;
        h.length === 0 && (h = [{ start: 0, count: c.count, materialIndex: 0 }]);
        for (let p = 0, y = h.length; p < y; ++p) {
          const x = h[p], b = x.start, w = x.count;
          for (let R = b, U = b + w; R < U; R += 3)
            for (let L = 0; L < 3; L++) {
              const A = c.getX(R + L), F = c.getX(R + (L + 1) % 3);
              i.fromBufferAttribute(l, A), o.fromBufferAttribute(l, F), AF(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let c = 0, h = l.count / 3; c < h; c++)
          for (let p = 0; p < 3; p++) {
            const y = 3 * c + p, x = 3 * c + (p + 1) % 3;
            i.fromBufferAttribute(l, y), o.fromBufferAttribute(l, x), AF(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new Yn(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function AF(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var DF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Mx,
  CapsuleGeometry: l2,
  CircleGeometry: u2,
  ConeGeometry: c2,
  CylinderGeometry: rE,
  DodecahedronGeometry: f2,
  EdgesGeometry: $4,
  ExtrudeGeometry: h2,
  IcosahedronGeometry: p2,
  LatheGeometry: uw,
  OctahedronGeometry: cw,
  PlaneGeometry: R0,
  PolyhedronGeometry: A0,
  RingGeometry: m2,
  ShapeGeometry: v2,
  SphereGeometry: fw,
  TetrahedronGeometry: g2,
  TorusGeometry: y2,
  TorusKnotGeometry: S2,
  TubeGeometry: x2,
  WireframeGeometry: K4
});
class Q4 extends ic {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Rn(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class Z4 extends Mv {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class jP extends ic {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Rn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class J4 extends jP {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ht(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Os(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Rn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Rn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Rn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class eB extends ic {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Rn(16777215), this.specular = new Rn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = iw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class tB extends ic {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Rn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class nB extends ic {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class rB extends ic {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Rn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = iw, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class iB extends ic {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Rn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = C0, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class aB extends Ff {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function cp(n, e, t) {
  return $P(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t);
}
function sx(n, e, t) {
  return !n || // let 'undefined' and 'null' pass
  !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function $P(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function oB(n) {
  function e(i, o) {
    return n[i] - n[o];
  }
  const t = n.length, r = new Array(t);
  for (let i = 0; i !== t; ++i)
    r[i] = i;
  return r.sort(e), r;
}
function MO(n, e, t) {
  const r = n.length, i = new n.constructor(r);
  for (let o = 0, l = 0; l !== r; ++o) {
    const c = t[o] * e;
    for (let h = 0; h !== e; ++h)
      i[l++] = n[c + h];
  }
  return i;
}
function YP(n, e, t, r) {
  let i = 1, o = n[0];
  for (; o !== void 0 && o[r] === void 0; )
    o = n[i++];
  if (o === void 0)
    return;
  let l = o[r];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = o[r], l !== void 0 && (e.push(o.time), t.push.apply(t, l)), o = n[i++];
      while (o !== void 0);
    else if (l.toArray !== void 0)
      do
        l = o[r], l !== void 0 && (e.push(o.time), l.toArray(t, t.length)), o = n[i++];
      while (o !== void 0);
    else
      do
        l = o[r], l !== void 0 && (e.push(o.time), t.push(l)), o = n[i++];
      while (o !== void 0);
}
function wY(n, e, t, r, i = 30) {
  const o = n.clone();
  o.name = e;
  const l = [];
  for (let h = 0; h < o.tracks.length; ++h) {
    const p = o.tracks[h], y = p.getValueSize(), x = [], b = [];
    for (let w = 0; w < p.times.length; ++w) {
      const R = p.times[w] * i;
      if (!(R < t || R >= r)) {
        x.push(p.times[w]);
        for (let U = 0; U < y; ++U)
          b.push(p.values[w * y + U]);
      }
    }
    x.length !== 0 && (p.times = sx(x, p.times.constructor), p.values = sx(b, p.values.constructor), l.push(p));
  }
  o.tracks = l;
  let c = 1 / 0;
  for (let h = 0; h < o.tracks.length; ++h)
    c > o.tracks[h].times[0] && (c = o.tracks[h].times[0]);
  for (let h = 0; h < o.tracks.length; ++h)
    o.tracks[h].shift(-1 * c);
  return o.resetDuration(), o;
}
function MY(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length, o = e / r;
  for (let l = 0; l < i; ++l) {
    const c = t.tracks[l], h = c.ValueTypeName;
    if (h === "bool" || h === "string")
      continue;
    const p = n.tracks.find(function(A) {
      return A.name === c.name && A.ValueTypeName === h;
    });
    if (p === void 0)
      continue;
    let y = 0;
    const x = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (y = x / 3);
    let b = 0;
    const w = p.getValueSize();
    p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (b = w / 3);
    const R = c.times.length - 1;
    let U;
    if (o <= c.times[0]) {
      const A = y, F = x - y;
      U = cp(c.values, A, F);
    } else if (o >= c.times[R]) {
      const A = R * x + y, F = A + x - y;
      U = cp(c.values, A, F);
    } else {
      const A = c.createInterpolant(), F = y, k = x - y;
      A.evaluate(o), U = cp(A.resultBuffer, F, k);
    }
    h === "quaternion" && new Bc().fromArray(U).normalize().conjugate().toArray(U);
    const L = p.times.length;
    for (let A = 0; A < L; ++A) {
      const F = A * w + b;
      if (h === "quaternion")
        Bc.multiplyQuaternionsFlat(
          p.values,
          F,
          U,
          0,
          p.values,
          F
        );
      else {
        const k = w - b * 2;
        for (let H = 0; H < k; ++H)
          p.values[F + H] -= U[H];
      }
    }
  }
  return n.blendMode = wP, n;
}
const CY = {
  arraySlice: cp,
  convertArray: sx,
  isTypedArray: $P,
  getKeyframeOrder: oB,
  sortedArray: MO,
  flattenJSON: YP,
  subclip: wY,
  makeClipAdditive: MY
};
class dw {
  constructor(e, t, r, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex, i = t[r], o = t[r - 1];
    e: {
      t: {
        let l;
        n: {
          r:
            if (!(e < i)) {
              for (let c = r + 2; ; ) {
                if (i === void 0) {
                  if (e < o)
                    break r;
                  return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
                }
                if (r === c)
                  break;
                if (o = i, i = t[++r], e < i)
                  break t;
              }
              l = t.length;
              break n;
            }
          if (!(e >= o)) {
            const c = t[1];
            e < c && (r = 2, o = c);
            for (let h = r - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === h)
                break;
              if (i = o, o = t[--r - 1], e >= o)
                break t;
            }
            l = r, r = 0;
            break n;
          }
          break e;
        }
        for (; r < l; ) {
          const c = r + l >>> 1;
          e < t[c] ? l = c : r = c + 1;
        }
        if (i = t[r], o = t[r - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
      }
      this._cachedIndex = r, this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, o = e * i;
    for (let l = 0; l !== i; ++l)
      t[l] = r[o + l];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class sB extends dw {
  constructor(e, t, r, i) {
    super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: ix,
      endingEnd: ix
    };
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let o = e - 2, l = e + 1, c = i[o], h = i[l];
    if (c === void 0)
      switch (this.getSettings_().endingStart) {
        case ax:
          o = e, c = 2 * t - r;
          break;
        case BT:
          o = i.length - 2, c = t + i[o] - i[o + 1];
          break;
        default:
          o = e, c = r;
      }
    if (h === void 0)
      switch (this.getSettings_().endingEnd) {
        case ax:
          l = e, h = 2 * r - t;
          break;
        case BT:
          l = 1, h = r + i[1] - i[0];
          break;
        default:
          l = e - 1, h = t;
      }
    const p = (r - t) * 0.5, y = this.valueSize;
    this._weightPrev = p / (t - c), this._weightNext = p / (h - r), this._offsetPrev = o * y, this._offsetNext = l * y;
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = e * c, p = h - c, y = this._offsetPrev, x = this._offsetNext, b = this._weightPrev, w = this._weightNext, R = (r - t) / (i - t), U = R * R, L = U * R, A = -b * L + 2 * b * U - b * R, F = (1 + b) * L + (-1.5 - 2 * b) * U + (-0.5 + b) * R + 1, k = (-1 - w) * L + (1.5 + w) * U + 0.5 * R, H = w * L - w * U;
    for (let B = 0; B !== c; ++B)
      o[B] = A * l[y + B] + F * l[p + B] + k * l[h + B] + H * l[x + B];
    return o;
  }
}
class XP extends dw {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = e * c, p = h - c, y = (r - t) / (i - t), x = 1 - y;
    for (let b = 0; b !== c; ++b)
      o[b] = l[p + b] * x + l[h + b] * y;
    return o;
  }
}
class lB extends dw {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class gm {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = sx(t, this.TimeBufferType), this.values = sx(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: sx(e.times, Array),
        values: sx(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return r.type = e.ValueTypeName, r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new lB(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new XP(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new sB(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case zT:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case IT:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case mR:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return zT;
      case this.InterpolantFactoryMethodLinear:
        return IT;
      case this.InterpolantFactoryMethodSmooth:
        return mR;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const r = this.times, i = r.length;
    let o = 0, l = i - 1;
    for (; o !== i && r[o] < e; )
      ++o;
    for (; l !== -1 && r[l] > t; )
      --l;
    if (++l, o !== 0 || l !== i) {
      o >= l && (l = Math.max(l, 1), o = l - 1);
      const c = this.getValueSize();
      this.times = cp(r, o, l), this.values = cp(this.values, o * c, l * c);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const r = this.times, i = this.values, o = r.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let c = 0; c !== o; c++) {
      const h = r[c];
      if (typeof h == "number" && isNaN(h)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, c, h), e = !1;
        break;
      }
      if (l !== null && l > h) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, c, h, l), e = !1;
        break;
      }
      l = h;
    }
    if (i !== void 0 && $P(i))
      for (let c = 0, h = i.length; c !== h; ++c) {
        const p = i[c];
        if (isNaN(p)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, c, p), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = cp(this.times), t = cp(this.values), r = this.getValueSize(), i = this.getInterpolation() === mR, o = e.length - 1;
    let l = 1;
    for (let c = 1; c < o; ++c) {
      let h = !1;
      const p = e[c], y = e[c + 1];
      if (p !== y && (c !== 1 || p !== e[0]))
        if (i)
          h = !0;
        else {
          const x = c * r, b = x - r, w = x + r;
          for (let R = 0; R !== r; ++R) {
            const U = t[x + R];
            if (U !== t[b + R] || U !== t[w + R]) {
              h = !0;
              break;
            }
          }
        }
      if (h) {
        if (c !== l) {
          e[l] = e[c];
          const x = c * r, b = l * r;
          for (let w = 0; w !== r; ++w)
            t[b + w] = t[x + w];
        }
        ++l;
      }
    }
    if (o > 0) {
      e[l] = e[o];
      for (let c = o * r, h = l * r, p = 0; p !== r; ++p)
        t[h + p] = t[c + p];
      ++l;
    }
    return l !== e.length ? (this.times = cp(e, 0, l), this.values = cp(t, 0, l * r)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = cp(this.times, 0), t = cp(this.values, 0), r = this.constructor, i = new r(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
gm.prototype.TimeBufferType = Float32Array;
gm.prototype.ValueBufferType = Float32Array;
gm.prototype.DefaultInterpolation = IT;
class Cx extends gm {
}
Cx.prototype.ValueTypeName = "bool";
Cx.prototype.ValueBufferType = Array;
Cx.prototype.DefaultInterpolation = zT;
Cx.prototype.InterpolantFactoryMethodLinear = void 0;
Cx.prototype.InterpolantFactoryMethodSmooth = void 0;
class qP extends gm {
}
qP.prototype.ValueTypeName = "color";
class XT extends gm {
}
XT.prototype.ValueTypeName = "number";
class uB extends dw {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, c = this.valueSize, h = (r - t) / (i - t);
    let p = e * c;
    for (let y = p + c; p !== y; p += 4)
      Bc.slerpFlat(o, 0, l, p - c, l, p, h);
    return o;
  }
}
class iE extends gm {
  InterpolantFactoryMethodLinear(e) {
    return new uB(this.times, this.values, this.getValueSize(), e);
  }
}
iE.prototype.ValueTypeName = "quaternion";
iE.prototype.DefaultInterpolation = IT;
iE.prototype.InterpolantFactoryMethodSmooth = void 0;
class Rx extends gm {
}
Rx.prototype.ValueTypeName = "string";
Rx.prototype.ValueBufferType = Array;
Rx.prototype.DefaultInterpolation = zT;
Rx.prototype.InterpolantFactoryMethodLinear = void 0;
Rx.prototype.InterpolantFactoryMethodSmooth = void 0;
class qT extends gm {
}
qT.prototype.ValueTypeName = "vector";
class KT {
  constructor(e, t = -1, r, i = qR) {
    this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = yh(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], r = e.tracks, i = 1 / (e.fps || 1);
    for (let l = 0, c = r.length; l !== c; ++l)
      t.push(AY(r[l]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  static toJSON(e) {
    const t = [], r = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, l = r.length; o !== l; ++o)
      t.push(gm.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const o = t.length, l = [];
    for (let c = 0; c < o; c++) {
      let h = [], p = [];
      h.push(
        (c + o - 1) % o,
        c,
        (c + 1) % o
      ), p.push(0, 1, 0);
      const y = oB(h);
      h = MO(h, 1, y), p = MO(p, 1, y), !i && h[0] === 0 && (h.push(o), p.push(p[0])), l.push(
        new XT(
          ".morphTargetInfluences[" + t[c].name + "]",
          h,
          p
        ).scale(1 / r)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let c = 0, h = e.length; c < h; c++) {
      const p = e[c], y = p.name.match(o);
      if (y && y.length > 1) {
        const x = y[1];
        let b = i[x];
        b || (i[x] = b = []), b.push(p);
      }
    }
    const l = [];
    for (const c in i)
      l.push(this.CreateFromMorphTargetSequence(c, i[c], t, r));
    return l;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const r = function(x, b, w, R, U) {
      if (w.length !== 0) {
        const L = [], A = [];
        YP(w, L, A, R), L.length !== 0 && U.push(new x(b, L, A));
      }
    }, i = [], o = e.name || "default", l = e.fps || 30, c = e.blendMode;
    let h = e.length || -1;
    const p = e.hierarchy || [];
    for (let x = 0; x < p.length; x++) {
      const b = p[x].keys;
      if (!(!b || b.length === 0))
        if (b[0].morphTargets) {
          const w = {};
          let R;
          for (R = 0; R < b.length; R++)
            if (b[R].morphTargets)
              for (let U = 0; U < b[R].morphTargets.length; U++)
                w[b[R].morphTargets[U]] = -1;
          for (const U in w) {
            const L = [], A = [];
            for (let F = 0; F !== b[R].morphTargets.length; ++F) {
              const k = b[R];
              L.push(k.time), A.push(k.morphTarget === U ? 1 : 0);
            }
            i.push(new XT(".morphTargetInfluence[" + U + "]", L, A));
          }
          h = w.length * l;
        } else {
          const w = ".bones[" + t[x].name + "]";
          r(
            qT,
            w + ".position",
            b,
            "pos",
            i
          ), r(
            iE,
            w + ".quaternion",
            b,
            "rot",
            i
          ), r(
            qT,
            w + ".scale",
            b,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(o, h, i, c);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function RY(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return XT;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return qT;
    case "color":
      return qP;
    case "quaternion":
      return iE;
    case "bool":
    case "boolean":
      return Cx;
    case "string":
      return Rx;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function AY(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = RY(n.type);
  if (n.times === void 0) {
    const t = [], r = [];
    YP(n.keys, t, r, "value"), n.times = t, n.values = r;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const _x = {
  enabled: !1,
  files: {},
  add: function(n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function(n) {
    if (this.enabled !== !1)
      return this.files[n];
  },
  remove: function(n) {
    delete this.files[n];
  },
  clear: function() {
    this.files = {};
  }
};
class KP {
  constructor(e, t, r) {
    const i = this;
    let o = !1, l = 0, c = 0, h;
    const p = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(y) {
      c++, o === !1 && i.onStart !== void 0 && i.onStart(y, l, c), o = !0;
    }, this.itemEnd = function(y) {
      l++, i.onProgress !== void 0 && i.onProgress(y, l, c), l === c && (o = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(y) {
      i.onError !== void 0 && i.onError(y);
    }, this.resolveURL = function(y) {
      return h ? h(y) : y;
    }, this.setURLModifier = function(y) {
      return h = y, this;
    }, this.addHandler = function(y, x) {
      return p.push(y, x), this;
    }, this.removeHandler = function(y) {
      const x = p.indexOf(y);
      return x !== -1 && p.splice(x, 2), this;
    }, this.getHandler = function(y) {
      for (let x = 0, b = p.length; x < b; x += 2) {
        const w = p[x], R = p[x + 1];
        if (w.global && (w.lastIndex = 0), w.test(y))
          return R;
      }
      return null;
    };
  }
}
const cB = /* @__PURE__ */ new KP();
class Cd {
  constructor(e) {
    this.manager = e !== void 0 ? e : cB, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const r = this;
    return new Promise(function(i, o) {
      r.load(e, i, t, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Cd.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ng = {};
class DY extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class $g extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = _x.get(e);
    if (o !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(o), this.manager.itemEnd(e);
      }, 0), o;
    if (Ng[e] !== void 0) {
      Ng[e].push({
        onLoad: t,
        onProgress: r,
        onError: i
      });
      return;
    }
    Ng[e] = [], Ng[e].push({
      onLoad: t,
      onProgress: r,
      onError: i
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), c = this.mimeType, h = this.responseType;
    fetch(l).then((p) => {
      if (p.status === 200 || p.status === 0) {
        if (p.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || p.body === void 0 || p.body.getReader === void 0)
          return p;
        const y = Ng[e], x = p.body.getReader(), b = p.headers.get("Content-Length") || p.headers.get("X-File-Size"), w = b ? parseInt(b) : 0, R = w !== 0;
        let U = 0;
        const L = new ReadableStream({
          start(A) {
            F();
            function F() {
              x.read().then(({ done: k, value: H }) => {
                if (k)
                  A.close();
                else {
                  U += H.byteLength;
                  const B = new ProgressEvent("progress", { lengthComputable: R, loaded: U, total: w });
                  for (let $ = 0, Y = y.length; $ < Y; $++) {
                    const J = y[$];
                    J.onProgress && J.onProgress(B);
                  }
                  A.enqueue(H), F();
                }
              });
            }
          }
        });
        return new Response(L);
      } else
        throw new DY(`fetch for "${p.url}" responded with ${p.status}: ${p.statusText}`, p);
    }).then((p) => {
      switch (h) {
        case "arraybuffer":
          return p.arrayBuffer();
        case "blob":
          return p.blob();
        case "document":
          return p.text().then((y) => new DOMParser().parseFromString(y, c));
        case "json":
          return p.json();
        default:
          if (c === void 0)
            return p.text();
          {
            const x = /charset="?([^;"\s]*)"?/i.exec(c), b = x && x[1] ? x[1].toLowerCase() : void 0, w = new TextDecoder(b);
            return p.arrayBuffer().then((R) => w.decode(R));
          }
      }
    }).then((p) => {
      _x.add(e, p);
      const y = Ng[e];
      delete Ng[e];
      for (let x = 0, b = y.length; x < b; x++) {
        const w = y[x];
        w.onLoad && w.onLoad(p);
      }
    }).catch((p) => {
      const y = Ng[e];
      if (y === void 0)
        throw this.manager.itemError(e), p;
      delete Ng[e];
      for (let x = 0, b = y.length; x < b; x++) {
        const w = y[x];
        w.onError && w.onError(p);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class LY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new $g(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        t(o.parse(JSON.parse(c)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = KT.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class OY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = [], c = new a2(), h = new $g(this.manager);
    h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(o.withCredentials);
    let p = 0;
    function y(x) {
      h.load(e[x], function(b) {
        const w = o.parse(b, !0);
        l[x] = {
          width: w.width,
          height: w.height,
          format: w.format,
          mipmaps: w.mipmaps
        }, p += 1, p === 6 && (w.mipmapCount === 1 && (c.minFilter = ss), c.image = l, c.format = w.format, c.needsUpdate = !0, t && t(c));
      }, r, i);
    }
    if (Array.isArray(e))
      for (let x = 0, b = e.length; x < b; ++x)
        y(x);
    else
      h.load(e, function(x) {
        const b = o.parse(x, !0);
        if (b.isCubemap) {
          const w = b.mipmaps.length / b.mipmapCount;
          for (let R = 0; R < w; R++) {
            l[R] = { mipmaps: [] };
            for (let U = 0; U < b.mipmapCount; U++)
              l[R].mipmaps.push(b.mipmaps[R * b.mipmapCount + U]), l[R].format = b.format, l[R].width = b.width, l[R].height = b.height;
          }
          c.image = l;
        } else
          c.image.width = b.width, c.image.height = b.height, c.mipmaps = b.mipmaps;
        b.mipmapCount === 1 && (c.minFilter = ss), c.format = b.format, c.needsUpdate = !0, t && t(c);
      }, r, i);
    return c;
  }
}
class QT extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = _x.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const c = GT("img");
    function h() {
      y(), _x.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function p(x) {
      y(), i && i(x), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function y() {
      c.removeEventListener("load", h, !1), c.removeEventListener("error", p, !1);
    }
    return c.addEventListener("load", h, !1), c.addEventListener("error", p, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (c.crossOrigin = this.crossOrigin), o.manager.itemStart(e), c.src = e, c;
  }
}
class PY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new lw();
    o.colorSpace = go;
    const l = new QT(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let c = 0;
    function h(p) {
      l.load(e[p], function(y) {
        o.images[p] = y, c++, c === 6 && (o.needsUpdate = !0, t && t(o));
      }, void 0, i);
    }
    for (let p = 0; p < e.length; ++p)
      h(p);
    return o;
  }
}
class UY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new j1(), c = new $g(this.manager);
    return c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(o.withCredentials), c.load(e, function(h) {
      let p;
      try {
        p = o.parse(h);
      } catch (y) {
        if (i !== void 0)
          i(y);
        else {
          console.error(y);
          return;
        }
      }
      p.image !== void 0 ? l.image = p.image : p.data !== void 0 && (l.image.width = p.width, l.image.height = p.height, l.image.data = p.data), l.wrapS = p.wrapS !== void 0 ? p.wrapS : kc, l.wrapT = p.wrapT !== void 0 ? p.wrapT : kc, l.magFilter = p.magFilter !== void 0 ? p.magFilter : ss, l.minFilter = p.minFilter !== void 0 ? p.minFilter : ss, l.anisotropy = p.anisotropy !== void 0 ? p.anisotropy : 1, p.colorSpace !== void 0 ? l.colorSpace = p.colorSpace : p.encoding !== void 0 && (l.encoding = p.encoding), p.flipY !== void 0 && (l.flipY = p.flipY), p.format !== void 0 && (l.format = p.format), p.type !== void 0 && (l.type = p.type), p.mipmaps !== void 0 && (l.mipmaps = p.mipmaps, l.minFilter = x0), p.mipmapCount === 1 && (l.minFilter = ss), p.generateMipmaps !== void 0 && (l.generateMipmaps = p.generateMipmaps), l.needsUpdate = !0, t && t(l, p);
    }, r, i), l;
  }
}
class NY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new cs(), l = new QT(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(c) {
      o.image = c, o.needsUpdate = !0, t !== void 0 && t(o);
    }, r, i), o;
  }
}
class D0 extends aa {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Rn(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class fB extends D0 {
  constructor(e, t, r) {
    super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(aa.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Rn(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const nL = /* @__PURE__ */ new Gr(), LF = /* @__PURE__ */ new Te(), OF = /* @__PURE__ */ new Te();
class QP {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ht(512, 512), this.map = null, this.mapPass = null, this.matrix = new Gr(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new QR(), this._frameExtents = new Ht(1, 1), this._viewportCount = 1, this._viewports = [
      new ua(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, r = this.matrix;
    LF.setFromMatrixPosition(e.matrixWorld), t.position.copy(LF), OF.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(OF), t.updateMatrixWorld(), nL.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(nL), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(nL);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class FY extends QP {
  constructor() {
    super(new Ps(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, r = q1 * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, o = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = r, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class dB extends D0 {
  constructor(e, t, r = 0, i = Math.PI / 3, o = 0, l = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(aa.DEFAULT_UP), this.updateMatrix(), this.target = new aa(), this.distance = r, this.angle = i, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new FY();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const PF = /* @__PURE__ */ new Gr(), dT = /* @__PURE__ */ new Te(), rL = /* @__PURE__ */ new Te();
class kY extends QP {
  constructor() {
    super(new Ps(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ht(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new ua(2, 1, 1, 1),
      // negative X
      new ua(0, 1, 1, 1),
      // positive Z
      new ua(3, 1, 1, 1),
      // negative Z
      new ua(1, 1, 1, 1),
      // positive Y
      new ua(3, 0, 1, 1),
      // negative Y
      new ua(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Te(1, 0, 0),
      new Te(-1, 0, 0),
      new Te(0, 0, 1),
      new Te(0, 0, -1),
      new Te(0, 1, 0),
      new Te(0, -1, 0)
    ], this._cubeUps = [
      new Te(0, 1, 0),
      new Te(0, 1, 0),
      new Te(0, 1, 0),
      new Te(0, 1, 0),
      new Te(0, 0, 1),
      new Te(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const r = this.camera, i = this.matrix, o = e.distance || r.far;
    o !== r.far && (r.far = o, r.updateProjectionMatrix()), dT.setFromMatrixPosition(e.matrixWorld), r.position.copy(dT), rL.copy(r.position), rL.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(rL), r.updateMatrixWorld(), i.makeTranslation(-dT.x, -dT.y, -dT.z), PF.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(PF);
  }
}
class hB extends D0 {
  constructor(e, t, r = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new kY();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class zY extends QP {
  constructor() {
    super(new Vg(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class pB extends D0 {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(aa.DEFAULT_UP), this.updateMatrix(), this.target = new aa(), this.shadow = new zY();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class mB extends D0 {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class vB extends D0 {
  constructor(e, t, r = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class gB {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new Te());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const r = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * r), t.addScaledVector(l[4], 1.092548 * (r * i)), t.addScaledVector(l[5], 1.092548 * (i * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (r * o)), t.addScaledVector(l[8], 0.546274 * (r * r - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const r = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * r), t.addScaledVector(l[4], 2 * 0.429043 * r * i), t.addScaledVector(l[5], 2 * 0.429043 * i * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * r * o), t.addScaledVector(l[8], 0.429043 * (r * r - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const r = e.x, i = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * o, t[3] = 0.488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * r * o, t[8] = 0.546274 * (r * r - i * i);
  }
}
class _2 extends D0 {
  constructor(e = new gB(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class E2 extends Cd {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, i) {
    const o = this, l = new $g(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(c) {
      try {
        t(o.parse(JSON.parse(c)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o];
    }
    const i = E2.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Rn().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const o in e.uniforms) {
        const l = e.uniforms[o];
        switch (i.uniforms[o] = {}, l.type) {
          case "t":
            i.uniforms[o].value = r(l.value);
            break;
          case "c":
            i.uniforms[o].value = new Rn().setHex(l.value);
            break;
          case "v2":
            i.uniforms[o].value = new Ht().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[o].value = new Te().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[o].value = new ua().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[o].value = new ii().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[o].value = new Gr().fromArray(l.value);
            break;
          default:
            i.uniforms[o].value = l.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const o in e.extensions)
        i.extensions[o] = e.extensions[o];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), i.normalScale = new Ht().fromArray(o);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Ht().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: Q4,
      SpriteMaterial: FP,
      RawShaderMaterial: Z4,
      ShaderMaterial: Mv,
      PointsMaterial: zP,
      MeshPhysicalMaterial: J4,
      MeshStandardMaterial: jP,
      MeshPhongMaterial: eB,
      MeshToonMaterial: tB,
      MeshNormalMaterial: nB,
      MeshLambertMaterial: rB,
      MeshDepthMaterial: JR,
      MeshDistanceMaterial: e2,
      MeshBasicMaterial: Qg,
      MeshMatcapMaterial: iB,
      LineDashedMaterial: aB,
      LineBasicMaterial: Ff,
      Material: ic
    };
    return new t[e]();
  }
}
class CO {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class ZP extends oi {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class yB extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new $g(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(c) {
      try {
        t(o.parse(JSON.parse(c)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = {}, r = {};
    function i(w, R) {
      if (t[R] !== void 0)
        return t[R];
      const L = w.interleavedBuffers[R], A = o(w, L.buffer), F = F1(L.type, A), k = new r2(F, L.stride);
      return k.uuid = L.uuid, t[R] = k, k;
    }
    function o(w, R) {
      if (r[R] !== void 0)
        return r[R];
      const L = w.arrayBuffers[R], A = new Uint32Array(L).buffer;
      return r[R] = A, A;
    }
    const l = e.isInstancedBufferGeometry ? new ZP() : new oi(), c = e.data.index;
    if (c !== void 0) {
      const w = F1(c.type, c.array);
      l.setIndex(new io(w, 1));
    }
    const h = e.data.attributes;
    for (const w in h) {
      const R = h[w];
      let U;
      if (R.isInterleavedBufferAttribute) {
        const L = i(e.data, R.data);
        U = new yx(L, R.itemSize, R.offset, R.normalized);
      } else {
        const L = F1(R.type, R.array), A = R.isInstancedBufferAttribute ? Sx : io;
        U = new A(L, R.itemSize, R.normalized);
      }
      R.name !== void 0 && (U.name = R.name), R.usage !== void 0 && U.setUsage(R.usage), R.updateRange !== void 0 && (U.updateRange.offset = R.updateRange.offset, U.updateRange.count = R.updateRange.count), l.setAttribute(w, U);
    }
    const p = e.data.morphAttributes;
    if (p)
      for (const w in p) {
        const R = p[w], U = [];
        for (let L = 0, A = R.length; L < A; L++) {
          const F = R[L];
          let k;
          if (F.isInterleavedBufferAttribute) {
            const H = i(e.data, F.data);
            k = new yx(H, F.itemSize, F.offset, F.normalized);
          } else {
            const H = F1(F.type, F.array);
            k = new io(H, F.itemSize, F.normalized);
          }
          F.name !== void 0 && (k.name = F.name), U.push(k);
        }
        l.morphAttributes[w] = U;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const x = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (x !== void 0)
      for (let w = 0, R = x.length; w !== R; ++w) {
        const U = x[w];
        l.addGroup(U.start, U.count, U.materialIndex);
      }
    const b = e.data.boundingSphere;
    if (b !== void 0) {
      const w = new Te();
      b.center !== void 0 && w.fromArray(b.center), l.boundingSphere = new vp(w, b.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class IY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = this.path === "" ? CO.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const c = new $g(this.manager);
    c.setPath(this.path), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(h) {
      let p = null;
      try {
        p = JSON.parse(h);
      } catch (x) {
        i !== void 0 && i(x), console.error("THREE:ObjectLoader: Can't parse " + e + ".", x.message);
        return;
      }
      const y = p.metadata;
      if (y === void 0 || y.type === void 0 || y.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      o.parse(p, t);
    }, r, i);
  }
  async loadAsync(e, t) {
    const r = this, i = this.path === "" ? CO.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new $g(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const l = await o.loadAsync(e, t), c = JSON.parse(l), h = c.metadata;
    if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(c);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
      t !== void 0 && t(p);
    }), c = this.parseTextures(e.textures, l), h = this.parseMaterials(e.materials, c), p = this.parseObject(e.object, o, h, c, r), y = this.parseSkeletons(e.skeletons, p);
    if (this.bindSkeletons(p, y), t !== void 0) {
      let x = !1;
      for (const b in l)
        if (l[b].data instanceof HTMLImageElement) {
          x = !0;
          break;
        }
      x === !1 && t(p);
    }
    return p;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), o = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, o), c = this.parseMaterials(e.materials, l), h = this.parseObject(e.object, i, c, l, t), p = this.parseSkeletons(e.skeletons, h);
    return this.bindSkeletons(h, p), h;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new dx().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {}, i = {};
    if (t.traverse(function(o) {
      o.isBone && (i[o.uuid] = o);
    }), e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const c = new i2().fromJSON(e[o], i);
        r[c.uuid] = c;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new yB();
      for (let o = 0, l = e.length; o < l; o++) {
        let c;
        const h = e[o];
        switch (h.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            c = i.parse(h);
            break;
          default:
            h.type in DF ? c = DF[h.type].fromJSON(h, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${h.type}"`);
        }
        c.uuid = h.uuid, h.name !== void 0 && (c.name = h.name), h.userData !== void 0 && (c.userData = h.userData), r[h.uuid] = c;
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {}, i = {};
    if (e !== void 0) {
      const o = new E2();
      o.setTextures(t);
      for (let l = 0, c = e.length; l < c; l++) {
        const h = e[l];
        r[h.uuid] === void 0 && (r[h.uuid] = o.parse(h)), i[h.uuid] = r[h.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r], o = KT.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this, i = {};
    let o;
    function l(h) {
      return r.manager.itemStart(h), o.load(h, function() {
        r.manager.itemEnd(h);
      }, void 0, function() {
        r.manager.itemError(h), r.manager.itemEnd(h);
      });
    }
    function c(h) {
      if (typeof h == "string") {
        const p = h, y = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : r.resourcePath + p;
        return l(y);
      } else
        return h.data ? {
          data: F1(h.type, h.data),
          width: h.width,
          height: h.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const h = new KP(t);
      o = new QT(h), o.setCrossOrigin(this.crossOrigin);
      for (let p = 0, y = e.length; p < y; p++) {
        const x = e[p], b = x.url;
        if (Array.isArray(b)) {
          const w = [];
          for (let R = 0, U = b.length; R < U; R++) {
            const L = b[R], A = c(L);
            A !== null && (A instanceof HTMLImageElement ? w.push(A) : w.push(new j1(A.data, A.width, A.height)));
          }
          i[x.uuid] = new ox(w);
        } else {
          const w = c(x.url);
          i[x.uuid] = new ox(w);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, r = {};
    let i;
    async function o(l) {
      if (typeof l == "string") {
        const c = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : t.resourcePath + c;
        return await i.loadAsync(h);
      } else
        return l.data ? {
          data: F1(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new QT(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, c = e.length; l < c; l++) {
        const h = e[l], p = h.url;
        if (Array.isArray(p)) {
          const y = [];
          for (let x = 0, b = p.length; x < b; x++) {
            const w = p[x], R = await o(w);
            R !== null && (R instanceof HTMLImageElement ? y.push(R) : y.push(new j1(R.data, R.width, R.height)));
          }
          r[h.uuid] = new ox(y);
        } else {
          const y = await o(h.url);
          r[h.uuid] = new ox(y);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, l) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), l[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const c = e[o];
        c.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', c.uuid), t[c.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", c.image);
        const h = t[c.image], p = h.data;
        let y;
        Array.isArray(p) ? (y = new lw(), p.length === 6 && (y.needsUpdate = !0)) : (p && p.data ? y = new j1() : y = new cs(), p && (y.needsUpdate = !0)), y.source = h, y.uuid = c.uuid, c.name !== void 0 && (y.name = c.name), c.mapping !== void 0 && (y.mapping = r(c.mapping, BY)), c.channel !== void 0 && (y.channel = c.channel), c.offset !== void 0 && y.offset.fromArray(c.offset), c.repeat !== void 0 && y.repeat.fromArray(c.repeat), c.center !== void 0 && y.center.fromArray(c.center), c.rotation !== void 0 && (y.rotation = c.rotation), c.wrap !== void 0 && (y.wrapS = r(c.wrap[0], UF), y.wrapT = r(c.wrap[1], UF)), c.format !== void 0 && (y.format = c.format), c.internalFormat !== void 0 && (y.internalFormat = c.internalFormat), c.type !== void 0 && (y.type = c.type), c.colorSpace !== void 0 && (y.colorSpace = c.colorSpace), c.encoding !== void 0 && (y.encoding = c.encoding), c.minFilter !== void 0 && (y.minFilter = r(c.minFilter, NF)), c.magFilter !== void 0 && (y.magFilter = r(c.magFilter, NF)), c.anisotropy !== void 0 && (y.anisotropy = c.anisotropy), c.flipY !== void 0 && (y.flipY = c.flipY), c.generateMipmaps !== void 0 && (y.generateMipmaps = c.generateMipmaps), c.premultiplyAlpha !== void 0 && (y.premultiplyAlpha = c.premultiplyAlpha), c.unpackAlignment !== void 0 && (y.unpackAlignment = c.unpackAlignment), c.compareFunction !== void 0 && (y.compareFunction = c.compareFunction), c.userData !== void 0 && (y.userData = c.userData), i[c.uuid] = y;
      }
    return i;
  }
  parseObject(e, t, r, i, o) {
    let l;
    function c(b) {
      return t[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", b), t[b];
    }
    function h(b) {
      if (b !== void 0) {
        if (Array.isArray(b)) {
          const w = [];
          for (let R = 0, U = b.length; R < U; R++) {
            const L = b[R];
            r[L] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", L), w.push(r[L]);
          }
          return w;
        }
        return r[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", b), r[b];
      }
    }
    function p(b) {
      return i[b] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", b), i[b];
    }
    let y, x;
    switch (e.type) {
      case "Scene":
        l = new CR(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new Rn(e.background) : l.background = p(e.background)), e.environment !== void 0 && (l.environment = p(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new n2(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new t2(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (l.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (l.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        l = new Ps(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new Vg(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new mB(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new pB(e.color, e.intensity);
        break;
      case "PointLight":
        l = new hB(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new vB(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new dB(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        l = new fB(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new _2().fromJSON(e);
        break;
      case "SkinnedMesh":
        y = c(e.geometry), x = h(e.material), l = new k4(y, x), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        y = c(e.geometry), x = h(e.material), l = new Al(y, x);
        break;
      case "InstancedMesh":
        y = c(e.geometry), x = h(e.material);
        const b = e.count, w = e.instanceMatrix, R = e.instanceColor;
        l = new z4(y, x, b), l.instanceMatrix = new Sx(new Float32Array(w.array), 16), R !== void 0 && (l.instanceColor = new Sx(new Float32Array(R.array), R.itemSize));
        break;
      case "LOD":
        l = new F4();
        break;
      case "Line":
        l = new _0(c(e.geometry), h(e.material));
        break;
      case "LineLoop":
        l = new I4(c(e.geometry), h(e.material));
        break;
      case "LineSegments":
        l = new Dv(c(e.geometry), h(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new B4(c(e.geometry), h(e.material));
        break;
      case "Sprite":
        l = new N4(h(e.material));
        break;
      case "Group":
        l = new z1();
        break;
      case "Bone":
        l = new kP();
        break;
      default:
        l = new aa();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.up !== void 0 && l.up.fromArray(e.up), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const b = e.children;
      for (let w = 0; w < b.length; w++)
        l.add(this.parseObject(b[w], t, r, i, o));
    }
    if (e.animations !== void 0) {
      const b = e.animations;
      for (let w = 0; w < b.length; w++) {
        const R = b[w];
        l.animations.push(o[R]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const b = e.levels;
      for (let w = 0; w < b.length; w++) {
        const R = b[w], U = l.getObjectByProperty("uuid", R.object);
        U !== void 0 && l.addLevel(U, R.distance, R.hysteresis);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(r) {
      if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
        const i = t[r.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix);
      }
    });
  }
}
const BY = {
  UVMapping: YR,
  CubeReflectionMapping: jg,
  CubeRefractionMapping: S0,
  EquirectangularReflectionMapping: UT,
  EquirectangularRefractionMapping: NT,
  CubeUVReflectionMapping: tE
}, UF = {
  RepeatWrapping: FT,
  ClampToEdgeWrapping: kc,
  MirroredRepeatWrapping: kT
}, NF = {
  NearestFilter: ol,
  NearestMipmapNearestFilter: TR,
  NearestMipmapLinearFilter: TT,
  LinearFilter: ss,
  LinearMipmapNearestFilter: yP,
  LinearMipmapLinearFilter: x0
};
class HY extends Cd {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = _x.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const c = {};
    c.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", c.headers = this.requestHeader, fetch(e, c).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(o.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      _x.add(e, h), t && t(h), o.manager.itemEnd(e);
    }).catch(function(h) {
      i && i(h), o.manager.itemError(e), o.manager.itemEnd(e);
    }), o.manager.itemStart(e);
  }
}
let VC;
class JP {
  static getContext() {
    return VC === void 0 && (VC = new (window.AudioContext || window.webkitAudioContext)()), VC;
  }
  static setContext(e) {
    VC = e;
  }
}
class VY extends Cd {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new $g(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(h) {
      try {
        const p = h.slice(0);
        JP.getContext().decodeAudioData(p, function(x) {
          t(x);
        }, c);
      } catch (p) {
        c(p);
      }
    }, r, i);
    function c(h) {
      i ? i(h) : console.error(h), o.manager.itemError(e);
    }
  }
}
class GY extends _2 {
  constructor(e, t, r = 1) {
    super(void 0, r), this.isHemisphereLightProbe = !0;
    const i = new Rn().set(e), o = new Rn().set(t), l = new Te(i.r, i.g, i.b), c = new Te(o.r, o.g, o.b), h = Math.sqrt(Math.PI), p = h * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(l).add(c).multiplyScalar(h), this.sh.coefficients[1].copy(l).sub(c).multiplyScalar(p);
  }
}
class WY extends _2 {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const r = new Rn().set(e);
    this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const FF = /* @__PURE__ */ new Gr(), kF = /* @__PURE__ */ new Gr(), YS = /* @__PURE__ */ new Gr();
class jY {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ps(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ps(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, YS.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, o = i * t.near / t.focus, l = t.near * Math.tan(cx * t.fov * 0.5) / t.zoom;
      let c, h;
      kF.elements[12] = -i, FF.elements[12] = i, c = -l * t.aspect + o, h = l * t.aspect + o, YS.elements[0] = 2 * t.near / (h - c), YS.elements[8] = (h + c) / (h - c), this.cameraL.projectionMatrix.copy(YS), c = -l * t.aspect - o, h = l * t.aspect - o, YS.elements[0] = 2 * t.near / (h - c), YS.elements[8] = (h + c) / (h - c), this.cameraR.projectionMatrix.copy(YS);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kF), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(FF);
  }
}
class e3 {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = zF(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = zF();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function zF() {
  return (typeof performance > "u" ? Date : performance).now();
}
const XS = /* @__PURE__ */ new Te(), IF = /* @__PURE__ */ new Bc(), $Y = /* @__PURE__ */ new Te(), qS = /* @__PURE__ */ new Te();
class YY extends aa {
  constructor() {
    super(), this.type = "AudioListener", this.context = JP.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new e3();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(XS, IF, $Y), qS.set(0, 0, -1).applyQuaternion(IF), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(XS.x, i), t.positionY.linearRampToValueAtTime(XS.y, i), t.positionZ.linearRampToValueAtTime(XS.z, i), t.forwardX.linearRampToValueAtTime(qS.x, i), t.forwardY.linearRampToValueAtTime(qS.y, i), t.forwardZ.linearRampToValueAtTime(qS.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(XS.x, XS.y, XS.z), t.setOrientation(qS.x, qS.y, qS.z, r.x, r.y, r.z);
  }
}
class SB extends aa {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const KS = /* @__PURE__ */ new Te(), BF = /* @__PURE__ */ new Bc(), XY = /* @__PURE__ */ new Te(), QS = /* @__PURE__ */ new Te();
class qY extends SB {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(KS, BF, XY), QS.set(0, 0, 1).applyQuaternion(BF);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(KS.x, r), t.positionY.linearRampToValueAtTime(KS.y, r), t.positionZ.linearRampToValueAtTime(KS.z, r), t.orientationX.linearRampToValueAtTime(QS.x, r), t.orientationY.linearRampToValueAtTime(QS.y, r), t.orientationZ.linearRampToValueAtTime(QS.z, r);
    } else
      t.setPosition(KS.x, KS.y, KS.z), t.setOrientation(QS.x, QS.y, QS.z);
  }
}
class KY {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
}
class xB {
  constructor(e, t, r) {
    this.binding = e, this.valueSize = r;
    let i, o, l;
    switch (t) {
      case "quaternion":
        i = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
        break;
      default:
        i = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const r = this.buffer, i = this.valueSize, o = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let c = 0; c !== i; ++c)
        r[o + c] = r[c];
      l = t;
    } else {
      l += t;
      const c = t / l;
      this._mixBufferRegion(r, o, 0, c, i);
    }
    this.cumulativeWeight = l;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, r = this.valueSize, i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, r = this.buffer, i = e * t + t, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, c = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const h = t * this._origIndex;
      this._mixBufferRegion(
        r,
        i,
        h,
        1 - o,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let h = t, p = t + t; h !== p; ++h)
      if (r[h] !== r[h + t]) {
        c.setValue(r, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex;
    e.getValue(t, i);
    for (let o = r, l = i; o !== l; ++o)
      t[o] = t[i + o % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let r = e; r < t; r++)
      this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  // mix functions
  _select(e, t, r, i, o) {
    if (i >= 0.5)
      for (let l = 0; l !== o; ++l)
        e[t + l] = e[r + l];
  }
  _slerp(e, t, r, i) {
    Bc.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, o) {
    const l = this._workIndex * o;
    Bc.multiplyQuaternionsFlat(e, l, e, t, e, r), Bc.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, r, i, o) {
    const l = 1 - i;
    for (let c = 0; c !== o; ++c) {
      const h = t + c;
      e[h] = e[h] * l + e[r + c] * i;
    }
  }
  _lerpAdditive(e, t, r, i, o) {
    for (let l = 0; l !== o; ++l) {
      const c = t + l;
      e[c] = e[c] + e[r + l] * i;
    }
  }
}
const t3 = "\\[\\]\\.:\\/", QY = new RegExp("[" + t3 + "]", "g"), n3 = "[^" + t3 + "]", ZY = "[^" + t3.replace("\\.", "") + "]", JY = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", n3), eX = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", ZY), tX = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", n3), nX = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", n3), rX = new RegExp(
  "^" + JY + eX + tX + nX + "$"
), iX = ["material", "materials", "bones", "map"];
class aX {
  constructor(e, t, r) {
    const i = r || Zi.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_, i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class Zi {
  constructor(e, t, r) {
    this.path = t, this.parsedPath = r || Zi.parseTrackName(t), this.node = Zi.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup ? new Zi.Composite(e, t, r) : new Zi(e, t, r);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(QY, "");
  }
  static parseTrackName(e) {
    const t = rX.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      iX.indexOf(o) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = o);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      const r = function(o) {
        for (let l = 0; l < o.length; l++) {
          const c = o[l];
          if (c.name === t || c.uuid === t)
            return c;
          const h = r(c.children);
          if (h)
            return h;
        }
        return null;
      }, i = r(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, r = t.objectName, i = t.propertyName;
    let o = t.propertyIndex;
    if (e || (e = Zi.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (r) {
      let p = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let y = 0; y < e.length; y++)
            if (e[y].name === p) {
              p = y;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (p !== void 0) {
        if (e[p] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[p];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const p = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + p + "." + i + " but it wasn't found.", e);
      return;
    }
    let c = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? c = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (c = this.Versioning.MatrixWorldNeedsUpdate);
    let h = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
    } else
      l.fromArray !== void 0 && l.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Zi.Composite = aX;
Zi.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Zi.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Zi.prototype.GetterByBindingType = [
  Zi.prototype._getValue_direct,
  Zi.prototype._getValue_array,
  Zi.prototype._getValue_arrayElement,
  Zi.prototype._getValue_toArray
];
Zi.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Zi.prototype._setValue_direct,
    Zi.prototype._setValue_direct_setNeedsUpdate,
    Zi.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Zi.prototype._setValue_array,
    Zi.prototype._setValue_array_setNeedsUpdate,
    Zi.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Zi.prototype._setValue_arrayElement,
    Zi.prototype._setValue_arrayElement_setNeedsUpdate,
    Zi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Zi.prototype._setValue_fromArray,
    Zi.prototype._setValue_fromArray_setNeedsUpdate,
    Zi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class oX {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = yh(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, o = this._bindings, l = o.length;
    let c, h = e.length, p = this.nCachedObjects_;
    for (let y = 0, x = arguments.length; y !== x; ++y) {
      const b = arguments[y], w = b.uuid;
      let R = t[w];
      if (R === void 0) {
        R = h++, t[w] = R, e.push(b);
        for (let U = 0, L = l; U !== L; ++U)
          o[U].push(new Zi(b, r[U], i[U]));
      } else if (R < p) {
        c = e[R];
        const U = --p, L = e[U];
        t[L.uuid] = R, e[R] = L, t[w] = U, e[U] = b;
        for (let A = 0, F = l; A !== F; ++A) {
          const k = o[A], H = k[U];
          let B = k[R];
          k[R] = H, B === void 0 && (B = new Zi(b, r[A], i[A])), k[U] = B;
        }
      } else
        e[R] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = p;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let o = this.nCachedObjects_;
    for (let l = 0, c = arguments.length; l !== c; ++l) {
      const h = arguments[l], p = h.uuid, y = t[p];
      if (y !== void 0 && y >= o) {
        const x = o++, b = e[x];
        t[b.uuid] = y, e[y] = b, t[p] = x, e[x] = h;
        for (let w = 0, R = i; w !== R; ++w) {
          const U = r[w], L = U[x], A = U[y];
          U[y] = L, U[x] = A;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let o = this.nCachedObjects_, l = e.length;
    for (let c = 0, h = arguments.length; c !== h; ++c) {
      const p = arguments[c], y = p.uuid, x = t[y];
      if (x !== void 0)
        if (delete t[y], x < o) {
          const b = --o, w = e[b], R = --l, U = e[R];
          t[w.uuid] = x, e[x] = w, t[U.uuid] = b, e[b] = U, e.pop();
          for (let L = 0, A = i; L !== A; ++L) {
            const F = r[L], k = F[b], H = F[R];
            F[x] = k, F[b] = H, F.pop();
          }
        } else {
          const b = --l, w = e[b];
          b > 0 && (t[w.uuid] = x), e[x] = w, e.pop();
          for (let R = 0, U = i; R !== U; ++R) {
            const L = r[R];
            L[x] = L[b], L.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0)
      return o[i];
    const l = this._paths, c = this._parsedPaths, h = this._objects, p = h.length, y = this.nCachedObjects_, x = new Array(p);
    i = o.length, r[e] = i, l.push(e), c.push(t), o.push(x);
    for (let b = y, w = h.length; b !== w; ++b) {
      const R = h[b];
      x[b] = new Zi(R, e, t);
    }
    return x;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      const i = this._paths, o = this._parsedPaths, l = this._bindings, c = l.length - 1, h = l[c], p = e[c];
      t[p] = r, l[r] = h, l.pop(), o[r] = o[c], o.pop(), i[r] = i[c], i.pop();
    }
  }
}
class _B {
  constructor(e, t, r = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i;
    const o = t.tracks, l = o.length, c = new Array(l), h = {
      endingStart: ix,
      endingEnd: ix
    };
    for (let p = 0; p !== l; ++p) {
      const y = o[p].createInterpolant(null);
      c[p] = y, y.settings = h;
    }
    this._interpolantSettings = h, this._interpolants = c, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = r4, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      const i = this._clip.duration, o = e._clip.duration, l = o / i, c = i / o;
      e.warp(1, l, t), this.warp(c, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer, o = i.time, l = this.timeScale;
    let c = this._timeScaleInterpolant;
    c === null && (c = i._lendControlInterpolant(), this._timeScaleInterpolant = c);
    const h = c.parameterPositions, p = c.sampleValues;
    return h[0] = o, h[1] = o + r, p[0] = e / l, p[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const h = (e - o) * r;
      h < 0 || r === 0 ? t = 0 : (this._startTime = null, t = r * h);
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), c = this._updateWeight(e);
    if (c > 0) {
      const h = this._interpolants, p = this._propertyBindings;
      switch (this.blendMode) {
        case wP:
          for (let y = 0, x = h.length; y !== x; ++y)
            h[y].evaluate(l), p[y].accumulateAdditive(c);
          break;
        case qR:
        default:
          for (let y = 0, x = h.length; y !== x; ++y)
            h[y].evaluate(l), p[y].accumulate(i, c);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, r = this.loop;
    let i = this.time + e, o = this._loopCount;
    const l = r === i4;
    if (e === 0)
      return o === -1 ? i : l && (o & 1) === 1 ? t - i : i;
    if (r === n4) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
        const c = Math.floor(i / t);
        i -= t * c, o += Math.abs(c);
        const h = this.repetitions - o;
        if (h <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (h === 1) {
            const p = e < 0;
            this._setEndings(p, !p, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = o, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: c
          });
        }
      } else
        this.time = i;
      if (l && (o & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r ? (i.endingStart = ax, i.endingEnd = ax) : (e ? i.endingStart = this.zeroSlopeAtStart ? ax : ix : i.endingStart = BT, t ? i.endingEnd = this.zeroSlopeAtEnd ? ax : ix : i.endingEnd = BT);
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer, o = i.time;
    let l = this._weightInterpolant;
    l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
    const c = l.parameterPositions, h = l.sampleValues;
    return c[0] = o, h[0] = t, c[1] = o + e, h[1] = r, this;
  }
}
const sX = new Float32Array(1);
class lX extends Av {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root, i = e._clip.tracks, o = i.length, l = e._propertyBindings, c = e._interpolants, h = r.uuid, p = this._bindingsByRootAndName;
    let y = p[h];
    y === void 0 && (y = {}, p[h] = y);
    for (let x = 0; x !== o; ++x) {
      const b = i[x], w = b.name;
      let R = y[w];
      if (R !== void 0)
        ++R.referenceCount, l[x] = R;
      else {
        if (R = l[x], R !== void 0) {
          R._cacheIndex === null && (++R.referenceCount, this._addInactiveBinding(R, h, w));
          continue;
        }
        const U = t && t._propertyBindings[x].binding.parsedPath;
        R = new xB(
          Zi.create(r, w, U),
          b.ValueTypeName,
          b.getValueSize()
        ), ++R.referenceCount, this._addInactiveBinding(R, h, w), l[x] = R;
      }
      c[x].resultBuffer = R.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, o = this._actionsByClip[i];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions, o = this._actionsByClip;
    let l = o[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[t] = l;
    else {
      const c = l.knownActions;
      e._byClipCacheIndex = c.length, c.push(e);
    }
    e._cacheIndex = i.length, i.push(e), l.actionByRoot[r] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, r = t[t.length - 1], i = e._cacheIndex;
    r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, l = this._actionsByClip, c = l[o], h = c.knownActions, p = h[h.length - 1], y = e._byClipCacheIndex;
    p._byClipCacheIndex = y, h[y] = p, h.pop(), e._byClipCacheIndex = null;
    const x = c.actionByRoot, b = (e._localRoot || this._root).uuid;
    delete x[b], h.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _takeBackAction(e) {
    const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName, o = this._bindings;
    let l = i[t];
    l === void 0 && (l = {}, i[t] = l), l[r] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, r = e.binding, i = r.rootNode.uuid, o = r.path, l = this._bindingsByRootAndName, c = l[i], h = t[t.length - 1], p = e._cacheIndex;
    h._cacheIndex = p, t[p] = h, t.pop(), delete c[o], Object.keys(c).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _takeBackBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let r = e[t];
    return r === void 0 && (r = new XP(
      new Float32Array(2),
      new Float32Array(2),
      1,
      sX
    ), r.__cacheIndex = t, e[t] = r), r;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, o = t[i];
    e.__cacheIndex = i, t[i] = e, o.__cacheIndex = r, t[r] = o;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, r) {
    const i = t || this._root, o = i.uuid;
    let l = typeof e == "string" ? KT.findByName(i, e) : e;
    const c = l !== null ? l.uuid : e, h = this._actionsByClip[c];
    let p = null;
    if (r === void 0 && (l !== null ? r = l.blendMode : r = qR), h !== void 0) {
      const x = h.actionByRoot[o];
      if (x !== void 0 && x.blendMode === r)
        return x;
      p = h.knownActions[0], l === null && (l = p._clip);
    }
    if (l === null)
      return null;
    const y = new _B(this, l, t, r);
    return this._bindAction(y, p), this._addInactiveAction(y, c, o), y;
  }
  // get an existing action
  existingAction(e, t) {
    const r = t || this._root, i = r.uuid, o = typeof e == "string" ? KT.findByName(r, e) : e, l = o ? o.uuid : e, c = this._actionsByClip[l];
    return c !== void 0 && c.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, r = this._nActiveActions, i = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1;
    for (let p = 0; p !== r; ++p)
      t[p]._update(i, e, o, l);
    const c = this._bindings, h = this._nActiveBindings;
    for (let p = 0; p !== h; ++p)
      c[p].apply(l);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, r = e.uuid, i = this._actionsByClip, o = i[r];
    if (o !== void 0) {
      const l = o.knownActions;
      for (let c = 0, h = l.length; c !== h; ++c) {
        const p = l[c];
        this._deactivateAction(p);
        const y = p._cacheIndex, x = t[t.length - 1];
        p._cacheIndex = null, p._byClipCacheIndex = null, x._cacheIndex = y, t[y] = x, t.pop(), this._removeInactiveBindingsForAction(p);
      }
      delete i[r];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, r = this._actionsByClip;
    for (const l in r) {
      const c = r[l].actionByRoot, h = c[t];
      h !== void 0 && (this._deactivateAction(h), this._removeInactiveAction(h));
    }
    const i = this._bindingsByRootAndName, o = i[t];
    if (o !== void 0)
      for (const l in o) {
        const c = o[l];
        c.restoreOriginalState(), this._removeInactiveBinding(c);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class r3 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new r3(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let uX = 0;
class cX extends Av {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: uX++ }), this.name = "", this.usage = HT, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++)
      this.uniforms.push(t[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class fX extends r2 {
  constructor(e, t, r = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class dX {
  constructor(e, t, r, i, o) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = o, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class EB {
  constructor(e, t, r = 0, i = 1 / 0) {
    this.ray = new wx(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new fx(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return RO(e, this, r, t), r.sort(HF), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++)
      RO(e[i], this, r, t);
    return r.sort(HF), r;
  }
}
function HF(n, e) {
  return n.distance - e.distance;
}
function RO(n, e, t, r) {
  if (n.layers.test(e.layers) && n.raycast(e, t), r === !0) {
    const i = n.children;
    for (let o = 0, l = i.length; o < l; o++)
      RO(i[o], e, t, !0);
  }
}
class AO {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Os(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class hX {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const VF = /* @__PURE__ */ new Ht();
class pX {
  constructor(e = new Ht(1 / 0, 1 / 0), t = new Ht(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = VF.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, VF).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const GF = /* @__PURE__ */ new Te(), GC = /* @__PURE__ */ new Te();
class mX {
  constructor(e = new Te(), t = new Te()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    GF.subVectors(e, this.start), GC.subVectors(this.end, this.start);
    const r = GC.dot(GC);
    let o = GC.dot(GF) / r;
    return t && (o = Os(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const WF = /* @__PURE__ */ new Te();
class vX extends aa {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const r = new oi(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, c = 1, h = 32; l < h; l++, c++) {
      const p = l / h * Math.PI * 2, y = c / h * Math.PI * 2;
      i.push(
        Math.cos(p),
        Math.sin(p),
        1,
        Math.cos(y),
        Math.sin(y),
        1
      );
    }
    r.setAttribute("position", new Yn(i, 3));
    const o = new Ff({ fog: !1, toneMapped: !1 });
    this.cone = new Dv(r, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), WF.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(WF), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const f0 = /* @__PURE__ */ new Te(), WC = /* @__PURE__ */ new Gr(), iL = /* @__PURE__ */ new Gr();
class gX extends Dv {
  constructor(e) {
    const t = bB(e), r = new oi(), i = [], o = [], l = new Rn(0, 0, 1), c = new Rn(0, 1, 0);
    for (let p = 0; p < t.length; p++) {
      const y = t[p];
      y.parent && y.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(c.r, c.g, c.b));
    }
    r.setAttribute("position", new Yn(i, 3)), r.setAttribute("color", new Yn(o, 3));
    const h = new Ff({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, h), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, r = this.geometry, i = r.getAttribute("position");
    iL.copy(this.root.matrixWorld).invert();
    for (let o = 0, l = 0; o < t.length; o++) {
      const c = t[o];
      c.parent && c.parent.isBone && (WC.multiplyMatrices(iL, c.matrixWorld), f0.setFromMatrixPosition(WC), i.setXYZ(l, f0.x, f0.y, f0.z), WC.multiplyMatrices(iL, c.parent.matrixWorld), f0.setFromMatrixPosition(WC), i.setXYZ(l + 1, f0.x, f0.y, f0.z), l += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function bB(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, bB(n.children[t]));
  return e;
}
class yX extends Al {
  constructor(e, t, r) {
    const i = new fw(t, 4, 2), o = new Qg({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const SX = /* @__PURE__ */ new Te(), jF = /* @__PURE__ */ new Rn(), $F = /* @__PURE__ */ new Rn();
class xX extends aa {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
    const i = new cw(t);
    i.rotateY(Math.PI * 0.5), this.material = new Qg({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"), l = new Float32Array(o.count * 3);
    i.setAttribute("color", new io(l, 3)), this.add(new Al(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      jF.copy(this.light.color), $F.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const o = r < i / 2 ? jF : $F;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(SX.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class _X extends Dv {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    r = new Rn(r), i = new Rn(i);
    const o = t / 2, l = e / t, c = e / 2, h = [], p = [];
    for (let b = 0, w = 0, R = -c; b <= t; b++, R += l) {
      h.push(-c, 0, R, c, 0, R), h.push(R, 0, -c, R, 0, c);
      const U = b === o ? r : i;
      U.toArray(p, w), w += 3, U.toArray(p, w), w += 3, U.toArray(p, w), w += 3, U.toArray(p, w), w += 3;
    }
    const y = new oi();
    y.setAttribute("position", new Yn(h, 3)), y.setAttribute("color", new Yn(p, 3));
    const x = new Ff({ vertexColors: !0, toneMapped: !1 });
    super(y, x), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class EX extends Dv {
  constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, l = 8947848) {
    o = new Rn(o), l = new Rn(l);
    const c = [], h = [];
    if (t > 1)
      for (let x = 0; x < t; x++) {
        const b = x / t * (Math.PI * 2), w = Math.sin(b) * e, R = Math.cos(b) * e;
        c.push(0, 0, 0), c.push(w, 0, R);
        const U = x & 1 ? o : l;
        h.push(U.r, U.g, U.b), h.push(U.r, U.g, U.b);
      }
    for (let x = 0; x < r; x++) {
      const b = x & 1 ? o : l, w = e - e / r * x;
      for (let R = 0; R < i; R++) {
        let U = R / i * (Math.PI * 2), L = Math.sin(U) * w, A = Math.cos(U) * w;
        c.push(L, 0, A), h.push(b.r, b.g, b.b), U = (R + 1) / i * (Math.PI * 2), L = Math.sin(U) * w, A = Math.cos(U) * w, c.push(L, 0, A), h.push(b.r, b.g, b.b);
      }
    }
    const p = new oi();
    p.setAttribute("position", new Yn(c, 3)), p.setAttribute("color", new Yn(h, 3));
    const y = new Ff({ vertexColors: !0, toneMapped: !1 });
    super(p, y), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const YF = /* @__PURE__ */ new Te(), jC = /* @__PURE__ */ new Te(), XF = /* @__PURE__ */ new Te();
class bX extends aa {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new oi();
    i.setAttribute("position", new Yn([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const o = new Ff({ fog: !1, toneMapped: !1 });
    this.lightPlane = new _0(i, o), this.add(this.lightPlane), i = new oi(), i.setAttribute("position", new Yn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new _0(i, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), YF.setFromMatrixPosition(this.light.matrixWorld), jC.setFromMatrixPosition(this.light.target.matrixWorld), XF.subVectors(jC, YF), this.lightPlane.lookAt(jC), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(jC), this.targetLine.scale.z = XF.length();
  }
}
const $C = /* @__PURE__ */ new Te(), Ls = /* @__PURE__ */ new sw();
class TX extends Dv {
  constructor(e) {
    const t = new oi(), r = new Ff({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], o = [], l = {};
    c("n1", "n2"), c("n2", "n4"), c("n4", "n3"), c("n3", "n1"), c("f1", "f2"), c("f2", "f4"), c("f4", "f3"), c("f3", "f1"), c("n1", "f1"), c("n2", "f2"), c("n3", "f3"), c("n4", "f4"), c("p", "n1"), c("p", "n2"), c("p", "n3"), c("p", "n4"), c("u1", "u2"), c("u2", "u3"), c("u3", "u1"), c("c", "t"), c("p", "c"), c("cn1", "cn2"), c("cn3", "cn4"), c("cf1", "cf2"), c("cf3", "cf4");
    function c(R, U) {
      h(R), h(U);
    }
    function h(R) {
      i.push(0, 0, 0), o.push(0, 0, 0), l[R] === void 0 && (l[R] = []), l[R].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Yn(i, 3)), t.setAttribute("color", new Yn(o, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const p = new Rn(16755200), y = new Rn(16711680), x = new Rn(43775), b = new Rn(16777215), w = new Rn(3355443);
    this.setColors(p, y, x, b, w);
  }
  setColors(e, t, r, i, o) {
    const c = this.geometry.getAttribute("color");
    c.setXYZ(0, e.r, e.g, e.b), c.setXYZ(1, e.r, e.g, e.b), c.setXYZ(2, e.r, e.g, e.b), c.setXYZ(3, e.r, e.g, e.b), c.setXYZ(4, e.r, e.g, e.b), c.setXYZ(5, e.r, e.g, e.b), c.setXYZ(6, e.r, e.g, e.b), c.setXYZ(7, e.r, e.g, e.b), c.setXYZ(8, e.r, e.g, e.b), c.setXYZ(9, e.r, e.g, e.b), c.setXYZ(10, e.r, e.g, e.b), c.setXYZ(11, e.r, e.g, e.b), c.setXYZ(12, e.r, e.g, e.b), c.setXYZ(13, e.r, e.g, e.b), c.setXYZ(14, e.r, e.g, e.b), c.setXYZ(15, e.r, e.g, e.b), c.setXYZ(16, e.r, e.g, e.b), c.setXYZ(17, e.r, e.g, e.b), c.setXYZ(18, e.r, e.g, e.b), c.setXYZ(19, e.r, e.g, e.b), c.setXYZ(20, e.r, e.g, e.b), c.setXYZ(21, e.r, e.g, e.b), c.setXYZ(22, e.r, e.g, e.b), c.setXYZ(23, e.r, e.g, e.b), c.setXYZ(24, t.r, t.g, t.b), c.setXYZ(25, t.r, t.g, t.b), c.setXYZ(26, t.r, t.g, t.b), c.setXYZ(27, t.r, t.g, t.b), c.setXYZ(28, t.r, t.g, t.b), c.setXYZ(29, t.r, t.g, t.b), c.setXYZ(30, t.r, t.g, t.b), c.setXYZ(31, t.r, t.g, t.b), c.setXYZ(32, r.r, r.g, r.b), c.setXYZ(33, r.r, r.g, r.b), c.setXYZ(34, r.r, r.g, r.b), c.setXYZ(35, r.r, r.g, r.b), c.setXYZ(36, r.r, r.g, r.b), c.setXYZ(37, r.r, r.g, r.b), c.setXYZ(38, i.r, i.g, i.b), c.setXYZ(39, i.r, i.g, i.b), c.setXYZ(40, o.r, o.g, o.b), c.setXYZ(41, o.r, o.g, o.b), c.setXYZ(42, o.r, o.g, o.b), c.setXYZ(43, o.r, o.g, o.b), c.setXYZ(44, o.r, o.g, o.b), c.setXYZ(45, o.r, o.g, o.b), c.setXYZ(46, o.r, o.g, o.b), c.setXYZ(47, o.r, o.g, o.b), c.setXYZ(48, o.r, o.g, o.b), c.setXYZ(49, o.r, o.g, o.b), c.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, r = 1, i = 1;
    Ls.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), al("c", t, e, Ls, 0, 0, -1), al("t", t, e, Ls, 0, 0, 1), al("n1", t, e, Ls, -r, -i, -1), al("n2", t, e, Ls, r, -i, -1), al("n3", t, e, Ls, -r, i, -1), al("n4", t, e, Ls, r, i, -1), al("f1", t, e, Ls, -r, -i, 1), al("f2", t, e, Ls, r, -i, 1), al("f3", t, e, Ls, -r, i, 1), al("f4", t, e, Ls, r, i, 1), al("u1", t, e, Ls, r * 0.7, i * 1.1, -1), al("u2", t, e, Ls, -r * 0.7, i * 1.1, -1), al("u3", t, e, Ls, 0, i * 2, -1), al("cf1", t, e, Ls, -r, 0, 1), al("cf2", t, e, Ls, r, 0, 1), al("cf3", t, e, Ls, 0, -i, 1), al("cf4", t, e, Ls, 0, i, 1), al("cn1", t, e, Ls, -r, 0, -1), al("cn2", t, e, Ls, r, 0, -1), al("cn3", t, e, Ls, 0, -i, -1), al("cn4", t, e, Ls, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function al(n, e, t, r, i, o, l) {
  $C.set(i, o, l).unproject(r);
  const c = e[n];
  if (c !== void 0) {
    const h = t.getAttribute("position");
    for (let p = 0, y = c.length; p < y; p++)
      h.setXYZ(c[p], $C.x, $C.y, $C.z);
  }
}
const YC = /* @__PURE__ */ new mm();
class wX extends Dv {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), o = new oi();
    o.setIndex(new io(r, 1)), o.setAttribute("position", new io(i, 3)), super(o, new Ff({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && YC.setFromObject(this.object), YC.isEmpty())
      return;
    const t = YC.min, r = YC.max, i = this.geometry.attributes.position, o = i.array;
    o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = t.x, o[4] = r.y, o[5] = r.z, o[6] = t.x, o[7] = t.y, o[8] = r.z, o[9] = r.x, o[10] = t.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = t.z, o[15] = t.x, o[16] = r.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = r.x, o[22] = t.y, o[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class MX extends Dv {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new oi();
    o.setIndex(new io(r, 1)), o.setAttribute("position", new Yn(i, 3)), super(o, new Ff({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class CX extends _0 {
  constructor(e, t = 1, r = 16776960) {
    const i = r, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new oi();
    l.setAttribute("position", new Yn(o, 3)), l.computeBoundingSphere(), super(l, new Ff({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const c = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], h = new oi();
    h.setAttribute("position", new Yn(c, 3)), h.computeBoundingSphere(), this.add(new Al(h, new Qg({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const qF = /* @__PURE__ */ new Te();
let XC, aL;
class RX extends aa {
  // dir is assumed to be normalized
  constructor(e = new Te(0, 0, 1), t = new Te(0, 0, 0), r = 1, i = 16776960, o = r * 0.2, l = o * 0.2) {
    super(), this.type = "ArrowHelper", XC === void 0 && (XC = new oi(), XC.setAttribute("position", new Yn([0, 0, 0, 0, 1, 0], 3)), aL = new rE(0, 0.5, 1, 5, 1), aL.translate(0, -0.5, 0)), this.position.copy(t), this.line = new _0(XC, new Ff({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Al(aL, new Qg({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, o, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      qF.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(qF, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class AX extends Dv {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], r = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new oi();
    i.setAttribute("position", new Yn(t, 3)), i.setAttribute("color", new Yn(r, 3));
    const o = new Ff({ vertexColors: !0, toneMapped: !1 });
    super(i, o), this.type = "AxesHelper";
  }
  setColors(e, t, r) {
    const i = new Rn(), o = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(o, 0), i.toArray(o, 3), i.set(t), i.toArray(o, 6), i.toArray(o, 9), i.set(r), i.toArray(o, 12), i.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class DX {
  constructor() {
    this.type = "ShapePath", this.color = new Rn(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new WT(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, l) {
    return this.currentPath.bezierCurveTo(e, t, r, i, o, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(A) {
      const F = [];
      for (let k = 0, H = A.length; k < H; k++) {
        const B = A[k], $ = new dx();
        $.curves = B.curves, F.push($);
      }
      return F;
    }
    function r(A, F) {
      const k = F.length;
      let H = !1;
      for (let B = k - 1, $ = 0; $ < k; B = $++) {
        let Y = F[B], J = F[$], K = J.x - Y.x, X = J.y - Y.y;
        if (Math.abs(X) > Number.EPSILON) {
          if (X < 0 && (Y = F[$], K = -K, J = F[B], X = -X), A.y < Y.y || A.y > J.y)
            continue;
          if (A.y === Y.y) {
            if (A.x === Y.x)
              return !0;
          } else {
            const le = X * (A.x - Y.x) - K * (A.y - Y.y);
            if (le === 0)
              return !0;
            if (le < 0)
              continue;
            H = !H;
          }
        } else {
          if (A.y !== Y.y)
            continue;
          if (J.x <= A.x && A.x <= Y.x || Y.x <= A.x && A.x <= J.x)
            return !0;
        }
      }
      return H;
    }
    const i = Tv.isClockWise, o = this.subPaths;
    if (o.length === 0)
      return [];
    let l, c, h;
    const p = [];
    if (o.length === 1)
      return c = o[0], h = new dx(), h.curves = c.curves, p.push(h), p;
    let y = !i(o[0].getPoints());
    y = e ? !y : y;
    const x = [], b = [];
    let w = [], R = 0, U;
    b[R] = void 0, w[R] = [];
    for (let A = 0, F = o.length; A < F; A++)
      c = o[A], U = c.getPoints(), l = i(U), l = e ? !l : l, l ? (!y && b[R] && R++, b[R] = { s: new dx(), p: U }, b[R].s.curves = c.curves, y && R++, w[R] = []) : w[R].push({ h: c, p: U[0] });
    if (!b[0])
      return t(o);
    if (b.length > 1) {
      let A = !1, F = 0;
      for (let k = 0, H = b.length; k < H; k++)
        x[k] = [];
      for (let k = 0, H = b.length; k < H; k++) {
        const B = w[k];
        for (let $ = 0; $ < B.length; $++) {
          const Y = B[$];
          let J = !0;
          for (let K = 0; K < b.length; K++)
            r(Y.p, b[K].p) && (k !== K && F++, J ? (J = !1, x[K].push(Y)) : A = !0);
          J && x[k].push(Y);
        }
      }
      F > 0 && A === !1 && (w = x);
    }
    let L;
    for (let A = 0, F = b.length; A < F; A++) {
      h = b[A].s, p.push(h), L = w[A];
      for (let k = 0, H = L.length; k < H; k++)
        h.holes.push(L[k].h);
    }
    return p;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: jR
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = jR);
const LX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: gP,
  AddEquation: nx,
  AddOperation: VI,
  AdditiveAnimationBlendMode: wP,
  AdditiveBlending: GL,
  AlphaFormat: qI,
  AlwaysCompare: m4,
  AlwaysDepth: NI,
  AlwaysStencilFunc: s4,
  AmbientLight: mB,
  AmbientLightProbe: WY,
  AnimationAction: _B,
  AnimationClip: KT,
  AnimationLoader: LY,
  AnimationMixer: lX,
  AnimationObjectGroup: oX,
  AnimationUtils: CY,
  ArcCurve: H4,
  ArrayCamera: L4,
  ArrowHelper: RX,
  Audio: SB,
  AudioAnalyser: KY,
  AudioContext: JP,
  AudioListener: YY,
  AudioLoader: VY,
  AxesHelper: AX,
  BackSide: Ic,
  BasicDepthPacking: a4,
  BasicShadowMap: _I,
  Bone: kP,
  BooleanKeyframeTrack: Cx,
  Box2: pX,
  Box3: mm,
  Box3Helper: MX,
  BoxGeometry: Mx,
  BoxHelper: wX,
  BufferAttribute: io,
  BufferGeometry: oi,
  BufferGeometryLoader: yB,
  ByteType: YI,
  Cache: _x,
  Camera: sw,
  CameraHelper: TX,
  CanvasTexture: Q$,
  CapsuleGeometry: l2,
  CatmullRomCurve3: V4,
  CineonToneMapping: jI,
  CircleGeometry: u2,
  ClampToEdgeWrapping: kc,
  Clock: e3,
  Color: Rn,
  ColorKeyframeTrack: qP,
  ColorManagement: up,
  CompressedArrayTexture: q$,
  CompressedCubeTexture: K$,
  CompressedTexture: a2,
  CompressedTextureLoader: OY,
  ConeGeometry: c2,
  CubeCamera: b4,
  CubeReflectionMapping: jg,
  CubeRefractionMapping: S0,
  CubeTexture: lw,
  CubeTextureLoader: PY,
  CubeUVReflectionMapping: tE,
  CubicBezierCurve: BP,
  CubicBezierCurve3: G4,
  CubicInterpolant: sB,
  CullFaceBack: VL,
  CullFaceFront: xI,
  CullFaceFrontBack: V8,
  CullFaceNone: SI,
  Curve: vm,
  CurvePath: j4,
  CustomBlending: EI,
  CustomToneMapping: $I,
  CylinderGeometry: rE,
  Cylindrical: hX,
  Data3DTexture: DP,
  DataArrayTexture: KR,
  DataTexture: j1,
  DataTextureLoader: UY,
  DataUtils: nW,
  DecrementStencilOp: tG,
  DecrementWrapStencilOp: rG,
  DefaultLoadingManager: cB,
  DepthFormat: v0,
  DepthStencilFormat: gx,
  DepthTexture: O4,
  DirectionalLight: pB,
  DirectionalLightHelper: bX,
  DiscreteInterpolant: lB,
  DisplayP3ColorSpace: aw,
  DodecahedronGeometry: f2,
  DoubleSide: dp,
  DstAlphaFactor: AI,
  DstColorFactor: LI,
  DynamicCopyUsage: yG,
  DynamicDrawUsage: dG,
  DynamicReadUsage: mG,
  EdgesGeometry: $4,
  EllipseCurve: o2,
  EqualCompare: c4,
  EqualDepth: kI,
  EqualStencilFunc: sG,
  EquirectangularReflectionMapping: UT,
  EquirectangularRefractionMapping: NT,
  Euler: ow,
  EventDispatcher: Av,
  ExtrudeGeometry: h2,
  FileLoader: $g,
  Float16BufferAttribute: lW,
  Float32BufferAttribute: Yn,
  Float64BufferAttribute: uW,
  FloatType: xv,
  Fog: n2,
  FogExp2: t2,
  FramebufferTexture: X$,
  FrontSide: wv,
  Frustum: QR,
  GLBufferAttribute: dX,
  GLSL1: xG,
  GLSL3: SO,
  GreaterCompare: d4,
  GreaterDepth: II,
  GreaterEqualCompare: p4,
  GreaterEqualDepth: zI,
  GreaterEqualStencilFunc: fG,
  GreaterStencilFunc: uG,
  GridHelper: _X,
  Group: z1,
  HalfFloatType: X1,
  HemisphereLight: fB,
  HemisphereLightHelper: xX,
  HemisphereLightProbe: GY,
  IcosahedronGeometry: p2,
  ImageBitmapLoader: HY,
  ImageLoader: QT,
  ImageUtils: AP,
  IncrementStencilOp: eG,
  IncrementWrapStencilOp: nG,
  InstancedBufferAttribute: Sx,
  InstancedBufferGeometry: ZP,
  InstancedInterleavedBuffer: fX,
  InstancedMesh: z4,
  Int16BufferAttribute: oW,
  Int32BufferAttribute: sW,
  Int8BufferAttribute: rW,
  IntType: SP,
  InterleavedBuffer: r2,
  InterleavedBufferAttribute: yx,
  Interpolant: dw,
  InterpolateDiscrete: zT,
  InterpolateLinear: IT,
  InterpolateSmooth: mR,
  InvertStencilOp: iG,
  KeepStencilOp: vR,
  KeyframeTrack: gm,
  LOD: F4,
  LatheGeometry: uw,
  Layers: fx,
  LessCompare: u4,
  LessDepth: FI,
  LessEqualCompare: f4,
  LessEqualDepth: bR,
  LessEqualStencilFunc: lG,
  LessStencilFunc: oG,
  Light: D0,
  LightProbe: _2,
  Line: _0,
  Line3: mX,
  LineBasicMaterial: Ff,
  LineCurve: s2,
  LineCurve3: W4,
  LineDashedMaterial: aB,
  LineLoop: I4,
  LineSegments: Dv,
  LinearDisplayP3ColorSpace: Q8,
  LinearEncoding: MP,
  LinearFilter: ss,
  LinearInterpolant: XP,
  LinearMipMapLinearFilter: Y8,
  LinearMipMapNearestFilter: $8,
  LinearMipmapLinearFilter: x0,
  LinearMipmapNearestFilter: yP,
  LinearSRGBColorSpace: dm,
  LinearToneMapping: GI,
  Loader: Cd,
  LoaderUtils: CO,
  LoadingManager: KP,
  LoopOnce: n4,
  LoopPingPong: i4,
  LoopRepeat: r4,
  LuminanceAlphaFormat: QI,
  LuminanceFormat: KI,
  MOUSE: JS,
  Material: ic,
  MaterialLoader: E2,
  MathUtils: g4,
  Matrix3: ii,
  Matrix4: Gr,
  MaxEquation: YL,
  Mesh: Al,
  MeshBasicMaterial: Qg,
  MeshDepthMaterial: JR,
  MeshDistanceMaterial: e2,
  MeshLambertMaterial: rB,
  MeshMatcapMaterial: iB,
  MeshNormalMaterial: nB,
  MeshPhongMaterial: eB,
  MeshPhysicalMaterial: J4,
  MeshStandardMaterial: jP,
  MeshToonMaterial: tB,
  MinEquation: $L,
  MirroredRepeatWrapping: kT,
  MixOperation: HI,
  MultiplyBlending: jL,
  MultiplyOperation: iw,
  NearestFilter: ol,
  NearestMipMapLinearFilter: j8,
  NearestMipMapNearestFilter: W8,
  NearestMipmapLinearFilter: TT,
  NearestMipmapNearestFilter: TR,
  NeverCompare: l4,
  NeverDepth: UI,
  NeverStencilFunc: aG,
  NoBlending: Gg,
  NoColorSpace: y0,
  NoToneMapping: Ev,
  NormalAnimationBlendMode: qR,
  NormalBlending: ux,
  NotEqualCompare: h4,
  NotEqualDepth: BI,
  NotEqualStencilFunc: cG,
  NumberKeyframeTrack: XT,
  Object3D: aa,
  ObjectLoader: IY,
  ObjectSpaceNormalMap: o4,
  OctahedronGeometry: cw,
  OneFactor: MI,
  OneMinusDstAlphaFactor: DI,
  OneMinusDstColorFactor: OI,
  OneMinusSrcAlphaFactor: vP,
  OneMinusSrcColorFactor: RI,
  OrthographicCamera: Vg,
  PCFShadowMap: $R,
  PCFSoftShadowMap: bT,
  PMREMGenerator: _O,
  Path: WT,
  PerspectiveCamera: Ps,
  Plane: kg,
  PlaneGeometry: R0,
  PlaneHelper: CX,
  PointLight: hB,
  PointLightHelper: yX,
  Points: B4,
  PointsMaterial: zP,
  PolarGridHelper: EX,
  PolyhedronGeometry: A0,
  PositionalAudio: qY,
  PropertyBinding: Zi,
  PropertyMixer: xB,
  QuadraticBezierCurve: HP,
  QuadraticBezierCurve3: VP,
  Quaternion: Bc,
  QuaternionKeyframeTrack: iE,
  QuaternionLinearInterpolant: uB,
  RED_GREEN_RGTC2_Format: gO,
  RED_RGTC1_Format: t4,
  REVISION: jR,
  RGBADepthPacking: CP,
  RGBAFormat: Td,
  RGBAIntegerFormat: TP,
  RGBA_ASTC_10x10_Format: fO,
  RGBA_ASTC_10x5_Format: lO,
  RGBA_ASTC_10x6_Format: uO,
  RGBA_ASTC_10x8_Format: cO,
  RGBA_ASTC_12x10_Format: dO,
  RGBA_ASTC_12x12_Format: hO,
  RGBA_ASTC_4x4_Format: eO,
  RGBA_ASTC_5x4_Format: tO,
  RGBA_ASTC_5x5_Format: nO,
  RGBA_ASTC_6x5_Format: rO,
  RGBA_ASTC_6x6_Format: iO,
  RGBA_ASTC_8x5_Format: aO,
  RGBA_ASTC_8x6_Format: oO,
  RGBA_ASTC_8x8_Format: sO,
  RGBA_BPTC_Format: pR,
  RGBA_ETC2_EAC_Format: JL,
  RGBA_PVRTC_2BPPV1_Format: QL,
  RGBA_PVRTC_4BPPV1_Format: KL,
  RGBA_S3TC_DXT1_Format: fR,
  RGBA_S3TC_DXT3_Format: dR,
  RGBA_S3TC_DXT5_Format: hR,
  RGB_BPTC_SIGNED_Format: pO,
  RGB_BPTC_UNSIGNED_Format: mO,
  RGB_ETC1_Format: e4,
  RGB_ETC2_Format: ZL,
  RGB_PVRTC_2BPPV1_Format: qL,
  RGB_PVRTC_4BPPV1_Format: XL,
  RGB_S3TC_DXT1_Format: cR,
  RGFormat: JI,
  RGIntegerFormat: bP,
  RawShaderMaterial: Z4,
  Ray: wx,
  Raycaster: EB,
  RectAreaLight: vB,
  RedFormat: ZI,
  RedIntegerFormat: EP,
  ReinhardToneMapping: WI,
  RenderTarget: x4,
  RepeatWrapping: FT,
  ReplaceStencilOp: J8,
  ReverseSubtractEquation: TI,
  RingGeometry: m2,
  SIGNED_RED_GREEN_RGTC2_Format: yO,
  SIGNED_RED_RGTC1_Format: vO,
  SRGBColorSpace: go,
  Scene: CR,
  ShaderChunk: Jr,
  ShaderLib: fm,
  ShaderMaterial: Mv,
  ShadowMaterial: Q4,
  Shape: dx,
  ShapeGeometry: v2,
  ShapePath: DX,
  ShapeUtils: Tv,
  ShortType: XI,
  Skeleton: i2,
  SkeletonHelper: gX,
  SkinnedMesh: k4,
  Source: ox,
  Sphere: vp,
  SphereGeometry: fw,
  Spherical: AO,
  SphericalHarmonics3: gB,
  SplineCurve: GP,
  SpotLight: dB,
  SpotLightHelper: vX,
  Sprite: N4,
  SpriteMaterial: FP,
  SrcAlphaFactor: mP,
  SrcAlphaSaturateFactor: PI,
  SrcColorFactor: CI,
  StaticCopyUsage: gG,
  StaticDrawUsage: HT,
  StaticReadUsage: pG,
  StereoCamera: jY,
  StreamCopyUsage: SG,
  StreamDrawUsage: hG,
  StreamReadUsage: vG,
  StringKeyframeTrack: Rx,
  SubtractEquation: bI,
  SubtractiveBlending: WL,
  TOUCH: ex,
  TangentSpaceNormalMap: C0,
  TetrahedronGeometry: g2,
  Texture: cs,
  TextureLoader: NY,
  TorusGeometry: y2,
  TorusKnotGeometry: S2,
  Triangle: bd,
  TriangleFanDrawMode: K8,
  TriangleStripDrawMode: q8,
  TrianglesDrawMode: X8,
  TubeGeometry: x2,
  TwoPassDoubleSide: G8,
  UVMapping: YR,
  Uint16BufferAttribute: LP,
  Uint32BufferAttribute: OP,
  Uint8BufferAttribute: iW,
  Uint8ClampedBufferAttribute: aW,
  Uniform: r3,
  UniformsGroup: cX,
  UniformsLib: yn,
  UniformsUtils: PP,
  UnsignedByteType: bv,
  UnsignedInt248Type: m0,
  UnsignedIntType: Hg,
  UnsignedShort4444Type: xP,
  UnsignedShort5551Type: _P,
  UnsignedShortType: XR,
  VSMShadowMap: um,
  Vector2: Ht,
  Vector3: Te,
  Vector4: ua,
  VectorKeyframeTrack: qT,
  VideoTexture: Y$,
  WebGL1Renderer: P4,
  WebGL3DRenderTarget: WG,
  WebGLArrayRenderTarget: GG,
  WebGLCoordinateSystem: _v,
  WebGLCubeRenderTarget: T4,
  WebGLMultipleRenderTargets: jG,
  WebGLRenderTarget: hm,
  WebGLRenderer: NP,
  WebGLUtils: D4,
  WebGPUCoordinateSystem: VT,
  WireframeGeometry: K4,
  WrapAroundEnding: BT,
  ZeroCurvatureEnding: ix,
  ZeroFactor: wI,
  ZeroSlopeEnding: ax,
  ZeroStencilOp: Z8,
  _SRGBAFormat: wR,
  createCanvasElement: S4,
  sRGBEncoding: g0
}, Symbol.toStringTag, { value: "Module" }));
var DO = { exports: {} }, d0 = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KF;
function OX() {
  return KF || (KF = 1, d0.ConcurrentRoot = 1, d0.ContinuousEventPriority = 4, d0.DefaultEventPriority = 16, d0.DiscreteEventPriority = 1, d0.IdleEventPriority = 536870912, d0.LegacyRoot = 0), d0;
}
var h0 = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QF;
function PX() {
  return QF || (QF = 1, process.env.NODE_ENV !== "production" && function() {
    var n = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), r = (
      /*                       */
      536870912
    ), i = n, o = e, l = t, c = r, h = 0, p = 1;
    h0.ConcurrentRoot = p, h0.ContinuousEventPriority = o, h0.DefaultEventPriority = l, h0.DiscreteEventPriority = i, h0.IdleEventPriority = c, h0.LegacyRoot = h;
  }()), h0;
}
process.env.NODE_ENV === "production" ? DO.exports = OX() : DO.exports = PX();
var B1 = DO.exports;
function UX(n) {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (p, y) => {
    const x = typeof p == "function" ? p(e) : p;
    if (x !== e) {
      const b = e;
      e = y ? x : Object.assign({}, e, x), t.forEach((w) => w(e, b));
    }
  }, i = () => e, o = (p, y = i, x = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let b = y(e);
    function w() {
      const R = y(e);
      if (!x(b, R)) {
        const U = b;
        p(b = R, U);
      }
    }
    return t.add(w), () => t.delete(w);
  }, h = { setState: r, getState: i, subscribe: (p, y, x) => y || x ? o(p, y, x) : (t.add(p), () => t.delete(p)), destroy: () => t.clear() };
  return e = n(r, i, h), h;
}
const NX = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), ZF = NX ? tr : M0;
function TB(n) {
  const e = typeof n == "function" ? UX(n) : n, t = (r = e.getState, i = Object.is) => {
    const [, o] = dP((L) => L + 1, 0), l = e.getState(), c = Sn(l), h = Sn(r), p = Sn(i), y = Sn(!1), x = Sn();
    x.current === void 0 && (x.current = r(l));
    let b, w = !1;
    (c.current !== l || h.current !== r || p.current !== i || y.current) && (b = r(l), w = !i(x.current, b)), ZF(() => {
      w && (x.current = b), c.current = l, h.current = r, p.current = i, y.current = !1;
    });
    const R = Sn(l);
    ZF(() => {
      const L = () => {
        try {
          const F = e.getState(), k = h.current(F);
          p.current(x.current, k) || (c.current = F, x.current = k, o());
        } catch {
          y.current = !0, o();
        }
      }, A = e.subscribe(L);
      return e.getState() !== R.current && L(), A;
    }, []);
    const U = w ? b : x.current;
    return I8(U), U;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [t, e];
    return {
      next() {
        const i = r.length <= 0;
        return { value: r.shift(), done: i };
      }
    };
  }, t;
}
var LO = { exports: {} }, OO = { exports: {} }, oL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JF;
function FX() {
  return JF || (JF = 1, function(n) {
    function e(ce, ve) {
      var re = ce.length;
      ce.push(ve);
      e:
        for (; 0 < re; ) {
          var ee = re - 1 >>> 1, he = ce[ee];
          if (0 < i(he, ve))
            ce[ee] = ve, ce[re] = he, re = ee;
          else
            break e;
        }
    }
    function t(ce) {
      return ce.length === 0 ? null : ce[0];
    }
    function r(ce) {
      if (ce.length === 0)
        return null;
      var ve = ce[0], re = ce.pop();
      if (re !== ve) {
        ce[0] = re;
        e:
          for (var ee = 0, he = ce.length, Me = he >>> 1; ee < Me; ) {
            var Le = 2 * (ee + 1) - 1, Ae = ce[Le], Ue = Le + 1, Ne = ce[Ue];
            if (0 > i(Ae, re))
              Ue < he && 0 > i(Ne, Ae) ? (ce[ee] = Ne, ce[Ue] = re, ee = Ue) : (ce[ee] = Ae, ce[Le] = re, ee = Le);
            else if (Ue < he && 0 > i(Ne, re))
              ce[ee] = Ne, ce[Ue] = re, ee = Ue;
            else
              break e;
          }
      }
      return ve;
    }
    function i(ce, ve) {
      var re = ce.sortIndex - ve.sortIndex;
      return re !== 0 ? re : ce.id - ve.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      n.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, c = l.now();
      n.unstable_now = function() {
        return l.now() - c;
      };
    }
    var h = [], p = [], y = 1, x = null, b = 3, w = !1, R = !1, U = !1, L = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function k(ce) {
      for (var ve = t(p); ve !== null; ) {
        if (ve.callback === null)
          r(p);
        else if (ve.startTime <= ce)
          r(p), ve.sortIndex = ve.expirationTime, e(h, ve);
        else
          break;
        ve = t(p);
      }
    }
    function H(ce) {
      if (U = !1, k(ce), !R)
        if (t(h) !== null)
          R = !0, _e(B);
        else {
          var ve = t(p);
          ve !== null && Pe(H, ve.startTime - ce);
        }
    }
    function B(ce, ve) {
      R = !1, U && (U = !1, A(J), J = -1), w = !0;
      var re = b;
      try {
        for (k(ve), x = t(h); x !== null && (!(x.expirationTime > ve) || ce && !le()); ) {
          var ee = x.callback;
          if (typeof ee == "function") {
            x.callback = null, b = x.priorityLevel;
            var he = ee(x.expirationTime <= ve);
            ve = n.unstable_now(), typeof he == "function" ? x.callback = he : x === t(h) && r(h), k(ve);
          } else
            r(h);
          x = t(h);
        }
        if (x !== null)
          var Me = !0;
        else {
          var Le = t(p);
          Le !== null && Pe(H, Le.startTime - ve), Me = !1;
        }
        return Me;
      } finally {
        x = null, b = re, w = !1;
      }
    }
    var $ = !1, Y = null, J = -1, K = 5, X = -1;
    function le() {
      return !(n.unstable_now() - X < K);
    }
    function oe() {
      if (Y !== null) {
        var ce = n.unstable_now();
        X = ce;
        var ve = !0;
        try {
          ve = Y(!0, ce);
        } finally {
          ve ? fe() : ($ = !1, Y = null);
        }
      } else
        $ = !1;
    }
    var fe;
    if (typeof F == "function")
      fe = function() {
        F(oe);
      };
    else if (typeof MessageChannel < "u") {
      var de = new MessageChannel(), xe = de.port2;
      de.port1.onmessage = oe, fe = function() {
        xe.postMessage(null);
      };
    } else
      fe = function() {
        L(oe, 0);
      };
    function _e(ce) {
      Y = ce, $ || ($ = !0, fe());
    }
    function Pe(ce, ve) {
      J = L(function() {
        ce(n.unstable_now());
      }, ve);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(ce) {
      ce.callback = null;
    }, n.unstable_continueExecution = function() {
      R || w || (R = !0, _e(B));
    }, n.unstable_forceFrameRate = function(ce) {
      0 > ce || 125 < ce ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < ce ? Math.floor(1e3 / ce) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, n.unstable_next = function(ce) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var ve = 3;
          break;
        default:
          ve = b;
      }
      var re = b;
      b = ve;
      try {
        return ce();
      } finally {
        b = re;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(ce, ve) {
      switch (ce) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ce = 3;
      }
      var re = b;
      b = ce;
      try {
        return ve();
      } finally {
        b = re;
      }
    }, n.unstable_scheduleCallback = function(ce, ve, re) {
      var ee = n.unstable_now();
      switch (typeof re == "object" && re !== null ? (re = re.delay, re = typeof re == "number" && 0 < re ? ee + re : ee) : re = ee, ce) {
        case 1:
          var he = -1;
          break;
        case 2:
          he = 250;
          break;
        case 5:
          he = 1073741823;
          break;
        case 4:
          he = 1e4;
          break;
        default:
          he = 5e3;
      }
      return he = re + he, ce = { id: y++, callback: ve, priorityLevel: ce, startTime: re, expirationTime: he, sortIndex: -1 }, re > ee ? (ce.sortIndex = re, e(p, ce), t(h) === null && ce === t(p) && (U ? (A(J), J = -1) : U = !0, Pe(H, re - ee))) : (ce.sortIndex = he, e(h, ce), R || w || (R = !0, _e(B))), ce;
    }, n.unstable_shouldYield = le, n.unstable_wrapCallback = function(ce) {
      var ve = b;
      return function() {
        var re = b;
        b = ve;
        try {
          return ce.apply(this, arguments);
        } finally {
          b = re;
        }
      };
    };
  }(oL)), oL;
}
var sL = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ek;
function kX() {
  return ek || (ek = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(Se, He) {
        var lt = Se.length;
        Se.push(He), c(Se, He, lt);
      }
      function o(Se) {
        return Se.length === 0 ? null : Se[0];
      }
      function l(Se) {
        if (Se.length === 0)
          return null;
        var He = Se[0], lt = Se.pop();
        return lt !== He && (Se[0] = lt, h(Se, lt, 0)), He;
      }
      function c(Se, He, lt) {
        for (var St = lt; St > 0; ) {
          var Je = St - 1 >>> 1, be = Se[Je];
          if (p(be, He) > 0)
            Se[Je] = He, Se[St] = be, St = Je;
          else
            return;
        }
      }
      function h(Se, He, lt) {
        for (var St = lt, Je = Se.length, be = Je >>> 1; St < be; ) {
          var Ze = (St + 1) * 2 - 1, ct = Se[Ze], pe = Ze + 1, Rt = Se[pe];
          if (p(ct, He) < 0)
            pe < Je && p(Rt, ct) < 0 ? (Se[St] = Rt, Se[pe] = He, St = pe) : (Se[St] = ct, Se[Ze] = He, St = Ze);
          else if (pe < Je && p(Rt, He) < 0)
            Se[St] = Rt, Se[pe] = He, St = pe;
          else
            return;
        }
      }
      function p(Se, He) {
        var lt = Se.sortIndex - He.sortIndex;
        return lt !== 0 ? lt : Se.id - He.id;
      }
      var y = 1, x = 2, b = 3, w = 4, R = 5;
      function U(Se, He) {
      }
      var L = typeof performance == "object" && typeof performance.now == "function";
      if (L) {
        var A = performance;
        n.unstable_now = function() {
          return A.now();
        };
      } else {
        var F = Date, k = F.now();
        n.unstable_now = function() {
          return F.now() - k;
        };
      }
      var H = 1073741823, B = -1, $ = 250, Y = 5e3, J = 1e4, K = H, X = [], le = [], oe = 1, fe = null, de = b, xe = !1, _e = !1, Pe = !1, ce = typeof setTimeout == "function" ? setTimeout : null, ve = typeof clearTimeout == "function" ? clearTimeout : null, re = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ee(Se) {
        for (var He = o(le); He !== null; ) {
          if (He.callback === null)
            l(le);
          else if (He.startTime <= Se)
            l(le), He.sortIndex = He.expirationTime, i(X, He);
          else
            return;
          He = o(le);
        }
      }
      function he(Se) {
        if (Pe = !1, ee(Se), !_e)
          if (o(X) !== null)
            _e = !0, _t(Me);
          else {
            var He = o(le);
            He !== null && ot(he, He.startTime - Se);
          }
      }
      function Me(Se, He) {
        _e = !1, Pe && (Pe = !1, at()), xe = !0;
        var lt = de;
        try {
          var St;
          if (!t)
            return Le(Se, He);
        } finally {
          fe = null, de = lt, xe = !1;
        }
      }
      function Le(Se, He) {
        var lt = He;
        for (ee(lt), fe = o(X); fe !== null && !e && !(fe.expirationTime > lt && (!Se || Ct())); ) {
          var St = fe.callback;
          if (typeof St == "function") {
            fe.callback = null, de = fe.priorityLevel;
            var Je = fe.expirationTime <= lt, be = St(Je);
            lt = n.unstable_now(), typeof be == "function" ? fe.callback = be : fe === o(X) && l(X), ee(lt);
          } else
            l(X);
          fe = o(X);
        }
        if (fe !== null)
          return !0;
        var Ze = o(le);
        return Ze !== null && ot(he, Ze.startTime - lt), !1;
      }
      function Ae(Se, He) {
        switch (Se) {
          case y:
          case x:
          case b:
          case w:
          case R:
            break;
          default:
            Se = b;
        }
        var lt = de;
        de = Se;
        try {
          return He();
        } finally {
          de = lt;
        }
      }
      function Ue(Se) {
        var He;
        switch (de) {
          case y:
          case x:
          case b:
            He = b;
            break;
          default:
            He = de;
            break;
        }
        var lt = de;
        de = He;
        try {
          return Se();
        } finally {
          de = lt;
        }
      }
      function Ne(Se) {
        var He = de;
        return function() {
          var lt = de;
          de = He;
          try {
            return Se.apply(this, arguments);
          } finally {
            de = lt;
          }
        };
      }
      function ke(Se, He, lt) {
        var St = n.unstable_now(), Je;
        if (typeof lt == "object" && lt !== null) {
          var be = lt.delay;
          typeof be == "number" && be > 0 ? Je = St + be : Je = St;
        } else
          Je = St;
        var Ze;
        switch (Se) {
          case y:
            Ze = B;
            break;
          case x:
            Ze = $;
            break;
          case R:
            Ze = K;
            break;
          case w:
            Ze = J;
            break;
          case b:
          default:
            Ze = Y;
            break;
        }
        var ct = Je + Ze, pe = {
          id: oe++,
          callback: He,
          priorityLevel: Se,
          startTime: Je,
          expirationTime: ct,
          sortIndex: -1
        };
        return Je > St ? (pe.sortIndex = Je, i(le, pe), o(X) === null && pe === o(le) && (Pe ? at() : Pe = !0, ot(he, Je - St))) : (pe.sortIndex = ct, i(X, pe), !_e && !xe && (_e = !0, _t(Me))), pe;
      }
      function it() {
      }
      function At() {
        !_e && !xe && (_e = !0, _t(Me));
      }
      function rt() {
        return o(X);
      }
      function ae(Se) {
        Se.callback = null;
      }
      function et() {
        return de;
      }
      var Ye = !1, Ge = null, $e = -1, Ut = r, nt = -1;
      function Ct() {
        var Se = n.unstable_now() - nt;
        return !(Se < Ut);
      }
      function Pt() {
      }
      function vt(Se) {
        if (Se < 0 || Se > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Se > 0 ? Ut = Math.floor(1e3 / Se) : Ut = r;
      }
      var Zt = function() {
        if (Ge !== null) {
          var Se = n.unstable_now();
          nt = Se;
          var He = !0, lt = !0;
          try {
            lt = Ge(He, Se);
          } finally {
            lt ? ie() : (Ye = !1, Ge = null);
          }
        } else
          Ye = !1;
      }, ie;
      if (typeof re == "function")
        ie = function() {
          re(Zt);
        };
      else if (typeof MessageChannel < "u") {
        var ne = new MessageChannel(), Oe = ne.port2;
        ne.port1.onmessage = Zt, ie = function() {
          Oe.postMessage(null);
        };
      } else
        ie = function() {
          ce(Zt, 0);
        };
      function _t(Se) {
        Ge = Se, Ye || (Ye = !0, ie());
      }
      function ot(Se, He) {
        $e = ce(function() {
          Se(n.unstable_now());
        }, He);
      }
      function at() {
        ve($e), $e = -1;
      }
      var Wt = Pt, Dt = null;
      n.unstable_IdlePriority = R, n.unstable_ImmediatePriority = y, n.unstable_LowPriority = w, n.unstable_NormalPriority = b, n.unstable_Profiling = Dt, n.unstable_UserBlockingPriority = x, n.unstable_cancelCallback = ae, n.unstable_continueExecution = At, n.unstable_forceFrameRate = vt, n.unstable_getCurrentPriorityLevel = et, n.unstable_getFirstCallbackNode = rt, n.unstable_next = Ue, n.unstable_pauseExecution = it, n.unstable_requestPaint = Wt, n.unstable_runWithPriority = Ae, n.unstable_scheduleCallback = ke, n.unstable_shouldYield = Ct, n.unstable_wrapCallback = Ne, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(sL)), sL;
}
process.env.NODE_ENV === "production" ? OO.exports = FX() : OO.exports = kX();
var RR = OO.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lL, tk;
function zX() {
  return tk || (tk = 1, lL = function(e) {
    var t = {}, r = Fe, i = RR, o = Object.assign;
    function l(g) {
      for (var S = "https://reactjs.org/docs/error-decoder.html?invariant=" + g, D = 1; D < arguments.length; D++)
        S += "&args[]=" + encodeURIComponent(arguments[D]);
      return "Minified React error #" + g + "; visit " + S + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var c = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, h = Symbol.for("react.element"), p = Symbol.for("react.portal"), y = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), b = Symbol.for("react.profiler"), w = Symbol.for("react.provider"), R = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), L = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), F = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), H = Symbol.for("react.offscreen"), B = Symbol.iterator;
    function $(g) {
      return g === null || typeof g != "object" ? null : (g = B && g[B] || g["@@iterator"], typeof g == "function" ? g : null);
    }
    function Y(g) {
      if (g == null)
        return null;
      if (typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case y:
          return "Fragment";
        case p:
          return "Portal";
        case b:
          return "Profiler";
        case x:
          return "StrictMode";
        case L:
          return "Suspense";
        case A:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case R:
            return (g.displayName || "Context") + ".Consumer";
          case w:
            return (g._context.displayName || "Context") + ".Provider";
          case U:
            var S = g.render;
            return g = g.displayName, g || (g = S.displayName || S.name || "", g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef"), g;
          case F:
            return S = g.displayName || null, S !== null ? S : Y(g.type) || "Memo";
          case k:
            S = g._payload, g = g._init;
            try {
              return Y(g(S));
            } catch {
            }
        }
      return null;
    }
    function J(g) {
      var S = g.type;
      switch (g.tag) {
        case 24:
          return "Cache";
        case 9:
          return (S.displayName || "Context") + ".Consumer";
        case 10:
          return (S._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return g = S.render, g = g.displayName || g.name || "", S.displayName || (g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return S;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Y(S);
        case 8:
          return S === x ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof S == "function")
            return S.displayName || S.name || null;
          if (typeof S == "string")
            return S;
      }
      return null;
    }
    function K(g) {
      var S = g, D = g;
      if (g.alternate)
        for (; S.return; )
          S = S.return;
      else {
        g = S;
        do
          S = g, S.flags & 4098 && (D = S.return), g = S.return;
        while (g);
      }
      return S.tag === 3 ? D : null;
    }
    function X(g) {
      if (K(g) !== g)
        throw Error(l(188));
    }
    function le(g) {
      var S = g.alternate;
      if (!S) {
        if (S = K(g), S === null)
          throw Error(l(188));
        return S !== g ? null : g;
      }
      for (var D = g, z = S; ; ) {
        var W = D.return;
        if (W === null)
          break;
        var Z = W.alternate;
        if (Z === null) {
          if (z = W.return, z !== null) {
            D = z;
            continue;
          }
          break;
        }
        if (W.child === Z.child) {
          for (Z = W.child; Z; ) {
            if (Z === D)
              return X(W), g;
            if (Z === z)
              return X(W), S;
            Z = Z.sibling;
          }
          throw Error(l(188));
        }
        if (D.return !== z.return)
          D = W, z = Z;
        else {
          for (var we = !1, Qe = W.child; Qe; ) {
            if (Qe === D) {
              we = !0, D = W, z = Z;
              break;
            }
            if (Qe === z) {
              we = !0, z = W, D = Z;
              break;
            }
            Qe = Qe.sibling;
          }
          if (!we) {
            for (Qe = Z.child; Qe; ) {
              if (Qe === D) {
                we = !0, D = Z, z = W;
                break;
              }
              if (Qe === z) {
                we = !0, z = Z, D = W;
                break;
              }
              Qe = Qe.sibling;
            }
            if (!we)
              throw Error(l(189));
          }
        }
        if (D.alternate !== z)
          throw Error(l(190));
      }
      if (D.tag !== 3)
        throw Error(l(188));
      return D.stateNode.current === D ? g : S;
    }
    function oe(g) {
      return g = le(g), g !== null ? fe(g) : null;
    }
    function fe(g) {
      if (g.tag === 5 || g.tag === 6)
        return g;
      for (g = g.child; g !== null; ) {
        var S = fe(g);
        if (S !== null)
          return S;
        g = g.sibling;
      }
      return null;
    }
    function de(g) {
      if (g.tag === 5 || g.tag === 6)
        return g;
      for (g = g.child; g !== null; ) {
        if (g.tag !== 4) {
          var S = de(g);
          if (S !== null)
            return S;
        }
        g = g.sibling;
      }
      return null;
    }
    var xe = Array.isArray, _e = e.getPublicInstance, Pe = e.getRootHostContext, ce = e.getChildHostContext, ve = e.prepareForCommit, re = e.resetAfterCommit, ee = e.createInstance, he = e.appendInitialChild, Me = e.finalizeInitialChildren, Le = e.prepareUpdate, Ae = e.shouldSetTextContent, Ue = e.createTextInstance, Ne = e.scheduleTimeout, ke = e.cancelTimeout, it = e.noTimeout, At = e.isPrimaryRenderer, rt = e.supportsMutation, ae = e.supportsPersistence, et = e.supportsHydration, Ye = e.getInstanceFromNode, Ge = e.preparePortalMount, $e = e.getCurrentEventPriority, Ut = e.detachDeletedInstance, nt = e.supportsMicrotasks, Ct = e.scheduleMicrotask, Pt = e.supportsTestSelectors, vt = e.findFiberRoot, Zt = e.getBoundingRect, ie = e.getTextContent, ne = e.isHiddenSubtree, Oe = e.matchAccessibilityRole, _t = e.setFocusIfFocusable, ot = e.setupIntersectionObserver, at = e.appendChild, Wt = e.appendChildToContainer, Dt = e.commitTextUpdate, Se = e.commitMount, He = e.commitUpdate, lt = e.insertBefore, St = e.insertInContainerBefore, Je = e.removeChild, be = e.removeChildFromContainer, Ze = e.resetTextContent, ct = e.hideInstance, pe = e.hideTextInstance, Rt = e.unhideInstance, Be = e.unhideTextInstance, ut = e.clearContainer, on = e.cloneInstance, zn = e.createContainerChildSet, Gn = e.appendChildToContainerChildSet, rr = e.finalizeContainerChildren, mn = e.replaceContainerChildren, er = e.cloneHiddenInstance, ir = e.cloneHiddenTextInstance, Wn = e.canHydrateInstance, Ei = e.canHydrateTextInstance, Wr = e.canHydrateSuspenseInstance, Br = e.isSuspenseInstancePending, Mr = e.isSuspenseInstanceFallback, Ri = e.registerSuspenseInstanceRetry, si = e.getNextHydratableSibling, De = e.getFirstHydratableChild, Ft = e.getFirstHydratableChildWithinContainer, qt = e.getFirstHydratableChildWithinSuspenseInstance, En = e.hydrateInstance, ye = e.hydrateTextInstance, qe = e.hydrateSuspenseInstance, tt = e.getNextHydratableInstanceAfterSuspenseInstance, Ve = e.commitHydratedContainer, pt = e.commitHydratedSuspenseInstance, en = e.clearSuspenseBoundary, cn = e.clearSuspenseBoundaryFromContainer, xn = e.shouldDeleteUnhydratedTailInstances, Nn = e.didNotMatchHydratedContainerTextInstance, lr = e.didNotMatchHydratedTextInstance, bt;
    function ar(g) {
      if (bt === void 0)
        try {
          throw Error();
        } catch (D) {
          var S = D.stack.trim().match(/\n( *(at )?)/);
          bt = S && S[1] || "";
        }
      return `
` + bt + g;
    }
    var Hr = !1;
    function Tn(g, S) {
      if (!g || Hr)
        return "";
      Hr = !0;
      var D = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (S)
          if (S = function() {
            throw Error();
          }, Object.defineProperty(S.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(S, []);
            } catch (Jt) {
              var z = Jt;
            }
            Reflect.construct(g, [], S);
          } else {
            try {
              S.call();
            } catch (Jt) {
              z = Jt;
            }
            g.call(S.prototype);
          }
        else {
          try {
            throw Error();
          } catch (Jt) {
            z = Jt;
          }
          g();
        }
      } catch (Jt) {
        if (Jt && z && typeof Jt.stack == "string") {
          for (var W = Jt.stack.split(`
`), Z = z.stack.split(`
`), we = W.length - 1, Qe = Z.length - 1; 1 <= we && 0 <= Qe && W[we] !== Z[Qe]; )
            Qe--;
          for (; 1 <= we && 0 <= Qe; we--, Qe--)
            if (W[we] !== Z[Qe]) {
              if (we !== 1 || Qe !== 1)
                do
                  if (we--, Qe--, 0 > Qe || W[we] !== Z[Qe]) {
                    var Ot = `
` + W[we].replace(" at new ", " at ");
                    return g.displayName && Ot.includes("<anonymous>") && (Ot = Ot.replace("<anonymous>", g.displayName)), Ot;
                  }
                while (1 <= we && 0 <= Qe);
              break;
            }
        }
      } finally {
        Hr = !1, Error.prepareStackTrace = D;
      }
      return (g = g ? g.displayName || g.name : "") ? ar(g) : "";
    }
    var Ji = Object.prototype.hasOwnProperty, Do = [], li = -1;
    function $n(g) {
      return { current: g };
    }
    function _r(g) {
      0 > li || (g.current = Do[li], Do[li] = null, li--);
    }
    function ur(g, S) {
      li++, Do[li] = g.current, g.current = S;
    }
    var di = {}, xa = $n(di), Xr = $n(!1), ds = di;
    function bi(g, S) {
      var D = g.type.contextTypes;
      if (!D)
        return di;
      var z = g.stateNode;
      if (z && z.__reactInternalMemoizedUnmaskedChildContext === S)
        return z.__reactInternalMemoizedMaskedChildContext;
      var W = {}, Z;
      for (Z in D)
        W[Z] = S[Z];
      return z && (g = g.stateNode, g.__reactInternalMemoizedUnmaskedChildContext = S, g.__reactInternalMemoizedMaskedChildContext = W), W;
    }
    function Ti(g) {
      return g = g.childContextTypes, g != null;
    }
    function Xa() {
      _r(Xr), _r(xa);
    }
    function Ai(g, S, D) {
      if (xa.current !== di)
        throw Error(l(168));
      ur(xa, S), ur(Xr, D);
    }
    function ru(g, S, D) {
      var z = g.stateNode;
      if (S = S.childContextTypes, typeof z.getChildContext != "function")
        return D;
      z = z.getChildContext();
      for (var W in z)
        if (!(W in S))
          throw Error(l(108, J(g) || "Unknown", W));
      return o({}, D, z);
    }
    function Ns(g) {
      return g = (g = g.stateNode) && g.__reactInternalMemoizedMergedChildContext || di, ds = xa.current, ur(xa, g), ur(Xr, Xr.current), !0;
    }
    function yo(g, S, D) {
      var z = g.stateNode;
      if (!z)
        throw Error(l(169));
      D ? (g = ru(g, S, ds), z.__reactInternalMemoizedMergedChildContext = g, _r(Xr), _r(xa), ur(xa, g)) : _r(Xr), ur(Xr, D);
    }
    var Wo = Math.clz32 ? Math.clz32 : yp, ac = Math.log, sl = Math.LN2;
    function yp(g) {
      return g >>>= 0, g === 0 ? 32 : 31 - (ac(g) / sl | 0) | 0;
    }
    var Dl = 64, Vr = 4194304;
    function ll(g) {
      switch (g & -g) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return g & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return g & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return g;
      }
    }
    function kf(g, S) {
      var D = g.pendingLanes;
      if (D === 0)
        return 0;
      var z = 0, W = g.suspendedLanes, Z = g.pingedLanes, we = D & 268435455;
      if (we !== 0) {
        var Qe = we & ~W;
        Qe !== 0 ? z = ll(Qe) : (Z &= we, Z !== 0 && (z = ll(Z)));
      } else
        we = D & ~W, we !== 0 ? z = ll(we) : Z !== 0 && (z = ll(Z));
      if (z === 0)
        return 0;
      if (S !== 0 && S !== z && !(S & W) && (W = z & -z, Z = S & -S, W >= Z || W === 16 && (Z & 4194240) !== 0))
        return S;
      if (z & 4 && (z |= D & 16), S = g.entangledLanes, S !== 0)
        for (g = g.entanglements, S &= z; 0 < S; )
          D = 31 - Wo(S), W = 1 << D, z |= g[D], S &= ~W;
      return z;
    }
    function jo(g, S) {
      switch (g) {
        case 1:
        case 2:
        case 4:
          return S + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return S + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function ei(g, S) {
      for (var D = g.suspendedLanes, z = g.pingedLanes, W = g.expirationTimes, Z = g.pendingLanes; 0 < Z; ) {
        var we = 31 - Wo(Z), Qe = 1 << we, Ot = W[we];
        Ot === -1 ? (!(Qe & D) || Qe & z) && (W[we] = jo(Qe, S)) : Ot <= S && (g.expiredLanes |= Qe), Z &= ~Qe;
      }
    }
    function Ra(g) {
      return g = g.pendingLanes & -1073741825, g !== 0 ? g : g & 1073741824 ? 1073741824 : 0;
    }
    function zf(g) {
      for (var S = [], D = 0; 31 > D; D++)
        S.push(g);
      return S;
    }
    function nr(g, S, D) {
      g.pendingLanes |= S, S !== 536870912 && (g.suspendedLanes = 0, g.pingedLanes = 0), g = g.eventTimes, S = 31 - Wo(S), g[S] = D;
    }
    function iu(g, S) {
      var D = g.pendingLanes & ~S;
      g.pendingLanes = S, g.suspendedLanes = 0, g.pingedLanes = 0, g.expiredLanes &= S, g.mutableReadLanes &= S, g.entangledLanes &= S, S = g.entanglements;
      var z = g.eventTimes;
      for (g = g.expirationTimes; 0 < D; ) {
        var W = 31 - Wo(D), Z = 1 << W;
        S[W] = 0, z[W] = -1, g[W] = -1, D &= ~Z;
      }
    }
    function Fi(g, S) {
      var D = g.entangledLanes |= S;
      for (g = g.entanglements; D; ) {
        var z = 31 - Wo(D), W = 1 << z;
        W & S | g[z] & S && (g[z] |= S), D &= ~W;
      }
    }
    var dr = 0;
    function hs(g) {
      return g &= -g, 1 < g ? 4 < g ? g & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var Lo = i.unstable_scheduleCallback, fa = i.unstable_cancelCallback, gi = i.unstable_shouldYield, Sm = i.unstable_requestPaint, qr = i.unstable_now, Aa = i.unstable_ImmediatePriority, Ru = i.unstable_UserBlockingPriority, ps = i.unstable_NormalPriority, oc = i.unstable_IdlePriority, Vc = null, ul = null;
    function Gc(g) {
      if (ul && typeof ul.onCommitFiberRoot == "function")
        try {
          ul.onCommitFiberRoot(Vc, g, void 0, (g.current.flags & 128) === 128);
        } catch {
        }
    }
    function If(g, S) {
      return g === S && (g !== 0 || 1 / g === 1 / S) || g !== g && S !== S;
    }
    var Oo = typeof Object.is == "function" ? Object.is : If, qa = null, Au = !1, Fs = !1;
    function Wc(g) {
      qa === null ? qa = [g] : qa.push(g);
    }
    function jc(g) {
      Au = !0, Wc(g);
    }
    function $o() {
      if (!Fs && qa !== null) {
        Fs = !0;
        var g = 0, S = dr;
        try {
          var D = qa;
          for (dr = 1; g < D.length; g++) {
            var z = D[g];
            do
              z = z(!0);
            while (z !== null);
          }
          qa = null, Au = !1;
        } catch (W) {
          throw qa !== null && (qa = qa.slice(g + 1)), Lo(Aa, $o), W;
        } finally {
          dr = S, Fs = !1;
        }
      }
      return null;
    }
    var $c = c.ReactCurrentBatchConfig;
    function ks(g, S) {
      if (Oo(g, S))
        return !0;
      if (typeof g != "object" || g === null || typeof S != "object" || S === null)
        return !1;
      var D = Object.keys(g), z = Object.keys(S);
      if (D.length !== z.length)
        return !1;
      for (z = 0; z < D.length; z++) {
        var W = D[z];
        if (!Ji.call(S, W) || !Oo(g[W], S[W]))
          return !1;
      }
      return !0;
    }
    function Du(g) {
      switch (g.tag) {
        case 5:
          return ar(g.type);
        case 16:
          return ar("Lazy");
        case 13:
          return ar("Suspense");
        case 19:
          return ar("SuspenseList");
        case 0:
        case 2:
        case 15:
          return g = Tn(g.type, !1), g;
        case 11:
          return g = Tn(g.type.render, !1), g;
        case 1:
          return g = Tn(g.type, !0), g;
        default:
          return "";
      }
    }
    function So(g, S) {
      if (g && g.defaultProps) {
        S = o({}, S), g = g.defaultProps;
        for (var D in g)
          S[D] === void 0 && (S[D] = g[D]);
        return S;
      }
      return S;
    }
    var Ka = $n(null), au = null, zs = null, sc = null;
    function Po() {
      sc = zs = au = null;
    }
    function ou(g, S, D) {
      At ? (ur(Ka, S._currentValue), S._currentValue = D) : (ur(Ka, S._currentValue2), S._currentValue2 = D);
    }
    function Da(g) {
      var S = Ka.current;
      _r(Ka), At ? g._currentValue = S : g._currentValue2 = S;
    }
    function ao(g, S, D) {
      for (; g !== null; ) {
        var z = g.alternate;
        if ((g.childLanes & S) !== S ? (g.childLanes |= S, z !== null && (z.childLanes |= S)) : z !== null && (z.childLanes & S) !== S && (z.childLanes |= S), g === D)
          break;
        g = g.return;
      }
    }
    function La(g, S) {
      au = g, sc = zs = null, g = g.dependencies, g !== null && g.firstContext !== null && (g.lanes & S && (Nr = !0), g.firstContext = null);
    }
    function da(g) {
      var S = At ? g._currentValue : g._currentValue2;
      if (sc !== g)
        if (g = { context: g, memoizedValue: S, next: null }, zs === null) {
          if (au === null)
            throw Error(l(308));
          zs = g, au.dependencies = { lanes: 0, firstContext: g };
        } else
          zs = zs.next = g;
      return S;
    }
    var ms = null, cl = !1;
    function oo(g) {
      g.updateQueue = { baseState: g.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Bf(g, S) {
      g = g.updateQueue, S.updateQueue === g && (S.updateQueue = { baseState: g.baseState, firstBaseUpdate: g.firstBaseUpdate, lastBaseUpdate: g.lastBaseUpdate, shared: g.shared, effects: g.effects });
    }
    function lc(g, S) {
      return { eventTime: g, lane: S, tag: 0, payload: null, callback: null, next: null };
    }
    function Yc(g, S) {
      var D = g.updateQueue;
      D !== null && (D = D.shared, qi !== null && g.mode & 1 && !(Lr & 2) ? (g = D.interleaved, g === null ? (S.next = S, ms === null ? ms = [D] : ms.push(D)) : (S.next = g.next, g.next = S), D.interleaved = S) : (g = D.pending, g === null ? S.next = S : (S.next = g.next, g.next = S), D.pending = S));
    }
    function xm(g, S, D) {
      if (S = S.updateQueue, S !== null && (S = S.shared, (D & 4194240) !== 0)) {
        var z = S.lanes;
        z &= g.pendingLanes, D |= z, S.lanes = D, Fi(g, D);
      }
    }
    function Xc(g, S) {
      var D = g.updateQueue, z = g.alternate;
      if (z !== null && (z = z.updateQueue, D === z)) {
        var W = null, Z = null;
        if (D = D.firstBaseUpdate, D !== null) {
          do {
            var we = { eventTime: D.eventTime, lane: D.lane, tag: D.tag, payload: D.payload, callback: D.callback, next: null };
            Z === null ? W = Z = we : Z = Z.next = we, D = D.next;
          } while (D !== null);
          Z === null ? W = Z = S : Z = Z.next = S;
        } else
          W = Z = S;
        D = { baseState: z.baseState, firstBaseUpdate: W, lastBaseUpdate: Z, shared: z.shared, effects: z.effects }, g.updateQueue = D;
        return;
      }
      g = D.lastBaseUpdate, g === null ? D.firstBaseUpdate = S : g.next = S, D.lastBaseUpdate = S;
    }
    function xh(g, S, D, z) {
      var W = g.updateQueue;
      cl = !1;
      var Z = W.firstBaseUpdate, we = W.lastBaseUpdate, Qe = W.shared.pending;
      if (Qe !== null) {
        W.shared.pending = null;
        var Ot = Qe, Jt = Ot.next;
        Ot.next = null, we === null ? Z = Jt : we.next = Jt, we = Ot;
        var ln = g.alternate;
        ln !== null && (ln = ln.updateQueue, Qe = ln.lastBaseUpdate, Qe !== we && (Qe === null ? ln.firstBaseUpdate = Jt : Qe.next = Jt, ln.lastBaseUpdate = Ot));
      }
      if (Z !== null) {
        var cr = W.baseState;
        we = 0, ln = Jt = Ot = null, Qe = Z;
        do {
          var Qn = Qe.lane, Ki = Qe.eventTime;
          if ((z & Qn) === Qn) {
            ln !== null && (ln = ln.next = {
              eventTime: Ki,
              lane: 0,
              tag: Qe.tag,
              payload: Qe.payload,
              callback: Qe.callback,
              next: null
            });
            e: {
              var hn = g, ri = Qe;
              switch (Qn = S, Ki = D, ri.tag) {
                case 1:
                  if (hn = ri.payload, typeof hn == "function") {
                    cr = hn.call(Ki, cr, Qn);
                    break e;
                  }
                  cr = hn;
                  break e;
                case 3:
                  hn.flags = hn.flags & -65537 | 128;
                case 0:
                  if (hn = ri.payload, Qn = typeof hn == "function" ? hn.call(Ki, cr, Qn) : hn, Qn == null)
                    break e;
                  cr = o({}, cr, Qn);
                  break e;
                case 2:
                  cl = !0;
              }
            }
            Qe.callback !== null && Qe.lane !== 0 && (g.flags |= 64, Qn = W.effects, Qn === null ? W.effects = [Qe] : Qn.push(Qe));
          } else
            Ki = { eventTime: Ki, lane: Qn, tag: Qe.tag, payload: Qe.payload, callback: Qe.callback, next: null }, ln === null ? (Jt = ln = Ki, Ot = cr) : ln = ln.next = Ki, we |= Qn;
          if (Qe = Qe.next, Qe === null) {
            if (Qe = W.shared.pending, Qe === null)
              break;
            Qn = Qe, Qe = Qn.next, Qn.next = null, W.lastBaseUpdate = Qn, W.shared.pending = null;
          }
        } while (1);
        if (ln === null && (Ot = cr), W.baseState = Ot, W.firstBaseUpdate = Jt, W.lastBaseUpdate = ln, S = W.shared.interleaved, S !== null) {
          W = S;
          do
            we |= W.lane, W = W.next;
          while (W !== S);
        } else
          Z === null && (W.shared.lanes = 0);
        Bu |= we, g.lanes = we, g.memoizedState = cr;
      }
    }
    function Lv(g, S, D) {
      if (g = S.effects, S.effects = null, g !== null)
        for (S = 0; S < g.length; S++) {
          var z = g[S], W = z.callback;
          if (W !== null) {
            if (z.callback = null, z = D, typeof W != "function")
              throw Error(l(191, W));
            W.call(z);
          }
        }
    }
    var ey = new r.Component().refs;
    function _m(g, S, D, z) {
      S = g.memoizedState, D = D(z, S), D = D == null ? S : o({}, S, D), g.memoizedState = D, g.lanes === 0 && (g.updateQueue.baseState = D);
    }
    var Em = { isMounted: function(g) {
      return (g = g._reactInternals) ? K(g) === g : !1;
    }, enqueueSetState: function(g, S, D) {
      g = g._reactInternals;
      var z = jr(), W = bo(g), Z = lc(z, W);
      Z.payload = S, D != null && (Z.callback = D), Yc(g, Z), S = Ks(g, W, z), S !== null && xm(S, g, W);
    }, enqueueReplaceState: function(g, S, D) {
      g = g._reactInternals;
      var z = jr(), W = bo(g), Z = lc(z, W);
      Z.tag = 1, Z.payload = S, D != null && (Z.callback = D), Yc(g, Z), S = Ks(g, W, z), S !== null && xm(S, g, W);
    }, enqueueForceUpdate: function(g, S) {
      g = g._reactInternals;
      var D = jr(), z = bo(g), W = lc(
        D,
        z
      );
      W.tag = 2, S != null && (W.callback = S), Yc(g, W), S = Ks(g, z, D), S !== null && xm(S, g, z);
    } };
    function bm(g, S, D, z, W, Z, we) {
      return g = g.stateNode, typeof g.shouldComponentUpdate == "function" ? g.shouldComponentUpdate(z, Z, we) : S.prototype && S.prototype.isPureReactComponent ? !ks(D, z) || !ks(W, Z) : !0;
    }
    function Tm(g, S, D) {
      var z = !1, W = di, Z = S.contextType;
      return typeof Z == "object" && Z !== null ? Z = da(Z) : (W = Ti(S) ? ds : xa.current, z = S.contextTypes, Z = (z = z != null) ? bi(g, W) : di), S = new S(D, Z), g.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = Em, g.stateNode = S, S._reactInternals = g, z && (g = g.stateNode, g.__reactInternalMemoizedUnmaskedChildContext = W, g.__reactInternalMemoizedMaskedChildContext = Z), S;
    }
    function Ov(g, S, D, z) {
      g = S.state, typeof S.componentWillReceiveProps == "function" && S.componentWillReceiveProps(D, z), typeof S.UNSAFE_componentWillReceiveProps == "function" && S.UNSAFE_componentWillReceiveProps(D, z), S.state !== g && Em.enqueueReplaceState(S, S.state, null);
    }
    function wm(g, S, D, z) {
      var W = g.stateNode;
      W.props = D, W.state = g.memoizedState, W.refs = ey, oo(g);
      var Z = S.contextType;
      typeof Z == "object" && Z !== null ? W.context = da(Z) : (Z = Ti(S) ? ds : xa.current, W.context = bi(g, Z)), W.state = g.memoizedState, Z = S.getDerivedStateFromProps, typeof Z == "function" && (_m(g, S, Z, D), W.state = g.memoizedState), typeof S.getDerivedStateFromProps == "function" || typeof W.getSnapshotBeforeUpdate == "function" || typeof W.UNSAFE_componentWillMount != "function" && typeof W.componentWillMount != "function" || (S = W.state, typeof W.componentWillMount == "function" && W.componentWillMount(), typeof W.UNSAFE_componentWillMount == "function" && W.UNSAFE_componentWillMount(), S !== W.state && Em.enqueueReplaceState(W, W.state, null), xh(g, D, W, z), W.state = g.memoizedState), typeof W.componentDidMount == "function" && (g.flags |= 4194308);
    }
    var Rd = [], Hf = 0, su = null, Mm = 0, fl = [], Is = 0, qc = null, Kc = 1, lu = "";
    function Vf(g, S) {
      Rd[Hf++] = Mm, Rd[Hf++] = su, su = g, Mm = S;
    }
    function Bs(g, S, D) {
      fl[Is++] = Kc, fl[Is++] = lu, fl[Is++] = qc, qc = g;
      var z = Kc;
      g = lu;
      var W = 32 - Wo(z) - 1;
      z &= ~(1 << W), D += 1;
      var Z = 32 - Wo(S) + W;
      if (30 < Z) {
        var we = W - W % 5;
        Z = (z & (1 << we) - 1).toString(32), z >>= we, W -= we, Kc = 1 << 32 - Wo(S) + W | D << W | z, lu = Z + g;
      } else
        Kc = 1 << Z | D << W | z, lu = g;
    }
    function Lu(g) {
      g.return !== null && (Vf(g, 1), Bs(g, 1, 0));
    }
    function Oa(g) {
      for (; g === su; )
        su = Rd[--Hf], Rd[Hf] = null, Mm = Rd[--Hf], Rd[Hf] = null;
      for (; g === qc; )
        qc = fl[--Is], fl[Is] = null, lu = fl[--Is], fl[Is] = null, Kc = fl[--Is], fl[Is] = null;
    }
    var _a = null, Ea = null, Hi = !1, Ad = !1, Yo = null;
    function Cm(g, S) {
      var D = wo(5, null, null, 0);
      D.elementType = "DELETED", D.stateNode = S, D.return = g, S = g.deletions, S === null ? (g.deletions = [D], g.flags |= 16) : S.push(D);
    }
    function Rm(g, S) {
      switch (g.tag) {
        case 5:
          return S = Wn(S, g.type, g.pendingProps), S !== null ? (g.stateNode = S, _a = g, Ea = De(S), !0) : !1;
        case 6:
          return S = Ei(S, g.pendingProps), S !== null ? (g.stateNode = S, _a = g, Ea = null, !0) : !1;
        case 13:
          if (S = Wr(S), S !== null) {
            var D = qc !== null ? { id: Kc, overflow: lu } : null;
            return g.memoizedState = { dehydrated: S, treeContext: D, retryLane: 1073741824 }, D = wo(18, null, null, 0), D.stateNode = S, D.return = g, g.child = D, _a = g, Ea = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function Dd(g) {
      return (g.mode & 1) !== 0 && (g.flags & 128) === 0;
    }
    function Qc(g) {
      if (Hi) {
        var S = Ea;
        if (S) {
          var D = S;
          if (!Rm(g, S)) {
            if (Dd(g))
              throw Error(l(418));
            S = si(D);
            var z = _a;
            S && Rm(g, S) ? Cm(z, D) : (g.flags = g.flags & -4097 | 2, Hi = !1, _a = g);
          }
        } else {
          if (Dd(g))
            throw Error(l(418));
          g.flags = g.flags & -4097 | 2, Hi = !1, _a = g;
        }
      }
    }
    function Pv(g) {
      for (g = g.return; g !== null && g.tag !== 5 && g.tag !== 3 && g.tag !== 13; )
        g = g.return;
      _a = g;
    }
    function Sp(g) {
      if (!et || g !== _a)
        return !1;
      if (!Hi)
        return Pv(g), Hi = !0, !1;
      if (g.tag !== 3 && (g.tag !== 5 || xn(g.type) && !Ae(g.type, g.memoizedProps))) {
        var S = Ea;
        if (S) {
          if (Dd(g)) {
            for (g = Ea; g; )
              g = si(g);
            throw Error(l(418));
          }
          for (; S; )
            Cm(g, S), S = si(S);
        }
      }
      if (Pv(g), g.tag === 13) {
        if (!et)
          throw Error(l(316));
        if (g = g.memoizedState, g = g !== null ? g.dehydrated : null, !g)
          throw Error(l(317));
        Ea = tt(g);
      } else
        Ea = _a ? si(g.stateNode) : null;
      return !0;
    }
    function Ld() {
      et && (Ea = _a = null, Ad = Hi = !1);
    }
    function _h(g) {
      Yo === null ? Yo = [g] : Yo.push(g);
    }
    function Gf(g, S, D) {
      if (g = D.ref, g !== null && typeof g != "function" && typeof g != "object") {
        if (D._owner) {
          if (D = D._owner, D) {
            if (D.tag !== 1)
              throw Error(l(309));
            var z = D.stateNode;
          }
          if (!z)
            throw Error(l(147, g));
          var W = z, Z = "" + g;
          return S !== null && S.ref !== null && typeof S.ref == "function" && S.ref._stringRef === Z ? S.ref : (S = function(we) {
            var Qe = W.refs;
            Qe === ey && (Qe = W.refs = {}), we === null ? delete Qe[Z] : Qe[Z] = we;
          }, S._stringRef = Z, S);
        }
        if (typeof g != "string")
          throw Error(l(284));
        if (!D._owner)
          throw Error(l(290, g));
      }
      return g;
    }
    function Hs(g, S) {
      throw g = Object.prototype.toString.call(S), Error(l(31, g === "[object Object]" ? "object with keys {" + Object.keys(S).join(", ") + "}" : g));
    }
    function Zc(g) {
      var S = g._init;
      return S(g._payload);
    }
    function uc(g) {
      function S(mt, We) {
        if (g) {
          var Mt = mt.deletions;
          Mt === null ? (mt.deletions = [We], mt.flags |= 16) : Mt.push(We);
        }
      }
      function D(mt, We) {
        if (!g)
          return null;
        for (; We !== null; )
          S(mt, We), We = We.sibling;
        return null;
      }
      function z(mt, We) {
        for (mt = /* @__PURE__ */ new Map(); We !== null; )
          We.key !== null ? mt.set(We.key, We) : mt.set(We.index, We), We = We.sibling;
        return mt;
      }
      function W(mt, We) {
        return mt = Ko(mt, We), mt.index = 0, mt.sibling = null, mt;
      }
      function Z(mt, We, Mt) {
        return mt.index = Mt, g ? (Mt = mt.alternate, Mt !== null ? (Mt = Mt.index, Mt < We ? (mt.flags |= 2, We) : Mt) : (mt.flags |= 2, We)) : (mt.flags |= 1048576, We);
      }
      function we(mt) {
        return g && mt.alternate === null && (mt.flags |= 2), mt;
      }
      function Qe(mt, We, Mt, Vt) {
        return We === null || We.tag !== 6 ? (We = vf(Mt, mt.mode, Vt), We.return = mt, We) : (We = W(We, Mt), We.return = mt, We);
      }
      function Ot(mt, We, Mt, Vt) {
        var An = Mt.type;
        return An === y ? ln(mt, We, Mt.props.children, Vt, Mt.key) : We !== null && (We.elementType === An || typeof An == "object" && An !== null && An.$$typeof === k && Zc(An) === We.type) ? (Vt = W(We, Mt.props), Vt.ref = Gf(mt, We, Mt), Vt.return = mt, Vt) : (Vt = mf(Mt.type, Mt.key, Mt.props, null, mt.mode, Vt), Vt.ref = Gf(mt, We, Mt), Vt.return = mt, Vt);
      }
      function Jt(mt, We, Mt, Vt) {
        return We === null || We.tag !== 4 || We.stateNode.containerInfo !== Mt.containerInfo || We.stateNode.implementation !== Mt.implementation ? (We = Su(Mt, mt.mode, Vt), We.return = mt, We) : (We = W(We, Mt.children || []), We.return = mt, We);
      }
      function ln(mt, We, Mt, Vt, An) {
        return We === null || We.tag !== 7 ? (We = Il(Mt, mt.mode, Vt, An), We.return = mt, We) : (We = W(We, Mt), We.return = mt, We);
      }
      function cr(mt, We, Mt) {
        if (typeof We == "string" && We !== "" || typeof We == "number")
          return We = vf("" + We, mt.mode, Mt), We.return = mt, We;
        if (typeof We == "object" && We !== null) {
          switch (We.$$typeof) {
            case h:
              return Mt = mf(We.type, We.key, We.props, null, mt.mode, Mt), Mt.ref = Gf(mt, null, We), Mt.return = mt, Mt;
            case p:
              return We = Su(We, mt.mode, Mt), We.return = mt, We;
            case k:
              var Vt = We._init;
              return cr(mt, Vt(We._payload), Mt);
          }
          if (xe(We) || $(We))
            return We = Il(We, mt.mode, Mt, null), We.return = mt, We;
          Hs(mt, We);
        }
        return null;
      }
      function Qn(mt, We, Mt, Vt) {
        var An = We !== null ? We.key : null;
        if (typeof Mt == "string" && Mt !== "" || typeof Mt == "number")
          return An !== null ? null : Qe(mt, We, "" + Mt, Vt);
        if (typeof Mt == "object" && Mt !== null) {
          switch (Mt.$$typeof) {
            case h:
              return Mt.key === An ? Ot(mt, We, Mt, Vt) : null;
            case p:
              return Mt.key === An ? Jt(mt, We, Mt, Vt) : null;
            case k:
              return An = Mt._init, Qn(
                mt,
                We,
                An(Mt._payload),
                Vt
              );
          }
          if (xe(Mt) || $(Mt))
            return An !== null ? null : ln(mt, We, Mt, Vt, null);
          Hs(mt, Mt);
        }
        return null;
      }
      function Ki(mt, We, Mt, Vt, An) {
        if (typeof Vt == "string" && Vt !== "" || typeof Vt == "number")
          return mt = mt.get(Mt) || null, Qe(We, mt, "" + Vt, An);
        if (typeof Vt == "object" && Vt !== null) {
          switch (Vt.$$typeof) {
            case h:
              return mt = mt.get(Vt.key === null ? Mt : Vt.key) || null, Ot(We, mt, Vt, An);
            case p:
              return mt = mt.get(Vt.key === null ? Mt : Vt.key) || null, Jt(We, mt, Vt, An);
            case k:
              var Rr = Vt._init;
              return Ki(mt, We, Mt, Rr(Vt._payload), An);
          }
          if (xe(Vt) || $(Vt))
            return mt = mt.get(Mt) || null, ln(We, mt, Vt, An, null);
          Hs(We, Vt);
        }
        return null;
      }
      function hn(mt, We, Mt, Vt) {
        for (var An = null, Rr = null, or = We, Fr = We = 0, va = null; or !== null && Fr < Mt.length; Fr++) {
          or.index > Fr ? (va = or, or = null) : va = or.sibling;
          var kr = Qn(mt, or, Mt[Fr], Vt);
          if (kr === null) {
            or === null && (or = va);
            break;
          }
          g && or && kr.alternate === null && S(mt, or), We = Z(kr, We, Fr), Rr === null ? An = kr : Rr.sibling = kr, Rr = kr, or = va;
        }
        if (Fr === Mt.length)
          return D(mt, or), Hi && Vf(mt, Fr), An;
        if (or === null) {
          for (; Fr < Mt.length; Fr++)
            or = cr(mt, Mt[Fr], Vt), or !== null && (We = Z(or, We, Fr), Rr === null ? An = or : Rr.sibling = or, Rr = or);
          return Hi && Vf(mt, Fr), An;
        }
        for (or = z(mt, or); Fr < Mt.length; Fr++)
          va = Ki(or, mt, Fr, Mt[Fr], Vt), va !== null && (g && va.alternate !== null && or.delete(va.key === null ? Fr : va.key), We = Z(va, We, Fr), Rr === null ? An = va : Rr.sibling = va, Rr = va);
        return g && or.forEach(function(xc) {
          return S(mt, xc);
        }), Hi && Vf(mt, Fr), An;
      }
      function ri(mt, We, Mt, Vt) {
        var An = $(Mt);
        if (typeof An != "function")
          throw Error(l(150));
        if (Mt = An.call(Mt), Mt == null)
          throw Error(l(151));
        for (var Rr = An = null, or = We, Fr = We = 0, va = null, kr = Mt.next(); or !== null && !kr.done; Fr++, kr = Mt.next()) {
          or.index > Fr ? (va = or, or = null) : va = or.sibling;
          var xc = Qn(mt, or, kr.value, Vt);
          if (xc === null) {
            or === null && (or = va);
            break;
          }
          g && or && xc.alternate === null && S(mt, or), We = Z(xc, We, Fr), Rr === null ? An = xc : Rr.sibling = xc, Rr = xc, or = va;
        }
        if (kr.done)
          return D(
            mt,
            or
          ), Hi && Vf(mt, Fr), An;
        if (or === null) {
          for (; !kr.done; Fr++, kr = Mt.next())
            kr = cr(mt, kr.value, Vt), kr !== null && (We = Z(kr, We, Fr), Rr === null ? An = kr : Rr.sibling = kr, Rr = kr);
          return Hi && Vf(mt, Fr), An;
        }
        for (or = z(mt, or); !kr.done; Fr++, kr = Mt.next())
          kr = Ki(or, mt, Fr, kr.value, Vt), kr !== null && (g && kr.alternate !== null && or.delete(kr.key === null ? Fr : kr.key), We = Z(kr, We, Fr), Rr === null ? An = kr : Rr.sibling = kr, Rr = kr);
        return g && or.forEach(function(Oh) {
          return S(mt, Oh);
        }), Hi && Vf(mt, Fr), An;
      }
      function ka(mt, We, Mt, Vt) {
        if (typeof Mt == "object" && Mt !== null && Mt.type === y && Mt.key === null && (Mt = Mt.props.children), typeof Mt == "object" && Mt !== null) {
          switch (Mt.$$typeof) {
            case h:
              e: {
                for (var An = Mt.key, Rr = We; Rr !== null; ) {
                  if (Rr.key === An) {
                    if (An = Mt.type, An === y) {
                      if (Rr.tag === 7) {
                        D(mt, Rr.sibling), We = W(Rr, Mt.props.children), We.return = mt, mt = We;
                        break e;
                      }
                    } else if (Rr.elementType === An || typeof An == "object" && An !== null && An.$$typeof === k && Zc(An) === Rr.type) {
                      D(mt, Rr.sibling), We = W(Rr, Mt.props), We.ref = Gf(mt, Rr, Mt), We.return = mt, mt = We;
                      break e;
                    }
                    D(mt, Rr);
                    break;
                  } else
                    S(mt, Rr);
                  Rr = Rr.sibling;
                }
                Mt.type === y ? (We = Il(Mt.props.children, mt.mode, Vt, Mt.key), We.return = mt, mt = We) : (Vt = mf(Mt.type, Mt.key, Mt.props, null, mt.mode, Vt), Vt.ref = Gf(mt, We, Mt), Vt.return = mt, mt = Vt);
              }
              return we(mt);
            case p:
              e: {
                for (Rr = Mt.key; We !== null; ) {
                  if (We.key === Rr)
                    if (We.tag === 4 && We.stateNode.containerInfo === Mt.containerInfo && We.stateNode.implementation === Mt.implementation) {
                      D(mt, We.sibling), We = W(We, Mt.children || []), We.return = mt, mt = We;
                      break e;
                    } else {
                      D(mt, We);
                      break;
                    }
                  else
                    S(mt, We);
                  We = We.sibling;
                }
                We = Su(Mt, mt.mode, Vt), We.return = mt, mt = We;
              }
              return we(mt);
            case k:
              return Rr = Mt._init, ka(mt, We, Rr(Mt._payload), Vt);
          }
          if (xe(Mt))
            return hn(mt, We, Mt, Vt);
          if ($(Mt))
            return ri(mt, We, Mt, Vt);
          Hs(mt, Mt);
        }
        return typeof Mt == "string" && Mt !== "" || typeof Mt == "number" ? (Mt = "" + Mt, We !== null && We.tag === 6 ? (D(mt, We.sibling), We = W(We, Mt), We.return = mt, mt = We) : (D(mt, We), We = vf(Mt, mt.mode, Vt), We.return = mt, mt = We), we(mt)) : D(mt, We);
      }
      return ka;
    }
    var Ou = uc(!0), xp = uc(!1), Od = {}, vs = $n(Od), Pd = $n(Od), Jc = $n(Od);
    function uu(g) {
      if (g === Od)
        throw Error(l(174));
      return g;
    }
    function _p(g, S) {
      ur(Jc, S), ur(Pd, g), ur(vs, Od), g = Pe(S), _r(vs), ur(vs, g);
    }
    function Ud() {
      _r(vs), _r(Pd), _r(Jc);
    }
    function Ep(g) {
      var S = uu(Jc.current), D = uu(vs.current);
      S = ce(D, g.type, S), D !== S && (ur(Pd, g), ur(vs, S));
    }
    function Ll(g) {
      Pd.current === g && (_r(vs), _r(Pd));
    }
    var ea = $n(0);
    function Nd(g) {
      for (var S = g; S !== null; ) {
        if (S.tag === 13) {
          var D = S.memoizedState;
          if (D !== null && (D = D.dehydrated, D === null || Br(D) || Mr(D)))
            return S;
        } else if (S.tag === 19 && S.memoizedProps.revealOrder !== void 0) {
          if (S.flags & 128)
            return S;
        } else if (S.child !== null) {
          S.child.return = S, S = S.child;
          continue;
        }
        if (S === g)
          break;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === g)
            return null;
          S = S.return;
        }
        S.sibling.return = S.return, S = S.sibling;
      }
      return null;
    }
    var Pa = [];
    function dl() {
      for (var g = 0; g < Pa.length; g++) {
        var S = Pa[g];
        At ? S._workInProgressVersionPrimary = null : S._workInProgressVersionSecondary = null;
      }
      Pa.length = 0;
    }
    var so = c.ReactCurrentDispatcher, ki = c.ReactCurrentBatchConfig, ef = 0, Kr = null, yi = null, Di = null, Fd = !1, lo = !1, Wf = 0, cc = 0;
    function Qa() {
      throw Error(l(321));
    }
    function Ol(g, S) {
      if (S === null)
        return !1;
      for (var D = 0; D < S.length && D < g.length; D++)
        if (!Oo(g[D], S[D]))
          return !1;
      return !0;
    }
    function tf(g, S, D, z, W, Z) {
      if (ef = Z, Kr = S, S.memoizedState = null, S.updateQueue = null, S.lanes = 0, so.current = g === null || g.memoizedState === null ? nf : Bd, g = D(z, W), lo) {
        Z = 0;
        do {
          if (lo = !1, Wf = 0, 25 <= Z)
            throw Error(l(301));
          Z += 1, Di = yi = null, S.updateQueue = null, so.current = rf, g = D(z, W);
        } while (lo);
      }
      if (so.current = Yf, S = yi !== null && yi.next !== null, ef = 0, Di = yi = Kr = null, Fd = !1, S)
        throw Error(l(300));
      return g;
    }
    function Pu() {
      var g = Wf !== 0;
      return Wf = 0, g;
    }
    function cu() {
      var g = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Di === null ? Kr.memoizedState = Di = g : Di = Di.next = g, Di;
    }
    function Pl() {
      if (yi === null) {
        var g = Kr.alternate;
        g = g !== null ? g.memoizedState : null;
      } else
        g = yi.next;
      var S = Di === null ? Kr.memoizedState : Di.next;
      if (S !== null)
        Di = S, yi = g;
      else {
        if (g === null)
          throw Error(l(310));
        yi = g, g = { memoizedState: yi.memoizedState, baseState: yi.baseState, baseQueue: yi.baseQueue, queue: yi.queue, next: null }, Di === null ? Kr.memoizedState = Di = g : Di = Di.next = g;
      }
      return Di;
    }
    function Yi(g, S) {
      return typeof S == "function" ? S(g) : S;
    }
    function kd(g) {
      var S = Pl(), D = S.queue;
      if (D === null)
        throw Error(l(311));
      D.lastRenderedReducer = g;
      var z = yi, W = z.baseQueue, Z = D.pending;
      if (Z !== null) {
        if (W !== null) {
          var we = W.next;
          W.next = Z.next, Z.next = we;
        }
        z.baseQueue = W = Z, D.pending = null;
      }
      if (W !== null) {
        Z = W.next, z = z.baseState;
        var Qe = we = null, Ot = null, Jt = Z;
        do {
          var ln = Jt.lane;
          if ((ef & ln) === ln)
            Ot !== null && (Ot = Ot.next = { lane: 0, action: Jt.action, hasEagerState: Jt.hasEagerState, eagerState: Jt.eagerState, next: null }), z = Jt.hasEagerState ? Jt.eagerState : g(z, Jt.action);
          else {
            var cr = {
              lane: ln,
              action: Jt.action,
              hasEagerState: Jt.hasEagerState,
              eagerState: Jt.eagerState,
              next: null
            };
            Ot === null ? (Qe = Ot = cr, we = z) : Ot = Ot.next = cr, Kr.lanes |= ln, Bu |= ln;
          }
          Jt = Jt.next;
        } while (Jt !== null && Jt !== Z);
        Ot === null ? we = z : Ot.next = Qe, Oo(z, S.memoizedState) || (Nr = !0), S.memoizedState = z, S.baseState = we, S.baseQueue = Ot, D.lastRenderedState = z;
      }
      if (g = D.interleaved, g !== null) {
        W = g;
        do
          Z = W.lane, Kr.lanes |= Z, Bu |= Z, W = W.next;
        while (W !== g);
      } else
        W === null && (D.lanes = 0);
      return [S.memoizedState, D.dispatch];
    }
    function bp(g) {
      var S = Pl(), D = S.queue;
      if (D === null)
        throw Error(l(311));
      D.lastRenderedReducer = g;
      var z = D.dispatch, W = D.pending, Z = S.memoizedState;
      if (W !== null) {
        D.pending = null;
        var we = W = W.next;
        do
          Z = g(Z, we.action), we = we.next;
        while (we !== W);
        Oo(Z, S.memoizedState) || (Nr = !0), S.memoizedState = Z, S.baseQueue === null && (S.baseState = Z), D.lastRenderedState = Z;
      }
      return [Z, z];
    }
    function jf() {
    }
    function Am(g, S) {
      var D = Kr, z = Pl(), W = S(), Z = !Oo(z.memoizedState, W);
      if (Z && (z.memoizedState = W, Nr = !0), z = z.queue, Yt(Dr.bind(null, D, z, g), [g]), z.getSnapshot !== S || Z || Di !== null && Di.memoizedState.tag & 1) {
        if (D.flags |= 2048, Eh(9, Li.bind(null, D, z, W, S), void 0, null), qi === null)
          throw Error(l(349));
        ef & 30 || mr(D, S, W);
      }
      return W;
    }
    function mr(g, S, D) {
      g.flags |= 16384, g = { getSnapshot: S, value: D }, S = Kr.updateQueue, S === null ? (S = { lastEffect: null, stores: null }, Kr.updateQueue = S, S.stores = [g]) : (D = S.stores, D === null ? S.stores = [g] : D.push(g));
    }
    function Li(g, S, D, z) {
      S.value = D, S.getSnapshot = z, oa(S) && Ks(g, 1, -1);
    }
    function Dr(g, S, D) {
      return D(function() {
        oa(S) && Ks(g, 1, -1);
      });
    }
    function oa(g) {
      var S = g.getSnapshot;
      g = g.value;
      try {
        var D = S();
        return !Oo(g, D);
      } catch {
        return !0;
      }
    }
    function Uo(g) {
      var S = cu();
      return typeof g == "function" && (g = g()), S.memoizedState = S.baseState = g, g = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Yi, lastRenderedState: g }, S.queue = g, g = g.dispatch = wp.bind(null, Kr, g), [S.memoizedState, g];
    }
    function Eh(g, S, D, z) {
      return g = { tag: g, create: S, destroy: D, deps: z, next: null }, S = Kr.updateQueue, S === null ? (S = { lastEffect: null, stores: null }, Kr.updateQueue = S, S.lastEffect = g.next = g) : (D = S.lastEffect, D === null ? S.lastEffect = g.next = g : (z = D.next, D.next = g, g.next = z, S.lastEffect = g)), g;
    }
    function bh() {
      return Pl().memoizedState;
    }
    function $f(g, S, D, z) {
      var W = cu();
      Kr.flags |= g, W.memoizedState = Eh(1 | S, D, void 0, z === void 0 ? null : z);
    }
    function Dm(g, S, D, z) {
      var W = Pl();
      z = z === void 0 ? null : z;
      var Z = void 0;
      if (yi !== null) {
        var we = yi.memoizedState;
        if (Z = we.destroy, z !== null && Ol(z, we.deps)) {
          W.memoizedState = Eh(S, D, Z, z);
          return;
        }
      }
      Kr.flags |= g, W.memoizedState = Eh(1 | S, D, Z, z);
    }
    function Th(g, S) {
      return $f(8390656, 8, g, S);
    }
    function Yt(g, S) {
      return Dm(2048, 8, g, S);
    }
    function Er(g, S) {
      return Dm(4, 2, g, S);
    }
    function wr(g, S) {
      return Dm(4, 4, g, S);
    }
    function Vs(g, S) {
      if (typeof S == "function")
        return g = g(), S(g), function() {
          S(null);
        };
      if (S != null)
        return g = g(), S.current = g, function() {
          S.current = null;
        };
    }
    function hl(g, S, D) {
      return D = D != null ? D.concat([g]) : null, Dm(4, 4, Vs.bind(null, S, g), D);
    }
    function fc() {
    }
    function Ul(g, S) {
      var D = Pl();
      S = S === void 0 ? null : S;
      var z = D.memoizedState;
      return z !== null && S !== null && Ol(S, z[1]) ? z[0] : (D.memoizedState = [g, S], g);
    }
    function dc(g, S) {
      var D = Pl();
      S = S === void 0 ? null : S;
      var z = D.memoizedState;
      return z !== null && S !== null && Ol(S, z[1]) ? z[0] : (g = g(), D.memoizedState = [g, S], g);
    }
    function hc(g, S) {
      var D = dr;
      dr = D !== 0 && 4 > D ? D : 4, g(!0);
      var z = ki.transition;
      ki.transition = {};
      try {
        g(!1), S();
      } finally {
        dr = D, ki.transition = z;
      }
    }
    function fu() {
      return Pl().memoizedState;
    }
    function Tp(g, S, D) {
      var z = bo(g);
      D = { lane: z, action: D, hasEagerState: !1, eagerState: null, next: null }, Lm(g) ? wh(S, D) : (zd(g, S, D), D = jr(), g = Ks(g, z, D), g !== null && Id(g, S, z));
    }
    function wp(g, S, D) {
      var z = bo(g), W = { lane: z, action: D, hasEagerState: !1, eagerState: null, next: null };
      if (Lm(g))
        wh(S, W);
      else {
        zd(g, S, W);
        var Z = g.alternate;
        if (g.lanes === 0 && (Z === null || Z.lanes === 0) && (Z = S.lastRenderedReducer, Z !== null))
          try {
            var we = S.lastRenderedState, Qe = Z(we, D);
            if (W.hasEagerState = !0, W.eagerState = Qe, Oo(Qe, we))
              return;
          } catch {
          } finally {
          }
        D = jr(), g = Ks(g, z, D), g !== null && Id(g, S, z);
      }
    }
    function Lm(g) {
      var S = g.alternate;
      return g === Kr || S !== null && S === Kr;
    }
    function wh(g, S) {
      lo = Fd = !0;
      var D = g.pending;
      D === null ? S.next = S : (S.next = D.next, D.next = S), g.pending = S;
    }
    function zd(g, S, D) {
      qi !== null && g.mode & 1 && !(Lr & 2) ? (g = S.interleaved, g === null ? (D.next = D, ms === null ? ms = [S] : ms.push(S)) : (D.next = g.next, g.next = D), S.interleaved = D) : (g = S.pending, g === null ? D.next = D : (D.next = g.next, g.next = D), S.pending = D);
    }
    function Id(g, S, D) {
      if (D & 4194240) {
        var z = S.lanes;
        z &= g.pendingLanes, D |= z, S.lanes = D, Fi(g, D);
      }
    }
    var Yf = { readContext: da, useCallback: Qa, useContext: Qa, useEffect: Qa, useImperativeHandle: Qa, useInsertionEffect: Qa, useLayoutEffect: Qa, useMemo: Qa, useReducer: Qa, useRef: Qa, useState: Qa, useDebugValue: Qa, useDeferredValue: Qa, useTransition: Qa, useMutableSource: Qa, useSyncExternalStore: Qa, useId: Qa, unstable_isNewReconciler: !1 }, nf = { readContext: da, useCallback: function(g, S) {
      return cu().memoizedState = [g, S === void 0 ? null : S], g;
    }, useContext: da, useEffect: Th, useImperativeHandle: function(g, S, D) {
      return D = D != null ? D.concat([g]) : null, $f(
        4194308,
        4,
        Vs.bind(null, S, g),
        D
      );
    }, useLayoutEffect: function(g, S) {
      return $f(4194308, 4, g, S);
    }, useInsertionEffect: function(g, S) {
      return $f(4, 2, g, S);
    }, useMemo: function(g, S) {
      var D = cu();
      return S = S === void 0 ? null : S, g = g(), D.memoizedState = [g, S], g;
    }, useReducer: function(g, S, D) {
      var z = cu();
      return S = D !== void 0 ? D(S) : S, z.memoizedState = z.baseState = S, g = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: g, lastRenderedState: S }, z.queue = g, g = g.dispatch = Tp.bind(null, Kr, g), [z.memoizedState, g];
    }, useRef: function(g) {
      var S = cu();
      return g = { current: g }, S.memoizedState = g;
    }, useState: Uo, useDebugValue: fc, useDeferredValue: function(g) {
      var S = Uo(g), D = S[0], z = S[1];
      return Th(function() {
        var W = ki.transition;
        ki.transition = {};
        try {
          z(g);
        } finally {
          ki.transition = W;
        }
      }, [g]), D;
    }, useTransition: function() {
      var g = Uo(!1), S = g[0];
      return g = hc.bind(null, g[1]), cu().memoizedState = g, [S, g];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(g, S, D) {
      var z = Kr, W = cu();
      if (Hi) {
        if (D === void 0)
          throw Error(l(407));
        D = D();
      } else {
        if (D = S(), qi === null)
          throw Error(l(349));
        ef & 30 || mr(z, S, D);
      }
      W.memoizedState = D;
      var Z = { value: D, getSnapshot: S };
      return W.queue = Z, Th(Dr.bind(null, z, Z, g), [g]), z.flags |= 2048, Eh(9, Li.bind(null, z, Z, D, S), void 0, null), D;
    }, useId: function() {
      var g = cu(), S = qi.identifierPrefix;
      if (Hi) {
        var D = lu, z = Kc;
        D = (z & ~(1 << 32 - Wo(z) - 1)).toString(32) + D, S = ":" + S + "R" + D, D = Wf++, 0 < D && (S += "H" + D.toString(32)), S += ":";
      } else
        D = cc++, S = ":" + S + "r" + D.toString(32) + ":";
      return g.memoizedState = S;
    }, unstable_isNewReconciler: !1 }, Bd = {
      readContext: da,
      useCallback: Ul,
      useContext: da,
      useEffect: Yt,
      useImperativeHandle: hl,
      useInsertionEffect: Er,
      useLayoutEffect: wr,
      useMemo: dc,
      useReducer: kd,
      useRef: bh,
      useState: function() {
        return kd(Yi);
      },
      useDebugValue: fc,
      useDeferredValue: function(g) {
        var S = kd(Yi), D = S[0], z = S[1];
        return Yt(function() {
          var W = ki.transition;
          ki.transition = {};
          try {
            z(g);
          } finally {
            ki.transition = W;
          }
        }, [g]), D;
      },
      useTransition: function() {
        var g = kd(Yi)[0], S = Pl().memoizedState;
        return [g, S];
      },
      useMutableSource: jf,
      useSyncExternalStore: Am,
      useId: fu,
      unstable_isNewReconciler: !1
    }, rf = {
      readContext: da,
      useCallback: Ul,
      useContext: da,
      useEffect: Yt,
      useImperativeHandle: hl,
      useInsertionEffect: Er,
      useLayoutEffect: wr,
      useMemo: dc,
      useReducer: bp,
      useRef: bh,
      useState: function() {
        return bp(Yi);
      },
      useDebugValue: fc,
      useDeferredValue: function(g) {
        var S = bp(Yi), D = S[0], z = S[1];
        return Yt(function() {
          var W = ki.transition;
          ki.transition = {};
          try {
            z(g);
          } finally {
            ki.transition = W;
          }
        }, [g]), D;
      },
      useTransition: function() {
        var g = bp(Yi)[0], S = Pl().memoizedState;
        return [g, S];
      },
      useMutableSource: jf,
      useSyncExternalStore: Am,
      useId: fu,
      unstable_isNewReconciler: !1
    };
    function Mh(g, S) {
      try {
        var D = "", z = S;
        do
          D += Du(z), z = z.return;
        while (z);
        var W = D;
      } catch (Z) {
        W = `
Error generating stack: ` + Z.message + `
` + Z.stack;
      }
      return { value: g, source: S, stack: W };
    }
    function Hd(g, S) {
      try {
        console.error(S.value);
      } catch (D) {
        setTimeout(function() {
          throw D;
        });
      }
    }
    var Mp = typeof WeakMap == "function" ? WeakMap : Map;
    function Om(g, S, D) {
      D = lc(-1, D), D.tag = 3, D.payload = { element: null };
      var z = S.value;
      return D.callback = function() {
        uf || (uf = !0, gl = z), Hd(g, S);
      }, D;
    }
    function Uu(g, S, D) {
      D = lc(-1, D), D.tag = 3;
      var z = g.type.getDerivedStateFromError;
      if (typeof z == "function") {
        var W = S.value;
        D.payload = function() {
          return z(W);
        }, D.callback = function() {
          Hd(g, S);
        };
      }
      var Z = g.stateNode;
      return Z !== null && typeof Z.componentDidCatch == "function" && (D.callback = function() {
        Hd(g, S), typeof z != "function" && (vu === null ? vu = /* @__PURE__ */ new Set([this]) : vu.add(this));
        var we = S.stack;
        this.componentDidCatch(S.value, { componentStack: we !== null ? we : "" });
      }), D;
    }
    function Gs(g, S, D) {
      var z = g.pingCache;
      if (z === null) {
        z = g.pingCache = new Mp();
        var W = /* @__PURE__ */ new Set();
        z.set(S, W);
      } else
        W = z.get(S), W === void 0 && (W = /* @__PURE__ */ new Set(), z.set(S, W));
      W.has(D) || (W.add(D), g = Fl.bind(null, g, S, D), S.then(g, g));
    }
    function Nu(g) {
      do {
        var S;
        if ((S = g.tag === 13) && (S = g.memoizedState, S = S !== null ? S.dehydrated !== null : !0), S)
          return g;
        g = g.return;
      } while (g !== null);
      return null;
    }
    function Fu(g, S, D, z, W) {
      return g.mode & 1 ? (g.flags |= 65536, g.lanes = W, g) : (g === S ? g.flags |= 65536 : (g.flags |= 128, D.flags |= 131072, D.flags &= -52805, D.tag === 1 && (D.alternate === null ? D.tag = 17 : (S = lc(-1, 1), S.tag = 2, Yc(D, S))), D.lanes |= 1), g);
    }
    function Za(g) {
      g.flags |= 4;
    }
    function pc(g, S) {
      if (g !== null && g.child === S.child)
        return !0;
      if (S.flags & 16)
        return !1;
      for (g = S.child; g !== null; ) {
        if (g.flags & 12854 || g.subtreeFlags & 12854)
          return !1;
        g = g.sibling;
      }
      return !0;
    }
    var Ws, Xf, qf, Vd;
    if (rt)
      Ws = function(g, S) {
        for (var D = S.child; D !== null; ) {
          if (D.tag === 5 || D.tag === 6)
            he(g, D.stateNode);
          else if (D.tag !== 4 && D.child !== null) {
            D.child.return = D, D = D.child;
            continue;
          }
          if (D === S)
            break;
          for (; D.sibling === null; ) {
            if (D.return === null || D.return === S)
              return;
            D = D.return;
          }
          D.sibling.return = D.return, D = D.sibling;
        }
      }, Xf = function() {
      }, qf = function(g, S, D, z, W) {
        if (g = g.memoizedProps, g !== z) {
          var Z = S.stateNode, we = uu(vs.current);
          D = Le(Z, D, g, z, W, we), (S.updateQueue = D) && Za(S);
        }
      }, Vd = function(g, S, D, z) {
        D !== z && Za(S);
      };
    else if (ae) {
      Ws = function(g, S, D, z) {
        for (var W = S.child; W !== null; ) {
          if (W.tag === 5) {
            var Z = W.stateNode;
            D && z && (Z = er(Z, W.type, W.memoizedProps, W)), he(g, Z);
          } else if (W.tag === 6)
            Z = W.stateNode, D && z && (Z = ir(Z, W.memoizedProps, W)), he(g, Z);
          else if (W.tag !== 4) {
            if (W.tag === 22 && W.memoizedState !== null)
              Z = W.child, Z !== null && (Z.return = W), Ws(g, W, !0, !0);
            else if (W.child !== null) {
              W.child.return = W, W = W.child;
              continue;
            }
          }
          if (W === S)
            break;
          for (; W.sibling === null; ) {
            if (W.return === null || W.return === S)
              return;
            W = W.return;
          }
          W.sibling.return = W.return, W = W.sibling;
        }
      };
      var Xo = function(g, S, D, z) {
        for (var W = S.child; W !== null; ) {
          if (W.tag === 5) {
            var Z = W.stateNode;
            D && z && (Z = er(Z, W.type, W.memoizedProps, W)), Gn(g, Z);
          } else if (W.tag === 6)
            Z = W.stateNode, D && z && (Z = ir(Z, W.memoizedProps, W)), Gn(g, Z);
          else if (W.tag !== 4) {
            if (W.tag === 22 && W.memoizedState !== null)
              Z = W.child, Z !== null && (Z.return = W), Xo(g, W, !0, !0);
            else if (W.child !== null) {
              W.child.return = W, W = W.child;
              continue;
            }
          }
          if (W === S)
            break;
          for (; W.sibling === null; ) {
            if (W.return === null || W.return === S)
              return;
            W = W.return;
          }
          W.sibling.return = W.return, W = W.sibling;
        }
      };
      Xf = function(g, S) {
        var D = S.stateNode;
        if (!pc(g, S)) {
          g = D.containerInfo;
          var z = zn(g);
          Xo(z, S, !1, !1), D.pendingChildren = z, Za(S), rr(g, z);
        }
      }, qf = function(g, S, D, z, W) {
        var Z = g.stateNode, we = g.memoizedProps;
        if ((g = pc(g, S)) && we === z)
          S.stateNode = Z;
        else {
          var Qe = S.stateNode, Ot = uu(vs.current), Jt = null;
          we !== z && (Jt = Le(Qe, D, we, z, W, Ot)), g && Jt === null ? S.stateNode = Z : (Z = on(Z, Jt, D, we, z, S, g, Qe), Me(Z, D, z, W, Ot) && Za(S), S.stateNode = Z, g ? Za(S) : Ws(Z, S, !1, !1));
        }
      }, Vd = function(g, S, D, z) {
        D !== z ? (g = uu(Jc.current), D = uu(vs.current), S.stateNode = Ue(z, g, D, S), Za(S)) : S.stateNode = g.stateNode;
      };
    } else
      Xf = function() {
      }, qf = function() {
      }, Vd = function() {
      };
    function js(g, S) {
      if (!Hi)
        switch (g.tailMode) {
          case "hidden":
            S = g.tail;
            for (var D = null; S !== null; )
              S.alternate !== null && (D = S), S = S.sibling;
            D === null ? g.tail = null : D.sibling = null;
            break;
          case "collapsed":
            D = g.tail;
            for (var z = null; D !== null; )
              D.alternate !== null && (z = D), D = D.sibling;
            z === null ? S || g.tail === null ? g.tail = null : g.tail.sibling = null : z.sibling = null;
        }
    }
    function hi(g) {
      var S = g.alternate !== null && g.alternate.child === g.child, D = 0, z = 0;
      if (S)
        for (var W = g.child; W !== null; )
          D |= W.lanes | W.childLanes, z |= W.subtreeFlags & 14680064, z |= W.flags & 14680064, W.return = g, W = W.sibling;
      else
        for (W = g.child; W !== null; )
          D |= W.lanes | W.childLanes, z |= W.subtreeFlags, z |= W.flags, W.return = g, W = W.sibling;
      return g.subtreeFlags |= z, g.childLanes = D, S;
    }
    function Xn(g, S, D) {
      var z = S.pendingProps;
      switch (Oa(S), S.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return hi(S), null;
        case 1:
          return Ti(S.type) && Xa(), hi(S), null;
        case 3:
          return z = S.stateNode, Ud(), _r(Xr), _r(xa), dl(), z.pendingContext && (z.context = z.pendingContext, z.pendingContext = null), (g === null || g.child === null) && (Sp(S) ? Za(S) : g === null || g.memoizedState.isDehydrated && !(S.flags & 256) || (S.flags |= 1024, Yo !== null && (Nt(Yo), Yo = null))), Xf(g, S), hi(S), null;
        case 5:
          Ll(S), D = uu(Jc.current);
          var W = S.type;
          if (g !== null && S.stateNode != null)
            qf(g, S, W, z, D), g.ref !== S.ref && (S.flags |= 512, S.flags |= 2097152);
          else {
            if (!z) {
              if (S.stateNode === null)
                throw Error(l(166));
              return hi(S), null;
            }
            if (g = uu(vs.current), Sp(S)) {
              if (!et)
                throw Error(l(175));
              g = En(S.stateNode, S.type, S.memoizedProps, D, g, S, !Ad), S.updateQueue = g, g !== null && Za(S);
            } else {
              var Z = ee(W, z, D, g, S);
              Ws(Z, S, !1, !1), S.stateNode = Z, Me(Z, W, z, D, g) && Za(S);
            }
            S.ref !== null && (S.flags |= 512, S.flags |= 2097152);
          }
          return hi(S), null;
        case 6:
          if (g && S.stateNode != null)
            Vd(g, S, g.memoizedProps, z);
          else {
            if (typeof z != "string" && S.stateNode === null)
              throw Error(l(166));
            if (g = uu(Jc.current), D = uu(vs.current), Sp(S)) {
              if (!et)
                throw Error(l(176));
              if (g = S.stateNode, z = S.memoizedProps, (D = ye(g, z, S, !Ad)) && (W = _a, W !== null))
                switch (Z = (W.mode & 1) !== 0, W.tag) {
                  case 3:
                    Nn(W.stateNode.containerInfo, g, z, Z);
                    break;
                  case 5:
                    lr(W.type, W.memoizedProps, W.stateNode, g, z, Z);
                }
              D && Za(S);
            } else
              S.stateNode = Ue(z, g, D, S);
          }
          return hi(S), null;
        case 13:
          if (_r(ea), z = S.memoizedState, Hi && Ea !== null && S.mode & 1 && !(S.flags & 128)) {
            for (g = Ea; g; )
              g = si(g);
            return Ld(), S.flags |= 98560, S;
          }
          if (z !== null && z.dehydrated !== null) {
            if (z = Sp(S), g === null) {
              if (!z)
                throw Error(l(318));
              if (!et)
                throw Error(l(344));
              if (g = S.memoizedState, g = g !== null ? g.dehydrated : null, !g)
                throw Error(l(317));
              qe(g, S);
            } else
              Ld(), !(S.flags & 128) && (S.memoizedState = null), S.flags |= 4;
            return hi(S), null;
          }
          return Yo !== null && (Nt(Yo), Yo = null), S.flags & 128 ? (S.lanes = D, S) : (z = z !== null, D = !1, g === null ? Sp(S) : D = g.memoizedState !== null, z && !D && (S.child.flags |= 8192, S.mode & 1 && (g === null || ea.current & 1 ? fo === 0 && (fo = 3) : hf())), S.updateQueue !== null && (S.flags |= 4), hi(S), null);
        case 4:
          return Ud(), Xf(g, S), g === null && Ge(S.stateNode.containerInfo), hi(S), null;
        case 10:
          return Da(S.type._context), hi(S), null;
        case 17:
          return Ti(S.type) && Xa(), hi(S), null;
        case 19:
          if (_r(ea), W = S.memoizedState, W === null)
            return hi(S), null;
          if (z = (S.flags & 128) !== 0, Z = W.rendering, Z === null)
            if (z)
              js(W, !1);
            else {
              if (fo !== 0 || g !== null && g.flags & 128)
                for (g = S.child; g !== null; ) {
                  if (Z = Nd(g), Z !== null) {
                    for (S.flags |= 128, js(W, !1), g = Z.updateQueue, g !== null && (S.updateQueue = g, S.flags |= 4), S.subtreeFlags = 0, g = D, z = S.child; z !== null; )
                      D = z, W = g, D.flags &= 14680066, Z = D.alternate, Z === null ? (D.childLanes = 0, D.lanes = W, D.child = null, D.subtreeFlags = 0, D.memoizedProps = null, D.memoizedState = null, D.updateQueue = null, D.dependencies = null, D.stateNode = null) : (D.childLanes = Z.childLanes, D.lanes = Z.lanes, D.child = Z.child, D.subtreeFlags = 0, D.deletions = null, D.memoizedProps = Z.memoizedProps, D.memoizedState = Z.memoizedState, D.updateQueue = Z.updateQueue, D.type = Z.type, W = Z.dependencies, D.dependencies = W === null ? null : { lanes: W.lanes, firstContext: W.firstContext }), z = z.sibling;
                    return ur(ea, ea.current & 1 | 2), S.child;
                  }
                  g = g.sibling;
                }
              W.tail !== null && qr() > td && (S.flags |= 128, z = !0, js(W, !1), S.lanes = 4194304);
            }
          else {
            if (!z)
              if (g = Nd(Z), g !== null) {
                if (S.flags |= 128, z = !0, g = g.updateQueue, g !== null && (S.updateQueue = g, S.flags |= 4), js(W, !0), W.tail === null && W.tailMode === "hidden" && !Z.alternate && !Hi)
                  return hi(S), null;
              } else
                2 * qr() - W.renderingStartTime > td && D !== 1073741824 && (S.flags |= 128, z = !0, js(W, !1), S.lanes = 4194304);
            W.isBackwards ? (Z.sibling = S.child, S.child = Z) : (g = W.last, g !== null ? g.sibling = Z : S.child = Z, W.last = Z);
          }
          return W.tail !== null ? (S = W.tail, W.rendering = S, W.tail = S.sibling, W.renderingStartTime = qr(), S.sibling = null, g = ea.current, ur(ea, z ? g & 1 | 2 : g & 1), S) : (hi(S), null);
        case 22:
        case 23:
          return No(), z = S.memoizedState !== null, g !== null && g.memoizedState !== null !== z && (S.flags |= 8192), z && S.mode & 1 ? Xs & 1073741824 && (hi(S), rt && S.subtreeFlags & 6 && (S.flags |= 8192)) : hi(S), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, S.tag));
    }
    var pi = c.ReactCurrentOwner, Nr = !1;
    function In(g, S, D, z) {
      S.child = g === null ? xp(S, null, D, z) : Ou(S, g.child, D, z);
    }
    function Zr(g, S, D, z, W) {
      D = D.render;
      var Z = S.ref;
      return La(S, W), z = tf(g, S, D, z, Z, W), D = Pu(), g !== null && !Nr ? (S.updateQueue = g.updateQueue, S.flags &= -2053, g.lanes &= ~W, ci(g, S, W)) : (Hi && D && Lu(S), S.flags |= 1, In(g, S, z, W), S.child);
    }
    function ui(g, S, D, z, W) {
      if (g === null) {
        var Z = D.type;
        return typeof Z == "function" && !Vu(Z) && Z.defaultProps === void 0 && D.compare === null && D.defaultProps === void 0 ? (S.tag = 15, S.type = Z, ku(g, S, Z, z, W)) : (g = mf(D.type, null, z, S, S.mode, W), g.ref = S.ref, g.return = S, S.child = g);
      }
      if (Z = g.child, !(g.lanes & W)) {
        var we = Z.memoizedProps;
        if (D = D.compare, D = D !== null ? D : ks, D(we, z) && g.ref === S.ref)
          return ci(g, S, W);
      }
      return S.flags |= 1, g = Ko(Z, z), g.ref = S.ref, g.return = S, S.child = g;
    }
    function ku(g, S, D, z, W) {
      if (g !== null && ks(g.memoizedProps, z) && g.ref === S.ref)
        if (Nr = !1, (g.lanes & W) !== 0)
          g.flags & 131072 && (Nr = !0);
        else
          return S.lanes = g.lanes, ci(g, S, W);
      return gs(g, S, D, z, W);
    }
    function hr(g, S, D) {
      var z = S.pendingProps, W = z.children, Z = g !== null ? g.memoizedState : null;
      if (z.mode === "hidden")
        if (!(S.mode & 1))
          S.memoizedState = { baseLanes: 0, cachePool: null }, ur(lf, Xs), Xs |= D;
        else if (D & 1073741824)
          S.memoizedState = { baseLanes: 0, cachePool: null }, z = Z !== null ? Z.baseLanes : D, ur(lf, Xs), Xs |= z;
        else
          return g = Z !== null ? Z.baseLanes | D : D, S.lanes = S.childLanes = 1073741824, S.memoizedState = { baseLanes: g, cachePool: null }, S.updateQueue = null, ur(lf, Xs), Xs |= g, null;
      else
        Z !== null ? (z = Z.baseLanes | D, S.memoizedState = null) : z = D, ur(lf, Xs), Xs |= z;
      return In(g, S, W, D), S.child;
    }
    function ba(g, S) {
      var D = S.ref;
      (g === null && D !== null || g !== null && g.ref !== D) && (S.flags |= 512, S.flags |= 2097152);
    }
    function gs(g, S, D, z, W) {
      var Z = Ti(D) ? ds : xa.current;
      return Z = bi(S, Z), La(S, W), D = tf(g, S, D, z, Z, W), z = Pu(), g !== null && !Nr ? (S.updateQueue = g.updateQueue, S.flags &= -2053, g.lanes &= ~W, ci(g, S, W)) : (Hi && z && Lu(S), S.flags |= 1, In(g, S, D, W), S.child);
    }
    function $s(g, S, D, z, W) {
      if (Ti(D)) {
        var Z = !0;
        Ns(S);
      } else
        Z = !1;
      if (La(S, W), S.stateNode === null)
        g !== null && (g.alternate = null, S.alternate = null, S.flags |= 2), Tm(S, D, z), wm(S, D, z, W), z = !0;
      else if (g === null) {
        var we = S.stateNode, Qe = S.memoizedProps;
        we.props = Qe;
        var Ot = we.context, Jt = D.contextType;
        typeof Jt == "object" && Jt !== null ? Jt = da(Jt) : (Jt = Ti(D) ? ds : xa.current, Jt = bi(S, Jt));
        var ln = D.getDerivedStateFromProps, cr = typeof ln == "function" || typeof we.getSnapshotBeforeUpdate == "function";
        cr || typeof we.UNSAFE_componentWillReceiveProps != "function" && typeof we.componentWillReceiveProps != "function" || (Qe !== z || Ot !== Jt) && Ov(S, we, z, Jt), cl = !1;
        var Qn = S.memoizedState;
        we.state = Qn, xh(S, z, we, W), Ot = S.memoizedState, Qe !== z || Qn !== Ot || Xr.current || cl ? (typeof ln == "function" && (_m(S, D, ln, z), Ot = S.memoizedState), (Qe = cl || bm(S, D, Qe, z, Qn, Ot, Jt)) ? (cr || typeof we.UNSAFE_componentWillMount != "function" && typeof we.componentWillMount != "function" || (typeof we.componentWillMount == "function" && we.componentWillMount(), typeof we.UNSAFE_componentWillMount == "function" && we.UNSAFE_componentWillMount()), typeof we.componentDidMount == "function" && (S.flags |= 4194308)) : (typeof we.componentDidMount == "function" && (S.flags |= 4194308), S.memoizedProps = z, S.memoizedState = Ot), we.props = z, we.state = Ot, we.context = Jt, z = Qe) : (typeof we.componentDidMount == "function" && (S.flags |= 4194308), z = !1);
      } else {
        we = S.stateNode, Bf(g, S), Qe = S.memoizedProps, Jt = S.type === S.elementType ? Qe : So(S.type, Qe), we.props = Jt, cr = S.pendingProps, Qn = we.context, Ot = D.contextType, typeof Ot == "object" && Ot !== null ? Ot = da(Ot) : (Ot = Ti(D) ? ds : xa.current, Ot = bi(S, Ot));
        var Ki = D.getDerivedStateFromProps;
        (ln = typeof Ki == "function" || typeof we.getSnapshotBeforeUpdate == "function") || typeof we.UNSAFE_componentWillReceiveProps != "function" && typeof we.componentWillReceiveProps != "function" || (Qe !== cr || Qn !== Ot) && Ov(S, we, z, Ot), cl = !1, Qn = S.memoizedState, we.state = Qn, xh(S, z, we, W);
        var hn = S.memoizedState;
        Qe !== cr || Qn !== hn || Xr.current || cl ? (typeof Ki == "function" && (_m(S, D, Ki, z), hn = S.memoizedState), (Jt = cl || bm(S, D, Jt, z, Qn, hn, Ot) || !1) ? (ln || typeof we.UNSAFE_componentWillUpdate != "function" && typeof we.componentWillUpdate != "function" || (typeof we.componentWillUpdate == "function" && we.componentWillUpdate(
          z,
          hn,
          Ot
        ), typeof we.UNSAFE_componentWillUpdate == "function" && we.UNSAFE_componentWillUpdate(z, hn, Ot)), typeof we.componentDidUpdate == "function" && (S.flags |= 4), typeof we.getSnapshotBeforeUpdate == "function" && (S.flags |= 1024)) : (typeof we.componentDidUpdate != "function" || Qe === g.memoizedProps && Qn === g.memoizedState || (S.flags |= 4), typeof we.getSnapshotBeforeUpdate != "function" || Qe === g.memoizedProps && Qn === g.memoizedState || (S.flags |= 1024), S.memoizedProps = z, S.memoizedState = hn), we.props = z, we.state = hn, we.context = Ot, z = Jt) : (typeof we.componentDidUpdate != "function" || Qe === g.memoizedProps && Qn === g.memoizedState || (S.flags |= 4), typeof we.getSnapshotBeforeUpdate != "function" || Qe === g.memoizedProps && Qn === g.memoizedState || (S.flags |= 1024), z = !1);
      }
      return ta(g, S, D, z, Z, W);
    }
    function ta(g, S, D, z, W, Z) {
      ba(g, S);
      var we = (S.flags & 128) !== 0;
      if (!z && !we)
        return W && yo(S, D, !1), ci(g, S, Z);
      z = S.stateNode, pi.current = S;
      var Qe = we && typeof D.getDerivedStateFromError != "function" ? null : z.render();
      return S.flags |= 1, g !== null && we ? (S.child = Ou(S, g.child, null, Z), S.child = Ou(S, null, Qe, Z)) : In(g, S, Qe, Z), S.memoizedState = z.state, W && yo(S, D, !0), S.child;
    }
    function Ys(g) {
      var S = g.stateNode;
      S.pendingContext ? Ai(g, S.pendingContext, S.pendingContext !== S.context) : S.context && Ai(g, S.context, !1), _p(g, S.containerInfo);
    }
    function mc(g, S, D, z, W) {
      return Ld(), _h(W), S.flags |= 256, In(g, S, D, z), S.child;
    }
    var Kf = { dehydrated: null, treeContext: null, retryLane: 0 };
    function vc(g) {
      return { baseLanes: g, cachePool: null };
    }
    function Uv(g, S, D) {
      var z = S.pendingProps, W = ea.current, Z = !1, we = (S.flags & 128) !== 0, Qe;
      if ((Qe = we) || (Qe = g !== null && g.memoizedState === null ? !1 : (W & 2) !== 0), Qe ? (Z = !0, S.flags &= -129) : (g === null || g.memoizedState !== null) && (W |= 1), ur(ea, W & 1), g === null)
        return Qc(S), g = S.memoizedState, g !== null && (g = g.dehydrated, g !== null) ? (S.mode & 1 ? Mr(g) ? S.lanes = 8 : S.lanes = 1073741824 : S.lanes = 1, null) : (W = z.children, g = z.fallback, Z ? (z = S.mode, Z = S.child, W = { mode: "hidden", children: W }, !(z & 1) && Z !== null ? (Z.childLanes = 0, Z.pendingProps = W) : Z = ad(W, z, 0, null), g = Il(g, z, D, null), Z.return = S, g.return = S, Z.sibling = g, S.child = Z, S.child.memoizedState = vc(D), S.memoizedState = Kf, g) : ys(S, W));
      if (W = g.memoizedState, W !== null) {
        if (Qe = W.dehydrated, Qe !== null) {
          if (we)
            return S.flags & 256 ? (S.flags &= -257, du(g, S, D, Error(l(422)))) : S.memoizedState !== null ? (S.child = g.child, S.flags |= 128, null) : (Z = z.fallback, W = S.mode, z = ad({ mode: "visible", children: z.children }, W, 0, null), Z = Il(Z, W, D, null), Z.flags |= 2, z.return = S, Z.return = S, z.sibling = Z, S.child = z, S.mode & 1 && Ou(
              S,
              g.child,
              null,
              D
            ), S.child.memoizedState = vc(D), S.memoizedState = Kf, Z);
          if (!(S.mode & 1))
            S = du(g, S, D, null);
          else if (Mr(Qe))
            S = du(g, S, D, Error(l(419)));
          else if (z = (D & g.childLanes) !== 0, Nr || z) {
            if (z = qi, z !== null) {
              switch (D & -D) {
                case 4:
                  Z = 2;
                  break;
                case 16:
                  Z = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  Z = 32;
                  break;
                case 536870912:
                  Z = 268435456;
                  break;
                default:
                  Z = 0;
              }
              z = Z & (z.suspendedLanes | D) ? 0 : Z, z !== 0 && z !== W.retryLane && (W.retryLane = z, Ks(g, z, -1));
            }
            hf(), S = du(g, S, D, Error(l(421)));
          } else
            Br(Qe) ? (S.flags |= 128, S.child = g.child, S = Im.bind(null, g), Ri(Qe, S), S = null) : (D = W.treeContext, et && (Ea = qt(Qe), _a = S, Hi = !0, Yo = null, Ad = !1, D !== null && (fl[Is++] = Kc, fl[Is++] = lu, fl[Is++] = qc, Kc = D.id, lu = D.overflow, qc = S)), S = ys(S, S.pendingProps.children), S.flags |= 4096);
          return S;
        }
        return Z ? (z = Ch(g, S, z.children, z.fallback, D), Z = S.child, W = g.child.memoizedState, Z.memoizedState = W === null ? vc(D) : { baseLanes: W.baseLanes | D, cachePool: null }, Z.childLanes = g.childLanes & ~D, S.memoizedState = Kf, z) : (D = xo(g, S, z.children, D), S.memoizedState = null, D);
      }
      return Z ? (z = Ch(g, S, z.children, z.fallback, D), Z = S.child, W = g.child.memoizedState, Z.memoizedState = W === null ? vc(D) : { baseLanes: W.baseLanes | D, cachePool: null }, Z.childLanes = g.childLanes & ~D, S.memoizedState = Kf, z) : (D = xo(g, S, z.children, D), S.memoizedState = null, D);
    }
    function ys(g, S) {
      return S = ad({ mode: "visible", children: S }, g.mode, 0, null), S.return = g, g.child = S;
    }
    function xo(g, S, D, z) {
      var W = g.child;
      return g = W.sibling, D = Ko(W, { mode: "visible", children: D }), !(S.mode & 1) && (D.lanes = z), D.return = S, D.sibling = null, g !== null && (z = S.deletions, z === null ? (S.deletions = [g], S.flags |= 16) : z.push(g)), S.child = D;
    }
    function Ch(g, S, D, z, W) {
      var Z = S.mode;
      g = g.child;
      var we = g.sibling, Qe = { mode: "hidden", children: D };
      return !(Z & 1) && S.child !== g ? (D = S.child, D.childLanes = 0, D.pendingProps = Qe, S.deletions = null) : (D = Ko(g, Qe), D.subtreeFlags = g.subtreeFlags & 14680064), we !== null ? z = Ko(we, z) : (z = Il(z, Z, W, null), z.flags |= 2), z.return = S, D.return = S, D.sibling = z, S.child = D, z;
    }
    function du(g, S, D, z) {
      return z !== null && _h(z), Ou(S, g.child, null, D), g = ys(S, S.pendingProps.children), g.flags |= 2, S.memoizedState = null, g;
    }
    function Qf(g, S, D) {
      g.lanes |= S;
      var z = g.alternate;
      z !== null && (z.lanes |= S), ao(g.return, S, D);
    }
    function Ua(g, S, D, z, W) {
      var Z = g.memoizedState;
      Z === null ? g.memoizedState = { isBackwards: S, rendering: null, renderingStartTime: 0, last: z, tail: D, tailMode: W } : (Z.isBackwards = S, Z.rendering = null, Z.renderingStartTime = 0, Z.last = z, Z.tail = D, Z.tailMode = W);
    }
    function zu(g, S, D) {
      var z = S.pendingProps, W = z.revealOrder, Z = z.tail;
      if (In(g, S, z.children, D), z = ea.current, z & 2)
        z = z & 1 | 2, S.flags |= 128;
      else {
        if (g !== null && g.flags & 128)
          e:
            for (g = S.child; g !== null; ) {
              if (g.tag === 13)
                g.memoizedState !== null && Qf(g, D, S);
              else if (g.tag === 19)
                Qf(g, D, S);
              else if (g.child !== null) {
                g.child.return = g, g = g.child;
                continue;
              }
              if (g === S)
                break e;
              for (; g.sibling === null; ) {
                if (g.return === null || g.return === S)
                  break e;
                g = g.return;
              }
              g.sibling.return = g.return, g = g.sibling;
            }
        z &= 1;
      }
      if (ur(ea, z), !(S.mode & 1))
        S.memoizedState = null;
      else
        switch (W) {
          case "forwards":
            for (D = S.child, W = null; D !== null; )
              g = D.alternate, g !== null && Nd(g) === null && (W = D), D = D.sibling;
            D = W, D === null ? (W = S.child, S.child = null) : (W = D.sibling, D.sibling = null), Ua(S, !1, W, D, Z);
            break;
          case "backwards":
            for (D = null, W = S.child, S.child = null; W !== null; ) {
              if (g = W.alternate, g !== null && Nd(g) === null) {
                S.child = W;
                break;
              }
              g = W.sibling, W.sibling = D, D = W, W = g;
            }
            Ua(S, !0, D, null, Z);
            break;
          case "together":
            Ua(S, !1, null, null, void 0);
            break;
          default:
            S.memoizedState = null;
        }
      return S.child;
    }
    function ci(g, S, D) {
      if (g !== null && (S.dependencies = g.dependencies), Bu |= S.lanes, !(D & S.childLanes))
        return null;
      if (g !== null && S.child !== g.child)
        throw Error(l(153));
      if (S.child !== null) {
        for (g = S.child, D = Ko(g, g.pendingProps), S.child = D, D.return = S; g.sibling !== null; )
          g = g.sibling, D = D.sibling = Ko(g, g.pendingProps), D.return = S;
        D.sibling = null;
      }
      return S.child;
    }
    function hu(g, S, D) {
      switch (S.tag) {
        case 3:
          Ys(S), Ld();
          break;
        case 5:
          Ep(S);
          break;
        case 1:
          Ti(S.type) && Ns(S);
          break;
        case 4:
          _p(S, S.stateNode.containerInfo);
          break;
        case 10:
          ou(S, S.type._context, S.memoizedProps.value);
          break;
        case 13:
          var z = S.memoizedState;
          if (z !== null)
            return z.dehydrated !== null ? (ur(ea, ea.current & 1), S.flags |= 128, null) : D & S.child.childLanes ? Uv(g, S, D) : (ur(ea, ea.current & 1), g = ci(g, S, D), g !== null ? g.sibling : null);
          ur(ea, ea.current & 1);
          break;
        case 19:
          if (z = (D & S.childLanes) !== 0, g.flags & 128) {
            if (z)
              return zu(
                g,
                S,
                D
              );
            S.flags |= 128;
          }
          var W = S.memoizedState;
          if (W !== null && (W.rendering = null, W.tail = null, W.lastEffect = null), ur(ea, ea.current), z)
            break;
          return null;
        case 22:
        case 23:
          return S.lanes = 0, hr(g, S, D);
      }
      return ci(g, S, D);
    }
    function gr(g, S) {
      switch (Oa(S), S.tag) {
        case 1:
          return Ti(S.type) && Xa(), g = S.flags, g & 65536 ? (S.flags = g & -65537 | 128, S) : null;
        case 3:
          return Ud(), _r(Xr), _r(xa), dl(), g = S.flags, g & 65536 && !(g & 128) ? (S.flags = g & -65537 | 128, S) : null;
        case 5:
          return Ll(S), null;
        case 13:
          if (_r(ea), g = S.memoizedState, g !== null && g.dehydrated !== null) {
            if (S.alternate === null)
              throw Error(l(340));
            Ld();
          }
          return g = S.flags, g & 65536 ? (S.flags = g & -65537 | 128, S) : null;
        case 19:
          return _r(ea), null;
        case 4:
          return Ud(), null;
        case 10:
          return Da(S.type._context), null;
        case 22:
        case 23:
          return No(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var uo = !1, Ta = !1, Iu = typeof WeakSet == "function" ? WeakSet : Set, nn = null;
    function pl(g, S) {
      var D = g.ref;
      if (D !== null)
        if (typeof D == "function")
          try {
            D(null);
          } catch (z) {
            fi(g, S, z);
          }
        else
          D.current = null;
    }
    function _o(g, S, D) {
      try {
        D();
      } catch (z) {
        fi(g, S, z);
      }
    }
    var Pm = !1;
    function Cp(g, S) {
      for (ve(g.containerInfo), nn = S; nn !== null; )
        if (g = nn, S = g.child, (g.subtreeFlags & 1028) !== 0 && S !== null)
          S.return = g, nn = S;
        else
          for (; nn !== null; ) {
            g = nn;
            try {
              var D = g.alternate;
              if (g.flags & 1024)
                switch (g.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (D !== null) {
                      var z = D.memoizedProps, W = D.memoizedState, Z = g.stateNode, we = Z.getSnapshotBeforeUpdate(g.elementType === g.type ? z : So(g.type, z), W);
                      Z.__reactInternalSnapshotBeforeUpdate = we;
                    }
                    break;
                  case 3:
                    rt && ut(g.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(l(163));
                }
            } catch (Qe) {
              fi(g, g.return, Qe);
            }
            if (S = g.sibling, S !== null) {
              S.return = g.return, nn = S;
              break;
            }
            nn = g.return;
          }
      return D = Pm, Pm = !1, D;
    }
    function af(g, S, D) {
      var z = S.updateQueue;
      if (z = z !== null ? z.lastEffect : null, z !== null) {
        var W = z = z.next;
        do {
          if ((W.tag & g) === g) {
            var Z = W.destroy;
            W.destroy = void 0, Z !== void 0 && _o(S, D, Z);
          }
          W = W.next;
        } while (W !== z);
      }
    }
    function Eo(g, S) {
      if (S = S.updateQueue, S = S !== null ? S.lastEffect : null, S !== null) {
        var D = S = S.next;
        do {
          if ((D.tag & g) === g) {
            var z = D.create;
            D.destroy = z();
          }
          D = D.next;
        } while (D !== S);
      }
    }
    function Ss(g) {
      var S = g.ref;
      if (S !== null) {
        var D = g.stateNode;
        switch (g.tag) {
          case 5:
            g = _e(D);
            break;
          default:
            g = D;
        }
        typeof S == "function" ? S(g) : S.current = g;
      }
    }
    function Xi(g, S, D) {
      if (ul && typeof ul.onCommitFiberUnmount == "function")
        try {
          ul.onCommitFiberUnmount(Vc, S);
        } catch {
        }
      switch (S.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (g = S.updateQueue, g !== null && (g = g.lastEffect, g !== null)) {
            var z = g = g.next;
            do {
              var W = z, Z = W.destroy;
              W = W.tag, Z !== void 0 && (W & 2 || W & 4) && _o(S, D, Z), z = z.next;
            } while (z !== g);
          }
          break;
        case 1:
          if (pl(S, D), g = S.stateNode, typeof g.componentWillUnmount == "function")
            try {
              g.props = S.memoizedProps, g.state = S.memoizedState, g.componentWillUnmount();
            } catch (we) {
              fi(
                S,
                D,
                we
              );
            }
          break;
        case 5:
          pl(S, D);
          break;
        case 4:
          rt ? co(g, S, D) : ae && ae && (S = S.stateNode.containerInfo, D = zn(S), mn(S, D));
      }
    }
    function ml(g, S, D) {
      for (var z = S; ; )
        if (Xi(g, z, D), z.child === null || rt && z.tag === 4) {
          if (z === S)
            break;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === S)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        } else
          z.child.return = z, z = z.child;
    }
    function Nl(g) {
      var S = g.alternate;
      S !== null && (g.alternate = null, Nl(S)), g.child = null, g.deletions = null, g.sibling = null, g.tag === 5 && (S = g.stateNode, S !== null && Ut(S)), g.stateNode = null, g.return = null, g.dependencies = null, g.memoizedProps = null, g.memoizedState = null, g.pendingProps = null, g.stateNode = null, g.updateQueue = null;
    }
    function Gd(g) {
      return g.tag === 5 || g.tag === 3 || g.tag === 4;
    }
    function of(g) {
      e:
        for (; ; ) {
          for (; g.sibling === null; ) {
            if (g.return === null || Gd(g.return))
              return null;
            g = g.return;
          }
          for (g.sibling.return = g.return, g = g.sibling; g.tag !== 5 && g.tag !== 6 && g.tag !== 18; ) {
            if (g.flags & 2 || g.child === null || g.tag === 4)
              continue e;
            g.child.return = g, g = g.child;
          }
          if (!(g.flags & 2))
            return g.stateNode;
        }
    }
    function Wd(g) {
      if (rt) {
        e: {
          for (var S = g.return; S !== null; ) {
            if (Gd(S))
              break e;
            S = S.return;
          }
          throw Error(l(160));
        }
        var D = S;
        switch (D.tag) {
          case 5:
            S = D.stateNode, D.flags & 32 && (Ze(S), D.flags &= -33), D = of(g), xs(g, D, S);
            break;
          case 3:
          case 4:
            S = D.stateNode.containerInfo, D = of(g), Zf(g, D, S);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function Zf(g, S, D) {
      var z = g.tag;
      if (z === 5 || z === 6)
        g = g.stateNode, S ? St(D, g, S) : Wt(D, g);
      else if (z !== 4 && (g = g.child, g !== null))
        for (Zf(g, S, D), g = g.sibling; g !== null; )
          Zf(g, S, D), g = g.sibling;
    }
    function xs(g, S, D) {
      var z = g.tag;
      if (z === 5 || z === 6)
        g = g.stateNode, S ? lt(D, g, S) : at(D, g);
      else if (z !== 4 && (g = g.child, g !== null))
        for (xs(g, S, D), g = g.sibling; g !== null; )
          xs(g, S, D), g = g.sibling;
    }
    function co(g, S, D) {
      for (var z = S, W = !1, Z, we; ; ) {
        if (!W) {
          W = z.return;
          e:
            for (; ; ) {
              if (W === null)
                throw Error(l(160));
              switch (Z = W.stateNode, W.tag) {
                case 5:
                  we = !1;
                  break e;
                case 3:
                  Z = Z.containerInfo, we = !0;
                  break e;
                case 4:
                  Z = Z.containerInfo, we = !0;
                  break e;
              }
              W = W.return;
            }
          W = !0;
        }
        if (z.tag === 5 || z.tag === 6)
          ml(g, z, D), we ? be(Z, z.stateNode) : Je(Z, z.stateNode);
        else if (z.tag === 18)
          we ? cn(Z, z.stateNode) : en(Z, z.stateNode);
        else if (z.tag === 4) {
          if (z.child !== null) {
            Z = z.stateNode.containerInfo, we = !0, z.child.return = z, z = z.child;
            continue;
          }
        } else if (Xi(g, z, D), z.child !== null) {
          z.child.return = z, z = z.child;
          continue;
        }
        if (z === S)
          break;
        for (; z.sibling === null; ) {
          if (z.return === null || z.return === S)
            return;
          z = z.return, z.tag === 4 && (W = !1);
        }
        z.sibling.return = z.return, z = z.sibling;
      }
    }
    function sa(g, S) {
      if (rt) {
        switch (S.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            af(3, S, S.return), Eo(3, S), af(5, S, S.return);
            return;
          case 1:
            return;
          case 5:
            var D = S.stateNode;
            if (D != null) {
              var z = S.memoizedProps;
              g = g !== null ? g.memoizedProps : z;
              var W = S.type, Z = S.updateQueue;
              S.updateQueue = null, Z !== null && He(D, Z, W, g, z, S);
            }
            return;
          case 6:
            if (S.stateNode === null)
              throw Error(l(162));
            D = S.memoizedProps, Dt(S.stateNode, g !== null ? g.memoizedProps : D, D);
            return;
          case 3:
            et && g !== null && g.memoizedState.isDehydrated && Ve(S.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Rh(S);
            return;
          case 19:
            Rh(S);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (S.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          af(3, S, S.return), Eo(3, S), af(5, S, S.return);
          return;
        case 12:
          return;
        case 13:
          Rh(S);
          return;
        case 19:
          Rh(S);
          return;
        case 3:
          et && g !== null && g.memoizedState.isDehydrated && Ve(S.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e:
        if (ae) {
          switch (S.tag) {
            case 1:
            case 5:
            case 6:
              break e;
            case 3:
            case 4:
              S = S.stateNode, mn(S.containerInfo, S.pendingChildren);
              break e;
          }
          throw Error(l(163));
        }
    }
    function Rh(g) {
      var S = g.updateQueue;
      if (S !== null) {
        g.updateQueue = null;
        var D = g.stateNode;
        D === null && (D = g.stateNode = new Iu()), S.forEach(function(z) {
          var W = kl.bind(null, g, z);
          D.has(z) || (D.add(z), z.then(W, W));
        });
      }
    }
    function Um(g, S) {
      for (nn = S; nn !== null; ) {
        S = nn;
        var D = S.deletions;
        if (D !== null)
          for (var z = 0; z < D.length; z++) {
            var W = D[z];
            try {
              var Z = g;
              rt ? co(Z, W, S) : ml(Z, W, S);
              var we = W.alternate;
              we !== null && (we.return = null), W.return = null;
            } catch (An) {
              fi(W, S, An);
            }
          }
        if (D = S.child, S.subtreeFlags & 12854 && D !== null)
          D.return = S, nn = D;
        else
          for (; nn !== null; ) {
            S = nn;
            try {
              var Qe = S.flags;
              if (Qe & 32 && rt && Ze(S.stateNode), Qe & 512) {
                var Ot = S.alternate;
                if (Ot !== null) {
                  var Jt = Ot.ref;
                  Jt !== null && (typeof Jt == "function" ? Jt(null) : Jt.current = null);
                }
              }
              if (Qe & 8192)
                switch (S.tag) {
                  case 13:
                    if (S.memoizedState !== null) {
                      var ln = S.alternate;
                      (ln === null || ln.memoizedState === null) && (km = qr());
                    }
                    break;
                  case 22:
                    var cr = S.memoizedState !== null, Qn = S.alternate, Ki = Qn !== null && Qn.memoizedState !== null;
                    if (D = S, rt) {
                      e:
                        if (z = D, W = cr, Z = null, rt)
                          for (var hn = z; ; ) {
                            if (hn.tag === 5) {
                              if (Z === null) {
                                Z = hn;
                                var ri = hn.stateNode;
                                W ? ct(ri) : Rt(hn.stateNode, hn.memoizedProps);
                              }
                            } else if (hn.tag === 6) {
                              if (Z === null) {
                                var ka = hn.stateNode;
                                W ? pe(ka) : Be(ka, hn.memoizedProps);
                              }
                            } else if ((hn.tag !== 22 && hn.tag !== 23 || hn.memoizedState === null || hn === z) && hn.child !== null) {
                              hn.child.return = hn, hn = hn.child;
                              continue;
                            }
                            if (hn === z)
                              break;
                            for (; hn.sibling === null; ) {
                              if (hn.return === null || hn.return === z)
                                break e;
                              Z === hn && (Z = null), hn = hn.return;
                            }
                            Z === hn && (Z = null), hn.sibling.return = hn.return, hn = hn.sibling;
                          }
                    }
                    if (cr && !Ki && D.mode & 1) {
                      nn = D;
                      for (var mt = D.child; mt !== null; ) {
                        for (D = nn = mt; nn !== null; ) {
                          z = nn;
                          var We = z.child;
                          switch (z.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              af(4, z, z.return);
                              break;
                            case 1:
                              pl(z, z.return);
                              var Mt = z.stateNode;
                              if (typeof Mt.componentWillUnmount == "function") {
                                var Vt = z.return;
                                try {
                                  Mt.props = z.memoizedProps, Mt.state = z.memoizedState, Mt.componentWillUnmount();
                                } catch (An) {
                                  fi(
                                    z,
                                    Vt,
                                    An
                                  );
                                }
                              }
                              break;
                            case 5:
                              pl(z, z.return);
                              break;
                            case 22:
                              if (z.memoizedState !== null) {
                                sf(D);
                                continue;
                              }
                          }
                          We !== null ? (We.return = z, nn = We) : sf(D);
                        }
                        mt = mt.sibling;
                      }
                    }
                }
              switch (Qe & 4102) {
                case 2:
                  Wd(S), S.flags &= -3;
                  break;
                case 6:
                  Wd(S), S.flags &= -3, sa(S.alternate, S);
                  break;
                case 4096:
                  S.flags &= -4097;
                  break;
                case 4100:
                  S.flags &= -4097, sa(S.alternate, S);
                  break;
                case 4:
                  sa(S.alternate, S);
              }
            } catch (An) {
              fi(S, S.return, An);
            }
            if (D = S.sibling, D !== null) {
              D.return = S.return, nn = D;
              break;
            }
            nn = S.return;
          }
      }
    }
    function vl(g, S, D) {
      nn = g, pu(g);
    }
    function pu(g, S, D) {
      for (var z = (g.mode & 1) !== 0; nn !== null; ) {
        var W = nn, Z = W.child;
        if (W.tag === 22 && z) {
          var we = W.memoizedState !== null || uo;
          if (!we) {
            var Qe = W.alternate, Ot = Qe !== null && Qe.memoizedState !== null || Ta;
            Qe = uo;
            var Jt = Ta;
            if (uo = we, (Ta = Ot) && !Jt)
              for (nn = W; nn !== null; )
                we = nn, Ot = we.child, we.tag === 22 && we.memoizedState !== null ? Nm(W) : Ot !== null ? (Ot.return = we, nn = Ot) : Nm(W);
            for (; Z !== null; )
              nn = Z, pu(Z), Z = Z.sibling;
            nn = W, uo = Qe, Ta = Jt;
          }
          Ah(g);
        } else
          W.subtreeFlags & 8772 && Z !== null ? (Z.return = W, nn = Z) : Ah(g);
      }
    }
    function Ah(g) {
      for (; nn !== null; ) {
        var S = nn;
        if (S.flags & 8772) {
          var D = S.alternate;
          try {
            if (S.flags & 8772)
              switch (S.tag) {
                case 0:
                case 11:
                case 15:
                  Ta || Eo(5, S);
                  break;
                case 1:
                  var z = S.stateNode;
                  if (S.flags & 4 && !Ta)
                    if (D === null)
                      z.componentDidMount();
                    else {
                      var W = S.elementType === S.type ? D.memoizedProps : So(S.type, D.memoizedProps);
                      z.componentDidUpdate(W, D.memoizedState, z.__reactInternalSnapshotBeforeUpdate);
                    }
                  var Z = S.updateQueue;
                  Z !== null && Lv(S, Z, z);
                  break;
                case 3:
                  var we = S.updateQueue;
                  if (we !== null) {
                    if (D = null, S.child !== null)
                      switch (S.child.tag) {
                        case 5:
                          D = _e(S.child.stateNode);
                          break;
                        case 1:
                          D = S.child.stateNode;
                      }
                    Lv(S, we, D);
                  }
                  break;
                case 5:
                  var Qe = S.stateNode;
                  D === null && S.flags & 4 && Se(Qe, S.type, S.memoizedProps, S);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (et && S.memoizedState === null) {
                    var Ot = S.alternate;
                    if (Ot !== null) {
                      var Jt = Ot.memoizedState;
                      if (Jt !== null) {
                        var ln = Jt.dehydrated;
                        ln !== null && pt(ln);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(l(163));
              }
            Ta || S.flags & 512 && Ss(S);
          } catch (cr) {
            fi(S, S.return, cr);
          }
        }
        if (S === g) {
          nn = null;
          break;
        }
        if (D = S.sibling, D !== null) {
          D.return = S.return, nn = D;
          break;
        }
        nn = S.return;
      }
    }
    function sf(g) {
      for (; nn !== null; ) {
        var S = nn;
        if (S === g) {
          nn = null;
          break;
        }
        var D = S.sibling;
        if (D !== null) {
          D.return = S.return, nn = D;
          break;
        }
        nn = S.return;
      }
    }
    function Nm(g) {
      for (; nn !== null; ) {
        var S = nn;
        try {
          switch (S.tag) {
            case 0:
            case 11:
            case 15:
              var D = S.return;
              try {
                Eo(4, S);
              } catch (Ot) {
                fi(S, D, Ot);
              }
              break;
            case 1:
              var z = S.stateNode;
              if (typeof z.componentDidMount == "function") {
                var W = S.return;
                try {
                  z.componentDidMount();
                } catch (Ot) {
                  fi(S, W, Ot);
                }
              }
              var Z = S.return;
              try {
                Ss(S);
              } catch (Ot) {
                fi(S, Z, Ot);
              }
              break;
            case 5:
              var we = S.return;
              try {
                Ss(S);
              } catch (Ot) {
                fi(S, we, Ot);
              }
          }
        } catch (Ot) {
          fi(S, S.return, Ot);
        }
        if (S === g) {
          nn = null;
          break;
        }
        var Qe = S.sibling;
        if (Qe !== null) {
          Qe.return = S.return, nn = Qe;
          break;
        }
        nn = S.return;
      }
    }
    var Dh = 0, Vi = 1, ha = 2, un = 3, zi = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Na = Symbol.for;
      Dh = Na("selector.component"), Vi = Na("selector.has_pseudo_class"), ha = Na("selector.role"), un = Na("selector.test_id"), zi = Na("selector.text");
    }
    function Rp(g) {
      var S = Ye(g);
      if (S != null) {
        if (typeof S.memoizedProps["data-testname"] != "string")
          throw Error(l(364));
        return S;
      }
      if (g = vt(g), g === null)
        throw Error(l(362));
      return g.stateNode.current;
    }
    function Fm(g, S) {
      switch (S.$$typeof) {
        case Dh:
          if (g.type === S.value)
            return !0;
          break;
        case Vi:
          e: {
            S = S.value, g = [g, 0];
            for (var D = 0; D < g.length; ) {
              var z = g[D++], W = g[D++], Z = S[W];
              if (z.tag !== 5 || !ne(z)) {
                for (; Z != null && Fm(z, Z); )
                  W++, Z = S[W];
                if (W === S.length) {
                  S = !0;
                  break e;
                } else
                  for (z = z.child; z !== null; )
                    g.push(z, W), z = z.sibling;
              }
            }
            S = !1;
          }
          return S;
        case ha:
          if (g.tag === 5 && Oe(g.stateNode, S.value))
            return !0;
          break;
        case zi:
          if ((g.tag === 5 || g.tag === 6) && (g = ie(g), g !== null && 0 <= g.indexOf(S.value)))
            return !0;
          break;
        case un:
          if (g.tag === 5 && (g = g.memoizedProps["data-testname"], typeof g == "string" && g.toLowerCase() === S.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function _s(g) {
      switch (g.$$typeof) {
        case Dh:
          return "<" + (Y(g.value) || "Unknown") + ">";
        case Vi:
          return ":has(" + (_s(g) || "") + ")";
        case ha:
          return '[role="' + g.value + '"]';
        case zi:
          return '"' + g.value + '"';
        case un:
          return '[data-testname="' + g.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function pa(g, S) {
      var D = [];
      g = [g, 0];
      for (var z = 0; z < g.length; ) {
        var W = g[z++], Z = g[z++], we = S[Z];
        if (W.tag !== 5 || !ne(W)) {
          for (; we != null && Fm(W, we); )
            Z++, we = S[Z];
          if (Z === S.length)
            D.push(W);
          else
            for (W = W.child; W !== null; )
              g.push(W, Z), W = W.sibling;
        }
      }
      return D;
    }
    function dn(g, S) {
      if (!Pt)
        throw Error(l(363));
      g = Rp(g), g = pa(g, S), S = [], g = Array.from(g);
      for (var D = 0; D < g.length; ) {
        var z = g[D++];
        if (z.tag === 5)
          ne(z) || S.push(z.stateNode);
        else
          for (z = z.child; z !== null; )
            g.push(z), z = z.sibling;
      }
      return S;
    }
    var Gi = Math.ceil, Fa = c.ReactCurrentDispatcher, gc = c.ReactCurrentOwner, ma = c.ReactCurrentBatchConfig, Lr = 0, qi = null, na = null, ti = 0, Xs = 0, lf = $n(0), fo = 0, jd = null, Bu = 0, mu = 0, Jf = 0, ed = null, qs = null, km = 0, td = 1 / 0;
    function $d() {
      td = qr() + 500;
    }
    var uf = !1, gl = null, vu = null, cf = !1, yl = null, Lh = 0, gu = 0, qn = null, Cr = -1, Kn = 0;
    function jr() {
      return Lr & 6 ? qr() : Cr !== -1 ? Cr : Cr = qr();
    }
    function bo(g) {
      return g.mode & 1 ? Lr & 2 && ti !== 0 ? ti & -ti : $c.transition !== null ? (Kn === 0 && (g = Dl, Dl <<= 1, !(Dl & 4194240) && (Dl = 64), Kn = g), Kn) : (g = dr, g !== 0 ? g : $e()) : 1;
    }
    function Ks(g, S, D) {
      if (50 < gu)
        throw gu = 0, qn = null, Error(l(185));
      var z = ff(g, S);
      return z === null ? null : (nr(z, S, D), (!(Lr & 2) || z !== qi) && (z === qi && (!(Lr & 2) && (mu |= S), fo === 4 && Hn(z, ti)), Es(z, D), S === 1 && Lr === 0 && !(g.mode & 1) && ($d(), Au && $o())), z);
    }
    function ff(g, S) {
      g.lanes |= S;
      var D = g.alternate;
      for (D !== null && (D.lanes |= S), D = g, g = g.return; g !== null; )
        g.childLanes |= S, D = g.alternate, D !== null && (D.childLanes |= S), D = g, g = g.return;
      return D.tag === 3 ? D.stateNode : null;
    }
    function Es(g, S) {
      var D = g.callbackNode;
      ei(g, S);
      var z = kf(g, g === qi ? ti : 0);
      if (z === 0)
        D !== null && fa(D), g.callbackNode = null, g.callbackPriority = 0;
      else if (S = z & -z, g.callbackPriority !== S) {
        if (D != null && fa(D), S === 1)
          g.tag === 0 ? jc(Hu.bind(null, g)) : Wc(Hu.bind(null, g)), nt ? Ct(function() {
            Lr === 0 && $o();
          }) : Lo(Aa, $o), D = null;
        else {
          switch (hs(z)) {
            case 1:
              D = Aa;
              break;
            case 4:
              D = Ru;
              break;
            case 16:
              D = ps;
              break;
            case 536870912:
              D = oc;
              break;
            default:
              D = ps;
          }
          D = yu(D, To.bind(null, g));
        }
        g.callbackPriority = S, g.callbackNode = D;
      }
    }
    function To(g, S) {
      if (Cr = -1, Kn = 0, Lr & 6)
        throw Error(l(327));
      var D = g.callbackNode;
      if (yc() && g.callbackNode !== D)
        return null;
      var z = kf(g, g === qi ? ti : 0);
      if (z === 0)
        return null;
      if (z & 30 || z & g.expiredLanes || S)
        S = Fo(g, z);
      else {
        S = z;
        var W = Lr;
        Lr |= 2;
        var Z = df();
        (qi !== g || ti !== S) && ($d(), Si(g, S));
        do
          try {
            rd();
            break;
          } catch (Qe) {
            nd(g, Qe);
          }
        while (1);
        Po(), Fa.current = Z, Lr = W, na !== null ? S = 0 : (qi = null, ti = 0, S = fo);
      }
      if (S !== 0) {
        if (S === 2 && (W = Ra(g), W !== 0 && (z = W, S = ni(g, W))), S === 1)
          throw D = jd, Si(g, 0), Hn(g, z), Es(g, qr()), D;
        if (S === 6)
          Hn(g, z);
        else {
          if (W = g.current.alternate, !(z & 30) && !Qr(W) && (S = Fo(g, z), S === 2 && (Z = Ra(g), Z !== 0 && (z = Z, S = ni(g, Z))), S === 1))
            throw D = jd, Si(g, 0), Hn(g, z), Es(g, qr()), D;
          switch (g.finishedWork = W, g.finishedLanes = z, S) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              xl(g, qs);
              break;
            case 3:
              if (Hn(g, z), (z & 130023424) === z && (S = km + 500 - qr(), 10 < S)) {
                if (kf(g, 0) !== 0)
                  break;
                if (W = g.suspendedLanes, (W & z) !== z) {
                  jr(), g.pingedLanes |= g.suspendedLanes & W;
                  break;
                }
                g.timeoutHandle = Ne(xl.bind(null, g, qs), S);
                break;
              }
              xl(g, qs);
              break;
            case 4:
              if (Hn(g, z), (z & 4194240) === z)
                break;
              for (S = g.eventTimes, W = -1; 0 < z; ) {
                var we = 31 - Wo(z);
                Z = 1 << we, we = S[we], we > W && (W = we), z &= ~Z;
              }
              if (z = W, z = qr() - z, z = (120 > z ? 120 : 480 > z ? 480 : 1080 > z ? 1080 : 1920 > z ? 1920 : 3e3 > z ? 3e3 : 4320 > z ? 4320 : 1960 * Gi(z / 1960)) - z, 10 < z) {
                g.timeoutHandle = Ne(xl.bind(null, g, qs), z);
                break;
              }
              xl(g, qs);
              break;
            case 5:
              xl(g, qs);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return Es(g, qr()), g.callbackNode === D ? To.bind(null, g) : null;
    }
    function ni(g, S) {
      var D = ed;
      return g.current.memoizedState.isDehydrated && (Si(g, S).flags |= 256), g = Fo(g, S), g !== 2 && (S = qs, qs = D, S !== null && Nt(S)), g;
    }
    function Nt(g) {
      qs === null ? qs = g : qs.push.apply(qs, g);
    }
    function Qr(g) {
      for (var S = g; ; ) {
        if (S.flags & 16384) {
          var D = S.updateQueue;
          if (D !== null && (D = D.stores, D !== null))
            for (var z = 0; z < D.length; z++) {
              var W = D[z], Z = W.getSnapshot;
              W = W.value;
              try {
                if (!Oo(Z(), W))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (D = S.child, S.subtreeFlags & 16384 && D !== null)
          D.return = S, S = D;
        else {
          if (S === g)
            break;
          for (; S.sibling === null; ) {
            if (S.return === null || S.return === g)
              return !0;
            S = S.return;
          }
          S.sibling.return = S.return, S = S.sibling;
        }
      }
      return !0;
    }
    function Hn(g, S) {
      for (S &= ~Jf, S &= ~mu, g.suspendedLanes |= S, g.pingedLanes &= ~S, g = g.expirationTimes; 0 < S; ) {
        var D = 31 - Wo(S), z = 1 << D;
        g[D] = -1, S &= ~z;
      }
    }
    function Hu(g) {
      if (Lr & 6)
        throw Error(l(327));
      yc();
      var S = kf(g, 0);
      if (!(S & 1))
        return Es(g, qr()), null;
      var D = Fo(g, S);
      if (g.tag !== 0 && D === 2) {
        var z = Ra(g);
        z !== 0 && (S = z, D = ni(g, z));
      }
      if (D === 1)
        throw D = jd, Si(g, 0), Hn(g, S), Es(g, qr()), D;
      if (D === 6)
        throw Error(l(345));
      return g.finishedWork = g.current.alternate, g.finishedLanes = S, xl(g, qs), Es(g, qr()), null;
    }
    function Qs(g) {
      yl !== null && yl.tag === 0 && !(Lr & 6) && yc();
      var S = Lr;
      Lr |= 1;
      var D = ma.transition, z = dr;
      try {
        if (ma.transition = null, dr = 1, g)
          return g();
      } finally {
        dr = z, ma.transition = D, Lr = S, !(Lr & 6) && $o();
      }
    }
    function No() {
      Xs = lf.current, _r(lf);
    }
    function Si(g, S) {
      g.finishedWork = null, g.finishedLanes = 0;
      var D = g.timeoutHandle;
      if (D !== it && (g.timeoutHandle = it, ke(D)), na !== null)
        for (D = na.return; D !== null; ) {
          var z = D;
          switch (Oa(z), z.tag) {
            case 1:
              z = z.type.childContextTypes, z != null && Xa();
              break;
            case 3:
              Ud(), _r(Xr), _r(xa), dl();
              break;
            case 5:
              Ll(z);
              break;
            case 4:
              Ud();
              break;
            case 13:
              _r(ea);
              break;
            case 19:
              _r(ea);
              break;
            case 10:
              Da(z.type._context);
              break;
            case 22:
            case 23:
              No();
          }
          D = D.return;
        }
      if (qi = g, na = g = Ko(g.current, null), ti = Xs = S, fo = 0, jd = null, Jf = mu = Bu = 0, qs = ed = null, ms !== null) {
        for (S = 0; S < ms.length; S++)
          if (D = ms[S], z = D.interleaved, z !== null) {
            D.interleaved = null;
            var W = z.next, Z = D.pending;
            if (Z !== null) {
              var we = Z.next;
              Z.next = W, z.next = we;
            }
            D.pending = z;
          }
        ms = null;
      }
      return g;
    }
    function nd(g, S) {
      do {
        var D = na;
        try {
          if (Po(), so.current = Yf, Fd) {
            for (var z = Kr.memoizedState; z !== null; ) {
              var W = z.queue;
              W !== null && (W.pending = null), z = z.next;
            }
            Fd = !1;
          }
          if (ef = 0, Di = yi = Kr = null, lo = !1, Wf = 0, gc.current = null, D === null || D.return === null) {
            fo = 1, jd = S, na = null;
            break;
          }
          e: {
            var Z = g, we = D.return, Qe = D, Ot = S;
            if (S = ti, Qe.flags |= 32768, Ot !== null && typeof Ot == "object" && typeof Ot.then == "function") {
              var Jt = Ot, ln = Qe, cr = ln.tag;
              if (!(ln.mode & 1) && (cr === 0 || cr === 11 || cr === 15)) {
                var Qn = ln.alternate;
                Qn ? (ln.updateQueue = Qn.updateQueue, ln.memoizedState = Qn.memoizedState, ln.lanes = Qn.lanes) : (ln.updateQueue = null, ln.memoizedState = null);
              }
              var Ki = Nu(we);
              if (Ki !== null) {
                Ki.flags &= -257, Fu(Ki, we, Qe, Z, S), Ki.mode & 1 && Gs(Z, Jt, S), S = Ki, Ot = Jt;
                var hn = S.updateQueue;
                if (hn === null) {
                  var ri = /* @__PURE__ */ new Set();
                  ri.add(Ot), S.updateQueue = ri;
                } else
                  hn.add(Ot);
                break e;
              } else {
                if (!(S & 1)) {
                  Gs(Z, Jt, S), hf();
                  break e;
                }
                Ot = Error(l(426));
              }
            } else if (Hi && Qe.mode & 1) {
              var ka = Nu(we);
              if (ka !== null) {
                !(ka.flags & 65536) && (ka.flags |= 256), Fu(ka, we, Qe, Z, S), _h(Ot);
                break e;
              }
            }
            Z = Ot, fo !== 4 && (fo = 2), ed === null ? ed = [Z] : ed.push(Z), Ot = Mh(Ot, Qe), Qe = we;
            do {
              switch (Qe.tag) {
                case 3:
                  Qe.flags |= 65536, S &= -S, Qe.lanes |= S;
                  var mt = Om(Qe, Ot, S);
                  Xc(Qe, mt);
                  break e;
                case 1:
                  Z = Ot;
                  var We = Qe.type, Mt = Qe.stateNode;
                  if (!(Qe.flags & 128) && (typeof We.getDerivedStateFromError == "function" || Mt !== null && typeof Mt.componentDidCatch == "function" && (vu === null || !vu.has(Mt)))) {
                    Qe.flags |= 65536, S &= -S, Qe.lanes |= S;
                    var Vt = Uu(Qe, Z, S);
                    Xc(Qe, Vt);
                    break e;
                  }
              }
              Qe = Qe.return;
            } while (Qe !== null);
          }
          qo(D);
        } catch (An) {
          S = An, na === D && D !== null && (na = D = D.return);
          continue;
        }
        break;
      } while (1);
    }
    function df() {
      var g = Fa.current;
      return Fa.current = Yf, g === null ? Yf : g;
    }
    function hf() {
      (fo === 0 || fo === 3 || fo === 2) && (fo = 4), qi === null || !(Bu & 268435455) && !(mu & 268435455) || Hn(qi, ti);
    }
    function Fo(g, S) {
      var D = Lr;
      Lr |= 2;
      var z = df();
      qi === g && ti === S || Si(g, S);
      do
        try {
          Sl();
          break;
        } catch (W) {
          nd(g, W);
        }
      while (1);
      if (Po(), Lr = D, Fa.current = z, na !== null)
        throw Error(l(261));
      return qi = null, ti = 0, fo;
    }
    function Sl() {
      for (; na !== null; )
        Yd(na);
    }
    function rd() {
      for (; na !== null && !gi(); )
        Yd(na);
    }
    function Yd(g) {
      var S = pf(g.alternate, g, Xs);
      g.memoizedProps = g.pendingProps, S === null ? qo(g) : na = S, gc.current = null;
    }
    function qo(g) {
      var S = g;
      do {
        var D = S.alternate;
        if (g = S.return, S.flags & 32768) {
          if (D = gr(D, S), D !== null) {
            D.flags &= 32767, na = D;
            return;
          }
          if (g !== null)
            g.flags |= 32768, g.subtreeFlags = 0, g.deletions = null;
          else {
            fo = 6, na = null;
            return;
          }
        } else if (D = Xn(D, S, Xs), D !== null) {
          na = D;
          return;
        }
        if (S = S.sibling, S !== null) {
          na = S;
          return;
        }
        na = S = g;
      } while (S !== null);
      fo === 0 && (fo = 5);
    }
    function xl(g, S) {
      var D = dr, z = ma.transition;
      try {
        ma.transition = null, dr = 1, zm(g, S, D);
      } finally {
        ma.transition = z, dr = D;
      }
      return null;
    }
    function zm(g, S, D) {
      do
        yc();
      while (yl !== null);
      if (Lr & 6)
        throw Error(l(327));
      var z = g.finishedWork, W = g.finishedLanes;
      if (z === null)
        return null;
      if (g.finishedWork = null, g.finishedLanes = 0, z === g.current)
        throw Error(l(177));
      g.callbackNode = null, g.callbackPriority = 0;
      var Z = z.lanes | z.childLanes;
      if (iu(g, Z), g === qi && (na = qi = null, ti = 0), !(z.subtreeFlags & 2064) && !(z.flags & 2064) || cf || (cf = !0, yu(ps, function() {
        return yc(), null;
      })), Z = (z.flags & 15990) !== 0, z.subtreeFlags & 15990 || Z) {
        Z = ma.transition, ma.transition = null;
        var we = dr;
        dr = 1;
        var Qe = Lr;
        Lr |= 4, gc.current = null, Cp(g, z), Um(g, z), re(g.containerInfo), g.current = z, vl(z), Sm(), Lr = Qe, dr = we, ma.transition = Z;
      } else
        g.current = z;
      if (cf && (cf = !1, yl = g, Lh = W), Z = g.pendingLanes, Z === 0 && (vu = null), Gc(z.stateNode), Es(g, qr()), S !== null)
        for (D = g.onRecoverableError, z = 0; z < S.length; z++)
          D(S[z]);
      if (uf)
        throw uf = !1, g = gl, gl = null, g;
      return Lh & 1 && g.tag !== 0 && yc(), Z = g.pendingLanes, Z & 1 ? g === qn ? gu++ : (gu = 0, qn = g) : gu = 0, $o(), null;
    }
    function yc() {
      if (yl !== null) {
        var g = hs(Lh), S = ma.transition, D = dr;
        try {
          if (ma.transition = null, dr = 16 > g ? 16 : g, yl === null)
            var z = !1;
          else {
            if (g = yl, yl = null, Lh = 0, Lr & 6)
              throw Error(l(331));
            var W = Lr;
            for (Lr |= 4, nn = g.current; nn !== null; ) {
              var Z = nn, we = Z.child;
              if (nn.flags & 16) {
                var Qe = Z.deletions;
                if (Qe !== null) {
                  for (var Ot = 0; Ot < Qe.length; Ot++) {
                    var Jt = Qe[Ot];
                    for (nn = Jt; nn !== null; ) {
                      var ln = nn;
                      switch (ln.tag) {
                        case 0:
                        case 11:
                        case 15:
                          af(8, ln, Z);
                      }
                      var cr = ln.child;
                      if (cr !== null)
                        cr.return = ln, nn = cr;
                      else
                        for (; nn !== null; ) {
                          ln = nn;
                          var Qn = ln.sibling, Ki = ln.return;
                          if (Nl(ln), ln === Jt) {
                            nn = null;
                            break;
                          }
                          if (Qn !== null) {
                            Qn.return = Ki, nn = Qn;
                            break;
                          }
                          nn = Ki;
                        }
                    }
                  }
                  var hn = Z.alternate;
                  if (hn !== null) {
                    var ri = hn.child;
                    if (ri !== null) {
                      hn.child = null;
                      do {
                        var ka = ri.sibling;
                        ri.sibling = null, ri = ka;
                      } while (ri !== null);
                    }
                  }
                  nn = Z;
                }
              }
              if (Z.subtreeFlags & 2064 && we !== null)
                we.return = Z, nn = we;
              else
                e:
                  for (; nn !== null; ) {
                    if (Z = nn, Z.flags & 2048)
                      switch (Z.tag) {
                        case 0:
                        case 11:
                        case 15:
                          af(9, Z, Z.return);
                      }
                    var mt = Z.sibling;
                    if (mt !== null) {
                      mt.return = Z.return, nn = mt;
                      break e;
                    }
                    nn = Z.return;
                  }
            }
            var We = g.current;
            for (nn = We; nn !== null; ) {
              we = nn;
              var Mt = we.child;
              if (we.subtreeFlags & 2064 && Mt !== null)
                Mt.return = we, nn = Mt;
              else
                e:
                  for (we = We; nn !== null; ) {
                    if (Qe = nn, Qe.flags & 2048)
                      try {
                        switch (Qe.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Eo(9, Qe);
                        }
                      } catch (An) {
                        fi(Qe, Qe.return, An);
                      }
                    if (Qe === we) {
                      nn = null;
                      break e;
                    }
                    var Vt = Qe.sibling;
                    if (Vt !== null) {
                      Vt.return = Qe.return, nn = Vt;
                      break e;
                    }
                    nn = Qe.return;
                  }
            }
            if (Lr = W, $o(), ul && typeof ul.onPostCommitFiberRoot == "function")
              try {
                ul.onPostCommitFiberRoot(Vc, g);
              } catch {
              }
            z = !0;
          }
          return z;
        } finally {
          dr = D, ma.transition = S;
        }
      }
      return !1;
    }
    function ho(g, S, D) {
      S = Mh(D, S), S = Om(g, S, 1), Yc(g, S), S = jr(), g = ff(g, 1), g !== null && (nr(g, 1, S), Es(g, S));
    }
    function fi(g, S, D) {
      if (g.tag === 3)
        ho(g, g, D);
      else
        for (; S !== null; ) {
          if (S.tag === 3) {
            ho(S, g, D);
            break;
          } else if (S.tag === 1) {
            var z = S.stateNode;
            if (typeof S.type.getDerivedStateFromError == "function" || typeof z.componentDidCatch == "function" && (vu === null || !vu.has(z))) {
              g = Mh(D, g), g = Uu(S, g, 1), Yc(S, g), g = jr(), S = ff(S, 1), S !== null && (nr(S, 1, g), Es(S, g));
              break;
            }
          }
          S = S.return;
        }
    }
    function Fl(g, S, D) {
      var z = g.pingCache;
      z !== null && z.delete(S), S = jr(), g.pingedLanes |= g.suspendedLanes & D, qi === g && (ti & D) === D && (fo === 4 || fo === 3 && (ti & 130023424) === ti && 500 > qr() - km ? Si(g, 0) : Jf |= D), Es(g, S);
    }
    function Zs(g, S) {
      S === 0 && (g.mode & 1 ? (S = Vr, Vr <<= 1, !(Vr & 130023424) && (Vr = 4194304)) : S = 1);
      var D = jr();
      g = ff(g, S), g !== null && (nr(g, S, D), Es(g, D));
    }
    function Im(g) {
      var S = g.memoizedState, D = 0;
      S !== null && (D = S.retryLane), Zs(g, D);
    }
    function kl(g, S) {
      var D = 0;
      switch (g.tag) {
        case 13:
          var z = g.stateNode, W = g.memoizedState;
          W !== null && (D = W.retryLane);
          break;
        case 19:
          z = g.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      z !== null && z.delete(S), Zs(g, D);
    }
    var pf;
    pf = function(g, S, D) {
      if (g !== null)
        if (g.memoizedProps !== S.pendingProps || Xr.current)
          Nr = !0;
        else {
          if (!(g.lanes & D) && !(S.flags & 128))
            return Nr = !1, hu(g, S, D);
          Nr = !!(g.flags & 131072);
        }
      else
        Nr = !1, Hi && S.flags & 1048576 && Bs(S, Mm, S.index);
      switch (S.lanes = 0, S.tag) {
        case 2:
          var z = S.type;
          g !== null && (g.alternate = null, S.alternate = null, S.flags |= 2), g = S.pendingProps;
          var W = bi(S, xa.current);
          La(S, D), W = tf(null, S, z, g, W, D);
          var Z = Pu();
          return S.flags |= 1, typeof W == "object" && W !== null && typeof W.render == "function" && W.$$typeof === void 0 ? (S.tag = 1, S.memoizedState = null, S.updateQueue = null, Ti(z) ? (Z = !0, Ns(S)) : Z = !1, S.memoizedState = W.state !== null && W.state !== void 0 ? W.state : null, oo(S), W.updater = Em, S.stateNode = W, W._reactInternals = S, wm(S, z, g, D), S = ta(null, S, z, !0, Z, D)) : (S.tag = 0, Hi && Z && Lu(S), In(null, S, W, D), S = S.child), S;
        case 16:
          z = S.elementType;
          e: {
            switch (g !== null && (g.alternate = null, S.alternate = null, S.flags |= 2), g = S.pendingProps, W = z._init, z = W(z._payload), S.type = z, W = S.tag = id(z), g = So(z, g), W) {
              case 0:
                S = gs(null, S, z, g, D);
                break e;
              case 1:
                S = $s(
                  null,
                  S,
                  z,
                  g,
                  D
                );
                break e;
              case 11:
                S = Zr(null, S, z, g, D);
                break e;
              case 14:
                S = ui(null, S, z, So(z.type, g), D);
                break e;
            }
            throw Error(l(306, z, ""));
          }
          return S;
        case 0:
          return z = S.type, W = S.pendingProps, W = S.elementType === z ? W : So(z, W), gs(g, S, z, W, D);
        case 1:
          return z = S.type, W = S.pendingProps, W = S.elementType === z ? W : So(z, W), $s(g, S, z, W, D);
        case 3:
          e: {
            if (Ys(S), g === null)
              throw Error(l(387));
            z = S.pendingProps, Z = S.memoizedState, W = Z.element, Bf(g, S), xh(S, z, null, D);
            var we = S.memoizedState;
            if (z = we.element, et && Z.isDehydrated)
              if (Z = {
                element: z,
                isDehydrated: !1,
                cache: we.cache,
                transitions: we.transitions
              }, S.updateQueue.baseState = Z, S.memoizedState = Z, S.flags & 256) {
                W = Error(l(423)), S = mc(g, S, z, D, W);
                break e;
              } else if (z !== W) {
                W = Error(l(424)), S = mc(g, S, z, D, W);
                break e;
              } else
                for (et && (Ea = Ft(S.stateNode.containerInfo), _a = S, Hi = !0, Yo = null, Ad = !1), D = xp(S, null, z, D), S.child = D; D; )
                  D.flags = D.flags & -3 | 4096, D = D.sibling;
            else {
              if (Ld(), z === W) {
                S = ci(g, S, D);
                break e;
              }
              In(g, S, z, D);
            }
            S = S.child;
          }
          return S;
        case 5:
          return Ep(S), g === null && Qc(S), z = S.type, W = S.pendingProps, Z = g !== null ? g.memoizedProps : null, we = W.children, Ae(z, W) ? we = null : Z !== null && Ae(z, Z) && (S.flags |= 32), ba(g, S), In(g, S, we, D), S.child;
        case 6:
          return g === null && Qc(S), null;
        case 13:
          return Uv(g, S, D);
        case 4:
          return _p(S, S.stateNode.containerInfo), z = S.pendingProps, g === null ? S.child = Ou(S, null, z, D) : In(g, S, z, D), S.child;
        case 11:
          return z = S.type, W = S.pendingProps, W = S.elementType === z ? W : So(z, W), Zr(g, S, z, W, D);
        case 7:
          return In(g, S, S.pendingProps, D), S.child;
        case 8:
          return In(g, S, S.pendingProps.children, D), S.child;
        case 12:
          return In(g, S, S.pendingProps.children, D), S.child;
        case 10:
          e: {
            if (z = S.type._context, W = S.pendingProps, Z = S.memoizedProps, we = W.value, ou(S, z, we), Z !== null)
              if (Oo(Z.value, we)) {
                if (Z.children === W.children && !Xr.current) {
                  S = ci(g, S, D);
                  break e;
                }
              } else
                for (Z = S.child, Z !== null && (Z.return = S); Z !== null; ) {
                  var Qe = Z.dependencies;
                  if (Qe !== null) {
                    we = Z.child;
                    for (var Ot = Qe.firstContext; Ot !== null; ) {
                      if (Ot.context === z) {
                        if (Z.tag === 1) {
                          Ot = lc(-1, D & -D), Ot.tag = 2;
                          var Jt = Z.updateQueue;
                          if (Jt !== null) {
                            Jt = Jt.shared;
                            var ln = Jt.pending;
                            ln === null ? Ot.next = Ot : (Ot.next = ln.next, ln.next = Ot), Jt.pending = Ot;
                          }
                        }
                        Z.lanes |= D, Ot = Z.alternate, Ot !== null && (Ot.lanes |= D), ao(Z.return, D, S), Qe.lanes |= D;
                        break;
                      }
                      Ot = Ot.next;
                    }
                  } else if (Z.tag === 10)
                    we = Z.type === S.type ? null : Z.child;
                  else if (Z.tag === 18) {
                    if (we = Z.return, we === null)
                      throw Error(l(341));
                    we.lanes |= D, Qe = we.alternate, Qe !== null && (Qe.lanes |= D), ao(we, D, S), we = Z.sibling;
                  } else
                    we = Z.child;
                  if (we !== null)
                    we.return = Z;
                  else
                    for (we = Z; we !== null; ) {
                      if (we === S) {
                        we = null;
                        break;
                      }
                      if (Z = we.sibling, Z !== null) {
                        Z.return = we.return, we = Z;
                        break;
                      }
                      we = we.return;
                    }
                  Z = we;
                }
            In(g, S, W.children, D), S = S.child;
          }
          return S;
        case 9:
          return W = S.type, z = S.pendingProps.children, La(S, D), W = da(W), z = z(W), S.flags |= 1, In(g, S, z, D), S.child;
        case 14:
          return z = S.type, W = So(z, S.pendingProps), W = So(z.type, W), ui(g, S, z, W, D);
        case 15:
          return ku(g, S, S.type, S.pendingProps, D);
        case 17:
          return z = S.type, W = S.pendingProps, W = S.elementType === z ? W : So(z, W), g !== null && (g.alternate = null, S.alternate = null, S.flags |= 2), S.tag = 1, Ti(z) ? (g = !0, Ns(S)) : g = !1, La(S, D), Tm(S, z, W), wm(S, z, W, D), ta(null, S, z, !0, g, D);
        case 19:
          return zu(g, S, D);
        case 22:
          return hr(g, S, D);
      }
      throw Error(l(156, S.tag));
    };
    function yu(g, S) {
      return Lo(g, S);
    }
    function zl(g, S, D, z) {
      this.tag = g, this.key = D, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = S, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = z, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function wo(g, S, D, z) {
      return new zl(g, S, D, z);
    }
    function Vu(g) {
      return g = g.prototype, !(!g || !g.isReactComponent);
    }
    function id(g) {
      if (typeof g == "function")
        return Vu(g) ? 1 : 0;
      if (g != null) {
        if (g = g.$$typeof, g === U)
          return 11;
        if (g === F)
          return 14;
      }
      return 2;
    }
    function Ko(g, S) {
      var D = g.alternate;
      return D === null ? (D = wo(g.tag, S, g.key, g.mode), D.elementType = g.elementType, D.type = g.type, D.stateNode = g.stateNode, D.alternate = g, g.alternate = D) : (D.pendingProps = S, D.type = g.type, D.flags = 0, D.subtreeFlags = 0, D.deletions = null), D.flags = g.flags & 14680064, D.childLanes = g.childLanes, D.lanes = g.lanes, D.child = g.child, D.memoizedProps = g.memoizedProps, D.memoizedState = g.memoizedState, D.updateQueue = g.updateQueue, S = g.dependencies, D.dependencies = S === null ? null : { lanes: S.lanes, firstContext: S.firstContext }, D.sibling = g.sibling, D.index = g.index, D.ref = g.ref, D;
    }
    function mf(g, S, D, z, W, Z) {
      var we = 2;
      if (z = g, typeof g == "function")
        Vu(g) && (we = 1);
      else if (typeof g == "string")
        we = 5;
      else
        e:
          switch (g) {
            case y:
              return Il(D.children, W, Z, S);
            case x:
              we = 8, W |= 8;
              break;
            case b:
              return g = wo(12, D, S, W | 2), g.elementType = b, g.lanes = Z, g;
            case L:
              return g = wo(13, D, S, W), g.elementType = L, g.lanes = Z, g;
            case A:
              return g = wo(19, D, S, W), g.elementType = A, g.lanes = Z, g;
            case H:
              return ad(D, W, Z, S);
            default:
              if (typeof g == "object" && g !== null)
                switch (g.$$typeof) {
                  case w:
                    we = 10;
                    break e;
                  case R:
                    we = 9;
                    break e;
                  case U:
                    we = 11;
                    break e;
                  case F:
                    we = 14;
                    break e;
                  case k:
                    we = 16, z = null;
                    break e;
                }
              throw Error(l(130, g == null ? g : typeof g, ""));
          }
      return S = wo(we, D, S, W), S.elementType = g, S.type = z, S.lanes = Z, S;
    }
    function Il(g, S, D, z) {
      return g = wo(7, g, z, S), g.lanes = D, g;
    }
    function ad(g, S, D, z) {
      return g = wo(22, g, z, S), g.elementType = H, g.lanes = D, g.stateNode = {}, g;
    }
    function vf(g, S, D) {
      return g = wo(6, g, null, S), g.lanes = D, g;
    }
    function Su(g, S, D) {
      return S = wo(4, g.children !== null ? g.children : [], g.key, S), S.lanes = D, S.stateNode = { containerInfo: g.containerInfo, pendingChildren: null, implementation: g.implementation }, S;
    }
    function _l(g, S, D, z, W) {
      this.tag = S, this.containerInfo = g, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = it, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zf(0), this.expirationTimes = zf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zf(0), this.identifierPrefix = z, this.onRecoverableError = W, et && (this.mutableSourceEagerHydrationData = null);
    }
    function ty(g, S, D, z, W, Z, we, Qe, Ot) {
      return g = new _l(g, S, D, Qe, Ot), S === 1 ? (S = 1, Z === !0 && (S |= 8)) : S = 0, Z = wo(3, null, null, S), g.current = Z, Z.stateNode = g, Z.memoizedState = { element: z, isDehydrated: D, cache: null, transitions: null }, oo(Z), g;
    }
    function $r(g) {
      if (!g)
        return di;
      g = g._reactInternals;
      e: {
        if (K(g) !== g || g.tag !== 1)
          throw Error(l(170));
        var S = g;
        do {
          switch (S.tag) {
            case 3:
              S = S.stateNode.context;
              break e;
            case 1:
              if (Ti(S.type)) {
                S = S.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          S = S.return;
        } while (S !== null);
        throw Error(l(171));
      }
      if (g.tag === 1) {
        var D = g.type;
        if (Ti(D))
          return ru(g, D, S);
      }
      return S;
    }
    function od(g) {
      var S = g._reactInternals;
      if (S === void 0)
        throw typeof g.render == "function" ? Error(l(188)) : (g = Object.keys(g).join(","), Error(l(268, g)));
      return g = oe(S), g === null ? null : g.stateNode;
    }
    function gf(g, S) {
      if (g = g.memoizedState, g !== null && g.dehydrated !== null) {
        var D = g.retryLane;
        g.retryLane = D !== 0 && D < S ? D : S;
      }
    }
    function Gu(g, S) {
      gf(g, S), (g = g.alternate) && gf(g, S);
    }
    function Sc(g) {
      return g = oe(g), g === null ? null : g.stateNode;
    }
    function Bm() {
      return null;
    }
    return t.attemptContinuousHydration = function(g) {
      if (g.tag === 13) {
        var S = jr();
        Ks(g, 134217728, S), Gu(g, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(g) {
      if (g.tag === 13) {
        var S = jr(), D = bo(g);
        Ks(g, D, S), Gu(g, D);
      }
    }, t.attemptSynchronousHydration = function(g) {
      switch (g.tag) {
        case 3:
          var S = g.stateNode;
          if (S.current.memoizedState.isDehydrated) {
            var D = ll(S.pendingLanes);
            D !== 0 && (Fi(S, D | 1), Es(S, qr()), !(Lr & 6) && ($d(), $o()));
          }
          break;
        case 13:
          var z = jr();
          Qs(function() {
            return Ks(g, 1, z);
          }), Gu(g, 1);
      }
    }, t.batchedUpdates = function(g, S) {
      var D = Lr;
      Lr |= 1;
      try {
        return g(S);
      } finally {
        Lr = D, Lr === 0 && ($d(), Au && $o());
      }
    }, t.createComponentSelector = function(g) {
      return { $$typeof: Dh, value: g };
    }, t.createContainer = function(g, S, D, z, W, Z, we) {
      return ty(g, S, !1, null, D, z, W, Z, we);
    }, t.createHasPseudoClassSelector = function(g) {
      return { $$typeof: Vi, value: g };
    }, t.createHydrationContainer = function(g, S, D, z, W, Z, we, Qe, Ot) {
      return g = ty(D, z, !0, g, W, Z, we, Qe, Ot), g.context = $r(null), D = g.current, z = jr(), W = bo(D), Z = lc(z, W), Z.callback = S ?? null, Yc(D, Z), g.current.lanes = W, nr(g, W, z), Es(g, z), g;
    }, t.createPortal = function(g, S, D) {
      var z = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: p, key: z == null ? null : "" + z, children: g, containerInfo: S, implementation: D };
    }, t.createRoleSelector = function(g) {
      return { $$typeof: ha, value: g };
    }, t.createTestNameSelector = function(g) {
      return { $$typeof: un, value: g };
    }, t.createTextSelector = function(g) {
      return { $$typeof: zi, value: g };
    }, t.deferredUpdates = function(g) {
      var S = dr, D = ma.transition;
      try {
        return ma.transition = null, dr = 16, g();
      } finally {
        dr = S, ma.transition = D;
      }
    }, t.discreteUpdates = function(g, S, D, z, W) {
      var Z = dr, we = ma.transition;
      try {
        return ma.transition = null, dr = 1, g(S, D, z, W);
      } finally {
        dr = Z, ma.transition = we, Lr === 0 && $d();
      }
    }, t.findAllNodes = dn, t.findBoundingRects = function(g, S) {
      if (!Pt)
        throw Error(l(363));
      S = dn(g, S), g = [];
      for (var D = 0; D < S.length; D++)
        g.push(Zt(S[D]));
      for (S = g.length - 1; 0 < S; S--) {
        D = g[S];
        for (var z = D.x, W = z + D.width, Z = D.y, we = Z + D.height, Qe = S - 1; 0 <= Qe; Qe--)
          if (S !== Qe) {
            var Ot = g[Qe], Jt = Ot.x, ln = Jt + Ot.width, cr = Ot.y, Qn = cr + Ot.height;
            if (z >= Jt && Z >= cr && W <= ln && we <= Qn) {
              g.splice(S, 1);
              break;
            } else if (z !== Jt || D.width !== Ot.width || Qn < Z || cr > we) {
              if (!(Z !== cr || D.height !== Ot.height || ln < z || Jt > W)) {
                Jt > z && (Ot.width += Jt - z, Ot.x = z), ln < W && (Ot.width = W - Jt), g.splice(S, 1);
                break;
              }
            } else {
              cr > Z && (Ot.height += cr - Z, Ot.y = Z), Qn < we && (Ot.height = we - cr), g.splice(S, 1);
              break;
            }
          }
      }
      return g;
    }, t.findHostInstance = od, t.findHostInstanceWithNoPortals = function(g) {
      return g = le(g), g = g !== null ? de(g) : null, g === null ? null : g.stateNode;
    }, t.findHostInstanceWithWarning = function(g) {
      return od(g);
    }, t.flushControlled = function(g) {
      var S = Lr;
      Lr |= 1;
      var D = ma.transition, z = dr;
      try {
        ma.transition = null, dr = 1, g();
      } finally {
        dr = z, ma.transition = D, Lr = S, Lr === 0 && ($d(), $o());
      }
    }, t.flushPassiveEffects = yc, t.flushSync = Qs, t.focusWithin = function(g, S) {
      if (!Pt)
        throw Error(l(363));
      for (g = Rp(g), S = pa(g, S), S = Array.from(S), g = 0; g < S.length; ) {
        var D = S[g++];
        if (!ne(D)) {
          if (D.tag === 5 && _t(D.stateNode))
            return !0;
          for (D = D.child; D !== null; )
            S.push(D), D = D.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return dr;
    }, t.getFindAllNodesFailureDescription = function(g, S) {
      if (!Pt)
        throw Error(l(363));
      var D = 0, z = [];
      g = [Rp(g), 0];
      for (var W = 0; W < g.length; ) {
        var Z = g[W++], we = g[W++], Qe = S[we];
        if ((Z.tag !== 5 || !ne(Z)) && (Fm(Z, Qe) && (z.push(_s(Qe)), we++, we > D && (D = we)), we < S.length))
          for (Z = Z.child; Z !== null; )
            g.push(Z, we), Z = Z.sibling;
      }
      if (D < S.length) {
        for (g = []; D < S.length; D++)
          g.push(_s(S[D]));
        return `findAllNodes was able to match part of the selector:
  ` + (z.join(" > ") + `

No matching component was found for:
  `) + g.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(g) {
      if (g = g.current, !g.child)
        return null;
      switch (g.child.tag) {
        case 5:
          return _e(g.child.stateNode);
        default:
          return g.child.stateNode;
      }
    }, t.injectIntoDevTools = function(g) {
      if (g = { bundleType: g.bundleType, version: g.version, rendererPackageName: g.rendererPackageName, rendererConfig: g.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: c.ReactCurrentDispatcher, findHostInstanceByFiber: Sc, findFiberByHostInstance: g.findFiberByHostInstance || Bm, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        g = !1;
      else {
        var S = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (S.isDisabled || !S.supportsFiber)
          g = !0;
        else {
          try {
            Vc = S.inject(g), ul = S;
          } catch {
          }
          g = !!S.checkDCE;
        }
      }
      return g;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(g, S, D, z) {
      if (!Pt)
        throw Error(l(363));
      g = dn(g, S);
      var W = ot(g, D, z).disconnect;
      return { disconnect: function() {
        W();
      } };
    }, t.registerMutableSourceForHydration = function(g, S) {
      var D = S._getVersion;
      D = D(S._source), g.mutableSourceEagerHydrationData == null ? g.mutableSourceEagerHydrationData = [S, D] : g.mutableSourceEagerHydrationData.push(S, D);
    }, t.runWithPriority = function(g, S) {
      var D = dr;
      try {
        return dr = g, S();
      } finally {
        dr = D;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(g, S, D, z) {
      var W = S.current, Z = jr(), we = bo(W);
      return D = $r(D), S.context === null ? S.context = D : S.pendingContext = D, S = lc(Z, we), S.payload = { element: g }, z = z === void 0 ? null : z, z !== null && (S.callback = z), Yc(W, S), g = Ks(W, we, Z), g !== null && xm(g, W, we), we;
    }, t;
  }), lL;
}
var uL = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nk;
function IX() {
  return nk || (nk = 1, process.env.NODE_ENV !== "production" && (uL.exports = function(e) {
    var t = {}, r = Fe, i = RR, o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = !1;
    function c(u) {
      l = u;
    }
    function h(u) {
      if (!l) {
        for (var d = arguments.length, T = new Array(d > 1 ? d - 1 : 0), C = 1; C < d; C++)
          T[C - 1] = arguments[C];
        y("warn", u, T);
      }
    }
    function p(u) {
      if (!l) {
        for (var d = arguments.length, T = new Array(d > 1 ? d - 1 : 0), C = 1; C < d; C++)
          T[C - 1] = arguments[C];
        y("error", u, T);
      }
    }
    function y(u, d, T) {
      {
        var C = o.ReactDebugCurrentFrame, P = C.getStackAddendum();
        P !== "" && (d += "%s", T = T.concat([P]));
        var V = T.map(function(Q) {
          return String(Q);
        });
        V.unshift("Warning: " + d), Function.prototype.apply.call(console[u], console, V);
      }
    }
    var x = Object.assign;
    function b(u) {
      return u._reactInternals;
    }
    function w(u, d) {
      u._reactInternals = d;
    }
    var R = !1, U = !1, L = !1, A = !1, F = !1, k = !1, H = !0, B = !0, $ = !0, Y = 0, J = 1, K = 2, X = 3, le = 4, oe = 5, fe = 6, de = 7, xe = 8, _e = 9, Pe = 10, ce = 11, ve = 12, re = 13, ee = 14, he = 15, Me = 16, Le = 17, Ae = 18, Ue = 19, Ne = 21, ke = 22, it = 23, At = 24, rt = 25, ae = Symbol.for("react.element"), et = Symbol.for("react.portal"), Ye = Symbol.for("react.fragment"), Ge = Symbol.for("react.strict_mode"), $e = Symbol.for("react.profiler"), Ut = Symbol.for("react.provider"), nt = Symbol.for("react.context"), Ct = Symbol.for("react.forward_ref"), Pt = Symbol.for("react.suspense"), vt = Symbol.for("react.suspense_list"), Zt = Symbol.for("react.memo"), ie = Symbol.for("react.lazy"), ne = Symbol.for("react.scope"), Oe = Symbol.for("react.debug_trace_mode"), _t = Symbol.for("react.offscreen"), ot = Symbol.for("react.legacy_hidden"), at = Symbol.for("react.cache"), Wt = Symbol.for("react.tracing_marker"), Dt = Symbol.iterator, Se = "@@iterator";
    function He(u) {
      if (u === null || typeof u != "object")
        return null;
      var d = Dt && u[Dt] || u[Se];
      return typeof d == "function" ? d : null;
    }
    function lt(u, d, T) {
      var C = u.displayName;
      if (C)
        return C;
      var P = d.displayName || d.name || "";
      return P !== "" ? T + "(" + P + ")" : T;
    }
    function St(u) {
      return u.displayName || "Context";
    }
    function Je(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && p("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case Ye:
          return "Fragment";
        case et:
          return "Portal";
        case $e:
          return "Profiler";
        case Ge:
          return "StrictMode";
        case Pt:
          return "Suspense";
        case vt:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case nt:
            var d = u;
            return St(d) + ".Consumer";
          case Ut:
            var T = u;
            return St(T._context) + ".Provider";
          case Ct:
            return lt(u, u.render, "ForwardRef");
          case Zt:
            var C = u.displayName || null;
            return C !== null ? C : Je(u.type) || "Memo";
          case ie: {
            var P = u, V = P._payload, Q = P._init;
            try {
              return Je(Q(V));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function be(u, d, T) {
      var C = d.displayName || d.name || "";
      return u.displayName || (C !== "" ? T + "(" + C + ")" : T);
    }
    function Ze(u) {
      return u.displayName || "Context";
    }
    function ct(u) {
      var d = u.tag, T = u.type;
      switch (d) {
        case At:
          return "Cache";
        case _e:
          var C = T;
          return Ze(C) + ".Consumer";
        case Pe:
          var P = T;
          return Ze(P._context) + ".Provider";
        case Ae:
          return "DehydratedFragment";
        case ce:
          return be(T, T.render, "ForwardRef");
        case de:
          return "Fragment";
        case oe:
          return T;
        case le:
          return "Portal";
        case X:
          return "Root";
        case fe:
          return "Text";
        case Me:
          return Je(T);
        case xe:
          return T === Ge ? "StrictMode" : "Mode";
        case ke:
          return "Offscreen";
        case ve:
          return "Profiler";
        case Ne:
          return "Scope";
        case re:
          return "Suspense";
        case Ue:
          return "SuspenseList";
        case rt:
          return "TracingMarker";
        case J:
        case Y:
        case Le:
        case K:
        case ee:
        case he:
          if (typeof T == "function")
            return T.displayName || T.name || null;
          if (typeof T == "string")
            return T;
          break;
      }
      return null;
    }
    var pe = (
      /*                      */
      0
    ), Rt = (
      /*                */
      1
    ), Be = (
      /*                    */
      2
    ), ut = (
      /*                       */
      4
    ), on = (
      /*           */
      Be | ut
    ), zn = (
      /*                */
      16
    ), Gn = (
      /*                 */
      32
    ), rr = (
      /*                     */
      64
    ), mn = (
      /*                   */
      128
    ), er = (
      /*            */
      256
    ), ir = (
      /*                          */
      512
    ), Wn = (
      /*                     */
      1024
    ), Ei = (
      /*                      */
      2048
    ), Wr = (
      /*                    */
      4096
    ), Br = (
      /*           */
      Wr | ut
    ), Mr = (
      /*                   */
      8192
    ), Ri = (
      /*             */
      16384
    ), si = Ei | ut | rr | ir | Wn | Ri, De = (
      /*               */
      32767
    ), Ft = (
      /*                   */
      32768
    ), qt = (
      /*                */
      65536
    ), En = (
      /* */
      131072
    ), ye = (
      /*                       */
      1048576
    ), qe = (
      /*                    */
      2097152
    ), tt = (
      /*                 */
      4194304
    ), Ve = (
      /*                */
      8388608
    ), pt = (
      /*               */
      16777216
    ), en = (
      /*              */
      33554432
    ), cn = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      ut | Wn | 0
    ), xn = Be | ut | zn | Gn | ir | Wr | Mr, Nn = ut | rr | ir | Mr, lr = Ei | zn, bt = tt | Ve | qe, ar = o.ReactCurrentOwner;
    function Hr(u) {
      var d = u, T = u;
      if (u.alternate)
        for (; d.return; )
          d = d.return;
      else {
        var C = d;
        do
          d = C, (d.flags & (Be | Wr)) !== pe && (T = d.return), C = d.return;
        while (C);
      }
      return d.tag === X ? T : null;
    }
    function Tn(u) {
      return Hr(u) === u;
    }
    function Ji(u) {
      {
        var d = ar.current;
        if (d !== null && d.tag === J) {
          var T = d, C = T.stateNode;
          C._warnedAboutRefsInRender || p("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ct(T) || "A component"), C._warnedAboutRefsInRender = !0;
        }
      }
      var P = b(u);
      return P ? Hr(P) === P : !1;
    }
    function Do(u) {
      if (Hr(u) !== u)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function li(u) {
      var d = u.alternate;
      if (!d) {
        var T = Hr(u);
        if (T === null)
          throw new Error("Unable to find node on an unmounted component.");
        return T !== u ? null : u;
      }
      for (var C = u, P = d; ; ) {
        var V = C.return;
        if (V === null)
          break;
        var Q = V.alternate;
        if (Q === null) {
          var se = V.return;
          if (se !== null) {
            C = P = se;
            continue;
          }
          break;
        }
        if (V.child === Q.child) {
          for (var me = V.child; me; ) {
            if (me === C)
              return Do(V), u;
            if (me === P)
              return Do(V), d;
            me = me.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (C.return !== P.return)
          C = V, P = Q;
        else {
          for (var Ce = !1, ze = V.child; ze; ) {
            if (ze === C) {
              Ce = !0, C = V, P = Q;
              break;
            }
            if (ze === P) {
              Ce = !0, P = V, C = Q;
              break;
            }
            ze = ze.sibling;
          }
          if (!Ce) {
            for (ze = Q.child; ze; ) {
              if (ze === C) {
                Ce = !0, C = Q, P = V;
                break;
              }
              if (ze === P) {
                Ce = !0, P = Q, C = V;
                break;
              }
              ze = ze.sibling;
            }
            if (!Ce)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (C.alternate !== P)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (C.tag !== X)
        throw new Error("Unable to find node on an unmounted component.");
      return C.stateNode.current === C ? u : d;
    }
    function $n(u) {
      var d = li(u);
      return d !== null ? _r(d) : null;
    }
    function _r(u) {
      if (u.tag === oe || u.tag === fe)
        return u;
      for (var d = u.child; d !== null; ) {
        var T = _r(d);
        if (T !== null)
          return T;
        d = d.sibling;
      }
      return null;
    }
    function ur(u) {
      var d = li(u);
      return d !== null ? di(d) : null;
    }
    function di(u) {
      if (u.tag === oe || u.tag === fe)
        return u;
      for (var d = u.child; d !== null; ) {
        if (d.tag !== le) {
          var T = di(d);
          if (T !== null)
            return T;
        }
        d = d.sibling;
      }
      return null;
    }
    var xa = Array.isArray;
    function Xr(u) {
      return xa(u);
    }
    var ds = e.getPublicInstance, bi = e.getRootHostContext, Ti = e.getChildHostContext, Xa = e.prepareForCommit, Ai = e.resetAfterCommit, ru = e.createInstance, Ns = e.appendInitialChild, yo = e.finalizeInitialChildren, Wo = e.prepareUpdate, ac = e.shouldSetTextContent, sl = e.createTextInstance, yp = e.scheduleTimeout, Dl = e.cancelTimeout, Vr = e.noTimeout;
    e.now;
    var ll = e.isPrimaryRenderer, kf = e.warnsIfNotActing, jo = e.supportsMutation, ei = e.supportsPersistence, Ra = e.supportsHydration, zf = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var nr = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var iu = e.getCurrentEventPriority, Fi = e.detachDeletedInstance, dr = e.supportsMicrotasks, hs = e.scheduleMicrotask, Lo = e.supportsTestSelectors, fa = e.findFiberRoot, gi = e.getBoundingRect, Sm = e.getTextContent, qr = e.isHiddenSubtree, Aa = e.matchAccessibilityRole, Ru = e.setFocusIfFocusable, ps = e.setupIntersectionObserver, oc = e.appendChild, Vc = e.appendChildToContainer, ul = e.commitTextUpdate, Gc = e.commitMount, If = e.commitUpdate, Oo = e.insertBefore, qa = e.insertInContainerBefore, Au = e.removeChild, Fs = e.removeChildFromContainer, Wc = e.resetTextContent, jc = e.hideInstance, $o = e.hideTextInstance, $c = e.unhideInstance, ks = e.unhideTextInstance, Du = e.clearContainer, So = e.cloneInstance, Ka = e.createContainerChildSet, au = e.appendChildToContainerChildSet, zs = e.finalizeContainerChildren, sc = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var Po = e.getOffscreenContainerProps, ou = e.cloneHiddenInstance, Da = e.cloneHiddenTextInstance, ao = e.canHydrateInstance, La = e.canHydrateTextInstance, da = e.canHydrateSuspenseInstance, ms = e.isSuspenseInstancePending, cl = e.isSuspenseInstanceFallback, oo = e.registerSuspenseInstanceRetry, Bf = e.getNextHydratableSibling, lc = e.getFirstHydratableChild, Yc = e.getFirstHydratableChildWithinContainer, xm = e.getFirstHydratableChildWithinSuspenseInstance, Xc = e.hydrateInstance, xh = e.hydrateTextInstance, Lv = e.hydrateSuspenseInstance, ey = e.getNextHydratableInstanceAfterSuspenseInstance, _m = e.commitHydratedContainer, Em = e.commitHydratedSuspenseInstance, bm = e.clearSuspenseBoundary, Tm = e.clearSuspenseBoundaryFromContainer, Ov = e.shouldDeleteUnhydratedTailInstances, wm = e.didNotMatchHydratedContainerTextInstance, Rd = e.didNotMatchHydratedTextInstance, Hf = e.didNotHydrateInstanceWithinContainer, su = e.didNotHydrateInstanceWithinSuspenseInstance, Mm = e.didNotHydrateInstance, fl = e.didNotFindHydratableInstanceWithinContainer, Is = e.didNotFindHydratableTextInstanceWithinContainer, qc = e.didNotFindHydratableSuspenseInstanceWithinContainer, Kc = e.didNotFindHydratableInstanceWithinSuspenseInstance, lu = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, Vf = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Bs = e.didNotFindHydratableInstance, Lu = e.didNotFindHydratableTextInstance, Oa = e.didNotFindHydratableSuspenseInstance, _a = e.errorHydratingContainer, Ea = 0, Hi, Ad, Yo, Cm, Rm, Dd, Qc;
    function Pv() {
    }
    Pv.__reactDisabledLog = !0;
    function Sp() {
      {
        if (Ea === 0) {
          Hi = console.log, Ad = console.info, Yo = console.warn, Cm = console.error, Rm = console.group, Dd = console.groupCollapsed, Qc = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Pv,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        Ea++;
      }
    }
    function Ld() {
      {
        if (Ea--, Ea === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: x({}, u, {
              value: Hi
            }),
            info: x({}, u, {
              value: Ad
            }),
            warn: x({}, u, {
              value: Yo
            }),
            error: x({}, u, {
              value: Cm
            }),
            group: x({}, u, {
              value: Rm
            }),
            groupCollapsed: x({}, u, {
              value: Dd
            }),
            groupEnd: x({}, u, {
              value: Qc
            })
          });
        }
        Ea < 0 && p("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var _h = o.ReactCurrentDispatcher, Gf;
    function Hs(u, d, T) {
      {
        if (Gf === void 0)
          try {
            throw Error();
          } catch (P) {
            var C = P.stack.trim().match(/\n( *(at )?)/);
            Gf = C && C[1] || "";
          }
        return `
` + Gf + u;
      }
    }
    var Zc = !1, uc;
    {
      var Ou = typeof WeakMap == "function" ? WeakMap : Map;
      uc = new Ou();
    }
    function xp(u, d) {
      if (!u || Zc)
        return "";
      {
        var T = uc.get(u);
        if (T !== void 0)
          return T;
      }
      var C;
      Zc = !0;
      var P = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var V;
      V = _h.current, _h.current = null, Sp();
      try {
        if (d) {
          var Q = function() {
            throw Error();
          };
          if (Object.defineProperty(Q.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Q, []);
            } catch (Qt) {
              C = Qt;
            }
            Reflect.construct(u, [], Q);
          } else {
            try {
              Q.call();
            } catch (Qt) {
              C = Qt;
            }
            u.call(Q.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Qt) {
            C = Qt;
          }
          u();
        }
      } catch (Qt) {
        if (Qt && C && typeof Qt.stack == "string") {
          for (var se = Qt.stack.split(`
`), me = C.stack.split(`
`), Ce = se.length - 1, ze = me.length - 1; Ce >= 1 && ze >= 0 && se[Ce] !== me[ze]; )
            ze--;
          for (; Ce >= 1 && ze >= 0; Ce--, ze--)
            if (se[Ce] !== me[ze]) {
              if (Ce !== 1 || ze !== 1)
                do
                  if (Ce--, ze--, ze < 0 || se[Ce] !== me[ze]) {
                    var ft = `
` + se[Ce].replace(" at new ", " at ");
                    return u.displayName && ft.includes("<anonymous>") && (ft = ft.replace("<anonymous>", u.displayName)), typeof u == "function" && uc.set(u, ft), ft;
                  }
                while (Ce >= 1 && ze >= 0);
              break;
            }
        }
      } finally {
        Zc = !1, _h.current = V, Ld(), Error.prepareStackTrace = P;
      }
      var Lt = u ? u.displayName || u.name : "", zt = Lt ? Hs(Lt) : "";
      return typeof u == "function" && uc.set(u, zt), zt;
    }
    function Od(u, d, T) {
      return xp(u, !0);
    }
    function vs(u, d, T) {
      return xp(u, !1);
    }
    function Pd(u) {
      var d = u.prototype;
      return !!(d && d.isReactComponent);
    }
    function Jc(u, d, T) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return xp(u, Pd(u));
      if (typeof u == "string")
        return Hs(u);
      switch (u) {
        case Pt:
          return Hs("Suspense");
        case vt:
          return Hs("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case Ct:
            return vs(u.render);
          case Zt:
            return Jc(u.type, d, T);
          case ie: {
            var C = u, P = C._payload, V = C._init;
            try {
              return Jc(V(P), d, T);
            } catch {
            }
          }
        }
      return "";
    }
    var uu = Object.prototype.hasOwnProperty, _p = {}, Ud = o.ReactDebugCurrentFrame;
    function Ep(u) {
      if (u) {
        var d = u._owner, T = Jc(u.type, u._source, d ? d.type : null);
        Ud.setExtraStackFrame(T);
      } else
        Ud.setExtraStackFrame(null);
    }
    function Ll(u, d, T, C, P) {
      {
        var V = Function.call.bind(uu);
        for (var Q in u)
          if (V(u, Q)) {
            var se = void 0;
            try {
              if (typeof u[Q] != "function") {
                var me = Error((C || "React class") + ": " + T + " type `" + Q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[Q] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw me.name = "Invariant Violation", me;
              }
              se = u[Q](d, Q, C, T, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ce) {
              se = Ce;
            }
            se && !(se instanceof Error) && (Ep(P), p("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", C || "React class", T, Q, typeof se), Ep(null)), se instanceof Error && !(se.message in _p) && (_p[se.message] = !0, Ep(P), p("Failed %s type: %s", T, se.message), Ep(null));
          }
      }
    }
    var ea = [], Nd;
    Nd = [];
    var Pa = -1;
    function dl(u) {
      return {
        current: u
      };
    }
    function so(u, d) {
      if (Pa < 0) {
        p("Unexpected pop.");
        return;
      }
      d !== Nd[Pa] && p("Unexpected Fiber popped."), u.current = ea[Pa], ea[Pa] = null, Nd[Pa] = null, Pa--;
    }
    function ki(u, d, T) {
      Pa++, ea[Pa] = u.current, Nd[Pa] = T, u.current = d;
    }
    var ef;
    ef = {};
    var Kr = {};
    Object.freeze(Kr);
    var yi = dl(Kr), Di = dl(!1), Fd = Kr;
    function lo(u, d, T) {
      return T && Ol(d) ? Fd : yi.current;
    }
    function Wf(u, d, T) {
      {
        var C = u.stateNode;
        C.__reactInternalMemoizedUnmaskedChildContext = d, C.__reactInternalMemoizedMaskedChildContext = T;
      }
    }
    function cc(u, d) {
      {
        var T = u.type, C = T.contextTypes;
        if (!C)
          return Kr;
        var P = u.stateNode;
        if (P && P.__reactInternalMemoizedUnmaskedChildContext === d)
          return P.__reactInternalMemoizedMaskedChildContext;
        var V = {};
        for (var Q in C)
          V[Q] = d[Q];
        {
          var se = ct(u) || "Unknown";
          Ll(C, V, "context", se);
        }
        return P && Wf(u, d, V), V;
      }
    }
    function Qa() {
      return Di.current;
    }
    function Ol(u) {
      {
        var d = u.childContextTypes;
        return d != null;
      }
    }
    function tf(u) {
      so(Di, u), so(yi, u);
    }
    function Pu(u) {
      so(Di, u), so(yi, u);
    }
    function cu(u, d, T) {
      {
        if (yi.current !== Kr)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        ki(yi, d, u), ki(Di, T, u);
      }
    }
    function Pl(u, d, T) {
      {
        var C = u.stateNode, P = d.childContextTypes;
        if (typeof C.getChildContext != "function") {
          {
            var V = ct(u) || "Unknown";
            ef[V] || (ef[V] = !0, p("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", V, V));
          }
          return T;
        }
        var Q = C.getChildContext();
        for (var se in Q)
          if (!(se in P))
            throw new Error((ct(u) || "Unknown") + '.getChildContext(): key "' + se + '" is not defined in childContextTypes.');
        {
          var me = ct(u) || "Unknown";
          Ll(P, Q, "child context", me);
        }
        return x({}, T, Q);
      }
    }
    function Yi(u) {
      {
        var d = u.stateNode, T = d && d.__reactInternalMemoizedMergedChildContext || Kr;
        return Fd = yi.current, ki(yi, T, u), ki(Di, Di.current, u), !0;
      }
    }
    function kd(u, d, T) {
      {
        var C = u.stateNode;
        if (!C)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (T) {
          var P = Pl(u, d, Fd);
          C.__reactInternalMemoizedMergedChildContext = P, so(Di, u), so(yi, u), ki(yi, P, u), ki(Di, T, u);
        } else
          so(Di, u), ki(Di, T, u);
      }
    }
    function bp(u) {
      {
        if (!Tn(u) || u.tag !== J)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var d = u;
        do {
          switch (d.tag) {
            case X:
              return d.stateNode.context;
            case J: {
              var T = d.type;
              if (Ol(T))
                return d.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          d = d.return;
        } while (d !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var jf = 0, Am = 1, mr = (
      /*                         */
      0
    ), Li = (
      /*                 */
      1
    ), Dr = (
      /*                    */
      2
    ), oa = (
      /*               */
      8
    ), Uo = (
      /*              */
      16
    ), Eh = Math.clz32 ? Math.clz32 : Dm, bh = Math.log, $f = Math.LN2;
    function Dm(u) {
      var d = u >>> 0;
      return d === 0 ? 32 : 31 - (bh(d) / $f | 0) | 0;
    }
    var Th = 31, Yt = (
      /*                        */
      0
    ), Er = (
      /*                          */
      0
    ), wr = (
      /*                        */
      1
    ), Vs = (
      /*    */
      2
    ), hl = (
      /*            */
      4
    ), fc = (
      /*            */
      8
    ), Ul = (
      /*                    */
      16
    ), dc = (
      /*                */
      32
    ), hc = (
      /*                       */
      4194240
    ), fu = (
      /*                        */
      64
    ), Tp = (
      /*                        */
      128
    ), wp = (
      /*                        */
      256
    ), Lm = (
      /*                        */
      512
    ), wh = (
      /*                        */
      1024
    ), zd = (
      /*                        */
      2048
    ), Id = (
      /*                        */
      4096
    ), Yf = (
      /*                        */
      8192
    ), nf = (
      /*                        */
      16384
    ), Bd = (
      /*                       */
      32768
    ), rf = (
      /*                       */
      65536
    ), Mh = (
      /*                       */
      131072
    ), Hd = (
      /*                       */
      262144
    ), Mp = (
      /*                       */
      524288
    ), Om = (
      /*                       */
      1048576
    ), Uu = (
      /*                       */
      2097152
    ), Gs = (
      /*                            */
      130023424
    ), Nu = (
      /*                             */
      4194304
    ), Fu = (
      /*                             */
      8388608
    ), Za = (
      /*                             */
      16777216
    ), pc = (
      /*                             */
      33554432
    ), Ws = (
      /*                             */
      67108864
    ), Xf = Nu, qf = (
      /*          */
      134217728
    ), Vd = (
      /*                                 */
      268435455
    ), Xo = (
      /*               */
      268435456
    ), js = (
      /*                       */
      536870912
    ), hi = (
      /*                   */
      1073741824
    );
    function Xn(u) {
      {
        if (u & wr)
          return "Sync";
        if (u & Vs)
          return "InputContinuousHydration";
        if (u & hl)
          return "InputContinuous";
        if (u & fc)
          return "DefaultHydration";
        if (u & Ul)
          return "Default";
        if (u & dc)
          return "TransitionHydration";
        if (u & hc)
          return "Transition";
        if (u & Gs)
          return "Retry";
        if (u & qf)
          return "SelectiveHydration";
        if (u & Xo)
          return "IdleHydration";
        if (u & js)
          return "Idle";
        if (u & hi)
          return "Offscreen";
      }
    }
    var pi = -1, Nr = fu, In = Nu;
    function Zr(u) {
      switch (du(u)) {
        case wr:
          return wr;
        case Vs:
          return Vs;
        case hl:
          return hl;
        case fc:
          return fc;
        case Ul:
          return Ul;
        case dc:
          return dc;
        case fu:
        case Tp:
        case wp:
        case Lm:
        case wh:
        case zd:
        case Id:
        case Yf:
        case nf:
        case Bd:
        case rf:
        case Mh:
        case Hd:
        case Mp:
        case Om:
        case Uu:
          return u & hc;
        case Nu:
        case Fu:
        case Za:
        case pc:
        case Ws:
          return u & Gs;
        case qf:
          return qf;
        case Xo:
          return Xo;
        case js:
          return js;
        case hi:
          return hi;
        default:
          return p("Should have found matching lanes. This is a bug in React."), u;
      }
    }
    function ui(u, d) {
      var T = u.pendingLanes;
      if (T === Yt)
        return Yt;
      var C = Yt, P = u.suspendedLanes, V = u.pingedLanes, Q = T & Vd;
      if (Q !== Yt) {
        var se = Q & ~P;
        if (se !== Yt)
          C = Zr(se);
        else {
          var me = Q & V;
          me !== Yt && (C = Zr(me));
        }
      } else {
        var Ce = T & ~P;
        Ce !== Yt ? C = Zr(Ce) : V !== Yt && (C = Zr(V));
      }
      if (C === Yt)
        return Yt;
      if (d !== Yt && d !== C && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (d & P) === Yt) {
        var ze = du(C), ft = du(d);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ze >= ft || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ze === Ul && (ft & hc) !== Yt
        )
          return d;
      }
      (C & hl) !== Yt && (C |= T & Ul);
      var Lt = u.entangledLanes;
      if (Lt !== Yt)
        for (var zt = u.entanglements, Qt = C & Lt; Qt > 0; ) {
          var rn = Ua(Qt), sr = 1 << rn;
          C |= zt[rn], Qt &= ~sr;
        }
      return C;
    }
    function ku(u, d) {
      for (var T = u.eventTimes, C = pi; d > 0; ) {
        var P = Ua(d), V = 1 << P, Q = T[P];
        Q > C && (C = Q), d &= ~V;
      }
      return C;
    }
    function hr(u, d) {
      switch (u) {
        case wr:
        case Vs:
        case hl:
          return d + 250;
        case fc:
        case Ul:
        case dc:
        case fu:
        case Tp:
        case wp:
        case Lm:
        case wh:
        case zd:
        case Id:
        case Yf:
        case nf:
        case Bd:
        case rf:
        case Mh:
        case Hd:
        case Mp:
        case Om:
        case Uu:
          return d + 5e3;
        case Nu:
        case Fu:
        case Za:
        case pc:
        case Ws:
          return pi;
        case qf:
        case Xo:
        case js:
        case hi:
          return pi;
        default:
          return p("Should have found matching lanes. This is a bug in React."), pi;
      }
    }
    function ba(u, d) {
      for (var T = u.pendingLanes, C = u.suspendedLanes, P = u.pingedLanes, V = u.expirationTimes, Q = T; Q > 0; ) {
        var se = Ua(Q), me = 1 << se, Ce = V[se];
        Ce === pi ? ((me & C) === Yt || (me & P) !== Yt) && (V[se] = hr(me, d)) : Ce <= d && (u.expiredLanes |= me), Q &= ~me;
      }
    }
    function gs(u) {
      return Zr(u.pendingLanes);
    }
    function $s(u) {
      var d = u.pendingLanes & ~hi;
      return d !== Yt ? d : d & hi ? hi : Yt;
    }
    function ta(u) {
      return (u & wr) !== Yt;
    }
    function Ys(u) {
      return (u & Vd) !== Yt;
    }
    function mc(u) {
      return (u & Gs) === u;
    }
    function Kf(u) {
      return (u & hc) === u;
    }
    function vc(u, d) {
      var T = Vs | hl | fc | Ul;
      return (d & T) !== Yt;
    }
    function Uv(u, d) {
      return (d & u.expiredLanes) !== Yt;
    }
    function ys(u) {
      return (u & hc) !== 0;
    }
    function xo() {
      var u = Nr;
      return Nr <<= 1, Nr & hc || (Nr = fu), u;
    }
    function Ch() {
      var u = In;
      return In <<= 1, In & Gs || (In = Nu), u;
    }
    function du(u) {
      return u & -u;
    }
    function Qf(u) {
      return du(u);
    }
    function Ua(u) {
      return 31 - Eh(u);
    }
    function zu(u) {
      return Ua(u);
    }
    function ci(u, d) {
      return (u & d) !== Yt;
    }
    function hu(u, d) {
      return (u & d) === d;
    }
    function gr(u, d) {
      return u | d;
    }
    function uo(u, d) {
      return u & ~d;
    }
    function Ta(u, d) {
      return u & d;
    }
    function Iu(u) {
      return u;
    }
    function nn(u, d) {
      return u !== Er && u < d ? u : d;
    }
    function pl(u) {
      for (var d = [], T = 0; T < Th; T++)
        d.push(u);
      return d;
    }
    function _o(u, d, T) {
      u.pendingLanes |= d, d !== js && (u.suspendedLanes = Yt, u.pingedLanes = Yt);
      var C = u.eventTimes, P = zu(d);
      C[P] = T;
    }
    function Pm(u, d) {
      u.suspendedLanes |= d, u.pingedLanes &= ~d;
      for (var T = u.expirationTimes, C = d; C > 0; ) {
        var P = Ua(C), V = 1 << P;
        T[P] = pi, C &= ~V;
      }
    }
    function Cp(u, d, T) {
      u.pingedLanes |= u.suspendedLanes & d;
    }
    function af(u, d) {
      var T = u.pendingLanes & ~d;
      u.pendingLanes = d, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= d, u.mutableReadLanes &= d, u.entangledLanes &= d;
      for (var C = u.entanglements, P = u.eventTimes, V = u.expirationTimes, Q = T; Q > 0; ) {
        var se = Ua(Q), me = 1 << se;
        C[se] = Yt, P[se] = pi, V[se] = pi, Q &= ~me;
      }
    }
    function Eo(u, d) {
      for (var T = u.entangledLanes |= d, C = u.entanglements, P = T; P; ) {
        var V = Ua(P), Q = 1 << V;
        // Is this one of the newly entangled lanes?
        Q & d | // Is this lane transitively entangled with the newly entangled lanes?
        C[V] & d && (C[V] |= d), P &= ~Q;
      }
    }
    function Ss(u, d) {
      var T = du(d), C;
      switch (T) {
        case hl:
          C = Vs;
          break;
        case Ul:
          C = fc;
          break;
        case fu:
        case Tp:
        case wp:
        case Lm:
        case wh:
        case zd:
        case Id:
        case Yf:
        case nf:
        case Bd:
        case rf:
        case Mh:
        case Hd:
        case Mp:
        case Om:
        case Uu:
        case Nu:
        case Fu:
        case Za:
        case pc:
        case Ws:
          C = dc;
          break;
        case js:
          C = Xo;
          break;
        default:
          C = Er;
          break;
      }
      return (C & (u.suspendedLanes | d)) !== Er ? Er : C;
    }
    function Xi(u, d, T) {
      if (Fa)
        for (var C = u.pendingUpdatersLaneMap; T > 0; ) {
          var P = zu(T), V = 1 << P, Q = C[P];
          Q.add(d), T &= ~V;
        }
    }
    function ml(u, d) {
      if (Fa)
        for (var T = u.pendingUpdatersLaneMap, C = u.memoizedUpdaters; d > 0; ) {
          var P = zu(d), V = 1 << P, Q = T[P];
          Q.size > 0 && (Q.forEach(function(se) {
            var me = se.alternate;
            (me === null || !C.has(me)) && C.add(se);
          }), Q.clear()), d &= ~V;
        }
    }
    var Nl = wr, Gd = hl, of = Ul, Wd = js, Zf = Er;
    function xs() {
      return Zf;
    }
    function co(u) {
      Zf = u;
    }
    function sa(u, d) {
      var T = Zf;
      try {
        return Zf = u, d();
      } finally {
        Zf = T;
      }
    }
    function Rh(u, d) {
      return u !== 0 && u < d ? u : d;
    }
    function Um(u, d) {
      return u === 0 || u > d ? u : d;
    }
    function vl(u, d) {
      return u !== 0 && u < d;
    }
    function pu(u) {
      var d = du(u);
      return vl(Nl, d) ? vl(Gd, d) ? Ys(d) ? of : Wd : Gd : Nl;
    }
    var Ah = i.unstable_scheduleCallback, sf = i.unstable_cancelCallback, Nm = i.unstable_shouldYield, Dh = i.unstable_requestPaint, Vi = i.unstable_now, ha = i.unstable_ImmediatePriority, un = i.unstable_UserBlockingPriority, zi = i.unstable_NormalPriority, Na = i.unstable_IdlePriority, Rp = i.unstable_yieldValue, Fm = i.unstable_setDisableYieldValue, _s = null, pa = null, dn = null, Gi = !1, Fa = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function gc(u) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (d.isDisabled)
        return !0;
      if (!d.supportsFiber)
        return p("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        H && (u = x({}, u, {
          getLaneLabelMap: lf,
          injectProfilingHooks: Xs
        })), _s = d.inject(u), pa = d;
      } catch (T) {
        p("React instrumentation encountered an error: %s.", T);
      }
      return !!d.checkDCE;
    }
    function ma(u, d) {
      if (pa && typeof pa.onScheduleFiberRoot == "function")
        try {
          pa.onScheduleFiberRoot(_s, u, d);
        } catch (T) {
          Gi || (Gi = !0, p("React instrumentation encountered an error: %s", T));
        }
    }
    function Lr(u, d) {
      if (pa && typeof pa.onCommitFiberRoot == "function")
        try {
          var T = (u.current.flags & mn) === mn;
          if (B) {
            var C;
            switch (d) {
              case Nl:
                C = ha;
                break;
              case Gd:
                C = un;
                break;
              case of:
                C = zi;
                break;
              case Wd:
                C = Na;
                break;
              default:
                C = zi;
                break;
            }
            pa.onCommitFiberRoot(_s, u, C, T);
          }
        } catch (P) {
          Gi || (Gi = !0, p("React instrumentation encountered an error: %s", P));
        }
    }
    function qi(u) {
      if (pa && typeof pa.onPostCommitFiberRoot == "function")
        try {
          pa.onPostCommitFiberRoot(_s, u);
        } catch (d) {
          Gi || (Gi = !0, p("React instrumentation encountered an error: %s", d));
        }
    }
    function na(u) {
      if (pa && typeof pa.onCommitFiberUnmount == "function")
        try {
          pa.onCommitFiberUnmount(_s, u);
        } catch (d) {
          Gi || (Gi = !0, p("React instrumentation encountered an error: %s", d));
        }
    }
    function ti(u) {
      if (typeof Rp == "function" && (Fm(u), c(u)), pa && typeof pa.setStrictMode == "function")
        try {
          pa.setStrictMode(_s, u);
        } catch (d) {
          Gi || (Gi = !0, p("React instrumentation encountered an error: %s", d));
        }
    }
    function Xs(u) {
      dn = u;
    }
    function lf() {
      {
        for (var u = /* @__PURE__ */ new Map(), d = 1, T = 0; T < Th; T++) {
          var C = Xn(d);
          u.set(d, C), d *= 2;
        }
        return u;
      }
    }
    function fo(u) {
      dn !== null && typeof dn.markCommitStarted == "function" && dn.markCommitStarted(u);
    }
    function jd() {
      dn !== null && typeof dn.markCommitStopped == "function" && dn.markCommitStopped();
    }
    function Bu(u) {
      dn !== null && typeof dn.markComponentRenderStarted == "function" && dn.markComponentRenderStarted(u);
    }
    function mu() {
      dn !== null && typeof dn.markComponentRenderStopped == "function" && dn.markComponentRenderStopped();
    }
    function Jf(u) {
      dn !== null && typeof dn.markComponentPassiveEffectMountStarted == "function" && dn.markComponentPassiveEffectMountStarted(u);
    }
    function ed() {
      dn !== null && typeof dn.markComponentPassiveEffectMountStopped == "function" && dn.markComponentPassiveEffectMountStopped();
    }
    function qs(u) {
      dn !== null && typeof dn.markComponentPassiveEffectUnmountStarted == "function" && dn.markComponentPassiveEffectUnmountStarted(u);
    }
    function km() {
      dn !== null && typeof dn.markComponentPassiveEffectUnmountStopped == "function" && dn.markComponentPassiveEffectUnmountStopped();
    }
    function td(u) {
      dn !== null && typeof dn.markComponentLayoutEffectMountStarted == "function" && dn.markComponentLayoutEffectMountStarted(u);
    }
    function $d() {
      dn !== null && typeof dn.markComponentLayoutEffectMountStopped == "function" && dn.markComponentLayoutEffectMountStopped();
    }
    function uf(u) {
      dn !== null && typeof dn.markComponentLayoutEffectUnmountStarted == "function" && dn.markComponentLayoutEffectUnmountStarted(u);
    }
    function gl() {
      dn !== null && typeof dn.markComponentLayoutEffectUnmountStopped == "function" && dn.markComponentLayoutEffectUnmountStopped();
    }
    function vu(u, d, T) {
      dn !== null && typeof dn.markComponentErrored == "function" && dn.markComponentErrored(u, d, T);
    }
    function cf(u, d, T) {
      dn !== null && typeof dn.markComponentSuspended == "function" && dn.markComponentSuspended(u, d, T);
    }
    function yl(u) {
      dn !== null && typeof dn.markLayoutEffectsStarted == "function" && dn.markLayoutEffectsStarted(u);
    }
    function Lh() {
      dn !== null && typeof dn.markLayoutEffectsStopped == "function" && dn.markLayoutEffectsStopped();
    }
    function gu(u) {
      dn !== null && typeof dn.markPassiveEffectsStarted == "function" && dn.markPassiveEffectsStarted(u);
    }
    function qn() {
      dn !== null && typeof dn.markPassiveEffectsStopped == "function" && dn.markPassiveEffectsStopped();
    }
    function Cr(u) {
      dn !== null && typeof dn.markRenderStarted == "function" && dn.markRenderStarted(u);
    }
    function Kn() {
      dn !== null && typeof dn.markRenderYielded == "function" && dn.markRenderYielded();
    }
    function jr() {
      dn !== null && typeof dn.markRenderStopped == "function" && dn.markRenderStopped();
    }
    function bo(u) {
      dn !== null && typeof dn.markRenderScheduled == "function" && dn.markRenderScheduled(u);
    }
    function Ks(u, d) {
      dn !== null && typeof dn.markForceUpdateScheduled == "function" && dn.markForceUpdateScheduled(u, d);
    }
    function ff(u, d) {
      dn !== null && typeof dn.markStateUpdateScheduled == "function" && dn.markStateUpdateScheduled(u, d);
    }
    function Es(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var To = typeof Object.is == "function" ? Object.is : Es, ni = null, Nt = !1, Qr = !1;
    function Hn(u) {
      ni === null ? ni = [u] : ni.push(u);
    }
    function Hu(u) {
      Nt = !0, Hn(u);
    }
    function Qs() {
      Nt && No();
    }
    function No() {
      if (!Qr && ni !== null) {
        Qr = !0;
        var u = 0, d = xs();
        try {
          var T = !0, C = ni;
          for (co(Nl); u < C.length; u++) {
            var P = C[u];
            do
              P = P(T);
            while (P !== null);
          }
          ni = null, Nt = !1;
        } catch (V) {
          throw ni !== null && (ni = ni.slice(u + 1)), Ah(ha, No), V;
        } finally {
          co(d), Qr = !1;
        }
      }
      return null;
    }
    function Si(u) {
      var d = u.current.memoizedState;
      return d.isDehydrated;
    }
    var nd = o.ReactCurrentBatchConfig, df = null;
    function hf() {
      return nd.transition;
    }
    function Fo(u, d) {
      if (To(u, d))
        return !0;
      if (typeof u != "object" || u === null || typeof d != "object" || d === null)
        return !1;
      var T = Object.keys(u), C = Object.keys(d);
      if (T.length !== C.length)
        return !1;
      for (var P = 0; P < T.length; P++) {
        var V = T[P];
        if (!uu.call(d, V) || !To(u[V], d[V]))
          return !1;
      }
      return !0;
    }
    function Sl(u) {
      switch (u._debugOwner && u._debugOwner.type, u._debugSource, u.tag) {
        case oe:
          return Hs(u.type);
        case Me:
          return Hs("Lazy");
        case re:
          return Hs("Suspense");
        case Ue:
          return Hs("SuspenseList");
        case Y:
        case K:
        case he:
          return vs(u.type);
        case ce:
          return vs(u.type.render);
        case J:
          return Od(u.type);
        default:
          return "";
      }
    }
    function rd(u) {
      try {
        var d = "", T = u;
        do
          d += Sl(T), T = T.return;
        while (T);
        return d;
      } catch (C) {
        return `
Error generating stack: ` + C.message + `
` + C.stack;
      }
    }
    var Yd = o.ReactDebugCurrentFrame, qo = null, xl = !1;
    function zm() {
      {
        if (qo === null)
          return null;
        var u = qo._debugOwner;
        if (u !== null && typeof u < "u")
          return ct(u);
      }
      return null;
    }
    function yc() {
      return qo === null ? "" : rd(qo);
    }
    function ho() {
      Yd.getCurrentStack = null, qo = null, xl = !1;
    }
    function fi(u) {
      Yd.getCurrentStack = yc, qo = u, xl = !1;
    }
    function Fl(u) {
      xl = u;
    }
    var Zs = {
      recordUnsafeLifecycleWarnings: function(u, d) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(u, d) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Im = function(u) {
        for (var d = null, T = u; T !== null; )
          T.mode & oa && (d = T), T = T.return;
        return d;
      }, kl = function(u) {
        var d = [];
        return u.forEach(function(T) {
          d.push(T);
        }), d.sort().join(", ");
      }, pf = [], yu = [], zl = [], wo = [], Vu = [], id = [], Ko = /* @__PURE__ */ new Set();
      Zs.recordUnsafeLifecycleWarnings = function(u, d) {
        Ko.has(u.type) || (typeof d.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        d.componentWillMount.__suppressDeprecationWarning !== !0 && pf.push(u), u.mode & oa && typeof d.UNSAFE_componentWillMount == "function" && yu.push(u), typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && zl.push(u), u.mode & oa && typeof d.UNSAFE_componentWillReceiveProps == "function" && wo.push(u), typeof d.componentWillUpdate == "function" && d.componentWillUpdate.__suppressDeprecationWarning !== !0 && Vu.push(u), u.mode & oa && typeof d.UNSAFE_componentWillUpdate == "function" && id.push(u));
      }, Zs.flushPendingUnsafeLifecycleWarnings = function() {
        var u = /* @__PURE__ */ new Set();
        pf.length > 0 && (pf.forEach(function(Lt) {
          u.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), pf = []);
        var d = /* @__PURE__ */ new Set();
        yu.length > 0 && (yu.forEach(function(Lt) {
          d.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), yu = []);
        var T = /* @__PURE__ */ new Set();
        zl.length > 0 && (zl.forEach(function(Lt) {
          T.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), zl = []);
        var C = /* @__PURE__ */ new Set();
        wo.length > 0 && (wo.forEach(function(Lt) {
          C.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), wo = []);
        var P = /* @__PURE__ */ new Set();
        Vu.length > 0 && (Vu.forEach(function(Lt) {
          P.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), Vu = []);
        var V = /* @__PURE__ */ new Set();
        if (id.length > 0 && (id.forEach(function(Lt) {
          V.add(ct(Lt) || "Component"), Ko.add(Lt.type);
        }), id = []), d.size > 0) {
          var Q = kl(d);
          p(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Q);
        }
        if (C.size > 0) {
          var se = kl(C);
          p(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, se);
        }
        if (V.size > 0) {
          var me = kl(V);
          p(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, me);
        }
        if (u.size > 0) {
          var Ce = kl(u);
          h(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ce);
        }
        if (T.size > 0) {
          var ze = kl(T);
          h(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ze);
        }
        if (P.size > 0) {
          var ft = kl(P);
          h(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ft);
        }
      };
      var mf = /* @__PURE__ */ new Map(), Il = /* @__PURE__ */ new Set();
      Zs.recordLegacyContextWarning = function(u, d) {
        var T = Im(u);
        if (T === null) {
          p("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Il.has(u.type)) {
          var C = mf.get(T);
          (u.type.contextTypes != null || u.type.childContextTypes != null || d !== null && typeof d.getChildContext == "function") && (C === void 0 && (C = [], mf.set(T, C)), C.push(u));
        }
      }, Zs.flushLegacyContextWarning = function() {
        mf.forEach(function(u, d) {
          if (u.length !== 0) {
            var T = u[0], C = /* @__PURE__ */ new Set();
            u.forEach(function(V) {
              C.add(ct(V) || "Component"), Il.add(V.type);
            });
            var P = kl(C);
            try {
              fi(T), p(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, P);
            } finally {
              ho();
            }
          }
        });
      }, Zs.discardPendingWarnings = function() {
        pf = [], yu = [], zl = [], wo = [], Vu = [], id = [], mf = /* @__PURE__ */ new Map();
      };
    }
    function ad(u) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, T = d && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return T;
      }
    }
    function vf(u) {
      try {
        return Su(u), !1;
      } catch {
        return !0;
      }
    }
    function Su(u) {
      return "" + u;
    }
    function _l(u) {
      if (vf(u))
        return p("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ad(u)), Su(u);
    }
    function ty(u, d) {
      if (vf(u))
        return p("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", d, ad(u)), Su(u);
    }
    function $r(u, d) {
      if (u && u.defaultProps) {
        var T = x({}, d), C = u.defaultProps;
        for (var P in C)
          T[P] === void 0 && (T[P] = C[P]);
        return T;
      }
      return d;
    }
    var od = dl(null), gf;
    gf = {};
    var Gu = null, Sc = null, Bm = null, g = !1;
    function S() {
      Gu = null, Sc = null, Bm = null, g = !1;
    }
    function D() {
      g = !0;
    }
    function z() {
      g = !1;
    }
    function W(u, d, T) {
      ll ? (ki(od, d._currentValue, u), d._currentValue = T, d._currentRenderer !== void 0 && d._currentRenderer !== null && d._currentRenderer !== gf && p("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer = gf) : (ki(od, d._currentValue2, u), d._currentValue2 = T, d._currentRenderer2 !== void 0 && d._currentRenderer2 !== null && d._currentRenderer2 !== gf && p("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), d._currentRenderer2 = gf);
    }
    function Z(u, d) {
      var T = od.current;
      so(od, d), ll ? u._currentValue = T : u._currentValue2 = T;
    }
    function we(u, d, T) {
      for (var C = u; C !== null; ) {
        var P = C.alternate;
        if (hu(C.childLanes, d) ? P !== null && !hu(P.childLanes, d) && (P.childLanes = gr(P.childLanes, d)) : (C.childLanes = gr(C.childLanes, d), P !== null && (P.childLanes = gr(P.childLanes, d))), C === T)
          break;
        C = C.return;
      }
      C !== T && p("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Qe(u, d, T) {
      Ot(u, d, T);
    }
    function Ot(u, d, T) {
      var C = u.child;
      for (C !== null && (C.return = u); C !== null; ) {
        var P = void 0, V = C.dependencies;
        if (V !== null) {
          P = C.child;
          for (var Q = V.firstContext; Q !== null; ) {
            if (Q.context === d) {
              if (C.tag === J) {
                var se = Qf(T), me = or(pi, se);
                me.tag = ka;
                var Ce = C.updateQueue;
                if (Ce !== null) {
                  var ze = Ce.shared, ft = ze.pending;
                  ft === null ? me.next = me : (me.next = ft.next, ft.next = me), ze.pending = me;
                }
              }
              C.lanes = gr(C.lanes, T);
              var Lt = C.alternate;
              Lt !== null && (Lt.lanes = gr(Lt.lanes, T)), we(C.return, T, u), V.lanes = gr(V.lanes, T);
              break;
            }
            Q = Q.next;
          }
        } else if (C.tag === Pe)
          P = C.type === u.type ? null : C.child;
        else if (C.tag === Ae) {
          var zt = C.return;
          if (zt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          zt.lanes = gr(zt.lanes, T);
          var Qt = zt.alternate;
          Qt !== null && (Qt.lanes = gr(Qt.lanes, T)), we(zt, T, u), P = C.sibling;
        } else
          P = C.child;
        if (P !== null)
          P.return = C;
        else
          for (P = C; P !== null; ) {
            if (P === u) {
              P = null;
              break;
            }
            var rn = P.sibling;
            if (rn !== null) {
              rn.return = P.return, P = rn;
              break;
            }
            P = P.return;
          }
        C = P;
      }
    }
    function Jt(u, d) {
      Gu = u, Sc = null, Bm = null;
      var T = u.dependencies;
      if (T !== null) {
        var C = T.firstContext;
        C !== null && (ci(T.lanes, d) && o_(), T.firstContext = null);
      }
    }
    function ln(u) {
      g && p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var d = ll ? u._currentValue : u._currentValue2;
      if (Bm !== u) {
        var T = {
          context: u,
          memoizedValue: d,
          next: null
        };
        if (Sc === null) {
          if (Gu === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Sc = T, Gu.dependencies = {
            lanes: Yt,
            firstContext: T
          };
        } else
          Sc = Sc.next = T;
      }
      return d;
    }
    var cr = null;
    function Qn(u) {
      cr === null ? cr = [u] : cr.push(u);
    }
    function Ki() {
      if (cr !== null) {
        for (var u = 0; u < cr.length; u++) {
          var d = cr[u], T = d.interleaved;
          if (T !== null) {
            d.interleaved = null;
            var C = T.next, P = d.pending;
            if (P !== null) {
              var V = P.next;
              P.next = C, T.next = V;
            }
            d.pending = T;
          }
        }
        cr = null;
      }
    }
    var hn = 0, ri = 1, ka = 2, mt = 3, We = !1, Mt, Vt;
    Mt = !1, Vt = null;
    function An(u) {
      var d = {
        baseState: u.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Yt
        },
        effects: null
      };
      u.updateQueue = d;
    }
    function Rr(u, d) {
      var T = d.updateQueue, C = u.updateQueue;
      if (T === C) {
        var P = {
          baseState: C.baseState,
          firstBaseUpdate: C.firstBaseUpdate,
          lastBaseUpdate: C.lastBaseUpdate,
          shared: C.shared,
          effects: C.effects
        };
        d.updateQueue = P;
      }
    }
    function or(u, d) {
      var T = {
        eventTime: u,
        lane: d,
        tag: hn,
        payload: null,
        callback: null,
        next: null
      };
      return T;
    }
    function Fr(u, d, T) {
      var C = u.updateQueue;
      if (C !== null) {
        var P = C.shared;
        if (M_(u)) {
          var V = P.interleaved;
          V === null ? (d.next = d, Qn(P)) : (d.next = V.next, V.next = d), P.interleaved = d;
        } else {
          var Q = P.pending;
          Q === null ? d.next = d : (d.next = Q.next, Q.next = d), P.pending = d;
        }
        Vt === P && !Mt && (p("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Mt = !0);
      }
    }
    function va(u, d, T) {
      var C = d.updateQueue;
      if (C !== null) {
        var P = C.shared;
        if (ys(T)) {
          var V = P.lanes;
          V = Ta(V, u.pendingLanes);
          var Q = gr(V, T);
          P.lanes = Q, Eo(u, Q);
        }
      }
    }
    function kr(u, d) {
      var T = u.updateQueue, C = u.alternate;
      if (C !== null) {
        var P = C.updateQueue;
        if (T === P) {
          var V = null, Q = null, se = T.firstBaseUpdate;
          if (se !== null) {
            var me = se;
            do {
              var Ce = {
                eventTime: me.eventTime,
                lane: me.lane,
                tag: me.tag,
                payload: me.payload,
                callback: me.callback,
                next: null
              };
              Q === null ? V = Q = Ce : (Q.next = Ce, Q = Ce), me = me.next;
            } while (me !== null);
            Q === null ? V = Q = d : (Q.next = d, Q = d);
          } else
            V = Q = d;
          T = {
            baseState: P.baseState,
            firstBaseUpdate: V,
            lastBaseUpdate: Q,
            shared: P.shared,
            effects: P.effects
          }, u.updateQueue = T;
          return;
        }
      }
      var ze = T.lastBaseUpdate;
      ze === null ? T.firstBaseUpdate = d : ze.next = d, T.lastBaseUpdate = d;
    }
    function xc(u, d, T, C, P, V) {
      switch (T.tag) {
        case ri: {
          var Q = T.payload;
          if (typeof Q == "function") {
            D();
            var se = Q.call(V, C, P);
            {
              if (u.mode & oa) {
                ti(!0);
                try {
                  Q.call(V, C, P);
                } finally {
                  ti(!1);
                }
              }
              z();
            }
            return se;
          }
          return Q;
        }
        case mt:
          u.flags = u.flags & ~qt | mn;
        case hn: {
          var me = T.payload, Ce;
          if (typeof me == "function") {
            D(), Ce = me.call(V, C, P);
            {
              if (u.mode & oa) {
                ti(!0);
                try {
                  me.call(V, C, P);
                } finally {
                  ti(!1);
                }
              }
              z();
            }
          } else
            Ce = me;
          return Ce == null ? C : x({}, C, Ce);
        }
        case ka:
          return We = !0, C;
      }
      return C;
    }
    function Oh(u, d, T, C) {
      var P = u.updateQueue;
      We = !1, Vt = P.shared;
      var V = P.firstBaseUpdate, Q = P.lastBaseUpdate, se = P.shared.pending;
      if (se !== null) {
        P.shared.pending = null;
        var me = se, Ce = me.next;
        me.next = null, Q === null ? V = Ce : Q.next = Ce, Q = me;
        var ze = u.alternate;
        if (ze !== null) {
          var ft = ze.updateQueue, Lt = ft.lastBaseUpdate;
          Lt !== Q && (Lt === null ? ft.firstBaseUpdate = Ce : Lt.next = Ce, ft.lastBaseUpdate = me);
        }
      }
      if (V !== null) {
        var zt = P.baseState, Qt = Yt, rn = null, sr = null, zr = null, pr = V;
        do {
          var Ga = pr.lane, Wa = pr.eventTime;
          if (hu(C, Ga)) {
            if (zr !== null) {
              var Gt = {
                eventTime: Wa,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Er,
                tag: pr.tag,
                payload: pr.payload,
                callback: pr.callback,
                next: null
              };
              zr = zr.next = Gt;
            }
            zt = xc(u, P, pr, zt, d, T);
            var yt = pr.callback;
            if (yt !== null && // If the update was already committed, we should not queue its
            // callback again.
            pr.lane !== Er) {
              u.flags |= rr;
              var sn = P.effects;
              sn === null ? P.effects = [pr] : sn.push(pr);
            }
          } else {
            var xt = {
              eventTime: Wa,
              lane: Ga,
              tag: pr.tag,
              payload: pr.payload,
              callback: pr.callback,
              next: null
            };
            zr === null ? (sr = zr = xt, rn = zt) : zr = zr.next = xt, Qt = gr(Qt, Ga);
          }
          if (pr = pr.next, pr === null) {
            if (se = P.shared.pending, se === null)
              break;
            var jn = se, pn = jn.next;
            jn.next = null, pr = pn, P.lastBaseUpdate = jn, P.shared.pending = null;
          }
        } while (!0);
        zr === null && (rn = zt), P.baseState = rn, P.firstBaseUpdate = sr, P.lastBaseUpdate = zr;
        var Ar = P.shared.interleaved;
        if (Ar !== null) {
          var Pi = Ar;
          do
            Qt = gr(Qt, Pi.lane), Pi = Pi.next;
          while (Pi !== Ar);
        } else
          V === null && (P.shared.lanes = Yt);
        By(Qt), u.lanes = Qt, u.memoizedState = zt;
      }
      Vt = null;
    }
    function L0(u, d) {
      if (typeof u != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + u));
      u.call(d);
    }
    function Ap() {
      We = !1;
    }
    function ny() {
      return We;
    }
    function ry(u, d, T) {
      var C = d.effects;
      if (d.effects = null, C !== null)
        for (var P = 0; P < C.length; P++) {
          var V = C[P], Q = V.callback;
          Q !== null && (V.callback = null, L0(Q, T));
        }
    }
    var Hm = {}, iy = new r.Component().refs, bs, Qo, yf, Dp, Xd, Wu, po, Lp, Ts, O0;
    {
      bs = /* @__PURE__ */ new Set(), Qo = /* @__PURE__ */ new Set(), yf = /* @__PURE__ */ new Set(), Dp = /* @__PURE__ */ new Set(), Lp = /* @__PURE__ */ new Set(), Xd = /* @__PURE__ */ new Set(), Ts = /* @__PURE__ */ new Set(), O0 = /* @__PURE__ */ new Set();
      var ay = /* @__PURE__ */ new Set();
      po = function(u, d) {
        if (!(u === null || typeof u == "function")) {
          var T = d + "_" + u;
          ay.has(T) || (ay.add(T), p("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, u));
        }
      }, Wu = function(u, d) {
        if (d === void 0) {
          var T = Je(u) || "Component";
          Xd.has(T) || (Xd.add(T), p("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", T));
        }
      }, Object.defineProperty(Hm, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Hm);
    }
    function Op(u, d, T, C) {
      var P = u.memoizedState, V = T(C, P);
      {
        if (u.mode & oa) {
          ti(!0);
          try {
            V = T(C, P);
          } finally {
            ti(!1);
          }
        }
        Wu(d, V);
      }
      var Q = V == null ? P : x({}, P, V);
      if (u.memoizedState = Q, u.lanes === Yt) {
        var se = u.updateQueue;
        se.baseState = Q;
      }
    }
    var Mo = {
      isMounted: Ji,
      enqueueSetState: function(u, d, T) {
        var C = b(u), P = Ml(), V = Zp(C), Q = or(P, V);
        Q.payload = d, T != null && (po(T, "setState"), Q.callback = T), Fr(C, Q);
        var se = Bo(C, V, P);
        se !== null && va(se, C, V), ff(C, V);
      },
      enqueueReplaceState: function(u, d, T) {
        var C = b(u), P = Ml(), V = Zp(C), Q = or(P, V);
        Q.tag = ri, Q.payload = d, T != null && (po(T, "replaceState"), Q.callback = T), Fr(C, Q);
        var se = Bo(C, V, P);
        se !== null && va(se, C, V), ff(C, V);
      },
      enqueueForceUpdate: function(u, d) {
        var T = b(u), C = Ml(), P = Zp(T), V = or(C, P);
        V.tag = ka, d != null && (po(d, "forceUpdate"), V.callback = d), Fr(T, V);
        var Q = Bo(T, P, C);
        Q !== null && va(Q, T, P), Ks(T, P);
      }
    };
    function P0(u, d, T, C, P, V, Q) {
      var se = u.stateNode;
      if (typeof se.shouldComponentUpdate == "function") {
        var me = se.shouldComponentUpdate(C, V, Q);
        {
          if (u.mode & oa) {
            ti(!0);
            try {
              me = se.shouldComponentUpdate(C, V, Q);
            } finally {
              ti(!1);
            }
          }
          me === void 0 && p("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Je(d) || "Component");
        }
        return me;
      }
      return d.prototype && d.prototype.isPureReactComponent ? !Fo(T, C) || !Fo(P, V) : !0;
    }
    function On(u, d, T) {
      var C = u.stateNode;
      {
        var P = Je(d) || "Component", V = C.render;
        V || (d.prototype && typeof d.prototype.render == "function" ? p("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", P) : p("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", P)), C.getInitialState && !C.getInitialState.isReactClassApproved && !C.state && p("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", P), C.getDefaultProps && !C.getDefaultProps.isReactClassApproved && p("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", P), C.propTypes && p("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", P), C.contextType && p("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", P), C.contextTypes && p("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", P), d.contextType && d.contextTypes && !Ts.has(d) && (Ts.add(d), p("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", P)), typeof C.componentShouldUpdate == "function" && p("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", P), d.prototype && d.prototype.isPureReactComponent && typeof C.shouldComponentUpdate < "u" && p("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Je(d) || "A pure component"), typeof C.componentDidUnmount == "function" && p("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", P), typeof C.componentDidReceiveProps == "function" && p("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", P), typeof C.componentWillRecieveProps == "function" && p("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", P), typeof C.UNSAFE_componentWillRecieveProps == "function" && p("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", P);
        var Q = C.props !== T;
        C.props !== void 0 && Q && p("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", P, P), C.defaultProps && p("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", P, P), typeof C.getSnapshotBeforeUpdate == "function" && typeof C.componentDidUpdate != "function" && !yf.has(d) && (yf.add(d), p("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Je(d))), typeof C.getDerivedStateFromProps == "function" && p("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof C.getDerivedStateFromError == "function" && p("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof d.getSnapshotBeforeUpdate == "function" && p("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", P);
        var se = C.state;
        se && (typeof se != "object" || Xr(se)) && p("%s.state: must be set to an object or null", P), typeof C.getChildContext == "function" && typeof d.childContextTypes != "object" && p("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", P);
      }
    }
    function Pp(u, d) {
      d.updater = Mo, u.stateNode = d, w(d, u), d._reactInternalInstance = Hm;
    }
    function Vm(u, d, T) {
      var C = !1, P = Kr, V = Kr, Q = d.contextType;
      if ("contextType" in d) {
        var se = (
          // Allow null for conditional declaration
          Q === null || Q !== void 0 && Q.$$typeof === nt && Q._context === void 0
        );
        if (!se && !O0.has(d)) {
          O0.add(d);
          var me = "";
          Q === void 0 ? me = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Q != "object" ? me = " However, it is set to a " + typeof Q + "." : Q.$$typeof === Ut ? me = " Did you accidentally pass the Context.Provider instead?" : Q._context !== void 0 ? me = " Did you accidentally pass the Context.Consumer instead?" : me = " However, it is set to an object with keys {" + Object.keys(Q).join(", ") + "}.", p("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Je(d) || "Component", me);
        }
      }
      if (typeof Q == "object" && Q !== null)
        V = ln(Q);
      else {
        P = lo(u, d, !0);
        var Ce = d.contextTypes;
        C = Ce != null, V = C ? cc(u, P) : Kr;
      }
      var ze = new d(T, V);
      if (u.mode & oa) {
        ti(!0);
        try {
          ze = new d(T, V);
        } finally {
          ti(!1);
        }
      }
      var ft = u.memoizedState = ze.state !== null && ze.state !== void 0 ? ze.state : null;
      Pp(u, ze);
      {
        if (typeof d.getDerivedStateFromProps == "function" && ft === null) {
          var Lt = Je(d) || "Component";
          Qo.has(Lt) || (Qo.add(Lt), p("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Lt, ze.state === null ? "null" : "undefined", Lt));
        }
        if (typeof d.getDerivedStateFromProps == "function" || typeof ze.getSnapshotBeforeUpdate == "function") {
          var zt = null, Qt = null, rn = null;
          if (typeof ze.componentWillMount == "function" && ze.componentWillMount.__suppressDeprecationWarning !== !0 ? zt = "componentWillMount" : typeof ze.UNSAFE_componentWillMount == "function" && (zt = "UNSAFE_componentWillMount"), typeof ze.componentWillReceiveProps == "function" && ze.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Qt = "componentWillReceiveProps" : typeof ze.UNSAFE_componentWillReceiveProps == "function" && (Qt = "UNSAFE_componentWillReceiveProps"), typeof ze.componentWillUpdate == "function" && ze.componentWillUpdate.__suppressDeprecationWarning !== !0 ? rn = "componentWillUpdate" : typeof ze.UNSAFE_componentWillUpdate == "function" && (rn = "UNSAFE_componentWillUpdate"), zt !== null || Qt !== null || rn !== null) {
            var sr = Je(d) || "Component", zr = typeof d.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Dp.has(sr) || (Dp.add(sr), p(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, sr, zr, zt !== null ? `
  ` + zt : "", Qt !== null ? `
  ` + Qt : "", rn !== null ? `
  ` + rn : ""));
          }
        }
      }
      return C && Wf(u, P, V), ze;
    }
    function Dx(u, d) {
      var T = d.state;
      typeof d.componentWillMount == "function" && d.componentWillMount(), typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), T !== d.state && (p("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ct(u) || "Component"), Mo.enqueueReplaceState(d, d.state, null));
    }
    function U0(u, d, T, C) {
      var P = d.state;
      if (typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(T, C), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(T, C), d.state !== P) {
        {
          var V = ct(u) || "Component";
          bs.has(V) || (bs.add(V), p("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", V));
        }
        Mo.enqueueReplaceState(d, d.state, null);
      }
    }
    function Up(u, d, T, C) {
      On(u, d, T);
      var P = u.stateNode;
      P.props = T, P.state = u.memoizedState, P.refs = iy, An(u);
      var V = d.contextType;
      if (typeof V == "object" && V !== null)
        P.context = ln(V);
      else {
        var Q = lo(u, d, !0);
        P.context = cc(u, Q);
      }
      {
        if (P.state === T) {
          var se = Je(d) || "Component";
          Lp.has(se) || (Lp.add(se), p("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", se));
        }
        u.mode & oa && Zs.recordLegacyContextWarning(u, P), Zs.recordUnsafeLifecycleWarnings(u, P);
      }
      P.state = u.memoizedState;
      var me = d.getDerivedStateFromProps;
      if (typeof me == "function" && (Op(u, d, me, T), P.state = u.memoizedState), typeof d.getDerivedStateFromProps != "function" && typeof P.getSnapshotBeforeUpdate != "function" && (typeof P.UNSAFE_componentWillMount == "function" || typeof P.componentWillMount == "function") && (Dx(u, P), Oh(u, T, P, C), P.state = u.memoizedState), typeof P.componentDidMount == "function") {
        var Ce = ut;
        Ce |= tt, (u.mode & Uo) !== mr && (Ce |= pt), u.flags |= Ce;
      }
    }
    function Nv(u, d, T, C) {
      var P = u.stateNode, V = u.memoizedProps;
      P.props = V;
      var Q = P.context, se = d.contextType, me = Kr;
      if (typeof se == "object" && se !== null)
        me = ln(se);
      else {
        var Ce = lo(u, d, !0);
        me = cc(u, Ce);
      }
      var ze = d.getDerivedStateFromProps, ft = typeof ze == "function" || typeof P.getSnapshotBeforeUpdate == "function";
      !ft && (typeof P.UNSAFE_componentWillReceiveProps == "function" || typeof P.componentWillReceiveProps == "function") && (V !== T || Q !== me) && U0(u, P, T, me), Ap();
      var Lt = u.memoizedState, zt = P.state = Lt;
      if (Oh(u, T, P, C), zt = u.memoizedState, V === T && Lt === zt && !Qa() && !ny()) {
        if (typeof P.componentDidMount == "function") {
          var Qt = ut;
          Qt |= tt, (u.mode & Uo) !== mr && (Qt |= pt), u.flags |= Qt;
        }
        return !1;
      }
      typeof ze == "function" && (Op(u, d, ze, T), zt = u.memoizedState);
      var rn = ny() || P0(u, d, V, T, Lt, zt, me);
      if (rn) {
        if (!ft && (typeof P.UNSAFE_componentWillMount == "function" || typeof P.componentWillMount == "function") && (typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount()), typeof P.componentDidMount == "function") {
          var sr = ut;
          sr |= tt, (u.mode & Uo) !== mr && (sr |= pt), u.flags |= sr;
        }
      } else {
        if (typeof P.componentDidMount == "function") {
          var zr = ut;
          zr |= tt, (u.mode & Uo) !== mr && (zr |= pt), u.flags |= zr;
        }
        u.memoizedProps = T, u.memoizedState = zt;
      }
      return P.props = T, P.state = zt, P.context = me, rn;
    }
    function N0(u, d, T, C, P) {
      var V = d.stateNode;
      Rr(u, d);
      var Q = d.memoizedProps, se = d.type === d.elementType ? Q : $r(d.type, Q);
      V.props = se;
      var me = d.pendingProps, Ce = V.context, ze = T.contextType, ft = Kr;
      if (typeof ze == "object" && ze !== null)
        ft = ln(ze);
      else {
        var Lt = lo(d, T, !0);
        ft = cc(d, Lt);
      }
      var zt = T.getDerivedStateFromProps, Qt = typeof zt == "function" || typeof V.getSnapshotBeforeUpdate == "function";
      !Qt && (typeof V.UNSAFE_componentWillReceiveProps == "function" || typeof V.componentWillReceiveProps == "function") && (Q !== me || Ce !== ft) && U0(d, V, C, ft), Ap();
      var rn = d.memoizedState, sr = V.state = rn;
      if (Oh(d, C, V, P), sr = d.memoizedState, Q === me && rn === sr && !Qa() && !ny() && !L)
        return typeof V.componentDidUpdate == "function" && (Q !== u.memoizedProps || rn !== u.memoizedState) && (d.flags |= ut), typeof V.getSnapshotBeforeUpdate == "function" && (Q !== u.memoizedProps || rn !== u.memoizedState) && (d.flags |= Wn), !1;
      typeof zt == "function" && (Op(d, T, zt, C), sr = d.memoizedState);
      var zr = ny() || P0(d, T, se, C, rn, sr, ft) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      L;
      return zr ? (!Qt && (typeof V.UNSAFE_componentWillUpdate == "function" || typeof V.componentWillUpdate == "function") && (typeof V.componentWillUpdate == "function" && V.componentWillUpdate(C, sr, ft), typeof V.UNSAFE_componentWillUpdate == "function" && V.UNSAFE_componentWillUpdate(C, sr, ft)), typeof V.componentDidUpdate == "function" && (d.flags |= ut), typeof V.getSnapshotBeforeUpdate == "function" && (d.flags |= Wn)) : (typeof V.componentDidUpdate == "function" && (Q !== u.memoizedProps || rn !== u.memoizedState) && (d.flags |= ut), typeof V.getSnapshotBeforeUpdate == "function" && (Q !== u.memoizedProps || rn !== u.memoizedState) && (d.flags |= Wn), d.memoizedProps = C, d.memoizedState = sr), V.props = C, V.state = sr, V.context = ft, zr;
    }
    var Ph = [], Np = 0, Fp = null, qd = 0, Co = [], mi = 0, za = null, ko = 1, xu = "";
    function Kd(u) {
      return Qd(), (u.flags & ye) !== pe;
    }
    function Sf(u) {
      return Qd(), qd;
    }
    function Lx() {
      var u = xu, d = ko, T = d & ~k0(d);
      return T.toString(32) + u;
    }
    function El(u, d) {
      Qd(), Ph[Np++] = qd, Ph[Np++] = Fp, Fp = u, qd = d;
    }
    function F0(u, d, T) {
      Qd(), Co[mi++] = ko, Co[mi++] = xu, Co[mi++] = za, za = u;
      var C = ko, P = xu, V = Fv(C) - 1, Q = C & ~(1 << V), se = T + 1, me = Fv(d) + V;
      if (me > 30) {
        var Ce = V - V % 5, ze = (1 << Ce) - 1, ft = (Q & ze).toString(32), Lt = Q >> Ce, zt = V - Ce, Qt = Fv(d) + zt, rn = se << zt, sr = rn | Lt, zr = ft + P;
        ko = 1 << Qt | sr, xu = zr;
      } else {
        var pr = se << V, Ga = pr | Q, Wa = P;
        ko = 1 << me | Ga, xu = Wa;
      }
    }
    function Uh(u) {
      Qd();
      var d = u.return;
      if (d !== null) {
        var T = 1, C = 0;
        El(u, T), F0(u, T, C);
      }
    }
    function Fv(u) {
      return 32 - Eh(u);
    }
    function k0(u) {
      return 1 << Fv(u) - 1;
    }
    function oy(u) {
      for (; u === Fp; )
        Fp = Ph[--Np], Ph[Np] = null, qd = Ph[--Np], Ph[Np] = null;
      for (; u === za; )
        za = Co[--mi], Co[mi] = null, xu = Co[--mi], Co[mi] = null, ko = Co[--mi], Co[mi] = null;
    }
    function sy() {
      return Qd(), za !== null ? {
        id: ko,
        overflow: xu
      } : null;
    }
    function kv(u, d) {
      Qd(), Co[mi++] = ko, Co[mi++] = xu, Co[mi++] = za, ko = d.id, xu = d.overflow, za = u;
    }
    function Qd() {
      Ii() || p("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Oi = null, yr = null, wi = !1, ra = !1, wa = null;
    function ju() {
      wi && p("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Gm() {
      ra = !0;
    }
    function Zo(u) {
      if (!Ra)
        return !1;
      var d = u.stateNode.containerInfo;
      return yr = Yc(d), Oi = u, wi = !0, wa = null, ra = !1, !0;
    }
    function zv(u, d, T) {
      return Ra ? (yr = xm(d), Oi = u, wi = !0, wa = null, ra = !1, T !== null && kv(u, T), !0) : !1;
    }
    function sd(u, d) {
      switch (u.tag) {
        case X:
          Hf(u.stateNode.containerInfo, d);
          break;
        case oe:
          Mm(u.type, u.memoizedProps, u.stateNode, d);
          break;
        case re:
          var T = u.memoizedState;
          T.dehydrated !== null && su(T.dehydrated, d);
          break;
      }
    }
    function Iv(u, d) {
      sd(u, d);
      var T = _b();
      T.stateNode = d, T.return = u;
      var C = u.deletions;
      C === null ? (u.deletions = [T], u.flags |= zn) : C.push(T);
    }
    function Nh(u, d) {
      {
        if (ra)
          return;
        switch (u.tag) {
          case X: {
            var T = u.stateNode.containerInfo;
            switch (d.tag) {
              case oe:
                var C = d.type, P = d.pendingProps;
                fl(T, C, P);
                break;
              case fe:
                var V = d.pendingProps;
                Is(T, V);
                break;
              case re:
                qc(T);
                break;
            }
            break;
          }
          case oe: {
            var Q = u.type, se = u.memoizedProps, me = u.stateNode;
            switch (d.tag) {
              case oe:
                var Ce = d.type, ze = d.pendingProps;
                Bs(Q, se, me, Ce, ze);
                break;
              case fe:
                var ft = d.pendingProps;
                Lu(Q, se, me, ft);
                break;
              case re:
                Oa(Q, se, me);
                break;
            }
            break;
          }
          case re: {
            var Lt = u.memoizedState, zt = Lt.dehydrated;
            if (zt !== null)
              switch (d.tag) {
                case oe:
                  var Qt = d.type, rn = d.pendingProps;
                  Kc(zt, Qt, rn);
                  break;
                case fe:
                  var sr = d.pendingProps;
                  lu(zt, sr);
                  break;
                case re:
                  Vf(zt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function Fh(u, d) {
      d.flags = d.flags & ~Wr | Be, Nh(u, d);
    }
    function bl(u, d) {
      switch (u.tag) {
        case oe: {
          var T = u.type, C = u.pendingProps, P = ao(d, T, C);
          return P !== null ? (u.stateNode = P, Oi = u, yr = lc(P), !0) : !1;
        }
        case fe: {
          var V = u.pendingProps, Q = La(d, V);
          return Q !== null ? (u.stateNode = Q, Oi = u, yr = null, !0) : !1;
        }
        case re: {
          {
            var se = da(d);
            if (se !== null) {
              var me = {
                dehydrated: se,
                treeContext: sy(),
                retryLane: hi
              };
              u.memoizedState = me;
              var Ce = Wi(se);
              return Ce.return = u, u.child = Ce, Oi = u, yr = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Bv(u) {
      return (u.mode & Li) !== mr && (u.flags & mn) === pe;
    }
    function kh(u) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function xf(u) {
      if (wi) {
        var d = yr;
        if (!d) {
          Bv(u) && (Nh(Oi, u), kh()), Fh(Oi, u), wi = !1, Oi = u;
          return;
        }
        var T = d;
        if (!bl(u, d)) {
          Bv(u) && (Nh(Oi, u), kh()), d = Bf(T);
          var C = Oi;
          if (!d || !bl(u, d)) {
            Fh(Oi, u), wi = !1, Oi = u;
            return;
          }
          Iv(C, T);
        }
      }
    }
    function ly(u, d, T) {
      if (!Ra)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var C = u.stateNode, P = !ra, V = Xc(C, u.type, u.memoizedProps, d, T, u, P);
      return u.updateQueue = V, V !== null;
    }
    function kp(u) {
      if (!Ra)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = u.stateNode, T = u.memoizedProps, C = !ra, P = xh(d, T, u, C);
      if (P) {
        var V = Oi;
        if (V !== null) {
          var Q = (V.mode & Li) !== mr;
          switch (V.tag) {
            case X: {
              var se = V.stateNode.containerInfo;
              wm(
                se,
                d,
                T,
                // TODO: Delete this argument when we remove the legacy root API.
                Q
              );
              break;
            }
            case oe: {
              var me = V.type, Ce = V.memoizedProps, ze = V.stateNode;
              Rd(
                me,
                Ce,
                ze,
                d,
                T,
                // TODO: Delete this argument when we remove the legacy root API.
                Q
              );
              break;
            }
          }
        }
      }
      return P;
    }
    function ld(u) {
      if (!Ra)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = u.memoizedState, T = d !== null ? d.dehydrated : null;
      if (!T)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Lv(T, u);
    }
    function zh(u) {
      if (!Ra)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var d = u.memoizedState, T = d !== null ? d.dehydrated : null;
      if (!T)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return ey(T);
    }
    function Zd(u) {
      for (var d = u.return; d !== null && d.tag !== oe && d.tag !== X && d.tag !== re; )
        d = d.return;
      Oi = d;
    }
    function Ih(u) {
      if (!Ra || u !== Oi)
        return !1;
      if (!wi)
        return Zd(u), wi = !0, !1;
      if (u.tag !== X && (u.tag !== oe || Ov(u.type) && !ac(u.type, u.memoizedProps))) {
        var d = yr;
        if (d)
          if (Bv(u))
            Hv(u), kh();
          else
            for (; d; )
              Iv(u, d), d = Bf(d);
      }
      return Zd(u), u.tag === re ? yr = zh(u) : yr = Oi ? Bf(u.stateNode) : null, !0;
    }
    function Wm() {
      return wi && yr !== null;
    }
    function Hv(u) {
      for (var d = yr; d; )
        sd(u, d), d = Bf(d);
    }
    function _c() {
      Ra && (Oi = null, yr = null, wi = !1, ra = !1);
    }
    function Bh() {
      wa !== null && (Qh(wa), wa = null);
    }
    function Ii() {
      return wi;
    }
    function mo(u) {
      wa === null ? wa = [u] : wa.push(u);
    }
    var ws, Ms, Hh, Vv, zp, uy = function(u, d) {
    };
    ws = !1, Ms = !1, Hh = {}, Vv = {}, zp = {}, uy = function(u, d) {
      if (!(u === null || typeof u != "object") && !(!u._store || u._store.validated || u.key != null)) {
        if (typeof u._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        u._store.validated = !0;
        var T = ct(d) || "Component";
        Vv[T] || (Vv[T] = !0, p('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Tl(u, d, T) {
      var C = T.ref;
      if (C !== null && typeof C != "function" && typeof C != "object") {
        if ((u.mode & oa || k) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(T._owner && T._self && T._owner.stateNode !== T._self)) {
          var P = ct(u) || "Component";
          Hh[P] || (p('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', C), Hh[P] = !0);
        }
        if (T._owner) {
          var V = T._owner, Q;
          if (V) {
            var se = V;
            if (se.tag !== J)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Q = se.stateNode;
          }
          if (!Q)
            throw new Error("Missing owner for string ref " + C + ". This error is likely caused by a bug in React. Please file an issue.");
          var me = Q;
          ty(C, "ref");
          var Ce = "" + C;
          if (d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === Ce)
            return d.ref;
          var ze = function(ft) {
            var Lt = me.refs;
            Lt === iy && (Lt = me.refs = {}), ft === null ? delete Lt[Ce] : Lt[Ce] = ft;
          };
          return ze._stringRef = Ce, ze;
        } else {
          if (typeof C != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!T._owner)
            throw new Error("Element ref was specified as a string (" + C + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return C;
    }
    function Gv(u, d) {
      var T = Object.prototype.toString.call(d);
      throw new Error("Objects are not valid as a React child (found: " + (T === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : T) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Jd(u) {
      {
        var d = ct(u) || "Component";
        if (zp[d])
          return;
        zp[d] = !0, p("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function eh(u) {
      var d = u._payload, T = u._init;
      return T(d);
    }
    function cy(u) {
      function d(xt, Gt) {
        if (u) {
          var yt = xt.deletions;
          yt === null ? (xt.deletions = [Gt], xt.flags |= zn) : yt.push(Gt);
        }
      }
      function T(xt, Gt) {
        if (!u)
          return null;
        for (var yt = Gt; yt !== null; )
          d(xt, yt), yt = yt.sibling;
        return null;
      }
      function C(xt, Gt) {
        for (var yt = /* @__PURE__ */ new Map(), sn = Gt; sn !== null; )
          sn.key !== null ? yt.set(sn.key, sn) : yt.set(sn.index, sn), sn = sn.sibling;
        return yt;
      }
      function P(xt, Gt) {
        var yt = _i(xt, Gt);
        return yt.index = 0, yt.sibling = null, yt;
      }
      function V(xt, Gt, yt) {
        if (xt.index = yt, !u)
          return xt.flags |= ye, Gt;
        var sn = xt.alternate;
        if (sn !== null) {
          var jn = sn.index;
          return jn < Gt ? (xt.flags |= Be, Gt) : jn;
        } else
          return xt.flags |= Be, Gt;
      }
      function Q(xt) {
        return u && xt.alternate === null && (xt.flags |= Be), xt;
      }
      function se(xt, Gt, yt, sn) {
        if (Gt === null || Gt.tag !== fe) {
          var jn = np(yt, xt.mode, sn);
          return jn.return = xt, jn;
        } else {
          var pn = P(Gt, yt);
          return pn.return = xt, pn;
        }
      }
      function me(xt, Gt, yt, sn) {
        var jn = yt.type;
        if (jn === Ye)
          return ze(xt, Gt, yt.props.children, sn, yt.key);
        if (Gt !== null && (Gt.elementType === jn || // Keep this check inline so it only runs on the false path:
        yg(Gt, yt) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof jn == "object" && jn !== null && jn.$$typeof === ie && eh(jn) === Gt.type)) {
          var pn = P(Gt, yt.props);
          return pn.ref = Tl(xt, Gt, yt), pn.return = xt, pn._debugSource = yt._source, pn._debugOwner = yt._owner, pn;
        }
        var Ar = xg(yt, xt.mode, sn);
        return Ar.ref = Tl(xt, Gt, yt), Ar.return = xt, Ar;
      }
      function Ce(xt, Gt, yt, sn) {
        if (Gt === null || Gt.tag !== le || Gt.stateNode.containerInfo !== yt.containerInfo || Gt.stateNode.implementation !== yt.implementation) {
          var jn = fn(yt, xt.mode, sn);
          return jn.return = xt, jn;
        } else {
          var pn = P(Gt, yt.children || []);
          return pn.return = xt, pn;
        }
      }
      function ze(xt, Gt, yt, sn, jn) {
        if (Gt === null || Gt.tag !== de) {
          var pn = md(yt, xt.mode, sn, jn);
          return pn.return = xt, pn;
        } else {
          var Ar = P(Gt, yt);
          return Ar.return = xt, Ar;
        }
      }
      function ft(xt, Gt, yt) {
        if (typeof Gt == "string" && Gt !== "" || typeof Gt == "number") {
          var sn = np("" + Gt, xt.mode, yt);
          return sn.return = xt, sn;
        }
        if (typeof Gt == "object" && Gt !== null) {
          switch (Gt.$$typeof) {
            case ae: {
              var jn = xg(Gt, xt.mode, yt);
              return jn.ref = Tl(xt, null, Gt), jn.return = xt, jn;
            }
            case et: {
              var pn = fn(Gt, xt.mode, yt);
              return pn.return = xt, pn;
            }
            case ie: {
              var Ar = Gt._payload, Pi = Gt._init;
              return ft(xt, Pi(Ar), yt);
            }
          }
          if (Xr(Gt) || He(Gt)) {
            var la = md(Gt, xt.mode, yt, null);
            return la.return = xt, la;
          }
          Gv(xt, Gt);
        }
        return typeof Gt == "function" && Jd(xt), null;
      }
      function Lt(xt, Gt, yt, sn) {
        var jn = Gt !== null ? Gt.key : null;
        if (typeof yt == "string" && yt !== "" || typeof yt == "number")
          return jn !== null ? null : se(xt, Gt, "" + yt, sn);
        if (typeof yt == "object" && yt !== null) {
          switch (yt.$$typeof) {
            case ae:
              return yt.key === jn ? me(xt, Gt, yt, sn) : null;
            case et:
              return yt.key === jn ? Ce(xt, Gt, yt, sn) : null;
            case ie: {
              var pn = yt._payload, Ar = yt._init;
              return Lt(xt, Gt, Ar(pn), sn);
            }
          }
          if (Xr(yt) || He(yt))
            return jn !== null ? null : ze(xt, Gt, yt, sn, null);
          Gv(xt, yt);
        }
        return typeof yt == "function" && Jd(xt), null;
      }
      function zt(xt, Gt, yt, sn, jn) {
        if (typeof sn == "string" && sn !== "" || typeof sn == "number") {
          var pn = xt.get(yt) || null;
          return se(Gt, pn, "" + sn, jn);
        }
        if (typeof sn == "object" && sn !== null) {
          switch (sn.$$typeof) {
            case ae: {
              var Ar = xt.get(sn.key === null ? yt : sn.key) || null;
              return me(Gt, Ar, sn, jn);
            }
            case et: {
              var Pi = xt.get(sn.key === null ? yt : sn.key) || null;
              return Ce(Gt, Pi, sn, jn);
            }
            case ie: {
              var la = sn._payload, vn = sn._init;
              return zt(xt, Gt, yt, vn(la), jn);
            }
          }
          if (Xr(sn) || He(sn)) {
            var ia = xt.get(yt) || null;
            return ze(Gt, ia, sn, jn, null);
          }
          Gv(Gt, sn);
        }
        return typeof sn == "function" && Jd(Gt), null;
      }
      function Qt(xt, Gt, yt) {
        {
          if (typeof xt != "object" || xt === null)
            return Gt;
          switch (xt.$$typeof) {
            case ae:
            case et:
              uy(xt, yt);
              var sn = xt.key;
              if (typeof sn != "string")
                break;
              if (Gt === null) {
                Gt = /* @__PURE__ */ new Set(), Gt.add(sn);
                break;
              }
              if (!Gt.has(sn)) {
                Gt.add(sn);
                break;
              }
              p("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", sn);
              break;
            case ie: {
              var jn = xt._payload, pn = xt._init;
              Qt(pn(jn), Gt, yt);
              break;
            }
          }
        }
        return Gt;
      }
      function rn(xt, Gt, yt, sn) {
        for (var jn = null, pn = 0; pn < yt.length; pn++) {
          var Ar = yt[pn];
          jn = Qt(Ar, jn, xt);
        }
        for (var Pi = null, la = null, vn = Gt, ia = 0, Ui = 0, Yr = null; vn !== null && Ui < yt.length; Ui++) {
          vn.index > Ui ? (Yr = vn, vn = null) : Yr = vn.sibling;
          var no = Lt(xt, vn, yt[Ui], sn);
          if (no === null) {
            vn === null && (vn = Yr);
            break;
          }
          u && vn && no.alternate === null && d(xt, vn), ia = V(no, ia, Ui), la === null ? Pi = no : la.sibling = no, la = no, vn = Yr;
        }
        if (Ui === yt.length) {
          if (T(xt, vn), Ii()) {
            var ja = Ui;
            El(xt, ja);
          }
          return Pi;
        }
        if (vn === null) {
          for (; Ui < yt.length; Ui++) {
            var Dc = ft(xt, yt[Ui], sn);
            Dc !== null && (ia = V(Dc, ia, Ui), la === null ? Pi = Dc : la.sibling = Dc, la = Dc);
          }
          if (Ii()) {
            var As = Ui;
            El(xt, As);
          }
          return Pi;
        }
        for (var Lc = C(xt, vn); Ui < yt.length; Ui++) {
          var wf = zt(Lc, xt, Ui, yt[Ui], sn);
          wf !== null && (u && wf.alternate !== null && Lc.delete(wf.key === null ? Ui : wf.key), ia = V(wf, ia, Ui), la === null ? Pi = wf : la.sibling = wf, la = wf);
        }
        if (u && Lc.forEach(function(e0) {
          return d(xt, e0);
        }), Ii()) {
          var ip = Ui;
          El(xt, ip);
        }
        return Pi;
      }
      function sr(xt, Gt, yt, sn) {
        var jn = He(yt);
        if (typeof jn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          yt[Symbol.toStringTag] === "Generator" && (Ms || p("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ms = !0), yt.entries === jn && (ws || p("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ws = !0);
          var pn = jn.call(yt);
          if (pn)
            for (var Ar = null, Pi = pn.next(); !Pi.done; Pi = pn.next()) {
              var la = Pi.value;
              Ar = Qt(la, Ar, xt);
            }
        }
        var vn = jn.call(yt);
        if (vn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var ia = null, Ui = null, Yr = Gt, no = 0, ja = 0, Dc = null, As = vn.next(); Yr !== null && !As.done; ja++, As = vn.next()) {
          Yr.index > ja ? (Dc = Yr, Yr = null) : Dc = Yr.sibling;
          var Lc = Lt(xt, Yr, As.value, sn);
          if (Lc === null) {
            Yr === null && (Yr = Dc);
            break;
          }
          u && Yr && Lc.alternate === null && d(xt, Yr), no = V(Lc, no, ja), Ui === null ? ia = Lc : Ui.sibling = Lc, Ui = Lc, Yr = Dc;
        }
        if (As.done) {
          if (T(xt, Yr), Ii()) {
            var wf = ja;
            El(xt, wf);
          }
          return ia;
        }
        if (Yr === null) {
          for (; !As.done; ja++, As = vn.next()) {
            var ip = ft(xt, As.value, sn);
            ip !== null && (no = V(ip, no, ja), Ui === null ? ia = ip : Ui.sibling = ip, Ui = ip);
          }
          if (Ii()) {
            var e0 = ja;
            El(xt, e0);
          }
          return ia;
        }
        for (var Eg = C(xt, Yr); !As.done; ja++, As = vn.next()) {
          var Oc = zt(Eg, xt, ja, As.value, sn);
          Oc !== null && (u && Oc.alternate !== null && Eg.delete(Oc.key === null ? ja : Oc.key), no = V(Oc, no, ja), Ui === null ? ia = Oc : Ui.sibling = Oc, Ui = Oc);
        }
        if (u && Eg.forEach(function(K_) {
          return d(xt, K_);
        }), Ii()) {
          var em = ja;
          El(xt, em);
        }
        return ia;
      }
      function zr(xt, Gt, yt, sn) {
        if (Gt !== null && Gt.tag === fe) {
          T(xt, Gt.sibling);
          var jn = P(Gt, yt);
          return jn.return = xt, jn;
        }
        T(xt, Gt);
        var pn = np(yt, xt.mode, sn);
        return pn.return = xt, pn;
      }
      function pr(xt, Gt, yt, sn) {
        for (var jn = yt.key, pn = Gt; pn !== null; ) {
          if (pn.key === jn) {
            var Ar = yt.type;
            if (Ar === Ye) {
              if (pn.tag === de) {
                T(xt, pn.sibling);
                var Pi = P(pn, yt.props.children);
                return Pi.return = xt, Pi._debugSource = yt._source, Pi._debugOwner = yt._owner, Pi;
              }
            } else if (pn.elementType === Ar || // Keep this check inline so it only runs on the false path:
            yg(pn, yt) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Ar == "object" && Ar !== null && Ar.$$typeof === ie && eh(Ar) === pn.type) {
              T(xt, pn.sibling);
              var la = P(pn, yt.props);
              return la.ref = Tl(xt, pn, yt), la.return = xt, la._debugSource = yt._source, la._debugOwner = yt._owner, la;
            }
            T(xt, pn);
            break;
          } else
            d(xt, pn);
          pn = pn.sibling;
        }
        if (yt.type === Ye) {
          var vn = md(yt.props.children, xt.mode, sn, yt.key);
          return vn.return = xt, vn;
        } else {
          var ia = xg(yt, xt.mode, sn);
          return ia.ref = Tl(xt, Gt, yt), ia.return = xt, ia;
        }
      }
      function Ga(xt, Gt, yt, sn) {
        for (var jn = yt.key, pn = Gt; pn !== null; ) {
          if (pn.key === jn)
            if (pn.tag === le && pn.stateNode.containerInfo === yt.containerInfo && pn.stateNode.implementation === yt.implementation) {
              T(xt, pn.sibling);
              var Ar = P(pn, yt.children || []);
              return Ar.return = xt, Ar;
            } else {
              T(xt, pn);
              break;
            }
          else
            d(xt, pn);
          pn = pn.sibling;
        }
        var Pi = fn(yt, xt.mode, sn);
        return Pi.return = xt, Pi;
      }
      function Wa(xt, Gt, yt, sn) {
        var jn = typeof yt == "object" && yt !== null && yt.type === Ye && yt.key === null;
        if (jn && (yt = yt.props.children), typeof yt == "object" && yt !== null) {
          switch (yt.$$typeof) {
            case ae:
              return Q(pr(xt, Gt, yt, sn));
            case et:
              return Q(Ga(xt, Gt, yt, sn));
            case ie: {
              var pn = yt._payload, Ar = yt._init;
              return Wa(xt, Gt, Ar(pn), sn);
            }
          }
          if (Xr(yt))
            return rn(xt, Gt, yt, sn);
          if (He(yt))
            return sr(xt, Gt, yt, sn);
          Gv(xt, yt);
        }
        return typeof yt == "string" && yt !== "" || typeof yt == "number" ? Q(zr(xt, Gt, "" + yt, sn)) : (typeof yt == "function" && Jd(xt), T(xt, Gt));
      }
      return Wa;
    }
    var Ec = cy(!0), z0 = cy(!1);
    function fy(u, d) {
      if (u !== null && d.child !== u.child)
        throw new Error("Resuming work not yet implemented.");
      if (d.child !== null) {
        var T = d.child, C = _i(T, T.pendingProps);
        for (d.child = C, C.return = d; T.sibling !== null; )
          T = T.sibling, C = C.sibling = _i(T, T.pendingProps), C.return = d;
        C.sibling = null;
      }
    }
    function I0(u, d) {
      for (var T = u.child; T !== null; )
        nl(T, d), T = T.sibling;
    }
    var Vh = {}, Gh = dl(Vh), Wv = dl(Vh), jv = dl(Vh);
    function jm(u) {
      if (u === Vh)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return u;
    }
    function th() {
      var u = jm(jv.current);
      return u;
    }
    function B0(u, d) {
      ki(jv, d, u), ki(Wv, u, u), ki(Gh, Vh, u);
      var T = bi(d);
      so(Gh, u), ki(Gh, T, u);
    }
    function _f(u) {
      so(Gh, u), so(Wv, u), so(jv, u);
    }
    function $m() {
      var u = jm(Gh.current);
      return u;
    }
    function Ja(u) {
      var d = jm(jv.current), T = jm(Gh.current), C = Ti(T, u.type, d);
      T !== C && (ki(Wv, u, u), ki(Gh, C, u));
    }
    function H0(u) {
      Wv.current === u && (so(Gh, u), so(Wv, u));
    }
    var dy = 0, Ox = 1, Px = 1, Ym = 2, $u = dl(dy);
    function V0(u, d) {
      return (u & d) !== 0;
    }
    function Js(u) {
      return u & Ox;
    }
    function $v(u, d) {
      return u & Ox | d;
    }
    function hE(u, d) {
      return u | d;
    }
    function Bl(u, d) {
      ki($u, d, u);
    }
    function nh(u) {
      so($u, u);
    }
    function Ip(u, d) {
      var T = u.memoizedState;
      return T !== null ? T.dehydrated !== null : (u.memoizedProps, !0);
    }
    function Wh(u) {
      for (var d = u; d !== null; ) {
        if (d.tag === re) {
          var T = d.memoizedState;
          if (T !== null) {
            var C = T.dehydrated;
            if (C === null || ms(C) || cl(C))
              return d;
          }
        } else if (d.tag === Ue && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        d.memoizedProps.revealOrder !== void 0) {
          var P = (d.flags & mn) !== pe;
          if (P)
            return d;
        } else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === u)
          return null;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === u)
            return null;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return null;
    }
    var _u = (
      /*   */
      0
    ), Qi = (
      /* */
      1
    ), jh = (
      /*  */
      2
    ), Ia = (
      /*    */
      4
    ), Cs = (
      /*   */
      8
    ), Yv = [];
    function hy() {
      for (var u = 0; u < Yv.length; u++) {
        var d = Yv[u];
        ll ? d._workInProgressVersionPrimary = null : d._workInProgressVersionSecondary = null;
      }
      Yv.length = 0;
    }
    function Xv(u, d) {
      var T = d._getVersion, C = T(d._source);
      u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [d, C] : u.mutableSourceEagerHydrationData.push(d, C);
    }
    var gn = o.ReactCurrentDispatcher, Hl = o.ReactCurrentBatchConfig, qv, Bp;
    qv = /* @__PURE__ */ new Set();
    var $h = Yt, Bi = null, Ba = null, Ro = null, Hp = !1, Xm = !1, Kv = 0, py = 0, pE = 25, kt = null, bc = null, Ef = -1, f = !1;
    function m() {
      {
        var u = kt;
        bc === null ? bc = [u] : bc.push(u);
      }
    }
    function E() {
      {
        var u = kt;
        bc !== null && (Ef++, bc[Ef] !== u && I(u));
      }
    }
    function O(u) {
      u != null && !Xr(u) && p("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", kt, typeof u);
    }
    function I(u) {
      {
        var d = ct(Bi);
        if (!qv.has(d) && (qv.add(d), bc !== null)) {
          for (var T = "", C = 30, P = 0; P <= Ef; P++) {
            for (var V = bc[P], Q = P === Ef ? u : V, se = P + 1 + ". " + V; se.length < C; )
              se += " ";
            se += Q + `
`, T += se;
          }
          p(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, d, T);
        }
      }
    }
    function j() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function ue(u, d) {
      if (f)
        return !1;
      if (d === null)
        return p("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", kt), !1;
      u.length !== d.length && p(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, kt, "[" + d.join(", ") + "]", "[" + u.join(", ") + "]");
      for (var T = 0; T < d.length && T < u.length; T++)
        if (!To(u[T], d[T]))
          return !1;
      return !0;
    }
    function Re(u, d, T, C, P, V) {
      $h = V, Bi = d, bc = u !== null ? u._debugHookTypes : null, Ef = -1, f = u !== null && u.type !== d.type, d.memoizedState = null, d.updateQueue = null, d.lanes = Yt, u !== null && u.memoizedState !== null ? gn.current = Ha : bc !== null ? gn.current = Rw : gn.current = EE;
      var Q = T(C, P);
      if (Xm) {
        var se = 0;
        do {
          if (Xm = !1, Kv = 0, se >= pE)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          se += 1, f = !1, Ba = null, Ro = null, d.updateQueue = null, Ef = -1, gn.current = $x, Q = T(C, P);
        } while (Xm);
      }
      gn.current = jx, d._debugHookTypes = bc;
      var me = Ba !== null && Ba.next !== null;
      if ($h = Yt, Bi = null, Ba = null, Ro = null, kt = null, bc = null, Ef = -1, u !== null && (u.flags & bt) !== (d.flags & bt) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (u.mode & Li) !== mr && p("Internal React error: Expected static flag was missing. Please notify the React team."), Hp = !1, me)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Q;
    }
    function Ie() {
      var u = Kv !== 0;
      return Kv = 0, u;
    }
    function Tt(u, d, T) {
      d.updateQueue = u.updateQueue, (d.mode & Uo) !== mr ? d.flags &= ~(en | pt | Ei | ut) : d.flags &= ~(Ei | ut), u.lanes = uo(u.lanes, T);
    }
    function Kt() {
      if (gn.current = jx, Hp) {
        for (var u = Bi.memoizedState; u !== null; ) {
          var d = u.queue;
          d !== null && (d.pending = null), u = u.next;
        }
        Hp = !1;
      }
      $h = Yt, Bi = null, Ba = null, Ro = null, bc = null, Ef = -1, kt = null, xE = !1, Xm = !1, Kv = 0;
    }
    function Xt() {
      var u = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ro === null ? Bi.memoizedState = Ro = u : Ro = Ro.next = u, Ro;
    }
    function $t() {
      var u;
      if (Ba === null) {
        var d = Bi.alternate;
        d !== null ? u = d.memoizedState : u = null;
      } else
        u = Ba.next;
      var T;
      if (Ro === null ? T = Bi.memoizedState : T = Ro.next, T !== null)
        Ro = T, T = Ro.next, Ba = u;
      else {
        if (u === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ba = u;
        var C = {
          memoizedState: Ba.memoizedState,
          baseState: Ba.baseState,
          baseQueue: Ba.baseQueue,
          queue: Ba.queue,
          next: null
        };
        Ro === null ? Bi.memoizedState = Ro = C : Ro = Ro.next = C;
      }
      return Ro;
    }
    function bn() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Pn(u, d) {
      return typeof d == "function" ? d(u) : d;
    }
    function Fn(u, d, T) {
      var C = Xt(), P;
      T !== void 0 ? P = T(d) : P = d, C.memoizedState = C.baseState = P;
      var V = {
        pending: null,
        interleaved: null,
        lanes: Yt,
        dispatch: null,
        lastRenderedReducer: u,
        lastRenderedState: P
      };
      C.queue = V;
      var Q = V.dispatch = Km.bind(null, Bi, V);
      return [C.memoizedState, Q];
    }
    function eo(u, d, T) {
      var C = $t(), P = C.queue;
      if (P === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      P.lastRenderedReducer = u;
      var V = Ba, Q = V.baseQueue, se = P.pending;
      if (se !== null) {
        if (Q !== null) {
          var me = Q.next, Ce = se.next;
          Q.next = Ce, se.next = me;
        }
        V.baseQueue !== Q && p("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), V.baseQueue = Q = se, P.pending = null;
      }
      if (Q !== null) {
        var ze = Q.next, ft = V.baseState, Lt = null, zt = null, Qt = null, rn = ze;
        do {
          var sr = rn.lane;
          if (hu($h, sr)) {
            if (Qt !== null) {
              var pr = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Er,
                action: rn.action,
                hasEagerState: rn.hasEagerState,
                eagerState: rn.eagerState,
                next: null
              };
              Qt = Qt.next = pr;
            }
            if (rn.hasEagerState)
              ft = rn.eagerState;
            else {
              var Ga = rn.action;
              ft = u(ft, Ga);
            }
          } else {
            var zr = {
              lane: sr,
              action: rn.action,
              hasEagerState: rn.hasEagerState,
              eagerState: rn.eagerState,
              next: null
            };
            Qt === null ? (zt = Qt = zr, Lt = ft) : Qt = Qt.next = zr, Bi.lanes = gr(Bi.lanes, sr), By(sr);
          }
          rn = rn.next;
        } while (rn !== null && rn !== ze);
        Qt === null ? Lt = ft : Qt.next = zt, To(ft, C.memoizedState) || o_(), C.memoizedState = ft, C.baseState = Lt, C.baseQueue = Qt, P.lastRenderedState = ft;
      }
      var Wa = P.interleaved;
      if (Wa !== null) {
        var xt = Wa;
        do {
          var Gt = xt.lane;
          Bi.lanes = gr(Bi.lanes, Gt), By(Gt), xt = xt.next;
        } while (xt !== Wa);
      } else
        Q === null && (P.lanes = Yt);
      var yt = P.dispatch;
      return [C.memoizedState, yt];
    }
    function st(u, d, T) {
      var C = $t(), P = C.queue;
      if (P === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      P.lastRenderedReducer = u;
      var V = P.dispatch, Q = P.pending, se = C.memoizedState;
      if (Q !== null) {
        P.pending = null;
        var me = Q.next, Ce = me;
        do {
          var ze = Ce.action;
          se = u(se, ze), Ce = Ce.next;
        } while (Ce !== me);
        To(se, C.memoizedState) || o_(), C.memoizedState = se, C.baseQueue === null && (C.baseState = se), P.lastRenderedState = se;
      }
      return [se, V];
    }
    function Xe(u, d, T) {
    }
    function gt(u, d, T) {
    }
    function an(u, d, T) {
      var C = Bi, P = Xt(), V, Q = Ii();
      if (Q) {
        if (T === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        V = T(), Bp || V !== T() && (p("The result of getServerSnapshot should be cached to avoid an infinite loop"), Bp = !0);
      } else {
        if (V = d(), !Bp) {
          var se = d();
          To(V, se) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), Bp = !0);
        }
        var me = w_();
        if (me === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        vc(me, $h) || Un(C, d, V);
      }
      P.memoizedState = V;
      var Ce = {
        value: V,
        getSnapshot: d
      };
      return P.queue = Ce, Qv(vr.bind(null, C, Ce, u), [u]), C.flags |= Ei, vy(Qi | Cs, Zn.bind(null, C, Ce, V, d), void 0, null), V;
    }
    function kn(u, d, T) {
      var C = Bi, P = $t(), V = d();
      if (!Bp) {
        var Q = d();
        To(V, Q) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), Bp = !0);
      }
      var se = P.memoizedState, me = !To(se, V);
      me && (P.memoizedState = V, o_());
      var Ce = P.queue;
      if (Zv(vr.bind(null, C, Ce, u), [u]), Ce.getSnapshot !== d || me || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ro !== null && Ro.memoizedState.tag & Qi) {
        C.flags |= Ei, vy(Qi | Cs, Zn.bind(null, C, Ce, V, d), void 0, null);
        var ze = w_();
        if (ze === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        vc(ze, $h) || Un(C, d, V);
      }
      return V;
    }
    function Un(u, d, T) {
      u.flags |= Ri;
      var C = {
        getSnapshot: d,
        value: T
      }, P = Bi.updateQueue;
      if (P === null)
        P = bn(), Bi.updateQueue = P, P.stores = [C];
      else {
        var V = P.stores;
        V === null ? P.stores = [C] : V.push(C);
      }
    }
    function Zn(u, d, T, C) {
      d.value = T, d.getSnapshot = C, Jo(d) && xi(u);
    }
    function vr(u, d, T) {
      var C = function() {
        Jo(d) && xi(u);
      };
      return T(C);
    }
    function Jo(u) {
      var d = u.getSnapshot, T = u.value;
      try {
        var C = d();
        return !To(T, C);
      } catch {
        return !0;
      }
    }
    function xi(u) {
      Bo(u, wr, pi);
    }
    function Tc(u) {
      var d = Xt();
      typeof u == "function" && (u = u()), d.memoizedState = d.baseState = u;
      var T = {
        pending: null,
        interleaved: null,
        lanes: Yt,
        dispatch: null,
        lastRenderedReducer: Pn,
        lastRenderedState: u
      };
      d.queue = T;
      var C = T.dispatch = O2.bind(null, Bi, T);
      return [d.memoizedState, C];
    }
    function my(u) {
      return eo(Pn);
    }
    function Ux(u) {
      return st(Pn);
    }
    function vy(u, d, T, C) {
      var P = {
        tag: u,
        create: d,
        destroy: T,
        deps: C,
        // Circular
        next: null
      }, V = Bi.updateQueue;
      if (V === null)
        V = bn(), Bi.updateQueue = V, V.lastEffect = P.next = P;
      else {
        var Q = V.lastEffect;
        if (Q === null)
          V.lastEffect = P.next = P;
        else {
          var se = Q.next;
          Q.next = P, P.next = se, V.lastEffect = P;
        }
      }
      return P;
    }
    function Nx(u) {
      var d = Xt();
      {
        var T = {
          current: u
        };
        return d.memoizedState = T, T;
      }
    }
    function Fx(u) {
      var d = $t();
      return d.memoizedState;
    }
    function G0(u, d, T, C) {
      var P = Xt(), V = C === void 0 ? null : C;
      Bi.flags |= u, P.memoizedState = vy(Qi | d, T, void 0, V);
    }
    function W0(u, d, T, C) {
      var P = $t(), V = C === void 0 ? null : C, Q = void 0;
      if (Ba !== null) {
        var se = Ba.memoizedState;
        if (Q = se.destroy, V !== null) {
          var me = se.deps;
          if (ue(V, me)) {
            P.memoizedState = vy(d, T, Q, V);
            return;
          }
        }
      }
      Bi.flags |= u, P.memoizedState = vy(Qi | d, T, Q, V);
    }
    function Qv(u, d) {
      return (Bi.mode & Uo) !== mr ? G0(en | Ei | Ve, Cs, u, d) : G0(Ei | Ve, Cs, u, d);
    }
    function Zv(u, d) {
      return W0(Ei, Cs, u, d);
    }
    function mE(u, d) {
      return G0(ut, jh, u, d);
    }
    function kx(u, d) {
      return W0(ut, jh, u, d);
    }
    function vE(u, d) {
      var T = ut;
      return T |= tt, (Bi.mode & Uo) !== mr && (T |= pt), G0(T, Ia, u, d);
    }
    function zx(u, d) {
      return W0(ut, Ia, u, d);
    }
    function bw(u, d) {
      if (typeof d == "function") {
        var T = d, C = u();
        return T(C), function() {
          T(null);
        };
      } else if (d != null) {
        var P = d;
        P.hasOwnProperty("current") || p("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(P).join(", ") + "}");
        var V = u();
        return P.current = V, function() {
          P.current = null;
        };
      }
    }
    function qm(u, d, T) {
      typeof d != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var C = T != null ? T.concat([u]) : null, P = ut;
      return P |= tt, (Bi.mode & Uo) !== mr && (P |= pt), G0(P, Ia, bw.bind(null, d, u), C);
    }
    function gy(u, d, T) {
      typeof d != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", d !== null ? typeof d : "null");
      var C = T != null ? T.concat([u]) : null;
      return W0(ut, Ia, bw.bind(null, d, u), C);
    }
    function j0(u, d) {
    }
    var yy = j0;
    function gE(u, d) {
      var T = Xt(), C = d === void 0 ? null : d;
      return T.memoizedState = [u, C], u;
    }
    function Ix(u, d) {
      var T = $t(), C = d === void 0 ? null : d, P = T.memoizedState;
      if (P !== null && C !== null) {
        var V = P[1];
        if (ue(C, V))
          return P[0];
      }
      return T.memoizedState = [u, C], u;
    }
    function Bx(u, d) {
      var T = Xt(), C = d === void 0 ? null : d, P = u();
      return T.memoizedState = [P, C], P;
    }
    function Hx(u, d) {
      var T = $t(), C = d === void 0 ? null : d, P = T.memoizedState;
      if (P !== null && C !== null) {
        var V = P[1];
        if (ue(C, V))
          return P[0];
      }
      var Q = u();
      return T.memoizedState = [Q, C], Q;
    }
    function Sy(u) {
      var d = Tc(u), T = d[0], C = d[1];
      return Qv(function() {
        var P = Hl.transition;
        Hl.transition = {};
        try {
          C(u);
        } finally {
          Hl.transition = P;
        }
      }, [u]), T;
    }
    function Jv(u) {
      var d = my(), T = d[0], C = d[1];
      return Zv(function() {
        var P = Hl.transition;
        Hl.transition = {};
        try {
          C(u);
        } finally {
          Hl.transition = P;
        }
      }, [u]), T;
    }
    function Vx(u) {
      var d = Ux(), T = d[0], C = d[1];
      return Zv(function() {
        var P = Hl.transition;
        Hl.transition = {};
        try {
          C(u);
        } finally {
          Hl.transition = P;
        }
      }, [u]), T;
    }
    function Tw(u, d, T) {
      var C = xs();
      co(Rh(C, Gd)), u(!0);
      var P = Hl.transition;
      Hl.transition = {};
      var V = Hl.transition;
      Hl.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        u(!1), d();
      } finally {
        if (co(C), Hl.transition = P, P === null && V._updatedFibers) {
          var Q = V._updatedFibers.size;
          Q > 10 && h("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), V._updatedFibers.clear();
        }
      }
    }
    function xy() {
      var u = Tc(!1), d = u[0], T = u[1], C = Tw.bind(null, T), P = Xt();
      return P.memoizedState = C, [d, C];
    }
    function yE() {
      var u = my(), d = u[0], T = $t(), C = T.memoizedState;
      return [d, C];
    }
    function SE() {
      var u = Ux(), d = u[0], T = $t(), C = T.memoizedState;
      return [d, C];
    }
    var xE = !1;
    function ww() {
      return xE;
    }
    function Gx() {
      var u = Xt(), d = w_(), T = d.identifierPrefix, C;
      if (Ii()) {
        var P = Lx();
        C = ":" + T + "R" + P;
        var V = Kv++;
        V > 0 && (C += "H" + V.toString(32)), C += ":";
      } else {
        var Q = py++;
        C = ":" + T + "r" + Q.toString(32) + ":";
      }
      return u.memoizedState = C, C;
    }
    function $0() {
      var u = $t(), d = u.memoizedState;
      return d;
    }
    function Km(u, d, T) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var C = Zp(u), P = {
        lane: C,
        action: T,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Mw(u))
        Cw(d, P);
      else {
        _y(u, d, P);
        var V = Ml(), Q = Bo(u, C, V);
        Q !== null && Wx(Q, d, C);
      }
      _E(u, C);
    }
    function O2(u, d, T) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var C = Zp(u), P = {
        lane: C,
        action: T,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Mw(u))
        Cw(d, P);
      else {
        _y(u, d, P);
        var V = u.alternate;
        if (u.lanes === Yt && (V === null || V.lanes === Yt)) {
          var Q = d.lastRenderedReducer;
          if (Q !== null) {
            var se;
            se = gn.current, gn.current = Yu;
            try {
              var me = d.lastRenderedState, Ce = Q(me, T);
              if (P.hasEagerState = !0, P.eagerState = Ce, To(Ce, me))
                return;
            } catch {
            } finally {
              gn.current = se;
            }
          }
        }
        var ze = Ml(), ft = Bo(u, C, ze);
        ft !== null && Wx(ft, d, C);
      }
      _E(u, C);
    }
    function Mw(u) {
      var d = u.alternate;
      return u === Bi || d !== null && d === Bi;
    }
    function Cw(u, d) {
      Xm = Hp = !0;
      var T = u.pending;
      T === null ? d.next = d : (d.next = T.next, T.next = d), u.pending = d;
    }
    function _y(u, d, T, C) {
      if (M_(u)) {
        var P = d.interleaved;
        P === null ? (T.next = T, Qn(d)) : (T.next = P.next, P.next = T), d.interleaved = T;
      } else {
        var V = d.pending;
        V === null ? T.next = T : (T.next = V.next, V.next = T), d.pending = T;
      }
    }
    function Wx(u, d, T) {
      if (ys(T)) {
        var C = d.lanes;
        C = Ta(C, u.pendingLanes);
        var P = gr(C, T);
        d.lanes = P, Eo(u, P);
      }
    }
    function _E(u, d, T) {
      ff(u, d);
    }
    var jx = {
      readContext: ln,
      useCallback: j,
      useContext: j,
      useEffect: j,
      useImperativeHandle: j,
      useInsertionEffect: j,
      useLayoutEffect: j,
      useMemo: j,
      useReducer: j,
      useRef: j,
      useState: j,
      useDebugValue: j,
      useDeferredValue: j,
      useTransition: j,
      useMutableSource: j,
      useSyncExternalStore: j,
      useId: j,
      unstable_isNewReconciler: U
    }, EE = null, Rw = null, Ha = null, $x = null, bf = null, Yu = null, Y0 = null;
    {
      var Yx = function() {
        p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Sr = function() {
        p("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      EE = {
        readContext: function(u) {
          return ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", m(), O(d), gE(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", m(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", m(), O(d), Qv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", m(), O(T), qm(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", m(), O(d), mE(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", m(), O(d), vE(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", m(), O(d);
          var T = gn.current;
          gn.current = bf;
          try {
            return Bx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", m();
          var C = gn.current;
          gn.current = bf;
          try {
            return Fn(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", m(), Nx(u);
        },
        useState: function(u) {
          kt = "useState", m();
          var d = gn.current;
          gn.current = bf;
          try {
            return Tc(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", m(), void 0;
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", m(), Sy(u);
        },
        useTransition: function() {
          return kt = "useTransition", m(), xy();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", m(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", m(), an(u, d, T);
        },
        useId: function() {
          return kt = "useId", m(), Gx();
        },
        unstable_isNewReconciler: U
      }, Rw = {
        readContext: function(u) {
          return ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", E(), gE(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", E(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", E(), Qv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", E(), qm(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", E(), mE(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", E(), vE(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", E();
          var T = gn.current;
          gn.current = bf;
          try {
            return Bx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", E();
          var C = gn.current;
          gn.current = bf;
          try {
            return Fn(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", E(), Nx(u);
        },
        useState: function(u) {
          kt = "useState", E();
          var d = gn.current;
          gn.current = bf;
          try {
            return Tc(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", E(), void 0;
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", E(), Sy(u);
        },
        useTransition: function() {
          return kt = "useTransition", E(), xy();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", E(), an(u, d, T);
        },
        useId: function() {
          return kt = "useId", E(), Gx();
        },
        unstable_isNewReconciler: U
      }, Ha = {
        readContext: function(u) {
          return ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", E(), Ix(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", E(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", E(), Zv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", E(), gy(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", E(), kx(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", E(), zx(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", E();
          var T = gn.current;
          gn.current = Yu;
          try {
            return Hx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", E();
          var C = gn.current;
          gn.current = Yu;
          try {
            return eo(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", E(), Fx();
        },
        useState: function(u) {
          kt = "useState", E();
          var d = gn.current;
          gn.current = Yu;
          try {
            return my(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", E(), yy();
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", E(), Jv(u);
        },
        useTransition: function() {
          return kt = "useTransition", E(), yE();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", E(), kn(u, d);
        },
        useId: function() {
          return kt = "useId", E(), $0();
        },
        unstable_isNewReconciler: U
      }, $x = {
        readContext: function(u) {
          return ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", E(), Ix(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", E(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", E(), Zv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", E(), gy(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", E(), kx(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", E(), zx(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", E();
          var T = gn.current;
          gn.current = Y0;
          try {
            return Hx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", E();
          var C = gn.current;
          gn.current = Y0;
          try {
            return st(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", E(), Fx();
        },
        useState: function(u) {
          kt = "useState", E();
          var d = gn.current;
          gn.current = Y0;
          try {
            return Ux(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", E(), yy();
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", E(), Vx(u);
        },
        useTransition: function() {
          return kt = "useTransition", E(), SE();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", E(), kn(u, d);
        },
        useId: function() {
          return kt = "useId", E(), $0();
        },
        unstable_isNewReconciler: U
      }, bf = {
        readContext: function(u) {
          return Yx(), ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", Sr(), m(), gE(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", Sr(), m(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", Sr(), m(), Qv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", Sr(), m(), qm(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", Sr(), m(), mE(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", Sr(), m(), vE(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", Sr(), m();
          var T = gn.current;
          gn.current = bf;
          try {
            return Bx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", Sr(), m();
          var C = gn.current;
          gn.current = bf;
          try {
            return Fn(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", Sr(), m(), Nx(u);
        },
        useState: function(u) {
          kt = "useState", Sr(), m();
          var d = gn.current;
          gn.current = bf;
          try {
            return Tc(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", Sr(), m(), void 0;
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", Sr(), m(), Sy(u);
        },
        useTransition: function() {
          return kt = "useTransition", Sr(), m(), xy();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", Sr(), m(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", Sr(), m(), an(u, d, T);
        },
        useId: function() {
          return kt = "useId", Sr(), m(), Gx();
        },
        unstable_isNewReconciler: U
      }, Yu = {
        readContext: function(u) {
          return Yx(), ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", Sr(), E(), Ix(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", Sr(), E(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", Sr(), E(), Zv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", Sr(), E(), gy(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", Sr(), E(), kx(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", Sr(), E(), zx(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", Sr(), E();
          var T = gn.current;
          gn.current = Yu;
          try {
            return Hx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", Sr(), E();
          var C = gn.current;
          gn.current = Yu;
          try {
            return eo(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", Sr(), E(), Fx();
        },
        useState: function(u) {
          kt = "useState", Sr(), E();
          var d = gn.current;
          gn.current = Yu;
          try {
            return my(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", Sr(), E(), yy();
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", Sr(), E(), Jv(u);
        },
        useTransition: function() {
          return kt = "useTransition", Sr(), E(), yE();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", Sr(), E(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", Sr(), E(), kn(u, d);
        },
        useId: function() {
          return kt = "useId", Sr(), E(), $0();
        },
        unstable_isNewReconciler: U
      }, Y0 = {
        readContext: function(u) {
          return Yx(), ln(u);
        },
        useCallback: function(u, d) {
          return kt = "useCallback", Sr(), E(), Ix(u, d);
        },
        useContext: function(u) {
          return kt = "useContext", Sr(), E(), ln(u);
        },
        useEffect: function(u, d) {
          return kt = "useEffect", Sr(), E(), Zv(u, d);
        },
        useImperativeHandle: function(u, d, T) {
          return kt = "useImperativeHandle", Sr(), E(), gy(u, d, T);
        },
        useInsertionEffect: function(u, d) {
          return kt = "useInsertionEffect", Sr(), E(), kx(u, d);
        },
        useLayoutEffect: function(u, d) {
          return kt = "useLayoutEffect", Sr(), E(), zx(u, d);
        },
        useMemo: function(u, d) {
          kt = "useMemo", Sr(), E();
          var T = gn.current;
          gn.current = Yu;
          try {
            return Hx(u, d);
          } finally {
            gn.current = T;
          }
        },
        useReducer: function(u, d, T) {
          kt = "useReducer", Sr(), E();
          var C = gn.current;
          gn.current = Yu;
          try {
            return st(u, d, T);
          } finally {
            gn.current = C;
          }
        },
        useRef: function(u) {
          return kt = "useRef", Sr(), E(), Fx();
        },
        useState: function(u) {
          kt = "useState", Sr(), E();
          var d = gn.current;
          gn.current = Yu;
          try {
            return Ux(u);
          } finally {
            gn.current = d;
          }
        },
        useDebugValue: function(u, d) {
          return kt = "useDebugValue", Sr(), E(), yy();
        },
        useDeferredValue: function(u) {
          return kt = "useDeferredValue", Sr(), E(), Vx(u);
        },
        useTransition: function() {
          return kt = "useTransition", Sr(), E(), SE();
        },
        useMutableSource: function(u, d, T) {
          return kt = "useMutableSource", Sr(), E(), void 0;
        },
        useSyncExternalStore: function(u, d, T) {
          return kt = "useSyncExternalStore", Sr(), E(), kn(u, d);
        },
        useId: function() {
          return kt = "useId", Sr(), E(), $0();
        },
        unstable_isNewReconciler: U
      };
    }
    var ud = i.unstable_now, Aw = 0, eg = -1, Yh = -1, Xx = -1, qx = !1, Kx = !1;
    function Dw() {
      return qx;
    }
    function wc() {
      Kx = !0;
    }
    function X0() {
      qx = !1, Kx = !1;
    }
    function Qx() {
      qx = Kx, Kx = !1;
    }
    function Vp() {
      return Aw;
    }
    function bE() {
      Aw = ud();
    }
    function Gp(u) {
      Yh = ud(), u.actualStartTime < 0 && (u.actualStartTime = ud());
    }
    function Qm(u) {
      Yh = -1;
    }
    function tg(u, d) {
      if (Yh >= 0) {
        var T = ud() - Yh;
        u.actualDuration += T, d && (u.selfBaseDuration = T), Yh = -1;
      }
    }
    function Mc(u) {
      if (eg >= 0) {
        var d = ud() - eg;
        eg = -1;
        for (var T = u.return; T !== null; ) {
          switch (T.tag) {
            case X:
              var C = T.stateNode;
              C.effectDuration += d;
              return;
            case ve:
              var P = T.stateNode;
              P.effectDuration += d;
              return;
          }
          T = T.return;
        }
      }
    }
    function Ey(u) {
      if (Xx >= 0) {
        var d = ud() - Xx;
        Xx = -1;
        for (var T = u.return; T !== null; ) {
          switch (T.tag) {
            case X:
              var C = T.stateNode;
              C !== null && (C.passiveEffectDuration += d);
              return;
            case ve:
              var P = T.stateNode;
              P !== null && (P.passiveEffectDuration += d);
              return;
          }
          T = T.return;
        }
      }
    }
    function Eu() {
      eg = ud();
    }
    function Zx() {
      Xx = ud();
    }
    function by(u) {
      for (var d = u.child; d; )
        u.actualDuration += d.actualDuration, d = d.sibling;
    }
    function q0(u, d) {
      return {
        value: u,
        source: d,
        stack: rd(d)
      };
    }
    function Lw(u, d) {
      return !0;
    }
    function TE(u, d) {
      try {
        var T = Lw(u, d);
        if (T === !1)
          return;
        var C = d.value, P = d.source, V = d.stack, Q = V !== null ? V : "";
        if (C != null && C._suppressLogging) {
          if (u.tag === J)
            return;
          console.error(C);
        }
        var se = P ? ct(P) : null, me = se ? "The above error occurred in the <" + se + "> component:" : "The above error occurred in one of your React components:", Ce;
        if (u.tag === X)
          Ce = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ze = ct(u) || "Anonymous";
          Ce = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ze + ".");
        }
        var ft = me + `
` + Q + `

` + ("" + Ce);
        console.error(ft);
      } catch (Lt) {
        setTimeout(function() {
          throw Lt;
        });
      }
    }
    var P2 = typeof WeakMap == "function" ? WeakMap : Map;
    function K0(u, d, T) {
      var C = or(pi, T);
      C.tag = mt, C.payload = {
        element: null
      };
      var P = d.value;
      return C.callback = function() {
        mb(P), TE(u, d);
      }, C;
    }
    function Ty(u, d, T) {
      var C = or(pi, T);
      C.tag = mt;
      var P = u.type.getDerivedStateFromError;
      if (typeof P == "function") {
        var V = d.value;
        C.payload = function() {
          return P(V);
        }, C.callback = function() {
          FM(u), TE(u, d);
        };
      }
      var Q = u.stateNode;
      return Q !== null && typeof Q.componentDidCatch == "function" && (C.callback = function() {
        FM(u), TE(u, d), typeof P != "function" && hb(this);
        var me = d.value, Ce = d.stack;
        this.componentDidCatch(me, {
          componentStack: Ce !== null ? Ce : ""
        }), typeof P != "function" && (ci(u.lanes, wr) || p("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", ct(u) || "Unknown"));
      }), C;
    }
    function wE(u, d, T) {
      var C = u.pingCache, P;
      if (C === null ? (C = u.pingCache = new P2(), P = /* @__PURE__ */ new Set(), C.set(d, P)) : (P = C.get(d), P === void 0 && (P = /* @__PURE__ */ new Set(), C.set(d, P))), !P.has(T)) {
        P.add(T);
        var V = F_.bind(null, u, d, T);
        Fa && gg(u, T), d.then(V, V);
      }
    }
    function U2(u, d, T, C) {
      var P = u.updateQueue;
      if (P === null) {
        var V = /* @__PURE__ */ new Set();
        V.add(T), u.updateQueue = V;
      } else
        P.add(T);
    }
    function Jx(u, d) {
      var T = u.tag;
      if ((u.mode & Li) === mr && (T === Y || T === ce || T === he)) {
        var C = u.alternate;
        C ? (u.updateQueue = C.updateQueue, u.memoizedState = C.memoizedState, u.lanes = C.lanes) : (u.updateQueue = null, u.memoizedState = null);
      }
    }
    function Ow(u) {
      var d = u;
      do {
        if (d.tag === re && Ip(d))
          return d;
        d = d.return;
      } while (d !== null);
      return null;
    }
    function Pw(u, d, T, C, P) {
      if ((u.mode & Li) === mr) {
        if (u === d)
          u.flags |= qt;
        else {
          if (u.flags |= mn, T.flags |= En, T.flags &= ~(si | Ft), ei && R) {
            var V = u.alternate;
            if (V === null) {
              var Q = u.child, se = Q.child;
              if (se !== null) {
                var me = se.memoizedProps.children, Ce = Po("hidden", me);
                se.pendingProps = Ce, se.memoizedProps = Ce;
              }
            }
          }
          if (T.tag === J) {
            var ze = T.alternate;
            if (ze === null)
              T.tag = Le;
            else {
              var ft = or(pi, wr);
              ft.tag = ka, Fr(T, ft);
            }
          }
          T.lanes = gr(T.lanes, wr);
        }
        return u;
      }
      return u.flags |= qt, u.lanes = P, u;
    }
    function N2(u, d, T, C, P) {
      if (T.flags |= Ft, Fa && gg(u, P), C !== null && typeof C == "object" && typeof C.then == "function") {
        var V = C;
        Jx(T);
        var Q = Ow(d);
        if (Q !== null) {
          Q.flags &= ~er, Pw(Q, d, T, u, P), Q.mode & Li && wE(u, V, P), U2(Q, u, V);
          return;
        } else {
          if (!ta(P)) {
            wE(u, V, P), ES();
            return;
          }
          var se = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          C = se;
        }
      } else if (Ii() && T.mode & Li) {
        Gm();
        var me = Ow(d);
        if (me !== null) {
          (me.flags & qt) === pe && (me.flags |= er), Pw(me, d, T, u, P), mo(C);
          return;
        }
      }
      MM(C), C = q0(C, T);
      var Ce = d;
      do {
        switch (Ce.tag) {
          case X: {
            var ze = C;
            Ce.flags |= qt;
            var ft = Qf(P);
            Ce.lanes = gr(Ce.lanes, ft);
            var Lt = K0(Ce, ze, ft);
            kr(Ce, Lt);
            return;
          }
          case J:
            var zt = C, Qt = Ce.type, rn = Ce.stateNode;
            if ((Ce.flags & mn) === pe && (typeof Qt.getDerivedStateFromError == "function" || rn !== null && typeof rn.componentDidCatch == "function" && !N_(rn))) {
              Ce.flags |= qt;
              var sr = Qf(P);
              Ce.lanes = gr(Ce.lanes, sr);
              var zr = Ty(Ce, zt, sr);
              kr(Ce, zr);
              return;
            }
            break;
        }
        Ce = Ce.return;
      } while (Ce !== null);
    }
    function F2() {
      return null;
    }
    function Xh(u) {
      u.flags |= ut;
    }
    function Uw(u) {
      u.flags |= ir, u.flags |= qe;
    }
    function Nw(u, d) {
      var T = u !== null && u.child === d.child;
      if (T)
        return !0;
      if ((d.flags & zn) !== pe)
        return !1;
      for (var C = d.child; C !== null; ) {
        if ((C.flags & xn) !== pe || (C.subtreeFlags & xn) !== pe)
          return !1;
        C = C.sibling;
      }
      return !0;
    }
    var Q0, Z0, e_, wy;
    if (jo)
      Q0 = function(u, d, T, C) {
        for (var P = d.child; P !== null; ) {
          if (P.tag === oe || P.tag === fe)
            Ns(u, P.stateNode);
          else if (P.tag !== le) {
            if (P.child !== null) {
              P.child.return = P, P = P.child;
              continue;
            }
          }
          if (P === d)
            return;
          for (; P.sibling === null; ) {
            if (P.return === null || P.return === d)
              return;
            P = P.return;
          }
          P.sibling.return = P.return, P = P.sibling;
        }
      }, Z0 = function(u, d) {
      }, e_ = function(u, d, T, C, P) {
        var V = u.memoizedProps;
        if (V !== C) {
          var Q = d.stateNode, se = $m(), me = Wo(Q, T, V, C, P, se);
          d.updateQueue = me, me && Xh(d);
        }
      }, wy = function(u, d, T, C) {
        T !== C && Xh(d);
      };
    else if (ei) {
      Q0 = function(u, d, T, C) {
        for (var P = d.child; P !== null; ) {
          if (P.tag === oe) {
            var V = P.stateNode;
            if (T && C) {
              var Q = P.memoizedProps, se = P.type;
              V = ou(V, se, Q, P);
            }
            Ns(u, V);
          } else if (P.tag === fe) {
            var me = P.stateNode;
            if (T && C) {
              var Ce = P.memoizedProps;
              me = Da(me, Ce, P);
            }
            Ns(u, me);
          } else if (P.tag !== le) {
            if (P.tag === ke && P.memoizedState !== null) {
              var ze = P.child;
              ze !== null && (ze.return = P), Q0(u, P, !0, !0);
            } else if (P.child !== null) {
              P.child.return = P, P = P.child;
              continue;
            }
          }
          if (P = P, P === d)
            return;
          for (; P.sibling === null; ) {
            if (P.return === null || P.return === d)
              return;
            P = P.return;
          }
          P.sibling.return = P.return, P = P.sibling;
        }
      };
      var t_ = function(u, d, T, C) {
        for (var P = d.child; P !== null; ) {
          if (P.tag === oe) {
            var V = P.stateNode;
            if (T && C) {
              var Q = P.memoizedProps, se = P.type;
              V = ou(V, se, Q, P);
            }
            au(u, V);
          } else if (P.tag === fe) {
            var me = P.stateNode;
            if (T && C) {
              var Ce = P.memoizedProps;
              me = Da(me, Ce, P);
            }
            au(u, me);
          } else if (P.tag !== le) {
            if (P.tag === ke && P.memoizedState !== null) {
              var ze = P.child;
              ze !== null && (ze.return = P), t_(u, P, !0, !0);
            } else if (P.child !== null) {
              P.child.return = P, P = P.child;
              continue;
            }
          }
          if (P = P, P === d)
            return;
          for (; P.sibling === null; ) {
            if (P.return === null || P.return === d)
              return;
            P = P.return;
          }
          P.sibling.return = P.return, P = P.sibling;
        }
      };
      Z0 = function(u, d) {
        var T = d.stateNode, C = Nw(u, d);
        if (!C) {
          var P = T.containerInfo, V = Ka(P);
          t_(V, d, !1, !1), T.pendingChildren = V, Xh(d), zs(P, V);
        }
      }, e_ = function(u, d, T, C, P) {
        var V = u.stateNode, Q = u.memoizedProps, se = Nw(u, d);
        if (se && Q === C) {
          d.stateNode = V;
          return;
        }
        var me = d.stateNode, Ce = $m(), ze = null;
        if (Q !== C && (ze = Wo(me, T, Q, C, P, Ce)), se && ze === null) {
          d.stateNode = V;
          return;
        }
        var ft = So(V, ze, T, Q, C, d, se, me);
        yo(ft, T, C, P, Ce) && Xh(d), d.stateNode = ft, se ? Xh(d) : Q0(ft, d, !1, !1);
      }, wy = function(u, d, T, C) {
        if (T !== C) {
          var P = th(), V = $m();
          d.stateNode = sl(C, P, V, d), Xh(d);
        } else
          d.stateNode = u.stateNode;
      };
    } else
      Z0 = function(u, d) {
      }, e_ = function(u, d, T, C, P) {
      }, wy = function(u, d, T, C) {
      };
    function ng(u, d) {
      if (!Ii())
        switch (u.tailMode) {
          case "hidden": {
            for (var T = u.tail, C = null; T !== null; )
              T.alternate !== null && (C = T), T = T.sibling;
            C === null ? u.tail = null : C.sibling = null;
            break;
          }
          case "collapsed": {
            for (var P = u.tail, V = null; P !== null; )
              P.alternate !== null && (V = P), P = P.sibling;
            V === null ? !d && u.tail !== null ? u.tail.sibling = null : u.tail = null : V.sibling = null;
            break;
          }
        }
    }
    function el(u) {
      var d = u.alternate !== null && u.alternate.child === u.child, T = Yt, C = pe;
      if (d) {
        if ((u.mode & Dr) !== mr) {
          for (var me = u.selfBaseDuration, Ce = u.child; Ce !== null; )
            T = gr(T, gr(Ce.lanes, Ce.childLanes)), C |= Ce.subtreeFlags & bt, C |= Ce.flags & bt, me += Ce.treeBaseDuration, Ce = Ce.sibling;
          u.treeBaseDuration = me;
        } else
          for (var ze = u.child; ze !== null; )
            T = gr(T, gr(ze.lanes, ze.childLanes)), C |= ze.subtreeFlags & bt, C |= ze.flags & bt, ze.return = u, ze = ze.sibling;
        u.subtreeFlags |= C;
      } else {
        if ((u.mode & Dr) !== mr) {
          for (var P = u.actualDuration, V = u.selfBaseDuration, Q = u.child; Q !== null; )
            T = gr(T, gr(Q.lanes, Q.childLanes)), C |= Q.subtreeFlags, C |= Q.flags, P += Q.actualDuration, V += Q.treeBaseDuration, Q = Q.sibling;
          u.actualDuration = P, u.treeBaseDuration = V;
        } else
          for (var se = u.child; se !== null; )
            T = gr(T, gr(se.lanes, se.childLanes)), C |= se.subtreeFlags, C |= se.flags, se.return = u, se = se.sibling;
        u.subtreeFlags |= C;
      }
      return u.childLanes = T, d;
    }
    function Fw(u, d, T) {
      var C = d.pendingProps;
      switch (oy(d), d.tag) {
        case K:
        case Me:
        case he:
        case Y:
        case ce:
        case de:
        case xe:
        case ve:
        case _e:
        case ee:
          return el(d), null;
        case J: {
          var P = d.type;
          return Ol(P) && tf(d), el(d), null;
        }
        case X: {
          var V = d.stateNode;
          if (_f(d), Pu(d), hy(), V.pendingContext && (V.context = V.pendingContext, V.pendingContext = null), u === null || u.child === null) {
            var Q = Ih(d);
            if (Q)
              Xh(d);
            else if (u !== null) {
              var se = u.memoizedState;
              // Check if this is a client root
              (!se.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (d.flags & er) !== pe) && (d.flags |= Wn, Bh());
            }
          }
          return Z0(u, d), el(d), null;
        }
        case oe: {
          H0(d);
          var me = th(), Ce = d.type;
          if (u !== null && d.stateNode != null)
            e_(u, d, Ce, C, me), u.ref !== d.ref && Uw(d);
          else {
            if (!C) {
              if (d.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return el(d), null;
            }
            var ze = $m(), ft = Ih(d);
            if (ft)
              ly(d, me, ze) && Xh(d);
            else {
              var Lt = ru(Ce, C, me, ze, d);
              Q0(Lt, d, !1, !1), d.stateNode = Lt, yo(Lt, Ce, C, me, ze) && Xh(d);
            }
            d.ref !== null && Uw(d);
          }
          return el(d), null;
        }
        case fe: {
          var zt = C;
          if (u && d.stateNode != null) {
            var Qt = u.memoizedProps;
            wy(u, d, Qt, zt);
          } else {
            if (typeof zt != "string" && d.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var rn = th(), sr = $m(), zr = Ih(d);
            zr ? kp(d) && Xh(d) : d.stateNode = sl(zt, rn, sr, d);
          }
          return el(d), null;
        }
        case re: {
          nh(d);
          var pr = d.memoizedState;
          {
            if (Wm() && (d.mode & Li) !== mr && (d.flags & mn) === pe)
              return Hv(d), _c(), d.flags |= er | Ft | qt, d;
            if (pr !== null && pr.dehydrated !== null) {
              var Ga = Ih(d);
              if (u === null) {
                if (!Ga)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (ld(d), el(d), (d.mode & Dr) !== mr) {
                  var Wa = pr !== null;
                  if (Wa) {
                    var xt = d.child;
                    xt !== null && (d.treeBaseDuration -= xt.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (_c(), (d.flags & mn) === pe && (d.memoizedState = null), d.flags |= ut, el(d), (d.mode & Dr) !== mr) {
                  var Gt = pr !== null;
                  if (Gt) {
                    var yt = d.child;
                    yt !== null && (d.treeBaseDuration -= yt.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            Bh();
          }
          if ((d.flags & mn) !== pe)
            return d.lanes = T, (d.mode & Dr) !== mr && by(d), d;
          var sn = pr !== null, jn = !1;
          if (u === null)
            Ih(d);
          else {
            var pn = u.memoizedState;
            jn = pn !== null;
          }
          if (sn && !jn) {
            var Ar = d.child;
            if (Ar.flags |= Mr, (d.mode & Li) !== mr) {
              var Pi = u === null && (d.memoizedProps.unstable_avoidThisFallback !== !0 || !F);
              Pi || V0($u.current, Px) ? lb() : ES();
            }
          }
          var la = d.updateQueue;
          if (la !== null && (d.flags |= ut), el(d), (d.mode & Dr) !== mr && sn) {
            var vn = d.child;
            vn !== null && (d.treeBaseDuration -= vn.treeBaseDuration);
          }
          return null;
        }
        case le:
          return _f(d), Z0(u, d), u === null && nr(d.stateNode.containerInfo), el(d), null;
        case Pe:
          var ia = d.type._context;
          return Z(ia, d), el(d), null;
        case Le: {
          var Ui = d.type;
          return Ol(Ui) && tf(d), el(d), null;
        }
        case Ue: {
          nh(d);
          var Yr = d.memoizedState;
          if (Yr === null)
            return el(d), null;
          var no = (d.flags & mn) !== pe, ja = Yr.rendering;
          if (ja === null)
            if (no)
              ng(Yr, !1);
            else {
              var Dc = ub() && (u === null || (u.flags & mn) === pe);
              if (!Dc)
                for (var As = d.child; As !== null; ) {
                  var Lc = Wh(As);
                  if (Lc !== null) {
                    no = !0, d.flags |= mn, ng(Yr, !1);
                    var wf = Lc.updateQueue;
                    return wf !== null && (d.updateQueue = wf, d.flags |= ut), d.subtreeFlags = pe, I0(d, T), Bl(d, $v($u.current, Ym)), d.child;
                  }
                  As = As.sibling;
                }
              Yr.tail !== null && Vi() > rb() && (d.flags |= mn, no = !0, ng(Yr, !1), d.lanes = Xf);
            }
          else {
            if (!no) {
              var ip = Wh(ja);
              if (ip !== null) {
                d.flags |= mn, no = !0;
                var e0 = ip.updateQueue;
                if (e0 !== null && (d.updateQueue = e0, d.flags |= ut), ng(Yr, !0), Yr.tail === null && Yr.tailMode === "hidden" && !ja.alternate && !Ii())
                  return el(d), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Vi() * 2 - Yr.renderingStartTime > rb() && T !== hi && (d.flags |= mn, no = !0, ng(Yr, !1), d.lanes = Xf);
            }
            if (Yr.isBackwards)
              ja.sibling = d.child, d.child = ja;
            else {
              var Eg = Yr.last;
              Eg !== null ? Eg.sibling = ja : d.child = ja, Yr.last = ja;
            }
          }
          if (Yr.tail !== null) {
            var Oc = Yr.tail;
            Yr.rendering = Oc, Yr.tail = Oc.sibling, Yr.renderingStartTime = Vi(), Oc.sibling = null;
            var em = $u.current;
            return no ? em = $v(em, Ym) : em = Js(em), Bl(d, em), Oc;
          }
          return el(d), null;
        }
        case Ne:
          break;
        case ke:
        case it: {
          _S(d);
          var K_ = d.memoizedState, NS = K_ !== null;
          if (u !== null) {
            var ap = u.memoizedState, Ub = ap !== null;
            Ub !== NS && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !A && (d.flags |= Mr);
          }
          return !NS || (d.mode & Li) === mr ? el(d) : ci(Rc, hi) && (el(d), jo && d.subtreeFlags & (Be | ut) && (d.flags |= Mr)), null;
        }
        case At:
          return null;
        case rt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Wp = o.ReactCurrentOwner, Xu = !1, ME, My, CE, RE, n_, rg, AE, J0;
    ME = {}, My = {}, CE = {}, RE = {}, n_ = {}, rg = !1, AE = {}, J0 = {};
    function wl(u, d, T, C) {
      u === null ? d.child = z0(d, null, T, C) : d.child = Ec(d, u.child, T, C);
    }
    function r_(u, d, T, C) {
      d.child = Ec(d, u.child, null, C), d.child = Ec(d, null, T, C);
    }
    function eS(u, d, T, C, P) {
      if (d.type !== d.elementType) {
        var V = T.propTypes;
        V && Ll(
          V,
          C,
          // Resolved props
          "prop",
          Je(T)
        );
      }
      var Q = T.render, se = d.ref, me, Ce;
      Jt(d, P), Bu(d);
      {
        if (Wp.current = d, Fl(!0), me = Re(u, d, Q, C, se, P), Ce = Ie(), d.mode & oa) {
          ti(!0);
          try {
            me = Re(u, d, Q, C, se, P), Ce = Ie();
          } finally {
            ti(!1);
          }
        }
        Fl(!1);
      }
      return mu(), u !== null && !Xu ? (Tt(u, d, P), jp(u, d, P)) : (Ii() && Ce && Uh(d), d.flags |= Rt, wl(u, d, me, P), d.child);
    }
    function Cy(u, d, T, C, P) {
      if (u === null) {
        var V = T.type;
        if (Xy(V) && T.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        T.defaultProps === void 0) {
          var Q = V;
          return Q = hv(V), d.tag = he, d.type = Q, NE(d, V), Ry(u, d, Q, C, P);
        }
        {
          var se = V.propTypes;
          se && Ll(
            se,
            C,
            // Resolved props
            "prop",
            Je(V)
          );
        }
        var me = qy(T.type, null, C, d, d.mode, P);
        return me.ref = d.ref, me.return = d, d.child = me, me;
      }
      {
        var Ce = T.type, ze = Ce.propTypes;
        ze && Ll(
          ze,
          C,
          // Resolved props
          "prop",
          Je(Ce)
        );
      }
      var ft = u.child, Lt = HE(u, P);
      if (!Lt) {
        var zt = ft.memoizedProps, Qt = T.compare;
        if (Qt = Qt !== null ? Qt : Fo, Qt(zt, C) && u.ref === d.ref)
          return jp(u, d, P);
      }
      d.flags |= Rt;
      var rn = _i(ft, C);
      return rn.ref = d.ref, rn.return = d, d.child = rn, rn;
    }
    function Ry(u, d, T, C, P) {
      if (d.type !== d.elementType) {
        var V = d.elementType;
        if (V.$$typeof === ie) {
          var Q = V, se = Q._payload, me = Q._init;
          try {
            V = me(se);
          } catch {
            V = null;
          }
          var Ce = V && V.propTypes;
          Ce && Ll(
            Ce,
            C,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Je(V)
          );
        }
      }
      if (u !== null) {
        var ze = u.memoizedProps;
        if (Fo(ze, C) && u.ref === d.ref && // Prevent bailout if the implementation changed due to hot reload.
        d.type === u.type)
          if (Xu = !1, HE(u, P))
            (u.flags & En) !== pe && (Xu = !0);
          else
            return d.lanes = u.lanes, jp(u, d, P);
      }
      return Iw(u, d, T, C, P);
    }
    function kw(u, d, T) {
      var C = d.pendingProps, P = C.children, V = u !== null ? u.memoizedState : null;
      if (C.mode === "hidden" || A)
        if ((d.mode & Li) === mr) {
          var Q = {
            baseLanes: Yt,
            cachePool: null
          };
          d.memoizedState = Q, Iy(d, T);
        } else if (ci(T, hi)) {
          var ft = {
            baseLanes: Yt,
            cachePool: null
          };
          d.memoizedState = ft;
          var Lt = V !== null ? V.baseLanes : T;
          Iy(d, Lt);
        } else {
          var se = null, me;
          if (V !== null) {
            var Ce = V.baseLanes;
            me = gr(Ce, T);
          } else
            me = T;
          d.lanes = d.childLanes = hi;
          var ze = {
            baseLanes: me,
            cachePool: se
          };
          return d.memoizedState = ze, d.updateQueue = null, Iy(d, me), null;
        }
      else {
        var zt;
        V !== null ? (zt = gr(V.baseLanes, T), d.memoizedState = null) : zt = T, Iy(d, zt);
      }
      return wl(u, d, P, T), d.child;
    }
    function DE(u, d, T) {
      var C = d.pendingProps;
      return wl(u, d, C, T), d.child;
    }
    function LE(u, d, T) {
      var C = d.pendingProps.children;
      return wl(u, d, C, T), d.child;
    }
    function k2(u, d, T) {
      {
        d.flags |= ut;
        {
          var C = d.stateNode;
          C.effectDuration = 0, C.passiveEffectDuration = 0;
        }
      }
      var P = d.pendingProps, V = P.children;
      return wl(u, d, V, T), d.child;
    }
    function zw(u, d) {
      var T = d.ref;
      (u === null && T !== null || u !== null && u.ref !== T) && (d.flags |= ir, d.flags |= qe);
    }
    function Iw(u, d, T, C, P) {
      if (d.type !== d.elementType) {
        var V = T.propTypes;
        V && Ll(
          V,
          C,
          // Resolved props
          "prop",
          Je(T)
        );
      }
      var Q;
      {
        var se = lo(d, T, !0);
        Q = cc(d, se);
      }
      var me, Ce;
      Jt(d, P), Bu(d);
      {
        if (Wp.current = d, Fl(!0), me = Re(u, d, T, C, Q, P), Ce = Ie(), d.mode & oa) {
          ti(!0);
          try {
            me = Re(u, d, T, C, Q, P), Ce = Ie();
          } finally {
            ti(!1);
          }
        }
        Fl(!1);
      }
      return mu(), u !== null && !Xu ? (Tt(u, d, P), jp(u, d, P)) : (Ii() && Ce && Uh(d), d.flags |= Rt, wl(u, d, me, P), d.child);
    }
    function Bw(u, d, T, C, P) {
      {
        switch (Ab(d)) {
          case !1: {
            var V = d.stateNode, Q = d.type, se = new Q(d.memoizedProps, V.context), me = se.state;
            V.updater.enqueueSetState(V, me, null);
            break;
          }
          case !0: {
            d.flags |= mn, d.flags |= qt;
            var Ce = new Error("Simulated error coming from DevTools"), ze = Qf(P);
            d.lanes = gr(d.lanes, ze);
            var ft = Ty(d, q0(Ce, d), ze);
            kr(d, ft);
            break;
          }
        }
        if (d.type !== d.elementType) {
          var Lt = T.propTypes;
          Lt && Ll(
            Lt,
            C,
            // Resolved props
            "prop",
            Je(T)
          );
        }
      }
      var zt;
      Ol(T) ? (zt = !0, Yi(d)) : zt = !1, Jt(d, P);
      var Qt = d.stateNode, rn;
      Qt === null ? (u !== null && (u.alternate = null, d.alternate = null, d.flags |= Be), Vm(d, T, C), Up(d, T, C, P), rn = !0) : u === null ? rn = Nv(d, T, C, P) : rn = N0(u, d, T, C, P);
      var sr = OE(u, d, T, rn, zt, P);
      {
        var zr = d.stateNode;
        rn && zr.props !== C && (rg || p("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", ct(d) || "a component"), rg = !0);
      }
      return sr;
    }
    function OE(u, d, T, C, P, V) {
      zw(u, d);
      var Q = (d.flags & mn) !== pe;
      if (!C && !Q)
        return P && kd(d, T, !1), jp(u, d, V);
      var se = d.stateNode;
      Wp.current = d;
      var me;
      if (Q && typeof T.getDerivedStateFromError != "function")
        me = null, Qm();
      else {
        Bu(d);
        {
          if (Fl(!0), me = se.render(), d.mode & oa) {
            ti(!0);
            try {
              se.render();
            } finally {
              ti(!1);
            }
          }
          Fl(!1);
        }
        mu();
      }
      return d.flags |= Rt, u !== null && Q ? r_(u, d, me, V) : wl(u, d, me, V), d.memoizedState = se.state, P && kd(d, T, !0), d.child;
    }
    function Hw(u) {
      var d = u.stateNode;
      d.pendingContext ? cu(u, d.pendingContext, d.pendingContext !== d.context) : d.context && cu(u, d.context, !1), B0(u, d.containerInfo);
    }
    function z2(u, d, T) {
      if (Hw(d), u === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var C = d.pendingProps, P = d.memoizedState, V = P.element;
      Rr(u, d), Oh(d, C, null, T);
      var Q = d.memoizedState;
      d.stateNode;
      var se = Q.element;
      if (Ra && P.isDehydrated) {
        var me = {
          element: se,
          isDehydrated: !1,
          cache: Q.cache,
          transitions: Q.transitions
        }, Ce = d.updateQueue;
        if (Ce.baseState = me, d.memoizedState = me, d.flags & er) {
          var ze = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return Vw(u, d, se, T, ze);
        } else if (se !== V) {
          var ft = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return Vw(u, d, se, T, ft);
        } else {
          Zo(d);
          var Lt = z0(d, null, se, T);
          d.child = Lt;
          for (var zt = Lt; zt; )
            zt.flags = zt.flags & ~Be | Wr, zt = zt.sibling;
        }
      } else {
        if (_c(), se === V)
          return jp(u, d, T);
        wl(u, d, se, T);
      }
      return d.child;
    }
    function Vw(u, d, T, C, P) {
      return _c(), mo(P), d.flags |= er, wl(u, d, T, C), d.child;
    }
    function I2(u, d, T) {
      Ja(d), u === null && xf(d);
      var C = d.type, P = d.pendingProps, V = u !== null ? u.memoizedProps : null, Q = P.children, se = ac(C, P);
      return se ? Q = null : V !== null && ac(C, V) && (d.flags |= Gn), zw(u, d), wl(u, d, Q, T), d.child;
    }
    function PE(u, d) {
      return u === null && xf(d), null;
    }
    function B2(u, d, T, C) {
      u !== null && (u.alternate = null, d.alternate = null, d.flags |= Be);
      var P = d.pendingProps, V = T, Q = V._payload, se = V._init, me = se(Q);
      d.type = me;
      var Ce = d.tag = Sg(me), ze = $r(me, P), ft;
      switch (Ce) {
        case Y:
          return NE(d, me), d.type = me = hv(me), ft = Iw(null, d, me, ze, C), ft;
        case J:
          return d.type = me = Sb(me), ft = Bw(null, d, me, ze, C), ft;
        case ce:
          return d.type = me = ep(me), ft = eS(null, d, me, ze, C), ft;
        case ee: {
          if (d.type !== d.elementType) {
            var Lt = me.propTypes;
            Lt && Ll(
              Lt,
              ze,
              // Resolved for outer only
              "prop",
              Je(me)
            );
          }
          return ft = Cy(
            null,
            d,
            me,
            $r(me.type, ze),
            // The inner type can have defaults too
            C
          ), ft;
        }
      }
      var zt = "";
      throw me !== null && typeof me == "object" && me.$$typeof === ie && (zt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + me + ". " + ("Lazy element type must resolve to a class or function." + zt));
    }
    function H2(u, d, T, C, P) {
      u !== null && (u.alternate = null, d.alternate = null, d.flags |= Be), d.tag = J;
      var V;
      return Ol(T) ? (V = !0, Yi(d)) : V = !1, Jt(d, P), Vm(d, T, C), Up(d, T, C, P), OE(null, d, T, !0, V, P);
    }
    function UE(u, d, T, C) {
      u !== null && (u.alternate = null, d.alternate = null, d.flags |= Be);
      var P = d.pendingProps, V;
      {
        var Q = lo(d, T, !1);
        V = cc(d, Q);
      }
      Jt(d, C);
      var se, me;
      Bu(d);
      {
        if (T.prototype && typeof T.prototype.render == "function") {
          var Ce = Je(T) || "Unknown";
          ME[Ce] || (p("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Ce, Ce), ME[Ce] = !0);
        }
        d.mode & oa && Zs.recordLegacyContextWarning(d, null), Fl(!0), Wp.current = d, se = Re(null, d, T, P, V, C), me = Ie(), Fl(!1);
      }
      if (mu(), d.flags |= Rt, typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
        var ze = Je(T) || "Unknown";
        My[ze] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ze, ze, ze), My[ze] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0
      ) {
        {
          var ft = Je(T) || "Unknown";
          My[ft] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ft, ft, ft), My[ft] = !0);
        }
        d.tag = J, d.memoizedState = null, d.updateQueue = null;
        var Lt = !1;
        return Ol(T) ? (Lt = !0, Yi(d)) : Lt = !1, d.memoizedState = se.state !== null && se.state !== void 0 ? se.state : null, An(d), Pp(d, se), Up(d, T, P, C), OE(null, d, T, !0, Lt, C);
      } else {
        if (d.tag = Y, d.mode & oa) {
          ti(!0);
          try {
            se = Re(null, d, T, P, V, C), me = Ie();
          } finally {
            ti(!1);
          }
        }
        return Ii() && me && Uh(d), wl(null, d, se, C), NE(d, T), d.child;
      }
    }
    function NE(u, d) {
      {
        if (d && d.childContextTypes && p("%s(...): childContextTypes cannot be defined on a function component.", d.displayName || d.name || "Component"), u.ref !== null) {
          var T = "", C = zm();
          C && (T += `

Check the render method of \`` + C + "`.");
          var P = C || "", V = u._debugSource;
          V && (P = V.fileName + ":" + V.lineNumber), n_[P] || (n_[P] = !0, p("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", T));
        }
        if (typeof d.getDerivedStateFromProps == "function") {
          var Q = Je(d) || "Unknown";
          RE[Q] || (p("%s: Function components do not support getDerivedStateFromProps.", Q), RE[Q] = !0);
        }
        if (typeof d.contextType == "object" && d.contextType !== null) {
          var se = Je(d) || "Unknown";
          CE[se] || (p("%s: Function components do not support contextType.", se), CE[se] = !0);
        }
      }
    }
    var Ay = {
      dehydrated: null,
      treeContext: null,
      retryLane: Er
    };
    function tS(u) {
      return {
        baseLanes: u,
        cachePool: F2()
      };
    }
    function Gw(u, d) {
      var T = null;
      return {
        baseLanes: gr(u.baseLanes, d),
        cachePool: T
      };
    }
    function V2(u, d, T, C) {
      if (d !== null) {
        var P = d.memoizedState;
        if (P === null)
          return !1;
      }
      return V0(u, Ym);
    }
    function Ww(u, d) {
      return uo(u.childLanes, d);
    }
    function jw(u, d, T) {
      var C = d.pendingProps;
      Lb(d) && (d.flags |= mn);
      var P = $u.current, V = !1, Q = (d.flags & mn) !== pe;
      if (Q || V2(P, u) ? (V = !0, d.flags &= ~mn) : (u === null || u.memoizedState !== null) && (P = hE(P, Px)), P = Js(P), Bl(d, P), u === null) {
        xf(d);
        {
          var se = d.memoizedState;
          if (se !== null) {
            var me = se.dehydrated;
            if (me !== null)
              return kE(d, me);
          }
        }
        var Ce = C.children, ze = C.fallback;
        if (V) {
          var ft = G2(d, Ce, ze, T), Lt = d.child;
          return Lt.memoizedState = tS(T), d.memoizedState = Ay, ft;
        } else
          return i_(d, Ce);
      } else {
        var zt = u.memoizedState;
        if (zt !== null) {
          {
            var Qt = zt.dehydrated;
            if (Qt !== null)
              if (Q) {
                if (d.flags & er)
                  return d.flags &= ~er, a_(u, d, T, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (d.memoizedState !== null)
                  return d.child = u.child, d.flags |= mn, null;
                var rn = C.children, sr = C.fallback, zr = W2(u, d, rn, sr, T), pr = d.child;
                return pr.memoizedState = tS(T), d.memoizedState = Ay, zr;
              } else
                return j2(u, d, Qt, zt, T);
          }
          if (V) {
            var Ga = C.fallback, Wa = C.children, xt = Xw(u, d, Wa, Ga, T), Gt = d.child, yt = u.child.memoizedState;
            return Gt.memoizedState = yt === null ? tS(T) : Gw(yt, T), Gt.childLanes = Ww(u, T), d.memoizedState = Ay, xt;
          } else {
            var sn = C.children, jn = Yw(u, d, sn, T);
            return d.memoizedState = null, jn;
          }
        } else if (V) {
          var pn = C.fallback, Ar = C.children, Pi = Xw(u, d, Ar, pn, T), la = d.child, vn = u.child.memoizedState;
          return la.memoizedState = vn === null ? tS(T) : Gw(vn, T), la.childLanes = Ww(u, T), d.memoizedState = Ay, Pi;
        } else {
          var ia = C.children, Ui = Yw(u, d, ia, T);
          return d.memoizedState = null, Ui;
        }
      }
    }
    function i_(u, d, T) {
      var C = u.mode, P = {
        mode: "visible",
        children: d
      }, V = FE(P, C);
      return V.return = u, u.child = V, V;
    }
    function G2(u, d, T, C) {
      var P = u.mode, V = u.child, Q = {
        mode: "hidden",
        children: d
      }, se, me;
      return (P & Li) === mr && V !== null ? (se = V, se.childLanes = Yt, se.pendingProps = Q, u.mode & Dr && (se.actualDuration = 0, se.actualStartTime = -1, se.selfBaseDuration = 0, se.treeBaseDuration = 0), me = md(T, P, C, null)) : (se = FE(Q, P), me = md(T, P, C, null)), se.return = u, me.return = u, se.sibling = me, u.child = se, me;
    }
    function FE(u, d, T) {
      return Tf(u, d, Yt, null);
    }
    function $w(u, d) {
      return _i(u, d);
    }
    function Yw(u, d, T, C) {
      var P = u.child, V = P.sibling, Q = $w(P, {
        mode: "visible",
        children: T
      });
      if ((d.mode & Li) === mr && (Q.lanes = C), Q.return = d, Q.sibling = null, V !== null) {
        var se = d.deletions;
        se === null ? (d.deletions = [V], d.flags |= zn) : se.push(V);
      }
      return d.child = Q, Q;
    }
    function Xw(u, d, T, C, P) {
      var V = d.mode, Q = u.child, se = Q.sibling, me = {
        mode: "hidden",
        children: T
      }, Ce;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (V & Li) === mr && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        d.child !== Q
      ) {
        var ze = d.child;
        Ce = ze, Ce.childLanes = Yt, Ce.pendingProps = me, d.mode & Dr && (Ce.actualDuration = 0, Ce.actualStartTime = -1, Ce.selfBaseDuration = Q.selfBaseDuration, Ce.treeBaseDuration = Q.treeBaseDuration), d.deletions = null;
      } else
        Ce = $w(Q, me), Ce.subtreeFlags = Q.subtreeFlags & bt;
      var ft;
      return se !== null ? ft = _i(se, C) : (ft = md(C, V, P, null), ft.flags |= Be), ft.return = d, Ce.return = d, Ce.sibling = ft, d.child = Ce, ft;
    }
    function a_(u, d, T, C) {
      C !== null && mo(C), Ec(d, u.child, null, T);
      var P = d.pendingProps, V = P.children, Q = i_(d, V);
      return Q.flags |= Be, d.memoizedState = null, Q;
    }
    function W2(u, d, T, C, P) {
      var V = d.mode, Q = {
        mode: "visible",
        children: T
      }, se = FE(Q, V), me = md(C, V, P, null);
      return me.flags |= Be, se.return = d, me.return = d, se.sibling = me, d.child = se, (d.mode & Li) !== mr && Ec(d, u.child, null, P), me;
    }
    function kE(u, d, T) {
      return (u.mode & Li) === mr ? (p("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), u.lanes = wr) : cl(d) ? u.lanes = fc : u.lanes = hi, null;
    }
    function j2(u, d, T, C, P) {
      if (ju(), (d.mode & Li) === mr)
        return a_(
          u,
          d,
          P,
          // TODO: When we delete legacy mode, we should make this error argument
          // required — every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (cl(T))
        return a_(
          u,
          d,
          P,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var V = ci(P, u.childLanes);
      if (Xu || V) {
        var Q = w_();
        if (Q !== null) {
          var se = Ss(Q, P);
          if (se !== Er && se !== C.retryLane) {
            C.retryLane = se;
            var me = pi;
            Bo(u, se, me);
          }
        }
        return ES(), a_(u, d, P, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (ms(T)) {
        d.flags |= mn, d.child = u.child;
        var Ce = DM.bind(null, u);
        return oo(T, Ce), null;
      } else {
        zv(d, T, C.treeContext);
        var ze = d.pendingProps, ft = ze.children, Lt = i_(d, ft);
        return Lt.flags |= Wr, Lt;
      }
    }
    function qw(u, d, T) {
      u.lanes = gr(u.lanes, d);
      var C = u.alternate;
      C !== null && (C.lanes = gr(C.lanes, d)), we(u.return, d, T);
    }
    function $2(u, d, T) {
      for (var C = d; C !== null; ) {
        if (C.tag === re) {
          var P = C.memoizedState;
          P !== null && qw(C, T, u);
        } else if (C.tag === Ue)
          qw(C, T, u);
        else if (C.child !== null) {
          C.child.return = C, C = C.child;
          continue;
        }
        if (C === u)
          return;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === u)
            return;
          C = C.return;
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }
    function Y2(u) {
      for (var d = u, T = null; d !== null; ) {
        var C = d.alternate;
        C !== null && Wh(C) === null && (T = d), d = d.sibling;
      }
      return T;
    }
    function X2(u) {
      if (u !== void 0 && u !== "forwards" && u !== "backwards" && u !== "together" && !AE[u])
        if (AE[u] = !0, typeof u == "string")
          switch (u.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', u, u.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', u, u.toLowerCase());
              break;
            }
            default:
              p('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
              break;
          }
        else
          p('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
    }
    function q2(u, d) {
      u !== void 0 && !J0[u] && (u !== "collapsed" && u !== "hidden" ? (J0[u] = !0, p('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', u)) : d !== "forwards" && d !== "backwards" && (J0[u] = !0, p('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', u)));
    }
    function Kw(u, d) {
      {
        var T = Xr(u), C = !T && typeof He(u) == "function";
        if (T || C) {
          var P = T ? "array" : "iterable";
          return p("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", P, d, P), !1;
        }
      }
      return !0;
    }
    function K2(u, d) {
      if ((d === "forwards" || d === "backwards") && u !== void 0 && u !== null && u !== !1)
        if (Xr(u)) {
          for (var T = 0; T < u.length; T++)
            if (!Kw(u[T], T))
              return;
        } else {
          var C = He(u);
          if (typeof C == "function") {
            var P = C.call(u);
            if (P)
              for (var V = P.next(), Q = 0; !V.done; V = P.next()) {
                if (!Kw(V.value, Q))
                  return;
                Q++;
              }
          } else
            p('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', d);
        }
    }
    function zE(u, d, T, C, P) {
      var V = u.memoizedState;
      V === null ? u.memoizedState = {
        isBackwards: d,
        rendering: null,
        renderingStartTime: 0,
        last: C,
        tail: T,
        tailMode: P
      } : (V.isBackwards = d, V.rendering = null, V.renderingStartTime = 0, V.last = C, V.tail = T, V.tailMode = P);
    }
    function IE(u, d, T) {
      var C = d.pendingProps, P = C.revealOrder, V = C.tail, Q = C.children;
      X2(P), q2(V, P), K2(Q, P), wl(u, d, Q, T);
      var se = $u.current, me = V0(se, Ym);
      if (me)
        se = $v(se, Ym), d.flags |= mn;
      else {
        var Ce = u !== null && (u.flags & mn) !== pe;
        Ce && $2(d, d.child, T), se = Js(se);
      }
      if (Bl(d, se), (d.mode & Li) === mr)
        d.memoizedState = null;
      else
        switch (P) {
          case "forwards": {
            var ze = Y2(d.child), ft;
            ze === null ? (ft = d.child, d.child = null) : (ft = ze.sibling, ze.sibling = null), zE(
              d,
              !1,
              // isBackwards
              ft,
              ze,
              V
            );
            break;
          }
          case "backwards": {
            var Lt = null, zt = d.child;
            for (d.child = null; zt !== null; ) {
              var Qt = zt.alternate;
              if (Qt !== null && Wh(Qt) === null) {
                d.child = zt;
                break;
              }
              var rn = zt.sibling;
              zt.sibling = Lt, Lt = zt, zt = rn;
            }
            zE(
              d,
              !0,
              // isBackwards
              Lt,
              null,
              // last
              V
            );
            break;
          }
          case "together": {
            zE(
              d,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            d.memoizedState = null;
        }
      return d.child;
    }
    function BE(u, d, T) {
      B0(d, d.stateNode.containerInfo);
      var C = d.pendingProps;
      return u === null ? d.child = Ec(d, null, C, T) : wl(u, d, C, T), d.child;
    }
    var Qw = !1;
    function Q2(u, d, T) {
      var C = d.type, P = C._context, V = d.pendingProps, Q = d.memoizedProps, se = V.value;
      {
        "value" in V || Qw || (Qw = !0, p("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var me = d.type.propTypes;
        me && Ll(me, V, "prop", "Context.Provider");
      }
      if (W(d, P, se), Q !== null) {
        var Ce = Q.value;
        if (To(Ce, se)) {
          if (Q.children === V.children && !Qa())
            return jp(u, d, T);
        } else
          Qe(d, P, T);
      }
      var ze = V.children;
      return wl(u, d, ze, T), d.child;
    }
    var nS = !1;
    function rS(u, d, T) {
      var C = d.type;
      C._context === void 0 ? C !== C.Consumer && (nS || (nS = !0, p("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : C = C._context;
      var P = d.pendingProps, V = P.children;
      typeof V != "function" && p("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Jt(d, T);
      var Q = ln(C);
      Bu(d);
      var se;
      return Wp.current = d, Fl(!0), se = V(Q), Fl(!1), mu(), d.flags |= Rt, wl(u, d, se, T), d.child;
    }
    function o_() {
      Xu = !0;
    }
    function jp(u, d, T) {
      return u !== null && (d.dependencies = u.dependencies), Qm(), By(d.lanes), ci(T, d.childLanes) ? (fy(u, d), d.child) : null;
    }
    function Z2(u, d, T) {
      {
        var C = d.return;
        if (C === null)
          throw new Error("Cannot swap the root fiber.");
        if (u.alternate = null, d.alternate = null, T.index = d.index, T.sibling = d.sibling, T.return = d.return, T.ref = d.ref, d === C.child)
          C.child = T;
        else {
          var P = C.child;
          if (P === null)
            throw new Error("Expected parent to have a child.");
          for (; P.sibling !== d; )
            if (P = P.sibling, P === null)
              throw new Error("Expected to find the previous sibling.");
          P.sibling = T;
        }
        var V = C.deletions;
        return V === null ? (C.deletions = [u], C.flags |= zn) : V.push(u), T.flags |= Be, T;
      }
    }
    function HE(u, d) {
      var T = u.lanes;
      return !!ci(T, d);
    }
    function J2(u, d, T) {
      switch (d.tag) {
        case X:
          Hw(d), d.stateNode, _c();
          break;
        case oe:
          Ja(d);
          break;
        case J: {
          var C = d.type;
          Ol(C) && Yi(d);
          break;
        }
        case le:
          B0(d, d.stateNode.containerInfo);
          break;
        case Pe: {
          var P = d.memoizedProps.value, V = d.type._context;
          W(d, V, P);
          break;
        }
        case ve:
          {
            var Q = ci(T, d.childLanes);
            Q && (d.flags |= ut);
            {
              var se = d.stateNode;
              se.effectDuration = 0, se.passiveEffectDuration = 0;
            }
          }
          break;
        case re: {
          var me = d.memoizedState;
          if (me !== null) {
            if (me.dehydrated !== null)
              return Bl(d, Js($u.current)), d.flags |= mn, null;
            var Ce = d.child, ze = Ce.childLanes;
            if (ci(T, ze))
              return jw(u, d, T);
            Bl(d, Js($u.current));
            var ft = jp(u, d, T);
            return ft !== null ? ft.sibling : null;
          } else
            Bl(d, Js($u.current));
          break;
        }
        case Ue: {
          var Lt = (u.flags & mn) !== pe, zt = ci(T, d.childLanes);
          if (Lt) {
            if (zt)
              return IE(u, d, T);
            d.flags |= mn;
          }
          var Qt = d.memoizedState;
          if (Qt !== null && (Qt.rendering = null, Qt.tail = null, Qt.lastEffect = null), Bl(d, $u.current), zt)
            break;
          return null;
        }
        case ke:
        case it:
          return d.lanes = Yt, kw(u, d, T);
      }
      return jp(u, d, T);
    }
    function Zw(u, d, T) {
      if (d._debugNeedsRemount && u !== null)
        return Z2(u, d, qy(d.type, d.key, d.pendingProps, d._debugOwner || null, d.mode, d.lanes));
      if (u !== null) {
        var C = u.memoizedProps, P = d.pendingProps;
        if (C !== P || Qa() || // Force a re-render if the implementation changed due to hot reload:
        d.type !== u.type)
          Xu = !0;
        else {
          var V = HE(u, T);
          if (!V && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (d.flags & mn) === pe)
            return Xu = !1, J2(u, d, T);
          (u.flags & En) !== pe ? Xu = !0 : Xu = !1;
        }
      } else if (Xu = !1, Ii() && Kd(d)) {
        var Q = d.index, se = Sf();
        F0(d, se, Q);
      }
      switch (d.lanes = Yt, d.tag) {
        case K:
          return UE(u, d, d.type, T);
        case Me: {
          var me = d.elementType;
          return B2(u, d, me, T);
        }
        case Y: {
          var Ce = d.type, ze = d.pendingProps, ft = d.elementType === Ce ? ze : $r(Ce, ze);
          return Iw(u, d, Ce, ft, T);
        }
        case J: {
          var Lt = d.type, zt = d.pendingProps, Qt = d.elementType === Lt ? zt : $r(Lt, zt);
          return Bw(u, d, Lt, Qt, T);
        }
        case X:
          return z2(u, d, T);
        case oe:
          return I2(u, d, T);
        case fe:
          return PE(u, d);
        case re:
          return jw(u, d, T);
        case le:
          return BE(u, d, T);
        case ce: {
          var rn = d.type, sr = d.pendingProps, zr = d.elementType === rn ? sr : $r(rn, sr);
          return eS(u, d, rn, zr, T);
        }
        case de:
          return DE(u, d, T);
        case xe:
          return LE(u, d, T);
        case ve:
          return k2(u, d, T);
        case Pe:
          return Q2(u, d, T);
        case _e:
          return rS(u, d, T);
        case ee: {
          var pr = d.type, Ga = d.pendingProps, Wa = $r(pr, Ga);
          if (d.type !== d.elementType) {
            var xt = pr.propTypes;
            xt && Ll(
              xt,
              Wa,
              // Resolved for outer only
              "prop",
              Je(pr)
            );
          }
          return Wa = $r(pr.type, Wa), Cy(u, d, pr, Wa, T);
        }
        case he:
          return Ry(u, d, d.type, d.pendingProps, T);
        case Le: {
          var Gt = d.type, yt = d.pendingProps, sn = d.elementType === Gt ? yt : $r(Gt, yt);
          return H2(u, d, Gt, sn, T);
        }
        case Ue:
          return IE(u, d, T);
        case Ne:
          break;
        case ke:
          return kw(u, d, T);
      }
      throw new Error("Unknown unit of work tag (" + d.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function eA(u, d, T) {
      switch (oy(d), d.tag) {
        case J: {
          var C = d.type;
          Ol(C) && tf(d);
          var P = d.flags;
          return P & qt ? (d.flags = P & ~qt | mn, (d.mode & Dr) !== mr && by(d), d) : null;
        }
        case X: {
          _f(d), Pu(d), hy();
          var V = d.flags;
          return (V & qt) !== pe && (V & mn) === pe ? (d.flags = V & ~qt | mn, d) : null;
        }
        case oe:
          return H0(d), null;
        case re: {
          nh(d);
          {
            var Q = d.memoizedState;
            if (Q !== null && Q.dehydrated !== null) {
              if (d.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              _c();
            }
          }
          var se = d.flags;
          return se & qt ? (d.flags = se & ~qt | mn, (d.mode & Dr) !== mr && by(d), d) : null;
        }
        case Ue:
          return nh(d), null;
        case le:
          return _f(d), null;
        case Pe:
          var me = d.type._context;
          return Z(me, d), null;
        case ke:
        case it:
          return _S(d), null;
        case At:
          return null;
        default:
          return null;
      }
    }
    function VE(u, d, T) {
      switch (oy(d), d.tag) {
        case J: {
          var C = d.type.childContextTypes;
          C != null && tf(d);
          break;
        }
        case X: {
          _f(d), Pu(d), hy();
          break;
        }
        case oe: {
          H0(d);
          break;
        }
        case le:
          _f(d);
          break;
        case re:
          nh(d);
          break;
        case Ue:
          nh(d);
          break;
        case Pe:
          var P = d.type._context;
          Z(P, d);
          break;
        case ke:
        case it:
          _S(d);
          break;
      }
    }
    function Jw(u, d, T, C, P, V, Q, se, me) {
      var Ce = Array.prototype.slice.call(arguments, 3);
      try {
        d.apply(T, Ce);
      } catch (ze) {
        this.onError(ze);
      }
    }
    var eM = Jw;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var GE = document.createElement("react");
      eM = function(d, T, C, P, V, Q, se, me, Ce) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ze = document.createEvent("Event"), ft = !1, Lt = !0, zt = window.event, Qt = Object.getOwnPropertyDescriptor(window, "event");
        function rn() {
          GE.removeEventListener(Gt, zr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = zt);
        }
        var sr = Array.prototype.slice.call(arguments, 3);
        function zr() {
          ft = !0, rn(), T.apply(C, sr), Lt = !1;
        }
        var pr, Ga = !1, Wa = !1;
        function xt(yt) {
          if (pr = yt.error, Ga = !0, pr === null && yt.colno === 0 && yt.lineno === 0 && (Wa = !0), yt.defaultPrevented && pr != null && typeof pr == "object")
            try {
              pr._suppressLogging = !0;
            } catch {
            }
        }
        var Gt = "react-" + (d || "invokeguardedcallback");
        if (window.addEventListener("error", xt), GE.addEventListener(Gt, zr, !1), ze.initEvent(Gt, !1, !1), GE.dispatchEvent(ze), Qt && Object.defineProperty(window, "event", Qt), ft && Lt && (Ga ? Wa && (pr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : pr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(pr)), window.removeEventListener("error", xt), !ft)
          return rn(), Jw.apply(this, arguments);
      };
    }
    var tA = eM, iS = !1, s_ = null, nA = {
      onError: function(u) {
        iS = !0, s_ = u;
      }
    };
    function tM(u, d, T, C, P, V, Q, se, me) {
      iS = !1, s_ = null, tA.apply(nA, arguments);
    }
    function rA() {
      return iS;
    }
    function nM() {
      if (iS) {
        var u = s_;
        return iS = !1, s_ = null, u;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var rM = null;
    rM = /* @__PURE__ */ new Set();
    var l_ = !1, Zm = !1, iA = typeof WeakSet == "function" ? WeakSet : Set, _n = null, Dy = null, rh = null;
    function zo(u) {
      tM(null, function() {
        throw u;
      }), nM();
    }
    var WE = function(u, d) {
      if (d.props = u.memoizedProps, d.state = u.memoizedState, u.mode & Dr)
        try {
          Eu(), d.componentWillUnmount();
        } finally {
          Mc(u);
        }
      else
        d.componentWillUnmount();
    };
    function Ly(u, d) {
      try {
        cd(Ia, u);
      } catch (T) {
        zo(T), ts(u, d, T);
      }
    }
    function aS(u, d, T) {
      try {
        WE(u, T);
      } catch (C) {
        zo(C), ts(u, d, C);
      }
    }
    function aA(u, d, T) {
      try {
        T.componentDidMount();
      } catch (C) {
        zo(C), ts(u, d, C);
      }
    }
    function iM(u, d) {
      try {
        lS(u);
      } catch (T) {
        zo(T), ts(u, d, T);
      }
    }
    function u_(u, d) {
      var T = u.ref;
      if (T !== null)
        if (typeof T == "function") {
          var C;
          try {
            if (B && $ && u.mode & Dr)
              try {
                Eu(), C = T(null);
              } finally {
                Mc(u);
              }
            else
              C = T(null);
          } catch (P) {
            zo(P), ts(u, d, P);
          }
          typeof C == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ct(u));
        } else
          T.current = null;
    }
    function Jm(u, d, T) {
      try {
        T();
      } catch (C) {
        zo(C), ts(u, d, C);
      }
    }
    var oS = !1;
    function aM(u, d) {
      Xa(u.containerInfo), _n = d, sS();
      var T = oS;
      return oS = !1, T;
    }
    function sS() {
      for (; _n !== null; ) {
        var u = _n, d = u.child;
        (u.subtreeFlags & cn) !== pe && d !== null ? (hd(d, u), _n = d) : ig();
      }
    }
    function ig() {
      for (; _n !== null; ) {
        var u = _n;
        fi(u);
        try {
          ev(u);
        } catch (T) {
          zo(T), ts(u, u.return, T);
        }
        ho();
        var d = u.sibling;
        if (d !== null) {
          hd(d, u.return), _n = d;
          return;
        }
        _n = u.return;
      }
    }
    function ev(u) {
      var d = u.alternate, T = u.flags;
      if ((T & Wn) !== pe) {
        switch (fi(u), u.tag) {
          case Y:
          case ce:
          case he:
            break;
          case J: {
            if (d !== null) {
              var C = d.memoizedProps, P = d.memoizedState, V = u.stateNode;
              u.type === u.elementType && !rg && (V.props !== u.memoizedProps && p("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ct(u) || "instance"), V.state !== u.memoizedState && p("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ct(u) || "instance"));
              var Q = V.getSnapshotBeforeUpdate(u.elementType === u.type ? C : $r(u.type, C), P);
              {
                var se = rM;
                Q === void 0 && !se.has(u.type) && (se.add(u.type), p("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", ct(u)));
              }
              V.__reactInternalSnapshotBeforeUpdate = Q;
            }
            break;
          }
          case X: {
            if (jo) {
              var me = u.stateNode;
              Du(me.containerInfo);
            }
            break;
          }
          case oe:
          case fe:
          case le:
          case Le:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ho();
      }
    }
    function tl(u, d, T) {
      var C = d.updateQueue, P = C !== null ? C.lastEffect : null;
      if (P !== null) {
        var V = P.next, Q = V;
        do {
          if ((Q.tag & u) === u) {
            var se = Q.destroy;
            Q.destroy = void 0, se !== void 0 && ((u & Cs) !== _u ? qs(d) : (u & Ia) !== _u && uf(d), Jm(d, T, se), (u & Cs) !== _u ? km() : (u & Ia) !== _u && gl());
          }
          Q = Q.next;
        } while (Q !== V);
      }
    }
    function cd(u, d) {
      var T = d.updateQueue, C = T !== null ? T.lastEffect : null;
      if (C !== null) {
        var P = C.next, V = P;
        do {
          if ((V.tag & u) === u) {
            (u & Cs) !== _u ? Jf(d) : (u & Ia) !== _u && td(d);
            var Q = V.create;
            V.destroy = Q(), (u & Cs) !== _u ? ed() : (u & Ia) !== _u && $d();
            {
              var se = V.destroy;
              if (se !== void 0 && typeof se != "function") {
                var me = void 0;
                (V.tag & Ia) !== pe ? me = "useLayoutEffect" : (V.tag & jh) !== pe ? me = "useInsertionEffect" : me = "useEffect";
                var Ce = void 0;
                se === null ? Ce = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof se.then == "function" ? Ce = `

It looks like you wrote ` + me + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + me + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Ce = " You returned: " + se, p("%s must not return anything besides a function, which is used for clean-up.%s", me, Ce);
              }
            }
          }
          V = V.next;
        } while (V !== P);
      }
    }
    function jE(u, d) {
      if ((d.flags & ut) !== pe)
        switch (d.tag) {
          case ve: {
            var T = d.stateNode.passiveEffectDuration, C = d.memoizedProps, P = C.id, V = C.onPostCommit, Q = Vp(), se = d.alternate === null ? "mount" : "update";
            Dw() && (se = "nested-update"), typeof V == "function" && V(P, se, T, Q);
            var me = d.return;
            e:
              for (; me !== null; ) {
                switch (me.tag) {
                  case X:
                    var Ce = me.stateNode;
                    Ce.passiveEffectDuration += T;
                    break e;
                  case ve:
                    var ze = me.stateNode;
                    ze.passiveEffectDuration += T;
                    break e;
                }
                me = me.return;
              }
            break;
          }
        }
    }
    function oA(u, d, T, C) {
      if ((T.flags & Nn) !== pe)
        switch (T.tag) {
          case Y:
          case ce:
          case he: {
            if (!Zm)
              if (T.mode & Dr)
                try {
                  Eu(), cd(Ia | Qi, T);
                } finally {
                  Mc(T);
                }
              else
                cd(Ia | Qi, T);
            break;
          }
          case J: {
            var P = T.stateNode;
            if (T.flags & ut && !Zm)
              if (d === null)
                if (T.type === T.elementType && !rg && (P.props !== T.memoizedProps && p("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ct(T) || "instance"), P.state !== T.memoizedState && p("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ct(T) || "instance")), T.mode & Dr)
                  try {
                    Eu(), P.componentDidMount();
                  } finally {
                    Mc(T);
                  }
                else
                  P.componentDidMount();
              else {
                var V = T.elementType === T.type ? d.memoizedProps : $r(T.type, d.memoizedProps), Q = d.memoizedState;
                if (T.type === T.elementType && !rg && (P.props !== T.memoizedProps && p("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ct(T) || "instance"), P.state !== T.memoizedState && p("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ct(T) || "instance")), T.mode & Dr)
                  try {
                    Eu(), P.componentDidUpdate(V, Q, P.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Mc(T);
                  }
                else
                  P.componentDidUpdate(V, Q, P.__reactInternalSnapshotBeforeUpdate);
              }
            var se = T.updateQueue;
            se !== null && (T.type === T.elementType && !rg && (P.props !== T.memoizedProps && p("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ct(T) || "instance"), P.state !== T.memoizedState && p("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ct(T) || "instance")), ry(T, se, P));
            break;
          }
          case X: {
            var me = T.updateQueue;
            if (me !== null) {
              var Ce = null;
              if (T.child !== null)
                switch (T.child.tag) {
                  case oe:
                    Ce = ds(T.child.stateNode);
                    break;
                  case J:
                    Ce = T.child.stateNode;
                    break;
                }
              ry(T, me, Ce);
            }
            break;
          }
          case oe: {
            var ze = T.stateNode;
            if (d === null && T.flags & ut) {
              var ft = T.type, Lt = T.memoizedProps;
              Gc(ze, ft, Lt, T);
            }
            break;
          }
          case fe:
            break;
          case le:
            break;
          case ve: {
            {
              var zt = T.memoizedProps, Qt = zt.onCommit, rn = zt.onRender, sr = T.stateNode.effectDuration, zr = Vp(), pr = d === null ? "mount" : "update";
              Dw() && (pr = "nested-update"), typeof rn == "function" && rn(T.memoizedProps.id, pr, T.actualDuration, T.treeBaseDuration, T.actualStartTime, zr);
              {
                typeof Qt == "function" && Qt(T.memoizedProps.id, pr, sr, zr), pA(T);
                var Ga = T.return;
                e:
                  for (; Ga !== null; ) {
                    switch (Ga.tag) {
                      case X:
                        var Wa = Ga.stateNode;
                        Wa.effectDuration += sr;
                        break e;
                      case ve:
                        var xt = Ga.stateNode;
                        xt.effectDuration += sr;
                        break e;
                    }
                    Ga = Ga.return;
                  }
              }
            }
            break;
          }
          case re: {
            f_(u, T);
            break;
          }
          case Ue:
          case Le:
          case Ne:
          case ke:
          case it:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Zm || T.flags & ir && lS(T);
    }
    function oM(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          if (u.mode & Dr)
            try {
              Eu(), Ly(u, u.return);
            } finally {
              Mc(u);
            }
          else
            Ly(u, u.return);
          break;
        }
        case J: {
          var d = u.stateNode;
          typeof d.componentDidMount == "function" && aA(u, u.return, d), iM(u, u.return);
          break;
        }
        case oe: {
          iM(u, u.return);
          break;
        }
      }
    }
    function sM(u, d) {
      var T = null;
      if (jo)
        for (var C = u; ; ) {
          if (C.tag === oe) {
            if (T === null) {
              T = C;
              var P = C.stateNode;
              d ? jc(P) : $c(C.stateNode, C.memoizedProps);
            }
          } else if (C.tag === fe) {
            if (T === null) {
              var V = C.stateNode;
              d ? $o(V) : ks(V, C.memoizedProps);
            }
          } else if (!((C.tag === ke || C.tag === it) && C.memoizedState !== null && C !== u)) {
            if (C.child !== null) {
              C.child.return = C, C = C.child;
              continue;
            }
          }
          if (C === u)
            return;
          for (; C.sibling === null; ) {
            if (C.return === null || C.return === u)
              return;
            T === C && (T = null), C = C.return;
          }
          T === C && (T = null), C.sibling.return = C.return, C = C.sibling;
        }
    }
    function lS(u) {
      var d = u.ref;
      if (d !== null) {
        var T = u.stateNode, C;
        switch (u.tag) {
          case oe:
            C = ds(T);
            break;
          default:
            C = T;
        }
        if (typeof d == "function") {
          var P;
          if (u.mode & Dr)
            try {
              Eu(), P = d(C);
            } finally {
              Mc(u);
            }
          else
            P = d(C);
          typeof P == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ct(u));
        } else
          d.hasOwnProperty("current") || p("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", ct(u)), d.current = C;
      }
    }
    function ih(u) {
      var d = u.ref;
      if (d !== null)
        if (typeof d == "function")
          if (u.mode & Dr)
            try {
              Eu(), d(null);
            } finally {
              Mc(u);
            }
          else
            d(null);
        else
          d.current = null;
    }
    function c_(u, d, T) {
      switch (na(d), d.tag) {
        case Y:
        case ce:
        case ee:
        case he: {
          var C = d.updateQueue;
          if (C !== null) {
            var P = C.lastEffect;
            if (P !== null) {
              var V = P.next, Q = V;
              do {
                var se = Q, me = se.destroy, Ce = se.tag;
                me !== void 0 && ((Ce & jh) !== _u ? Jm(d, T, me) : (Ce & Ia) !== _u && (uf(d), d.mode & Dr ? (Eu(), Jm(d, T, me), Mc(d)) : Jm(d, T, me), gl())), Q = Q.next;
              } while (Q !== V);
            }
          }
          return;
        }
        case J: {
          u_(d, T);
          var ze = d.stateNode;
          typeof ze.componentWillUnmount == "function" && aS(d, T, ze);
          return;
        }
        case oe: {
          u_(d, T);
          return;
        }
        case le: {
          jo ? YE(u, d, T) : ei && bu(d);
          return;
        }
        case Ae:
          return;
        case Ne:
          return;
      }
    }
    function uS(u, d, T) {
      for (var C = d; ; ) {
        if (c_(u, C, T), C.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!jo || C.tag !== le)) {
          C.child.return = C, C = C.child;
          continue;
        }
        if (C === d)
          return;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === d)
            return;
          C = C.return;
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }
    function $p(u) {
      var d = u.alternate;
      d !== null && (d.return = null), u.return = null;
    }
    function Yp(u) {
      var d = u.alternate;
      d !== null && (u.alternate = null, Yp(d));
      {
        if (u.child = null, u.deletions = null, u.sibling = null, u.tag === oe) {
          var T = u.stateNode;
          T !== null && Fi(T);
        }
        u.stateNode = null, u._debugOwner = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
      }
    }
    function bu(u) {
      if (ei) {
        var d = u.stateNode, T = d.containerInfo, C = Ka(T);
        sc(T, C);
      }
    }
    function Tu(u) {
      if (ei) {
        switch (u.tag) {
          case J:
          case oe:
          case fe:
            return;
          case X:
          case le: {
            var d = u.stateNode, T = d.containerInfo, C = d.pendingChildren;
            sc(T, C);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function $E(u) {
      for (var d = u.return; d !== null; ) {
        if (Cc(d))
          return d;
        d = d.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Cc(u) {
      return u.tag === oe || u.tag === X || u.tag === le;
    }
    function qh(u) {
      var d = u;
      e:
        for (; ; ) {
          for (; d.sibling === null; ) {
            if (d.return === null || Cc(d.return))
              return null;
            d = d.return;
          }
          for (d.sibling.return = d.return, d = d.sibling; d.tag !== oe && d.tag !== fe && d.tag !== Ae; ) {
            if (d.flags & Be || d.child === null || d.tag === le)
              continue e;
            d.child.return = d, d = d.child;
          }
          if (!(d.flags & Be))
            return d.stateNode;
        }
    }
    function ah(u) {
      if (jo) {
        var d = $E(u);
        switch (d.tag) {
          case oe: {
            var T = d.stateNode;
            d.flags & Gn && (Wc(T), d.flags &= ~Gn);
            var C = qh(u);
            tv(u, C, T);
            break;
          }
          case X:
          case le: {
            var P = d.stateNode.containerInfo, V = qh(u);
            cS(u, V, P);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function cS(u, d, T) {
      var C = u.tag, P = C === oe || C === fe;
      if (P) {
        var V = u.stateNode;
        d ? qa(T, V, d) : Vc(T, V);
      } else if (C !== le) {
        var Q = u.child;
        if (Q !== null) {
          cS(Q, d, T);
          for (var se = Q.sibling; se !== null; )
            cS(se, d, T), se = se.sibling;
        }
      }
    }
    function tv(u, d, T) {
      var C = u.tag, P = C === oe || C === fe;
      if (P) {
        var V = u.stateNode;
        d ? Oo(T, V, d) : oc(T, V);
      } else if (C !== le) {
        var Q = u.child;
        if (Q !== null) {
          tv(Q, d, T);
          for (var se = Q.sibling; se !== null; )
            tv(se, d, T), se = se.sibling;
        }
      }
    }
    function YE(u, d, T) {
      for (var C = d, P = !1, V, Q; ; ) {
        if (!P) {
          var se = C.return;
          e:
            for (; ; ) {
              if (se === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var me = se.stateNode;
              switch (se.tag) {
                case oe:
                  V = me, Q = !1;
                  break e;
                case X:
                  V = me.containerInfo, Q = !0;
                  break e;
                case le:
                  V = me.containerInfo, Q = !0;
                  break e;
              }
              se = se.return;
            }
          P = !0;
        }
        if (C.tag === oe || C.tag === fe)
          uS(u, C, T), Q ? Fs(V, C.stateNode) : Au(V, C.stateNode);
        else if (C.tag === Ae)
          Q ? Tm(V, C.stateNode) : bm(V, C.stateNode);
        else if (C.tag === le) {
          if (C.child !== null) {
            V = C.stateNode.containerInfo, Q = !0, C.child.return = C, C = C.child;
            continue;
          }
        } else if (c_(u, C, T), C.child !== null) {
          C.child.return = C, C = C.child;
          continue;
        }
        if (C === d)
          return;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === d)
            return;
          C = C.return, C.tag === le && (P = !1);
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }
    function Oy(u, d, T) {
      jo ? YE(u, d, T) : uS(u, d, T), $p(d);
    }
    function Py(u, d) {
      if (!jo) {
        switch (d.tag) {
          case Y:
          case ce:
          case ee:
          case he: {
            if (tl(jh | Qi, d, d.return), cd(jh | Qi, d), d.mode & Dr)
              try {
                Eu(), tl(Ia | Qi, d, d.return);
              } finally {
                Mc(d);
              }
            else
              tl(Ia | Qi, d, d.return);
            return;
          }
          case ve:
            return;
          case re: {
            oh(d), Uy(d);
            return;
          }
          case Ue: {
            Uy(d);
            return;
          }
          case X: {
            if (Ra && u !== null) {
              var T = u.memoizedState;
              if (T.isDehydrated) {
                var C = d.stateNode;
                _m(C.containerInfo);
              }
            }
            break;
          }
          case ke:
          case it:
            return;
        }
        Tu(d);
        return;
      }
      switch (d.tag) {
        case Y:
        case ce:
        case ee:
        case he: {
          if (tl(jh | Qi, d, d.return), cd(jh | Qi, d), d.mode & Dr)
            try {
              Eu(), tl(Ia | Qi, d, d.return);
            } finally {
              Mc(d);
            }
          else
            tl(Ia | Qi, d, d.return);
          return;
        }
        case J:
          return;
        case oe: {
          var P = d.stateNode;
          if (P != null) {
            var V = d.memoizedProps, Q = u !== null ? u.memoizedProps : V, se = d.type, me = d.updateQueue;
            d.updateQueue = null, me !== null && If(P, me, se, Q, V, d);
          }
          return;
        }
        case fe: {
          if (d.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Ce = d.stateNode, ze = d.memoizedProps, ft = u !== null ? u.memoizedProps : ze;
          ul(Ce, ft, ze);
          return;
        }
        case X: {
          if (Ra && u !== null) {
            var Lt = u.memoizedState;
            if (Lt.isDehydrated) {
              var zt = d.stateNode;
              _m(zt.containerInfo);
            }
          }
          return;
        }
        case ve:
          return;
        case re: {
          oh(d), Uy(d);
          return;
        }
        case Ue: {
          Uy(d);
          return;
        }
        case Le:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function oh(u) {
      u.memoizedState;
    }
    function f_(u, d) {
      if (Ra) {
        var T = d.memoizedState;
        if (T === null) {
          var C = d.alternate;
          if (C !== null) {
            var P = C.memoizedState;
            if (P !== null) {
              var V = P.dehydrated;
              V !== null && Em(V);
            }
          }
        }
      }
    }
    function Uy(u) {
      var d = u.updateQueue;
      if (d !== null) {
        u.updateQueue = null;
        var T = u.stateNode;
        T === null && (T = u.stateNode = new iA()), d.forEach(function(C) {
          var P = LM.bind(null, u, C);
          if (!T.has(C)) {
            if (T.add(C), Fa)
              if (Dy !== null && rh !== null)
                gg(rh, Dy);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            C.then(P, P);
          }
        });
      }
    }
    function lM(u) {
      jo && Wc(u.stateNode);
    }
    function uM(u, d, T) {
      Dy = T, rh = u, _n = d, d_(u, T), Dy = null, rh = null;
    }
    function d_(u, d) {
      for (; _n !== null; ) {
        var T = _n, C = T.deletions;
        if (C !== null)
          for (var P = 0; P < C.length; P++) {
            var V = C[P];
            try {
              Oy(u, V, T);
            } catch (se) {
              zo(se), ts(V, T, se);
            }
          }
        var Q = T.child;
        (T.subtreeFlags & xn) !== pe && Q !== null ? (hd(Q, T), _n = Q) : cM(u, d);
      }
    }
    function cM(u, d) {
      for (; _n !== null; ) {
        var T = _n;
        fi(T);
        try {
          sA(T, u, d);
        } catch (P) {
          zo(P), ts(T, T.return, P);
        }
        ho();
        var C = T.sibling;
        if (C !== null) {
          hd(C, T.return), _n = C;
          return;
        }
        _n = T.return;
      }
    }
    function sA(u, d, T) {
      var C = u.flags;
      if (C & Gn && lM(u), C & ir) {
        var P = u.alternate;
        P !== null && ih(P);
      }
      if (C & Mr)
        switch (u.tag) {
          case re: {
            var V = u.memoizedState, Q = V !== null;
            if (Q) {
              var se = u.alternate, me = se !== null && se.memoizedState !== null;
              me || U_();
            }
            break;
          }
          case ke: {
            var Ce = u.memoizedState, ze = Ce !== null, ft = u.alternate, Lt = ft !== null && ft.memoizedState !== null, zt = u;
            jo && sM(zt, ze);
            {
              if (ze && !Lt && (zt.mode & Li) !== mr) {
                _n = zt;
                for (var Qt = zt.child; Qt !== null; )
                  _n = Qt, XE(Qt), Qt = Qt.sibling;
              }
              break;
            }
          }
        }
      var rn = C & (Be | ut | Wr);
      switch (rn) {
        case Be: {
          ah(u), u.flags &= ~Be;
          break;
        }
        case on: {
          ah(u), u.flags &= ~Be;
          var sr = u.alternate;
          Py(sr, u);
          break;
        }
        case Wr: {
          u.flags &= ~Wr;
          break;
        }
        case Br: {
          u.flags &= ~Wr;
          var zr = u.alternate;
          Py(zr, u);
          break;
        }
        case ut: {
          var pr = u.alternate;
          Py(pr, u);
          break;
        }
      }
    }
    function nv(u, d, T) {
      Dy = T, rh = d, _n = u, fS(u, d, T), Dy = null, rh = null;
    }
    function fS(u, d, T) {
      for (var C = (u.mode & Li) !== mr; _n !== null; ) {
        var P = _n, V = P.child;
        if (P.tag === ke && C) {
          var Q = P.memoizedState !== null, se = Q || l_;
          if (se) {
            sh(u, d, T);
            continue;
          } else {
            var me = P.alternate, Ce = me !== null && me.memoizedState !== null, ze = Ce || Zm, ft = l_, Lt = Zm;
            l_ = se, Zm = ze, Zm && !Lt && (_n = P, fM(P));
            for (var zt = V; zt !== null; )
              _n = zt, fS(
                zt,
                // New root; bubble back up to here and stop.
                d,
                T
              ), zt = zt.sibling;
            _n = P, l_ = ft, Zm = Lt, sh(u, d, T);
            continue;
          }
        }
        (P.subtreeFlags & Nn) !== pe && V !== null ? (hd(V, P), _n = V) : sh(u, d, T);
      }
    }
    function sh(u, d, T) {
      for (; _n !== null; ) {
        var C = _n;
        if ((C.flags & Nn) !== pe) {
          var P = C.alternate;
          fi(C);
          try {
            oA(d, P, C, T);
          } catch (Q) {
            zo(Q), ts(C, C.return, Q);
          }
          ho();
        }
        if (C === u) {
          _n = null;
          return;
        }
        var V = C.sibling;
        if (V !== null) {
          hd(V, C.return), _n = V;
          return;
        }
        _n = C.return;
      }
    }
    function XE(u) {
      for (; _n !== null; ) {
        var d = _n, T = d.child;
        switch (d.tag) {
          case Y:
          case ce:
          case ee:
          case he: {
            if (d.mode & Dr)
              try {
                Eu(), tl(Ia, d, d.return);
              } finally {
                Mc(d);
              }
            else
              tl(Ia, d, d.return);
            break;
          }
          case J: {
            u_(d, d.return);
            var C = d.stateNode;
            typeof C.componentWillUnmount == "function" && aS(d, d.return, C);
            break;
          }
          case oe: {
            u_(d, d.return);
            break;
          }
          case ke: {
            var P = d.memoizedState !== null;
            if (P) {
              h_(u);
              continue;
            }
            break;
          }
        }
        T !== null ? (T.return = d, _n = T) : h_(u);
      }
    }
    function h_(u) {
      for (; _n !== null; ) {
        var d = _n;
        if (d === u) {
          _n = null;
          return;
        }
        var T = d.sibling;
        if (T !== null) {
          T.return = d.return, _n = T;
          return;
        }
        _n = d.return;
      }
    }
    function fM(u) {
      for (; _n !== null; ) {
        var d = _n, T = d.child;
        if (d.tag === ke) {
          var C = d.memoizedState !== null;
          if (C) {
            dM(u);
            continue;
          }
        }
        T !== null ? (T.return = d, _n = T) : dM(u);
      }
    }
    function dM(u) {
      for (; _n !== null; ) {
        var d = _n;
        fi(d);
        try {
          oM(d);
        } catch (C) {
          zo(C), ts(d, d.return, C);
        }
        if (ho(), d === u) {
          _n = null;
          return;
        }
        var T = d.sibling;
        if (T !== null) {
          T.return = d.return, _n = T;
          return;
        }
        _n = d.return;
      }
    }
    function hM(u, d) {
      _n = d, rv(d, u);
    }
    function rv(u, d) {
      for (; _n !== null; ) {
        var T = _n, C = T.child;
        (T.subtreeFlags & lr) !== pe && C !== null ? (hd(C, T), _n = C) : Ny(u, d);
      }
    }
    function Ny(u, d) {
      for (; _n !== null; ) {
        var T = _n;
        if ((T.flags & Ei) !== pe) {
          fi(T);
          try {
            Fy(d, T);
          } catch (P) {
            zo(P), ts(T, T.return, P);
          }
          ho();
        }
        if (T === u) {
          _n = null;
          return;
        }
        var C = T.sibling;
        if (C !== null) {
          hd(C, T.return), _n = C;
          return;
        }
        _n = T.return;
      }
    }
    function Fy(u, d) {
      switch (d.tag) {
        case Y:
        case ce:
        case he: {
          if (d.mode & Dr) {
            Zx();
            try {
              cd(Cs | Qi, d);
            } finally {
              Ey(d);
            }
          } else
            cd(Cs | Qi, d);
          break;
        }
      }
    }
    function p_(u) {
      _n = u, m_();
    }
    function m_() {
      for (; _n !== null; ) {
        var u = _n, d = u.child;
        if ((_n.flags & zn) !== pe) {
          var T = u.deletions;
          if (T !== null) {
            for (var C = 0; C < T.length; C++) {
              var P = T[C];
              _n = P, ag(P, u);
            }
            {
              var V = u.alternate;
              if (V !== null) {
                var Q = V.child;
                if (Q !== null) {
                  V.child = null;
                  do {
                    var se = Q.sibling;
                    Q.sibling = null, Q = se;
                  } while (Q !== null);
                }
              }
            }
            _n = u;
          }
        }
        (u.subtreeFlags & lr) !== pe && d !== null ? (hd(d, u), _n = d) : fd();
      }
    }
    function fd() {
      for (; _n !== null; ) {
        var u = _n;
        (u.flags & Ei) !== pe && (fi(u), dd(u), ho());
        var d = u.sibling;
        if (d !== null) {
          hd(d, u.return), _n = d;
          return;
        }
        _n = u.return;
      }
    }
    function dd(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          u.mode & Dr ? (Zx(), tl(Cs | Qi, u, u.return), Ey(u)) : tl(Cs | Qi, u, u.return);
          break;
        }
      }
    }
    function ag(u, d) {
      for (; _n !== null; ) {
        var T = _n;
        fi(T), qp(T, d), ho();
        var C = T.child;
        C !== null ? (hd(C, T), _n = C) : Xp(u);
      }
    }
    function Xp(u) {
      for (; _n !== null; ) {
        var d = _n, T = d.sibling, C = d.return;
        if (Yp(d), d === u) {
          _n = null;
          return;
        }
        if (T !== null) {
          hd(T, C), _n = T;
          return;
        }
        _n = C;
      }
    }
    function qp(u, d) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          u.mode & Dr ? (Zx(), tl(Cs, u, d), Ey(u)) : tl(Cs, u, d);
          break;
        }
      }
    }
    var pM = !1;
    function hd(u, d) {
      !pM && u.return !== d && (pM = !0, p("Internal React error: Return pointer is inconsistent with parent.")), u.return = d;
    }
    function lA(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          try {
            cd(Ia | Qi, u);
          } catch (T) {
            zo(T), ts(u, u.return, T);
          }
          break;
        }
        case J: {
          var d = u.stateNode;
          try {
            d.componentDidMount();
          } catch (T) {
            zo(T), ts(u, u.return, T);
          }
          break;
        }
      }
    }
    function og(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          try {
            cd(Cs | Qi, u);
          } catch (d) {
            zo(d), ts(u, u.return, d);
          }
          break;
        }
      }
    }
    function mM(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he: {
          try {
            tl(Ia | Qi, u, u.return);
          } catch (T) {
            zo(T), ts(u, u.return, T);
          }
          break;
        }
        case J: {
          var d = u.stateNode;
          typeof d.componentWillUnmount == "function" && aS(u, u.return, d);
          break;
        }
      }
    }
    function qE(u) {
      switch (u.tag) {
        case Y:
        case ce:
        case he:
          try {
            tl(Cs | Qi, u, u.return);
          } catch (d) {
            zo(d), ts(u, u.return, d);
          }
      }
    }
    var sg = 0, v_ = 1, ky = 2, g_ = 3, y_ = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var lh = Symbol.for;
      sg = lh("selector.component"), v_ = lh("selector.has_pseudo_class"), ky = lh("selector.role"), g_ = lh("selector.test_id"), y_ = lh("selector.text");
    }
    function Vl(u) {
      return {
        $$typeof: sg,
        value: u
      };
    }
    function pd(u) {
      return {
        $$typeof: v_,
        value: u
      };
    }
    function uh(u) {
      return {
        $$typeof: ky,
        value: u
      };
    }
    function lg(u) {
      return {
        $$typeof: y_,
        value: u
      };
    }
    function iv(u) {
      return {
        $$typeof: g_,
        value: u
      };
    }
    function KE(u) {
      var d = zf(u);
      if (d != null) {
        if (typeof d.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return d;
      } else {
        var T = fa(u);
        if (T === null)
          throw new Error("Could not find React container within specified host subtree.");
        return T.stateNode.current;
      }
    }
    function S_(u, d) {
      switch (d.$$typeof) {
        case sg:
          if (u.type === d.value)
            return !0;
          break;
        case v_:
          return uA(u, d.value);
        case ky:
          if (u.tag === oe) {
            var T = u.stateNode;
            if (Aa(T, d.value))
              return !0;
          }
          break;
        case y_:
          if (u.tag === oe || u.tag === fe) {
            var C = Sm(u);
            if (C !== null && C.indexOf(d.value) >= 0)
              return !0;
          }
          break;
        case g_:
          if (u.tag === oe) {
            var P = u.memoizedProps["data-testname"];
            if (typeof P == "string" && P.toLowerCase() === d.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function QE(u) {
      switch (u.$$typeof) {
        case sg:
          var d = Je(u.value) || "Unknown";
          return "<" + d + ">";
        case v_:
          return ":has(" + (QE(u) || "") + ")";
        case ky:
          return '[role="' + u.value + '"]';
        case y_:
          return '"' + u.value + '"';
        case g_:
          return '[data-testname="' + u.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function vM(u, d) {
      for (var T = [], C = [u, 0], P = 0; P < C.length; ) {
        var V = C[P++], Q = C[P++], se = d[Q];
        if (!(V.tag === oe && qr(V))) {
          for (; se != null && S_(V, se); )
            Q++, se = d[Q];
          if (Q === d.length)
            T.push(V);
          else
            for (var me = V.child; me !== null; )
              C.push(me, Q), me = me.sibling;
        }
      }
      return T;
    }
    function uA(u, d) {
      for (var T = [u, 0], C = 0; C < T.length; ) {
        var P = T[C++], V = T[C++], Q = d[V];
        if (!(P.tag === oe && qr(P))) {
          for (; Q != null && S_(P, Q); )
            V++, Q = d[V];
          if (V === d.length)
            return !0;
          for (var se = P.child; se !== null; )
            T.push(se, V), se = se.sibling;
        }
      }
      return !1;
    }
    function dS(u, d) {
      if (!Lo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var T = KE(u), C = vM(T, d), P = [], V = Array.from(C), Q = 0; Q < V.length; ) {
        var se = V[Q++];
        if (se.tag === oe) {
          if (qr(se))
            continue;
          P.push(se.stateNode);
        } else
          for (var me = se.child; me !== null; )
            V.push(me), me = me.sibling;
      }
      return P;
    }
    function gM(u, d) {
      if (!Lo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var T = KE(u), C = 0, P = [], V = [T, 0], Q = 0; Q < V.length; ) {
        var se = V[Q++], me = V[Q++], Ce = d[me];
        if (!(se.tag === oe && qr(se)) && (S_(se, Ce) && (P.push(QE(Ce)), me++, me > C && (C = me)), me < d.length))
          for (var ze = se.child; ze !== null; )
            V.push(ze, me), ze = ze.sibling;
      }
      if (C < d.length) {
        for (var ft = [], Lt = C; Lt < d.length; Lt++)
          ft.push(QE(d[Lt]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + P.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + ft.join(" > "));
      }
      return null;
    }
    function ZE(u, d) {
      if (!Lo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var T = dS(u, d), C = [], P = 0; P < T.length; P++)
        C.push(gi(T[P]));
      for (var V = C.length - 1; V > 0; V--)
        for (var Q = C[V], se = Q.x, me = se + Q.width, Ce = Q.y, ze = Ce + Q.height, ft = V - 1; ft >= 0; ft--)
          if (V !== ft) {
            var Lt = C[ft], zt = Lt.x, Qt = zt + Lt.width, rn = Lt.y, sr = rn + Lt.height;
            if (se >= zt && Ce >= rn && me <= Qt && ze <= sr) {
              C.splice(V, 1);
              break;
            } else if (se === zt && Q.width === Lt.width && !(sr < Ce) && !(rn > ze)) {
              rn > Ce && (Lt.height += rn - Ce, Lt.y = Ce), sr < ze && (Lt.height = ze - rn), C.splice(V, 1);
              break;
            } else if (Ce === rn && Q.height === Lt.height && !(Qt < se) && !(zt > me)) {
              zt > se && (Lt.width += zt - se, Lt.x = se), Qt < me && (Lt.width = me - zt), C.splice(V, 1);
              break;
            }
          }
      return C;
    }
    function yM(u, d) {
      if (!Lo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var T = KE(u), C = vM(T, d), P = Array.from(C), V = 0; V < P.length; ) {
        var Q = P[V++];
        if (!qr(Q)) {
          if (Q.tag === oe) {
            var se = Q.stateNode;
            if (Ru(se))
              return !0;
          }
          for (var me = Q.child; me !== null; )
            P.push(me), me = me.sibling;
        }
      }
      return !1;
    }
    var hS = [];
    function JE() {
      Lo && hS.forEach(function(u) {
        return u();
      });
    }
    function eb(u, d, T, C) {
      if (!Lo)
        throw new Error("Test selector API is not supported by this renderer.");
      var P = dS(u, d), V = ps(P, T, C), Q = V.disconnect, se = V.observe, me = V.unobserve, Ce = function() {
        var ze = dS(u, d);
        P.forEach(function(ft) {
          ze.indexOf(ft) < 0 && me(ft);
        }), ze.forEach(function(ft) {
          P.indexOf(ft) < 0 && se(ft);
        });
      };
      return hS.push(Ce), {
        disconnect: function() {
          var ze = hS.indexOf(Ce);
          ze >= 0 && hS.splice(ze, 1), Q();
        }
      };
    }
    var tb = o.ReactCurrentActQueue;
    function cA(u) {
      {
        var d = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), T = typeof jest < "u";
        return kf && T && d !== !1;
      }
    }
    function SM() {
      {
        var u = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !u && tb.current !== null && p("The current testing environment is not configured to support act(...)"), u;
      }
    }
    var fA = Math.ceil, nb = o.ReactCurrentDispatcher, x_ = o.ReactCurrentOwner, Va = o.ReactCurrentBatchConfig, ch = o.ReactCurrentActQueue, es = (
      /*             */
      0
    ), av = (
      /*               */
      1
    ), Gl = (
      /*                */
      2
    ), Ma = (
      /*                */
      4
    ), fh = 0, pS = 1, ug = 2, __ = 3, qu = 4, xM = 5, Kp = 6, Or = es, Rs = null, Ca = null, Ao = Yt, Rc = Yt, cg = dl(Yt), to = fh, ov = null, mS = Yt, Ku = Yt, zy = Yt, fg = null, Wl = null, sv = 0, E_ = 500, vS = 1 / 0, b_ = 500;
    function dg() {
      vS = Vi() + b_;
    }
    function rb() {
      return vS;
    }
    var gS = !1, yS = null, lv = null, hg = !1, Qp = null, Kh = Yt, Io = [], pg = 50, mg = 0, ib = null, _M = 50, T_ = 0, SS = pi, jl = Yt;
    function w_() {
      return Rs;
    }
    function Ml() {
      return (Or & (Gl | Ma)) !== es ? Vi() : (SS !== pi || (SS = Vi()), SS);
    }
    function Zp(u) {
      var d = u.mode;
      if ((d & Li) === mr)
        return wr;
      if ((Or & Gl) !== es && Ao !== Yt)
        return Qf(Ao);
      var T = hf() !== df;
      if (T) {
        if (Va.transition !== null) {
          var C = Va.transition;
          C._updatedFibers || (C._updatedFibers = /* @__PURE__ */ new Set()), C._updatedFibers.add(u);
        }
        return jl === Er && (jl = xo()), jl;
      }
      var P = xs();
      if (P !== Er)
        return P;
      var V = iu();
      return V;
    }
    function EM(u) {
      var d = u.mode;
      return (d & Li) === mr ? wr : Ch();
    }
    function Bo(u, d, T) {
      OM();
      var C = vg(u, d);
      return C === null ? null : (_o(C, d, T), (Or & Gl) !== Yt && C === Rs ? jy(u) : (Fa && Xi(C, u, d), NM(u), C === Rs && ((Or & Gl) === es && (Ku = gr(Ku, d)), to === qu && Zh(C, Ao)), $l(C, T), d === wr && Or === es && (u.mode & Li) === mr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ch.isBatchingLegacy && (dg(), Qs())), C);
    }
    function ab(u, d, T) {
      var C = u.current;
      C.lanes = d, _o(u, d, T), $l(u, T);
    }
    function vg(u, d) {
      u.lanes = gr(u.lanes, d);
      var T = u.alternate;
      T !== null && (T.lanes = gr(T.lanes, d)), T === null && (u.flags & (Be | Wr)) !== pe && Gy(u);
      for (var C = u, P = u.return; P !== null; )
        P.childLanes = gr(P.childLanes, d), T = P.alternate, T !== null ? T.childLanes = gr(T.childLanes, d) : (P.flags & (Be | Wr)) !== pe && Gy(u), C = P, P = P.return;
      if (C.tag === X) {
        var V = C.stateNode;
        return V;
      } else
        return null;
    }
    function M_(u, d) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        Rs !== null && (u.mode & Li) !== mr && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (Or & Gl) === es
      );
    }
    function $l(u, d) {
      var T = u.callbackNode;
      ba(u, d);
      var C = ui(u, u === Rs ? Ao : Yt);
      if (C === Yt) {
        T !== null && UM(T), u.callbackNode = null, u.callbackPriority = Er;
        return;
      }
      var P = du(C), V = u.callbackPriority;
      if (V === P && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ch.current !== null && T !== z_)) {
        T == null && V !== wr && p("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      T != null && UM(T);
      var Q;
      if (P === wr)
        u.tag === jf ? (ch.isBatchingLegacy !== null && (ch.didScheduleLegacyUpdate = !0), Hu(bM.bind(null, u))) : Hn(bM.bind(null, u)), dr ? ch.current !== null ? ch.current.push(No) : hs(function() {
          Or === es && No();
        }) : $y(ha, No), Q = null;
      else {
        var se;
        switch (pu(C)) {
          case Nl:
            se = ha;
            break;
          case Gd:
            se = un;
            break;
          case of:
            se = zi;
            break;
          case Wd:
            se = Na;
            break;
          default:
            se = zi;
            break;
        }
        Q = $y(se, C_.bind(null, u));
      }
      u.callbackPriority = P, u.callbackNode = Q;
    }
    function C_(u, d) {
      if (X0(), SS = pi, jl = Yt, (Or & (Gl | Ma)) !== es)
        throw new Error("Should not already be working.");
      var T = u.callbackNode, C = Jh();
      if (C && u.callbackNode !== T)
        return null;
      var P = ui(u, u === Rs ? Ao : Yt);
      if (P === Yt)
        return null;
      var V = !vc(u, P) && !Uv(u, P) && !d, Q = V ? hA(u, P) : Hy(u, P);
      if (Q !== fh) {
        if (Q === ug) {
          var se = $s(u);
          se !== Yt && (P = se, Q = R_(u, se));
        }
        if (Q === pS) {
          var me = ov;
          throw Jp(u, Yt), Zh(u, P), $l(u, Vi()), me;
        }
        if (Q === Kp)
          Zh(u, P);
        else {
          var Ce = !vc(u, P), ze = u.current.alternate;
          if (Ce && !A_(ze)) {
            if (Q = Hy(u, P), Q === ug) {
              var ft = $s(u);
              ft !== Yt && (P = ft, Q = R_(u, ft));
            }
            if (Q === pS) {
              var Lt = ov;
              throw Jp(u, Yt), Zh(u, P), $l(u, Vi()), Lt;
            }
          }
          u.finishedWork = ze, u.finishedLanes = P, uv(u, Q, P);
        }
      }
      return $l(u, Vi()), u.callbackNode === T ? C_.bind(null, u) : null;
    }
    function R_(u, d) {
      var T = fg;
      if (Si(u)) {
        var C = Jp(u, d);
        C.flags |= er, _a(u.containerInfo);
      }
      var P = Hy(u, d);
      if (P !== ug) {
        var V = Wl;
        Wl = T, V !== null && Qh(V);
      }
      return P;
    }
    function Qh(u) {
      Wl === null ? Wl = u : Wl.push.apply(Wl, u);
    }
    function uv(u, d, T) {
      switch (d) {
        case fh:
        case pS:
          throw new Error("Root did not complete. This is a bug in React.");
        case ug: {
          cv(u, Wl);
          break;
        }
        case __: {
          if (Zh(u, T), mc(T) && // do not delay if we're inside an act() scope
          !yb()) {
            var C = sv + E_ - Vi();
            if (C > 10) {
              var P = ui(u, Yt);
              if (P !== Yt)
                break;
              var V = u.suspendedLanes;
              if (!hu(V, T)) {
                Ml(), Cp(u, V);
                break;
              }
              u.timeoutHandle = yp(cv.bind(null, u, Wl), C);
              break;
            }
          }
          cv(u, Wl);
          break;
        }
        case qu: {
          if (Zh(u, T), Kf(T))
            break;
          if (!yb()) {
            var Q = ku(u, T), se = Q, me = Vi() - se, Ce = Vy(me) - me;
            if (Ce > 10) {
              u.timeoutHandle = yp(cv.bind(null, u, Wl), Ce);
              break;
            }
          }
          cv(u, Wl);
          break;
        }
        case xM: {
          cv(u, Wl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function A_(u) {
      for (var d = u; ; ) {
        if (d.flags & Ri) {
          var T = d.updateQueue;
          if (T !== null) {
            var C = T.stores;
            if (C !== null)
              for (var P = 0; P < C.length; P++) {
                var V = C[P], Q = V.getSnapshot, se = V.value;
                try {
                  if (!To(Q(), se))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var me = d.child;
        if (d.subtreeFlags & Ri && me !== null) {
          me.return = d, d = me;
          continue;
        }
        if (d === u)
          return !0;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === u)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !0;
    }
    function Zh(u, d) {
      d = uo(d, zy), d = uo(d, Ku), Pm(u, d);
    }
    function bM(u) {
      if (Qx(), (Or & (Gl | Ma)) !== es)
        throw new Error("Should not already be working.");
      Jh();
      var d = ui(u, Yt);
      if (!ci(d, wr))
        return $l(u, Vi()), null;
      var T = Hy(u, d);
      if (u.tag !== jf && T === ug) {
        var C = $s(u);
        C !== Yt && (d = C, T = R_(u, C));
      }
      if (T === pS) {
        var P = ov;
        throw Jp(u, Yt), Zh(u, d), $l(u, Vi()), P;
      }
      if (T === Kp)
        throw new Error("Root did not complete. This is a bug in React.");
      var V = u.current.alternate;
      return u.finishedWork = V, u.finishedLanes = d, cv(u, Wl), $l(u, Vi()), null;
    }
    function D_(u, d) {
      d !== Yt && (Eo(u, gr(d, wr)), $l(u, Vi()), (Or & (Gl | Ma)) === es && (dg(), No()));
    }
    function dA(u) {
      var d = xs(), T = Va.transition;
      try {
        return Va.transition = null, co(of), u();
      } finally {
        co(d), Va.transition = T;
      }
    }
    function TM(u, d) {
      var T = Or;
      Or |= av;
      try {
        return u(d);
      } finally {
        Or = T, Or === es && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ch.isBatchingLegacy && (dg(), Qs());
      }
    }
    function L_(u, d, T, C, P) {
      var V = xs(), Q = Va.transition;
      try {
        return Va.transition = null, co(Nl), u(d, T, C, P);
      } finally {
        co(V), Va.transition = Q, Or === es && dg();
      }
    }
    function xS(u) {
      Qp !== null && Qp.tag === jf && (Or & (Gl | Ma)) === es && Jh();
      var d = Or;
      Or |= av;
      var T = Va.transition, C = xs();
      try {
        return Va.transition = null, co(Nl), u ? u() : void 0;
      } finally {
        co(C), Va.transition = T, Or = d, (Or & (Gl | Ma)) === es && No();
      }
    }
    function ob() {
      return (Or & (Gl | Ma)) !== es;
    }
    function wM(u) {
      var d = Or;
      Or |= av;
      var T = Va.transition, C = xs();
      try {
        Va.transition = null, co(Nl), u();
      } finally {
        co(C), Va.transition = T, Or = d, Or === es && (dg(), No());
      }
    }
    function Iy(u, d) {
      ki(cg, Rc, u), Rc = gr(Rc, d);
    }
    function _S(u) {
      Rc = cg.current, so(cg, u);
    }
    function Jp(u, d) {
      u.finishedWork = null, u.finishedLanes = Yt;
      var T = u.timeoutHandle;
      if (T !== Vr && (u.timeoutHandle = Vr, Dl(T)), Ca !== null)
        for (var C = Ca.return; C !== null; ) {
          var P = C.alternate;
          VE(P, C), C = C.return;
        }
      Rs = u;
      var V = _i(u.current, null);
      return Ca = V, Ao = Rc = d, to = fh, ov = null, mS = Yt, Ku = Yt, zy = Yt, fg = null, Wl = null, Ki(), Zs.discardPendingWarnings(), V;
    }
    function O_(u, d) {
      do {
        var T = Ca;
        try {
          if (S(), Kt(), ho(), x_.current = null, T === null || T.return === null) {
            to = pS, ov = d, Ca = null;
            return;
          }
          if (B && T.mode & Dr && tg(T, !0), H)
            if (mu(), d !== null && typeof d == "object" && typeof d.then == "function") {
              var C = d;
              cf(T, C, Ao);
            } else
              vu(T, d, Ao);
          N2(u, T.return, T, d, Ao), AM(T);
        } catch (P) {
          d = P, Ca === T && T !== null ? (T = T.return, Ca = T) : T = Ca;
          continue;
        }
        return;
      } while (!0);
    }
    function P_() {
      var u = nb.current;
      return nb.current = jx, u === null ? jx : u;
    }
    function sb(u) {
      nb.current = u;
    }
    function U_() {
      sv = Vi();
    }
    function By(u) {
      mS = gr(u, mS);
    }
    function lb() {
      to === fh && (to = __);
    }
    function ES() {
      (to === fh || to === __ || to === ug) && (to = qu), Rs !== null && (Ys(mS) || Ys(Ku)) && Zh(Rs, Ao);
    }
    function MM(u) {
      to !== qu && (to = ug), fg === null ? fg = [u] : fg.push(u);
    }
    function ub() {
      return to === fh;
    }
    function Hy(u, d) {
      var T = Or;
      Or |= Gl;
      var C = P_();
      if (Rs !== u || Ao !== d) {
        if (Fa) {
          var P = u.memoizedUpdaters;
          P.size > 0 && (gg(u, Ao), P.clear()), ml(u, d);
        }
        Jp(u, d);
      }
      Cr(d);
      do
        try {
          CM();
          break;
        } catch (V) {
          O_(u, V);
        }
      while (!0);
      if (S(), Or = T, sb(C), Ca !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return jr(), Rs = null, Ao = Yt, to;
    }
    function CM() {
      for (; Ca !== null; )
        cb(Ca);
    }
    function hA(u, d) {
      var T = Or;
      Or |= Gl;
      var C = P_();
      if (Rs !== u || Ao !== d) {
        if (Fa) {
          var P = u.memoizedUpdaters;
          P.size > 0 && (gg(u, Ao), P.clear()), ml(u, d);
        }
        dg(), Jp(u, d);
      }
      Cr(d);
      do
        try {
          RM();
          break;
        } catch (V) {
          O_(u, V);
        }
      while (!0);
      return S(), sb(C), Or = T, Ca !== null ? (Kn(), fh) : (jr(), Rs = null, Ao = Yt, to);
    }
    function RM() {
      for (; Ca !== null && !Nm(); )
        cb(Ca);
    }
    function cb(u) {
      var d = u.alternate;
      fi(u);
      var T;
      (u.mode & Dr) !== mr ? (Gp(u), T = Wy(d, u, Rc), tg(u, !0)) : T = Wy(d, u, Rc), ho(), u.memoizedProps = u.pendingProps, T === null ? AM(u) : Ca = T, x_.current = null;
    }
    function AM(u) {
      var d = u;
      do {
        var T = d.alternate, C = d.return;
        if ((d.flags & Ft) === pe) {
          fi(d);
          var P = void 0;
          if ((d.mode & Dr) === mr ? P = Fw(T, d, Rc) : (Gp(d), P = Fw(T, d, Rc), tg(d, !1)), ho(), P !== null) {
            Ca = P;
            return;
          }
        } else {
          var V = eA(T, d);
          if (V !== null) {
            V.flags &= De, Ca = V;
            return;
          }
          if ((d.mode & Dr) !== mr) {
            tg(d, !1);
            for (var Q = d.actualDuration, se = d.child; se !== null; )
              Q += se.actualDuration, se = se.sibling;
            d.actualDuration = Q;
          }
          if (C !== null)
            C.flags |= Ft, C.subtreeFlags = pe, C.deletions = null;
          else {
            to = Kp, Ca = null;
            return;
          }
        }
        var me = d.sibling;
        if (me !== null) {
          Ca = me;
          return;
        }
        d = C, Ca = d;
      } while (d !== null);
      to === fh && (to = xM);
    }
    function cv(u, d) {
      var T = xs(), C = Va.transition;
      try {
        Va.transition = null, co(Nl), fb(u, d, T);
      } finally {
        Va.transition = C, co(T);
      }
      return null;
    }
    function fb(u, d, T) {
      do
        Jh();
      while (Qp !== null);
      if (mA(), (Or & (Gl | Ma)) !== es)
        throw new Error("Should not already be working.");
      var C = u.finishedWork, P = u.finishedLanes;
      if (fo(P), C === null)
        return jd(), null;
      if (P === Yt && p("root.finishedLanes should not be empty during a commit. This is a bug in React."), u.finishedWork = null, u.finishedLanes = Yt, C === u.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      u.callbackNode = null, u.callbackPriority = Er;
      var V = gr(C.lanes, C.childLanes);
      af(u, V), u === Rs && (Rs = null, Ca = null, Ao = Yt), ((C.subtreeFlags & lr) !== pe || (C.flags & lr) !== pe) && (hg || (hg = !0, $y(zi, function() {
        return Jh(), null;
      })));
      var Q = (C.subtreeFlags & (cn | xn | Nn | lr)) !== pe, se = (C.flags & (cn | xn | Nn | lr)) !== pe;
      if (Q || se) {
        var me = Va.transition;
        Va.transition = null;
        var Ce = xs();
        co(Nl);
        var ze = Or;
        Or |= Ma, x_.current = null, aM(u, C), bE(), uM(u, C, P), Ai(u.containerInfo), u.current = C, yl(P), nv(C, u, P), Lh(), Dh(), Or = ze, co(Ce), Va.transition = me;
      } else
        u.current = C, bE();
      var ft = hg;
      if (hg && (hg = !1, Qp = u, Kh = P), V = u.pendingLanes, V === Yt && (lv = null), ft || PM(u.current, !1), Lr(C.stateNode, T), Fa && u.memoizedUpdaters.clear(), JE(), $l(u, Vi()), d !== null)
        for (var Lt = u.onRecoverableError, zt = 0; zt < d.length; zt++) {
          var Qt = d[zt];
          Lt(Qt);
        }
      if (gS) {
        gS = !1;
        var rn = yS;
        throw yS = null, rn;
      }
      return ci(Kh, wr) && u.tag !== jf && Jh(), V = u.pendingLanes, ci(V, wr) ? (wc(), u === ib ? mg++ : (mg = 0, ib = u)) : mg = 0, No(), jd(), null;
    }
    function Jh() {
      if (Qp !== null) {
        var u = pu(Kh), d = Um(of, u), T = Va.transition, C = xs();
        try {
          return Va.transition = null, co(d), db();
        } finally {
          co(C), Va.transition = T;
        }
      }
      return !1;
    }
    function pA(u) {
      Io.push(u), hg || (hg = !0, $y(zi, function() {
        return Jh(), null;
      }));
    }
    function db() {
      if (Qp === null)
        return !1;
      var u = Qp, d = Kh;
      if (Qp = null, Kh = Yt, (Or & (Gl | Ma)) !== es)
        throw new Error("Cannot flush passive effects while already rendering.");
      gu(d);
      var T = Or;
      Or |= Ma, p_(u.current), hM(u, u.current);
      {
        var C = Io;
        Io = [];
        for (var P = 0; P < C.length; P++) {
          var V = C[P];
          jE(u, V);
        }
      }
      qn(), PM(u.current, !0), Or = T, No(), T_ = Qp === null ? 0 : T_ + 1, qi(u);
      {
        var Q = u.current.stateNode;
        Q.effectDuration = 0, Q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function N_(u) {
      return lv !== null && lv.has(u);
    }
    function hb(u) {
      lv === null ? lv = /* @__PURE__ */ new Set([u]) : lv.add(u);
    }
    function pb(u) {
      gS || (gS = !0, yS = u);
    }
    var mb = pb;
    function vb(u, d, T) {
      var C = q0(T, d), P = K0(u, C, wr);
      Fr(u, P);
      var V = Ml(), Q = vg(u, wr);
      Q !== null && (_o(Q, wr, V), $l(Q, V));
    }
    function ts(u, d, T) {
      if (u.tag === X) {
        vb(u, u, T);
        return;
      }
      var C = null;
      for (C = d; C !== null; ) {
        if (C.tag === X) {
          vb(C, u, T);
          return;
        } else if (C.tag === J) {
          var P = C.type, V = C.stateNode;
          if (typeof P.getDerivedStateFromError == "function" || typeof V.componentDidCatch == "function" && !N_(V)) {
            var Q = q0(T, u), se = Ty(C, Q, wr);
            Fr(C, se);
            var me = Ml(), Ce = vg(C, wr);
            Ce !== null && (_o(Ce, wr, me), $l(Ce, me));
            return;
          }
        }
        C = C.return;
      }
      p(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, T);
    }
    function F_(u, d, T) {
      var C = u.pingCache;
      C !== null && C.delete(d);
      var P = Ml();
      Cp(u, T), wS(u), Rs === u && hu(Ao, T) && (to === qu || to === __ && mc(Ao) && Vi() - sv < E_ ? Jp(u, Yt) : zy = gr(zy, T)), $l(u, P);
    }
    function bS(u, d) {
      d === Er && (d = EM(u));
      var T = Ml(), C = vg(u, d);
      C !== null && (_o(C, d, T), $l(C, T));
    }
    function DM(u) {
      var d = u.memoizedState, T = Er;
      d !== null && (T = d.retryLane), bS(u, T);
    }
    function LM(u, d) {
      var T = Er, C;
      switch (u.tag) {
        case re:
          C = u.stateNode;
          var P = u.memoizedState;
          P !== null && (T = P.retryLane);
          break;
        case Ue:
          C = u.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      C !== null && C.delete(d), bS(u, T);
    }
    function Vy(u) {
      return u < 120 ? 120 : u < 480 ? 480 : u < 1080 ? 1080 : u < 1920 ? 1920 : u < 3e3 ? 3e3 : u < 4320 ? 4320 : fA(u / 1960) * 1960;
    }
    function OM() {
      if (mg > pg)
        throw mg = 0, ib = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      T_ > _M && (T_ = 0, p("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function mA() {
      Zs.flushLegacyContextWarning(), Zs.flushPendingUnsafeLifecycleWarnings();
    }
    function PM(u, d) {
      fi(u), fv(u, pt, mM), d && fv(u, en, qE), fv(u, pt, lA), d && fv(u, en, og), ho();
    }
    function fv(u, d, T) {
      for (var C = u, P = null; C !== null; ) {
        var V = C.subtreeFlags & d;
        C !== P && C.child !== null && V !== pe ? C = C.child : ((C.flags & d) !== pe && T(C), C.sibling !== null ? C = C.sibling : C = P = C.return);
      }
    }
    var dh = null;
    function Gy(u) {
      {
        if ((Or & Gl) !== es || !(u.mode & Li))
          return;
        var d = u.tag;
        if (d !== K && d !== X && d !== J && d !== Y && d !== ce && d !== ee && d !== he)
          return;
        var T = ct(u) || "ReactComponent";
        if (dh !== null) {
          if (dh.has(T))
            return;
          dh.add(T);
        } else
          dh = /* @__PURE__ */ new Set([T]);
        var C = qo;
        try {
          fi(u), p("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          C ? fi(u) : ho();
        }
      }
    }
    var Wy;
    {
      var k_ = null;
      Wy = function(u, d, T) {
        var C = _g(k_, d);
        try {
          return Zw(u, d, T);
        } catch (V) {
          if (V !== null && typeof V == "object" && typeof V.then == "function")
            throw V;
          if (S(), Kt(), VE(u, d), _g(d, C), d.mode & Dr && Gp(d), tM(null, Zw, null, u, d, T), rA()) {
            var P = nM();
            typeof P == "object" && P !== null && P._suppressLogging && typeof V == "object" && V !== null && !V._suppressLogging && (V._suppressLogging = !0);
          }
          throw V;
        }
      };
    }
    var gb = !1, TS;
    TS = /* @__PURE__ */ new Set();
    function jy(u) {
      if (xl && !ww())
        switch (u.tag) {
          case Y:
          case ce:
          case he: {
            var d = Ca && ct(Ca) || "Unknown", T = d;
            if (!TS.has(T)) {
              TS.add(T);
              var C = ct(u) || "Unknown";
              p("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", C, d, d);
            }
            break;
          }
          case J: {
            gb || (p("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), gb = !0);
            break;
          }
        }
    }
    function gg(u, d) {
      if (Fa) {
        var T = u.memoizedUpdaters;
        T.forEach(function(C) {
          Xi(u, C, d);
        });
      }
    }
    var z_ = {};
    function $y(u, d) {
      {
        var T = ch.current;
        return T !== null ? (T.push(d), z_) : Ah(u, d);
      }
    }
    function UM(u) {
      if (u !== z_)
        return sf(u);
    }
    function yb() {
      return ch.current !== null;
    }
    function NM(u) {
      {
        if (u.mode & Li) {
          if (!SM())
            return;
        } else if (!cA() || Or !== es || u.tag !== Y && u.tag !== ce && u.tag !== he)
          return;
        if (ch.current === null) {
          var d = qo;
          try {
            fi(u), p(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, ct(u));
          } finally {
            d ? fi(u) : ho();
          }
        }
      }
    }
    function wS(u) {
      u.tag !== jf && SM() && ch.current === null && p(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Ho = null, dv = null, Yy = function(u) {
      Ho = u;
    };
    function hv(u) {
      {
        if (Ho === null)
          return u;
        var d = Ho(u);
        return d === void 0 ? u : d.current;
      }
    }
    function Sb(u) {
      return hv(u);
    }
    function ep(u) {
      {
        if (Ho === null)
          return u;
        var d = Ho(u);
        if (d === void 0) {
          if (u != null && typeof u.render == "function") {
            var T = hv(u.render);
            if (u.render !== T) {
              var C = {
                $$typeof: Ct,
                render: T
              };
              return u.displayName !== void 0 && (C.displayName = u.displayName), C;
            }
          }
          return u;
        }
        return d.current;
      }
    }
    function yg(u, d) {
      {
        if (Ho === null)
          return !1;
        var T = u.elementType, C = d.type, P = !1, V = typeof C == "object" && C !== null ? C.$$typeof : null;
        switch (u.tag) {
          case J: {
            typeof C == "function" && (P = !0);
            break;
          }
          case Y: {
            (typeof C == "function" || V === ie) && (P = !0);
            break;
          }
          case ce: {
            (V === Ct || V === ie) && (P = !0);
            break;
          }
          case ee:
          case he: {
            (V === Zt || V === ie) && (P = !0);
            break;
          }
          default:
            return !1;
        }
        if (P) {
          var Q = Ho(T);
          if (Q !== void 0 && Q === Ho(C))
            return !0;
        }
        return !1;
      }
    }
    function FM(u) {
      {
        if (Ho === null || typeof WeakSet != "function")
          return;
        dv === null && (dv = /* @__PURE__ */ new WeakSet()), dv.add(u);
      }
    }
    var I_ = function(u, d) {
      {
        if (Ho === null)
          return;
        var T = d.staleFamilies, C = d.updatedFamilies;
        Jh(), xS(function() {
          ns(u.current, C, T);
        });
      }
    }, Ac = function(u, d) {
      {
        if (u.context !== Kr)
          return;
        Jh(), xS(function() {
          H_(d, u, null, null);
        });
      }
    };
    function ns(u, d, T) {
      {
        var C = u.alternate, P = u.child, V = u.sibling, Q = u.tag, se = u.type, me = null;
        switch (Q) {
          case Y:
          case he:
          case J:
            me = se;
            break;
          case ce:
            me = se.render;
            break;
        }
        if (Ho === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Ce = !1, ze = !1;
        if (me !== null) {
          var ft = Ho(me);
          ft !== void 0 && (T.has(ft) ? ze = !0 : d.has(ft) && (Q === J ? ze = !0 : Ce = !0));
        }
        dv !== null && (dv.has(u) || C !== null && dv.has(C)) && (ze = !0), ze && (u._debugNeedsRemount = !0), (ze || Ce) && Bo(u, wr, pi), P !== null && !ze && ns(P, d, T), V !== null && ns(V, d, T);
      }
    }
    var tp = function(u, d) {
      {
        var T = /* @__PURE__ */ new Set(), C = new Set(d.map(function(P) {
          return P.current;
        }));
        return rs(u.current, C, T), T;
      }
    };
    function rs(u, d, T) {
      {
        var C = u.child, P = u.sibling, V = u.tag, Q = u.type, se = null;
        switch (V) {
          case Y:
          case he:
          case J:
            se = Q;
            break;
          case ce:
            se = Q.render;
            break;
        }
        var me = !1;
        se !== null && d.has(se) && (me = !0), me ? Yl(u, T) : C !== null && rs(C, d, T), P !== null && rs(P, d, T);
      }
    }
    function Yl(u, d) {
      {
        var T = xb(u, d);
        if (T)
          return;
        for (var C = u; ; ) {
          switch (C.tag) {
            case oe:
              d.add(C.stateNode);
              return;
            case le:
              d.add(C.stateNode.containerInfo);
              return;
            case X:
              d.add(C.stateNode.containerInfo);
              return;
          }
          if (C.return === null)
            throw new Error("Expected to reach root first.");
          C = C.return;
        }
      }
    }
    function xb(u, d) {
      for (var T = u, C = !1; ; ) {
        if (T.tag === oe)
          C = !0, d.add(T.stateNode);
        else if (T.child !== null) {
          T.child.return = T, T = T.child;
          continue;
        }
        if (T === u)
          return C;
        for (; T.sibling === null; ) {
          if (T.return === null || T.return === u)
            return C;
          T = T.return;
        }
        T.sibling.return = T.return, T = T.sibling;
      }
      return !1;
    }
    var MS;
    {
      MS = !1;
      try {
        var kM = Object.preventExtensions({});
      } catch {
        MS = !0;
      }
    }
    function wn(u, d, T, C) {
      this.tag = u, this.key = T, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = d, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = C, this.flags = pe, this.subtreeFlags = pe, this.deletions = null, this.lanes = Yt, this.childLanes = Yt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !MS && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Xl = function(u, d, T, C) {
      return new wn(u, d, T, C);
    };
    function CS(u) {
      var d = u.prototype;
      return !!(d && d.isReactComponent);
    }
    function Xy(u) {
      return typeof u == "function" && !CS(u) && u.defaultProps === void 0;
    }
    function Sg(u) {
      if (typeof u == "function")
        return CS(u) ? J : Y;
      if (u != null) {
        var d = u.$$typeof;
        if (d === Ct)
          return ce;
        if (d === Zt)
          return ee;
      }
      return K;
    }
    function _i(u, d) {
      var T = u.alternate;
      T === null ? (T = Xl(u.tag, d, u.key, u.mode), T.elementType = u.elementType, T.type = u.type, T.stateNode = u.stateNode, T._debugSource = u._debugSource, T._debugOwner = u._debugOwner, T._debugHookTypes = u._debugHookTypes, T.alternate = u, u.alternate = T) : (T.pendingProps = d, T.type = u.type, T.flags = pe, T.subtreeFlags = pe, T.deletions = null, T.actualDuration = 0, T.actualStartTime = -1), T.flags = u.flags & bt, T.childLanes = u.childLanes, T.lanes = u.lanes, T.child = u.child, T.memoizedProps = u.memoizedProps, T.memoizedState = u.memoizedState, T.updateQueue = u.updateQueue;
      var C = u.dependencies;
      switch (T.dependencies = C === null ? null : {
        lanes: C.lanes,
        firstContext: C.firstContext
      }, T.sibling = u.sibling, T.index = u.index, T.ref = u.ref, T.selfBaseDuration = u.selfBaseDuration, T.treeBaseDuration = u.treeBaseDuration, T._debugNeedsRemount = u._debugNeedsRemount, T.tag) {
        case K:
        case Y:
        case he:
          T.type = hv(u.type);
          break;
        case J:
          T.type = Sb(u.type);
          break;
        case ce:
          T.type = ep(u.type);
          break;
      }
      return T;
    }
    function nl(u, d) {
      u.flags &= bt | Be;
      var T = u.alternate;
      if (T === null)
        u.childLanes = Yt, u.lanes = d, u.child = null, u.subtreeFlags = pe, u.memoizedProps = null, u.memoizedState = null, u.updateQueue = null, u.dependencies = null, u.stateNode = null, u.selfBaseDuration = 0, u.treeBaseDuration = 0;
      else {
        u.childLanes = T.childLanes, u.lanes = T.lanes, u.child = T.child, u.subtreeFlags = pe, u.deletions = null, u.memoizedProps = T.memoizedProps, u.memoizedState = T.memoizedState, u.updateQueue = T.updateQueue, u.type = T.type;
        var C = T.dependencies;
        u.dependencies = C === null ? null : {
          lanes: C.lanes,
          firstContext: C.firstContext
        }, u.selfBaseDuration = T.selfBaseDuration, u.treeBaseDuration = T.treeBaseDuration;
      }
      return u;
    }
    function rl(u, d, T) {
      var C;
      return u === Am ? (C = Li, d === !0 && (C |= oa, C |= Uo)) : C = mr, Fa && (C |= Dr), Xl(X, null, null, C);
    }
    function qy(u, d, T, C, P, V) {
      var Q = K, se = u;
      if (typeof u == "function")
        CS(u) ? (Q = J, se = Sb(se)) : se = hv(se);
      else if (typeof u == "string")
        Q = oe;
      else
        e:
          switch (u) {
            case Ye:
              return md(T.children, P, V, d);
            case Ge:
              Q = xe, P |= oa, (P & Li) !== mr && (P |= Uo);
              break;
            case $e:
              return vA(T, P, V, d);
            case Pt:
              return gA(T, P, V, d);
            case vt:
              return jt(T, P, V, d);
            case _t:
              return Tf(T, P, V, d);
            case ot:
            case ne:
            case at:
            case Wt:
            case Oe:
            default: {
              if (typeof u == "object" && u !== null)
                switch (u.$$typeof) {
                  case Ut:
                    Q = Pe;
                    break e;
                  case nt:
                    Q = _e;
                    break e;
                  case Ct:
                    Q = ce, se = ep(se);
                    break e;
                  case Zt:
                    Q = ee;
                    break e;
                  case ie:
                    Q = Me, se = null;
                    break e;
                }
              var me = "";
              {
                (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (me += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Ce = C ? ct(C) : null;
                Ce && (me += `

Check the render method of \`` + Ce + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (u == null ? u : typeof u) + "." + me));
            }
          }
      var ze = Xl(Q, T, d, P);
      return ze.elementType = u, ze.type = se, ze.lanes = V, ze._debugOwner = C, ze;
    }
    function xg(u, d, T) {
      var C = null;
      C = u._owner;
      var P = u.type, V = u.key, Q = u.props, se = qy(P, V, Q, C, d, T);
      return se._debugSource = u._source, se._debugOwner = u._owner, se;
    }
    function md(u, d, T, C) {
      var P = Xl(de, u, C, d);
      return P.lanes = T, P;
    }
    function vA(u, d, T, C) {
      typeof u.id != "string" && p('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof u.id);
      var P = Xl(ve, u, C, d | Dr);
      return P.elementType = $e, P.lanes = T, P.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, P;
    }
    function gA(u, d, T, C) {
      var P = Xl(re, u, C, d);
      return P.elementType = Pt, P.lanes = T, P;
    }
    function jt(u, d, T, C) {
      var P = Xl(Ue, u, C, d);
      return P.elementType = vt, P.lanes = T, P;
    }
    function Tf(u, d, T, C) {
      var P = Xl(ke, u, C, d);
      P.elementType = _t, P.lanes = T;
      var V = {};
      return P.stateNode = V, P;
    }
    function np(u, d, T) {
      var C = Xl(fe, u, null, d);
      return C.lanes = T, C;
    }
    function _b() {
      var u = Xl(oe, null, null, mr);
      return u.elementType = "DELETED", u;
    }
    function Wi(u) {
      var d = Xl(Ae, null, null, mr);
      return d.stateNode = u, d;
    }
    function fn(u, d, T) {
      var C = u.children !== null ? u.children : [], P = Xl(le, C, u.key, d);
      return P.lanes = T, P.stateNode = {
        containerInfo: u.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: u.implementation
      }, P;
    }
    function _g(u, d) {
      return u === null && (u = Xl(K, null, null, mr)), u.tag = d.tag, u.key = d.key, u.elementType = d.elementType, u.type = d.type, u.stateNode = d.stateNode, u.return = d.return, u.child = d.child, u.sibling = d.sibling, u.index = d.index, u.ref = d.ref, u.pendingProps = d.pendingProps, u.memoizedProps = d.memoizedProps, u.updateQueue = d.updateQueue, u.memoizedState = d.memoizedState, u.dependencies = d.dependencies, u.mode = d.mode, u.flags = d.flags, u.subtreeFlags = d.subtreeFlags, u.deletions = d.deletions, u.lanes = d.lanes, u.childLanes = d.childLanes, u.alternate = d.alternate, u.actualDuration = d.actualDuration, u.actualStartTime = d.actualStartTime, u.selfBaseDuration = d.selfBaseDuration, u.treeBaseDuration = d.treeBaseDuration, u._debugSource = d._debugSource, u._debugOwner = d._debugOwner, u._debugNeedsRemount = d._debugNeedsRemount, u._debugHookTypes = d._debugHookTypes, u;
    }
    function yA(u, d, T, C, P) {
      this.tag = d, this.containerInfo = u, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Vr, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Er, this.eventTimes = pl(Yt), this.expirationTimes = pl(pi), this.pendingLanes = Yt, this.suspendedLanes = Yt, this.pingedLanes = Yt, this.expiredLanes = Yt, this.mutableReadLanes = Yt, this.finishedLanes = Yt, this.entangledLanes = Yt, this.entanglements = pl(Yt), this.identifierPrefix = C, this.onRecoverableError = P, Ra && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var V = this.pendingUpdatersLaneMap = [], Q = 0; Q < Th; Q++)
          V.push(/* @__PURE__ */ new Set());
      }
      switch (d) {
        case Am:
          this._debugRootType = T ? "hydrateRoot()" : "createRoot()";
          break;
        case jf:
          this._debugRootType = T ? "hydrate()" : "render()";
          break;
      }
    }
    function ql(u, d, T, C, P, V, Q, se, me, Ce) {
      var ze = new yA(u, d, T, se, me), ft = rl(d, V);
      ze.current = ft, ft.stateNode = ze;
      {
        var Lt = {
          element: C,
          isDehydrated: T,
          cache: null,
          // not enabled yet
          transitions: null
        };
        ft.memoizedState = Lt;
      }
      return An(ft), ze;
    }
    var Eb = "18.0.0-fc46dba67-20220329";
    function Ky(u, d, T) {
      var C = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return _l(C), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: et,
        key: C == null ? null : "" + C,
        children: u,
        containerInfo: d,
        implementation: T
      };
    }
    var pv, B_;
    pv = !1, B_ = {};
    function bb(u) {
      if (!u)
        return Kr;
      var d = b(u), T = bp(d);
      if (d.tag === J) {
        var C = d.type;
        if (Ol(C))
          return Pl(d, C, T);
      }
      return T;
    }
    function rp(u) {
      var d = b(u);
      if (d === void 0) {
        if (typeof u.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var T = Object.keys(u).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + T);
      }
      var C = $n(d);
      return C === null ? null : C.stateNode;
    }
    function vd(u, d) {
      {
        var T = b(u);
        if (T === void 0) {
          if (typeof u.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var C = Object.keys(u).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + C);
        }
        var P = $n(T);
        if (P === null)
          return null;
        if (P.mode & oa) {
          var V = ct(T) || "Component";
          if (!B_[V]) {
            B_[V] = !0;
            var Q = qo;
            try {
              fi(P), T.mode & oa ? p("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, V) : p("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", d, d, V);
            } finally {
              Q ? fi(Q) : ho();
            }
          }
        }
        return P.stateNode;
      }
    }
    function zM(u, d, T, C, P, V, Q, se) {
      var me = !1, Ce = null;
      return ql(u, d, me, Ce, T, C, P, V, Q);
    }
    function Tb(u, d, T, C, P, V, Q, se, me, Ce) {
      var ze = !0, ft = ql(T, C, ze, u, P, V, Q, se, me);
      ft.context = bb(null);
      var Lt = ft.current, zt = Ml(), Qt = Zp(Lt), rn = or(zt, Qt);
      return rn.callback = d ?? null, Fr(Lt, rn), ab(ft, Qt, zt), ft;
    }
    function H_(u, d, T, C) {
      ma(d, u);
      var P = d.current, V = Ml(), Q = Zp(P);
      bo(Q);
      var se = bb(T);
      d.context === null ? d.context = se : d.pendingContext = se, xl && qo !== null && !pv && (pv = !0, p(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, ct(qo) || "Unknown"));
      var me = or(V, Q);
      me.payload = {
        element: u
      }, C = C === void 0 ? null : C, C !== null && (typeof C != "function" && p("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", C), me.callback = C), Fr(P, me);
      var Ce = Bo(P, Q, V);
      return Ce !== null && va(Ce, P, Q), Q;
    }
    function wb(u) {
      var d = u.current;
      if (!d.child)
        return null;
      switch (d.child.tag) {
        case oe:
          return ds(d.child.stateNode);
        default:
          return d.child.stateNode;
      }
    }
    function Mb(u) {
      switch (u.tag) {
        case X:
          var d = u.stateNode;
          if (Si(d)) {
            var T = gs(d);
            D_(d, T);
          }
          break;
        case re:
          var C = Ml();
          xS(function() {
            return Bo(u, wr, C);
          });
          var P = wr;
          IM(u, P);
          break;
      }
    }
    function SA(u, d) {
      var T = u.memoizedState;
      T !== null && T.dehydrated !== null && (T.retryLane = nn(T.retryLane, d));
    }
    function IM(u, d) {
      SA(u, d);
      var T = u.alternate;
      T && SA(T, d);
    }
    function Cb(u) {
      if (u.tag === re) {
        var d = Ml(), T = qf;
        Bo(u, T, d), IM(u, T);
      }
    }
    function V_(u) {
      if (u.tag === re) {
        var d = Ml(), T = Zp(u);
        Bo(u, T, d), IM(u, T);
      }
    }
    function BM(u) {
      var d = ur(u);
      return d === null ? null : d.stateNode;
    }
    var Rb = function(u) {
      return null;
    };
    function Ab(u) {
      return Rb(u);
    }
    var Db = function(u) {
      return !1;
    };
    function Lb(u) {
      return Db(u);
    }
    var RS = null, G_ = null, W_ = null, Qy = null, j_ = null, AS = null, Zy = null, DS = null, LS = null;
    {
      var Jy = function(u, d, T) {
        var C = d[T], P = Xr(u) ? u.slice() : x({}, u);
        return T + 1 === d.length ? (Xr(P) ? P.splice(C, 1) : delete P[C], P) : (P[C] = Jy(u[C], d, T + 1), P);
      }, $_ = function(u, d) {
        return Jy(u, d, 0);
      }, OS = function(u, d, T, C) {
        var P = d[C], V = Xr(u) ? u.slice() : x({}, u);
        if (C + 1 === d.length) {
          var Q = T[C];
          V[Q] = V[P], Xr(V) ? V.splice(P, 1) : delete V[P];
        } else
          V[P] = OS(
            // $FlowFixMe number or string is fine here
            u[P],
            d,
            T,
            C + 1
          );
        return V;
      }, Y_ = function(u, d, T) {
        if (d.length !== T.length) {
          h("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var C = 0; C < T.length - 1; C++)
            if (d[C] !== T[C]) {
              h("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return OS(u, d, T, 0);
      }, PS = function(u, d, T, C) {
        if (T >= d.length)
          return C;
        var P = d[T], V = Xr(u) ? u.slice() : x({}, u);
        return V[P] = PS(u[P], d, T + 1, C), V;
      }, Ob = function(u, d, T) {
        return PS(u, d, 0, T);
      }, US = function(u, d) {
        for (var T = u.memoizedState; T !== null && d > 0; )
          T = T.next, d--;
        return T;
      };
      RS = function(u, d, T, C) {
        var P = US(u, d);
        if (P !== null) {
          var V = Ob(P.memoizedState, T, C);
          P.memoizedState = V, P.baseState = V, u.memoizedProps = x({}, u.memoizedProps), Bo(u, wr, pi);
        }
      }, G_ = function(u, d, T) {
        var C = US(u, d);
        if (C !== null) {
          var P = $_(C.memoizedState, T);
          C.memoizedState = P, C.baseState = P, u.memoizedProps = x({}, u.memoizedProps), Bo(u, wr, pi);
        }
      }, W_ = function(u, d, T, C) {
        var P = US(u, d);
        if (P !== null) {
          var V = Y_(P.memoizedState, T, C);
          P.memoizedState = V, P.baseState = V, u.memoizedProps = x({}, u.memoizedProps), Bo(u, wr, pi);
        }
      }, Qy = function(u, d, T) {
        u.pendingProps = Ob(u.memoizedProps, d, T), u.alternate && (u.alternate.pendingProps = u.pendingProps), Bo(u, wr, pi);
      }, j_ = function(u, d) {
        u.pendingProps = $_(u.memoizedProps, d), u.alternate && (u.alternate.pendingProps = u.pendingProps), Bo(u, wr, pi);
      }, AS = function(u, d, T) {
        u.pendingProps = Y_(u.memoizedProps, d, T), u.alternate && (u.alternate.pendingProps = u.pendingProps), Bo(u, wr, pi);
      }, Zy = function(u) {
        Bo(u, wr, pi);
      }, DS = function(u) {
        Rb = u;
      }, LS = function(u) {
        Db = u;
      };
    }
    function X_(u) {
      var d = $n(u);
      return d === null ? null : d.stateNode;
    }
    function xA(u) {
      return null;
    }
    function q_() {
      return qo;
    }
    function Pb(u) {
      var d = u.findFiberByHostInstance, T = o.ReactCurrentDispatcher;
      return gc({
        bundleType: u.bundleType,
        version: u.version,
        rendererPackageName: u.rendererPackageName,
        rendererConfig: u.rendererConfig,
        overrideHookState: RS,
        overrideHookStateDeletePath: G_,
        overrideHookStateRenamePath: W_,
        overrideProps: Qy,
        overridePropsDeletePath: j_,
        overridePropsRenamePath: AS,
        setErrorHandler: DS,
        setSuspenseHandler: LS,
        scheduleUpdate: Zy,
        currentDispatcherRef: T,
        findHostInstanceByFiber: X_,
        findFiberByHostInstance: d || xA,
        // React Refresh
        findHostInstancesForRefresh: tp,
        scheduleRefresh: I_,
        scheduleRoot: Ac,
        setRefreshHandler: Yy,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: q_,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: Eb
      });
    }
    return t.attemptContinuousHydration = Cb, t.attemptHydrationAtCurrentPriority = V_, t.attemptSynchronousHydration = Mb, t.batchedUpdates = TM, t.createComponentSelector = Vl, t.createContainer = zM, t.createHasPseudoClassSelector = pd, t.createHydrationContainer = Tb, t.createPortal = Ky, t.createRoleSelector = uh, t.createTestNameSelector = iv, t.createTextSelector = lg, t.deferredUpdates = dA, t.discreteUpdates = L_, t.findAllNodes = dS, t.findBoundingRects = ZE, t.findHostInstance = rp, t.findHostInstanceWithNoPortals = BM, t.findHostInstanceWithWarning = vd, t.flushControlled = wM, t.flushPassiveEffects = Jh, t.flushSync = xS, t.focusWithin = yM, t.getCurrentUpdatePriority = xs, t.getFindAllNodesFailureDescription = gM, t.getPublicRootInstance = wb, t.injectIntoDevTools = Pb, t.isAlreadyRendering = ob, t.observeVisibleRects = eb, t.registerMutableSourceForHydration = Xv, t.runWithPriority = sa, t.shouldError = Ab, t.shouldSuspend = Lb, t.updateContainer = H_, t;
  })), uL.exports;
}
process.env.NODE_ENV === "production" ? LO.exports = zX() : LO.exports = IX();
var BX = LO.exports;
const HX = /* @__PURE__ */ rw(BX), VX = (n) => typeof n == "object" && typeof n.then == "function", qC = [];
function GX(n, e, t = (r, i) => r === i) {
  if (n === e)
    return !0;
  if (!n || !e)
    return !1;
  const r = n.length;
  if (e.length !== r)
    return !1;
  for (let i = 0; i < r; i++)
    if (!t(n[i], e[i]))
      return !1;
  return !0;
}
function WX(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const o of qC)
    if (GX(e, o.keys, o.equal)) {
      if (t)
        return;
      if (Object.prototype.hasOwnProperty.call(o, "error"))
        throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return r.lifespan && r.lifespan > 0 && (o.timeout && clearTimeout(o.timeout), o.timeout = setTimeout(o.remove, r.lifespan)), o.response;
      if (!t)
        throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = qC.indexOf(i);
      o !== -1 && qC.splice(o, 1);
    },
    promise: (
      // Execute the promise
      (VX(n) ? n : n(...e)).then((o) => {
        i.response = o, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan));
      }).catch((o) => i.error = o)
    )
  };
  if (qC.push(i), !t)
    throw i.promise;
}
const jX = (n, e, t) => WX(n, e, !1, t), i3 = {}, $X = (n) => void Object.assign(i3, n);
function YX(n, e) {
  function t(y, {
    args: x = [],
    attach: b,
    ...w
  }, R) {
    let U = `${y[0].toUpperCase()}${y.slice(1)}`, L;
    if (y === "primitive") {
      if (w.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const A = w.object;
      L = U1(A, {
        type: y,
        root: R,
        attach: b,
        primitive: !0
      });
    } else {
      const A = i3[U];
      if (!A)
        throw new Error(`R3F: ${U} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(x))
        throw new Error("R3F: The args prop must be an array!");
      L = U1(new A(...x), {
        type: y,
        root: R,
        attach: b,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: x
        }
      });
    }
    return L.__r3f.attach === void 0 && (L instanceof oi ? L.__r3f.attach = "geometry" : L instanceof ic && (L.__r3f.attach = "material")), U !== "inject" && dL(L, w), L;
  }
  function r(y, x) {
    let b = !1;
    if (x) {
      var w, R;
      (w = x.__r3f) != null && w.attach ? fL(y, x, x.__r3f.attach) : x.isObject3D && y.isObject3D && (y.add(x), b = !0), b || (R = y.__r3f) == null || R.objects.push(x), x.__r3f || U1(x, {}), x.__r3f.parent = y, UO(x), N1(x);
    }
  }
  function i(y, x, b) {
    let w = !1;
    if (x) {
      var R, U;
      if ((R = x.__r3f) != null && R.attach)
        fL(y, x, x.__r3f.attach);
      else if (x.isObject3D && y.isObject3D) {
        x.parent = y, x.dispatchEvent({
          type: "added"
        });
        const L = y.children.filter((F) => F !== x), A = L.indexOf(b);
        y.children = [...L.slice(0, A), x, ...L.slice(A)], w = !0;
      }
      w || (U = y.__r3f) == null || U.objects.push(x), x.__r3f || U1(x, {}), x.__r3f.parent = y, UO(x), N1(x);
    }
  }
  function o(y, x, b = !1) {
    y && [...y].forEach((w) => l(x, w, b));
  }
  function l(y, x, b) {
    if (x) {
      var w, R, U;
      if (x.__r3f && (x.__r3f.parent = null), (w = y.__r3f) != null && w.objects && (y.__r3f.objects = y.__r3f.objects.filter((H) => H !== x)), (R = x.__r3f) != null && R.attach)
        sk(y, x, x.__r3f.attach);
      else if (x.isObject3D && y.isObject3D) {
        var L;
        y.remove(x), (L = x.__r3f) != null && L.root && tq(x.__r3f.root, x);
      }
      const F = (U = x.__r3f) == null ? void 0 : U.primitive, k = b === void 0 ? x.dispose !== null && !F : b;
      if (!F) {
        var A;
        o((A = x.__r3f) == null ? void 0 : A.objects, x, k), o(x.children, x, k);
      }
      delete x.__r3f, k && x.dispose && x.type !== "Scene" && RR.unstable_scheduleCallback(RR.unstable_IdlePriority, () => {
        try {
          x.dispose();
        } catch {
        }
      }), N1(y);
    }
  }
  function c(y, x, b, w) {
    var R;
    const U = (R = y.__r3f) == null ? void 0 : R.parent;
    if (!U)
      return;
    const L = t(x, b, y.__r3f.root);
    if (y.children) {
      for (const A of y.children)
        A.__r3f && r(L, A);
      y.children = y.children.filter((A) => !A.__r3f);
    }
    y.__r3f.objects.forEach((A) => r(L, A)), y.__r3f.objects = [], y.__r3f.autoRemovedBeforeAppend || l(U, y), L.parent && (L.__r3f.autoRemovedBeforeAppend = !0), r(U, L), L.raycast && L.__r3f.eventCount && L.__r3f.root.getState().internal.interaction.push(L), [w, w.alternate].forEach((A) => {
      A !== null && (A.stateNode = L, A.ref && (typeof A.ref == "function" ? A.ref(L) : A.ref.current = L));
    });
  }
  const h = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: HX({
      createInstance: t,
      removeChild: l,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (y, x) => {
        if (!x)
          return;
        const b = y.getState().scene;
        b.__r3f && (b.__r3f.root = y, r(b, x));
      },
      removeChildFromContainer: (y, x) => {
        x && l(y.getState().scene, x);
      },
      insertInContainerBefore: (y, x, b) => {
        if (!x || !b)
          return;
        const w = y.getState().scene;
        w.__r3f && i(w, x, b);
      },
      getRootHostContext: () => null,
      getChildHostContext: (y) => y,
      finalizeInitialChildren(y) {
        var x;
        return !!((x = y == null ? void 0 : y.__r3f) != null ? x : {}).handlers;
      },
      prepareUpdate(y, x, b, w) {
        var R;
        if (((R = y == null ? void 0 : y.__r3f) != null ? R : {}).primitive && w.object && w.object !== y)
          return [!0];
        {
          const {
            args: L = [],
            children: A,
            ...F
          } = w, {
            args: k = [],
            children: H,
            ...B
          } = b;
          if (!Array.isArray(L))
            throw new Error("R3F: the args prop must be an array!");
          if (L.some((Y, J) => Y !== k[J]))
            return [!0];
          const $ = LB(y, F, B, !0);
          return $.changes.length ? [!1, $] : null;
        }
      },
      commitUpdate(y, [x, b], w, R, U, L) {
        x ? c(y, w, U, L) : dL(y, b);
      },
      commitMount(y, x, b, w) {
        var R;
        const U = (R = y.__r3f) != null ? R : {};
        y.raycast && U.handlers && U.eventCount && y.__r3f.root.getState().internal.interaction.push(y);
      },
      getPublicInstance: (y) => y,
      prepareForCommit: () => null,
      preparePortalMount: (y) => U1(y.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(y) {
        var x;
        const {
          attach: b,
          parent: w
        } = (x = y.__r3f) != null ? x : {};
        b && w && sk(w, y, b), y.isObject3D && (y.visible = !1), N1(y);
      },
      unhideInstance(y, x) {
        var b;
        const {
          attach: w,
          parent: R
        } = (b = y.__r3f) != null ? b : {};
        w && R && fL(R, y, w), (y.isObject3D && x.visible == null || x.visible) && (y.visible = !0), N1(y);
      },
      createTextInstance: h,
      hideTextInstance: h,
      unhideTextInstance: h,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-ignore
      getCurrentEventPriority: () => e ? e() : B1.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Go.fun(performance.now) ? performance.now : Go.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: Go.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Go.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: dL
  };
}
var rk, ik;
const cL = (n) => "colorSpace" in n || "outputColorSpace" in n, wB = () => {
  var n;
  return (n = i3.ColorManagement) != null ? n : null;
}, MB = (n) => n && n.isOrthographicCamera, XX = (n) => n && n.hasOwnProperty("current"), hw = typeof window < "u" && ((rk = window.document) != null && rk.createElement || ((ik = window.navigator) == null ? void 0 : ik.product) === "ReactNative") ? Cn.useLayoutEffect : Cn.useEffect;
function CB(n) {
  const e = Cn.useRef(n);
  return hw(() => void (e.current = n), [n]), e;
}
function qX({
  set: n
}) {
  return hw(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class RB extends Cn.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
RB.getDerivedStateFromError = () => ({
  error: !0
});
const AB = "__default", ak = /* @__PURE__ */ new Map(), KX = (n) => n && !!n.memoized && !!n.changes;
function DB(n) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const hT = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
}, Go = {
  obj: (n) => n === Object(n) && !Go.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(n, e, {
    arrays: t = "shallow",
    objects: r = "reference",
    strict: i = !0
  } = {}) {
    if (typeof n != typeof e || !!n != !!e)
      return !1;
    if (Go.str(n) || Go.num(n))
      return n === e;
    const o = Go.obj(n);
    if (o && r === "reference")
      return n === e;
    const l = Go.arr(n);
    if (l && t === "reference")
      return n === e;
    if ((l || o) && n === e)
      return !0;
    let c;
    for (c in n)
      if (!(c in e))
        return !1;
    if (o && t === "shallow" && r === "shallow") {
      for (c in i ? e : n)
        if (!Go.equ(n[c], e[c], {
          strict: i,
          objects: "reference"
        }))
          return !1;
    } else
      for (c in i ? e : n)
        if (n[c] !== e[c])
          return !1;
    if (Go.und(c)) {
      if (l && n.length === 0 && e.length === 0 || o && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (n !== e)
        return !1;
    }
    return !0;
  }
};
function QX(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n)
    e.dispose == null || e.dispose(), delete n[e];
}
function U1(n, e) {
  const t = n;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, n;
}
function PO(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"), i = r.pop();
    return t = r.reduce((o, l) => o[l], n), {
      target: t,
      key: i
    };
  } else
    return {
      target: t,
      key: e
    };
}
const ok = /-\d+$/;
function fL(n, e, t) {
  if (Go.str(t)) {
    if (ok.test(t)) {
      const o = t.replace(ok, ""), {
        target: l,
        key: c
      } = PO(n, o);
      Array.isArray(l[c]) || (l[c] = []);
    }
    const {
      target: r,
      key: i
    } = PO(n, t);
    e.__r3f.previousAttach = r[i], r[i] = e;
  } else
    e.__r3f.previousAttach = t(n, e);
}
function sk(n, e, t) {
  var r, i;
  if (Go.str(t)) {
    const {
      target: o,
      key: l
    } = PO(n, t), c = e.__r3f.previousAttach;
    c === void 0 ? delete o[l] : o[l] = c;
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function LB(n, {
  children: e,
  key: t,
  ref: r,
  ...i
}, {
  children: o,
  key: l,
  ref: c,
  ...h
} = {}, p = !1) {
  var y;
  const x = (y = n == null ? void 0 : n.__r3f) != null ? y : {}, b = Object.entries(i), w = [];
  if (p) {
    const U = Object.keys(h);
    for (let L = 0; L < U.length; L++)
      i.hasOwnProperty(U[L]) || b.unshift([U[L], AB + "remove"]);
  }
  b.forEach(([U, L]) => {
    var A;
    if ((A = n.__r3f) != null && A.primitive && U === "object" || Go.equ(L, h[U]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(U))
      return w.push([U, L, !0, []]);
    let F = [];
    U.includes("-") && (F = U.split("-")), w.push([U, L, !1, F]);
    for (const k in i) {
      const H = i[k];
      k.startsWith(`${U}-`) && w.push([k, H, !1, k.split("-")]);
    }
  });
  const R = {
    ...i
  };
  return x.memoizedProps && x.memoizedProps.args && (R.args = x.memoizedProps.args), x.memoizedProps && x.memoizedProps.attach && (R.attach = x.memoizedProps.attach), {
    memoized: R,
    changes: w
  };
}
const ZX = typeof process < "u" && process.env.NODE_ENV !== "production";
function dL(n, e) {
  var t, r, i;
  const o = (t = n.__r3f) != null ? t : {}, l = o.root, c = (r = l == null || l.getState == null ? void 0 : l.getState()) != null ? r : {}, {
    memoized: h,
    changes: p
  } = KX(e) ? e : LB(n, e), y = o.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = h);
  for (let b = 0; b < p.length; b++) {
    let [w, R, U, L] = p[b];
    if (cL(n)) {
      const H = "srgb", B = "srgb-linear";
      w === "encoding" ? (w = "colorSpace", R = R === 3001 ? H : B) : w === "outputEncoding" && (w = "outputColorSpace", R = R === 3001 ? H : B);
    }
    let A = n, F = A[w];
    if (L.length && (F = L.reduce((k, H) => k[H], n), !(F && F.set))) {
      const [k, ...H] = L.reverse();
      A = H.reverse().reduce((B, $) => B[$], n), w = k;
    }
    if (R === AB + "remove")
      if (A.constructor) {
        let k = ak.get(A.constructor);
        k || (k = new A.constructor(), ak.set(A.constructor, k)), R = k[w];
      } else
        R = 0;
    if (U)
      R ? o.handlers[w] = R : delete o.handlers[w], o.eventCount = Object.keys(o.handlers).length;
    else if (F && F.set && (F.copy || F instanceof fx)) {
      if (Array.isArray(R))
        F.fromArray ? F.fromArray(R) : F.set(...R);
      else if (F.copy && R && R.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (ZX ? F.constructor.name === R.constructor.name : F.constructor === R.constructor))
        F.copy(R);
      else if (R !== void 0) {
        const k = F instanceof Rn;
        !k && F.setScalar ? F.setScalar(R) : F instanceof fx && R instanceof fx ? F.mask = R.mask : F.set(R), !wB() && !c.linear && k && F.convertSRGBToLinear();
      }
    } else if (A[w] = R, A[w] instanceof cs && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
    A[w].format === Td && A[w].type === bv) {
      const k = A[w];
      cL(k) && cL(c.gl) ? k.colorSpace = c.gl.outputColorSpace : k.encoding = c.gl.outputEncoding;
    }
    N1(n);
  }
  if (o.parent && c.internal && n.raycast && y !== o.eventCount) {
    const b = c.internal.interaction.indexOf(n);
    b > -1 && c.internal.interaction.splice(b, 1), o.eventCount && c.internal.interaction.push(n);
  }
  return !(p.length === 1 && p[0][0] === "onUpdate") && p.length && (i = n.__r3f) != null && i.parent && UO(n), n;
}
function N1(n) {
  var e, t;
  const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function UO(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function JX(n, e) {
  n.manual || (MB(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld());
}
function KC(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function eq() {
  var n;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e)
    return B1.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return B1.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return B1.ContinuousEventPriority;
    default:
      return B1.DefaultEventPriority;
  }
}
function OB(n, e, t, r) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function tq(n, e) {
  const {
    internal: t
  } = n.getState();
  t.interaction = t.interaction.filter((r) => r !== e), t.initialHits = t.initialHits.filter((r) => r !== e), t.hovered.forEach((r, i) => {
    (r.eventObject === e || r.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((r, i) => {
    OB(t.capturedMap, e, r, i);
  });
}
function nq(n) {
  function e(h) {
    const {
      internal: p
    } = n.getState(), y = h.offsetX - p.initialClick[0], x = h.offsetY - p.initialClick[1];
    return Math.round(Math.sqrt(y * y + x * x));
  }
  function t(h) {
    return h.filter((p) => ["Move", "Over", "Enter", "Out", "Leave"].some((y) => {
      var x;
      return (x = p.__r3f) == null ? void 0 : x.handlers["onPointer" + y];
    }));
  }
  function r(h, p) {
    const y = n.getState(), x = /* @__PURE__ */ new Set(), b = [], w = p ? p(y.internal.interaction) : y.internal.interaction;
    for (let A = 0; A < w.length; A++) {
      const F = hT(w[A]);
      F && (F.raycaster.camera = void 0);
    }
    y.previousRoot || y.events.compute == null || y.events.compute(h, y);
    function R(A) {
      const F = hT(A);
      if (!F || !F.events.enabled || F.raycaster.camera === null)
        return [];
      if (F.raycaster.camera === void 0) {
        var k;
        F.events.compute == null || F.events.compute(h, F, (k = F.previousRoot) == null ? void 0 : k.getState()), F.raycaster.camera === void 0 && (F.raycaster.camera = null);
      }
      return F.raycaster.camera ? F.raycaster.intersectObject(A, !0) : [];
    }
    let U = w.flatMap(R).sort((A, F) => {
      const k = hT(A.object), H = hT(F.object);
      return !k || !H ? A.distance - F.distance : H.events.priority - k.events.priority || A.distance - F.distance;
    }).filter((A) => {
      const F = KC(A);
      return x.has(F) ? !1 : (x.add(F), !0);
    });
    y.events.filter && (U = y.events.filter(U, y));
    for (const A of U) {
      let F = A.object;
      for (; F; ) {
        var L;
        (L = F.__r3f) != null && L.eventCount && b.push({
          ...A,
          eventObject: F
        }), F = F.parent;
      }
    }
    if ("pointerId" in h && y.internal.capturedMap.has(h.pointerId))
      for (let A of y.internal.capturedMap.get(h.pointerId).values())
        x.has(KC(A.intersection)) || b.push(A.intersection);
    return b;
  }
  function i(h, p, y, x) {
    const b = n.getState();
    if (h.length) {
      const w = {
        stopped: !1
      };
      for (const R of h) {
        const U = hT(R.object) || b, {
          raycaster: L,
          pointer: A,
          camera: F,
          internal: k
        } = U, H = new Te(A.x, A.y, 0).unproject(F), B = (X) => {
          var le, oe;
          return (le = (oe = k.capturedMap.get(X)) == null ? void 0 : oe.has(R.eventObject)) != null ? le : !1;
        }, $ = (X) => {
          const le = {
            intersection: R,
            target: p.target
          };
          k.capturedMap.has(X) ? k.capturedMap.get(X).set(R.eventObject, le) : k.capturedMap.set(X, /* @__PURE__ */ new Map([[R.eventObject, le]])), p.target.setPointerCapture(X);
        }, Y = (X) => {
          const le = k.capturedMap.get(X);
          le && OB(k.capturedMap, R.eventObject, le, X);
        };
        let J = {};
        for (let X in p) {
          let le = p[X];
          typeof le != "function" && (J[X] = le);
        }
        let K = {
          ...R,
          ...J,
          pointer: A,
          intersections: h,
          stopped: w.stopped,
          delta: y,
          unprojectedPoint: H,
          ray: L.ray,
          camera: F,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const X = "pointerId" in p && k.capturedMap.get(p.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!X || // ... or if the hit object is capturing the pointer
              X.has(R.eventObject)) && (K.stopped = w.stopped = !0, k.hovered.size && Array.from(k.hovered.values()).find((le) => le.eventObject === R.eventObject))
            ) {
              const le = h.slice(0, h.indexOf(R));
              o([...le, R]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: B,
            setPointerCapture: $,
            releasePointerCapture: Y
          },
          currentTarget: {
            hasPointerCapture: B,
            setPointerCapture: $,
            releasePointerCapture: Y
          },
          nativeEvent: p
        };
        if (x(K), w.stopped === !0)
          break;
      }
    }
    return h;
  }
  function o(h) {
    const {
      internal: p
    } = n.getState();
    for (const y of p.hovered.values())
      if (!h.length || !h.find((x) => x.object === y.object && x.index === y.index && x.instanceId === y.instanceId)) {
        const b = y.eventObject.__r3f, w = b == null ? void 0 : b.handlers;
        if (p.hovered.delete(KC(y)), b != null && b.eventCount) {
          const R = {
            ...y,
            intersections: h
          };
          w.onPointerOut == null || w.onPointerOut(R), w.onPointerLeave == null || w.onPointerLeave(R);
        }
      }
  }
  function l(h, p) {
    for (let y = 0; y < p.length; y++) {
      const x = p[y].__r3f;
      x == null || x.handlers.onPointerMissed == null || x.handlers.onPointerMissed(h);
    }
  }
  function c(h) {
    switch (h) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (p) => {
          const {
            internal: y
          } = n.getState();
          "pointerId" in p && y.capturedMap.has(p.pointerId) && requestAnimationFrame(() => {
            y.capturedMap.has(p.pointerId) && (y.capturedMap.delete(p.pointerId), o([]));
          });
        };
    }
    return function(y) {
      const {
        onPointerMissed: x,
        internal: b
      } = n.getState();
      b.lastEvent.current = y;
      const w = h === "onPointerMove", R = h === "onClick" || h === "onContextMenu" || h === "onDoubleClick", L = r(y, w ? t : void 0), A = R ? e(y) : 0;
      h === "onPointerDown" && (b.initialClick = [y.offsetX, y.offsetY], b.initialHits = L.map((k) => k.eventObject)), R && !L.length && A <= 2 && (l(y, b.interaction), x && x(y)), w && o(L);
      function F(k) {
        const H = k.eventObject, B = H.__r3f, $ = B == null ? void 0 : B.handlers;
        if (B != null && B.eventCount)
          if (w) {
            if ($.onPointerOver || $.onPointerEnter || $.onPointerOut || $.onPointerLeave) {
              const Y = KC(k), J = b.hovered.get(Y);
              J ? J.stopped && k.stopPropagation() : (b.hovered.set(Y, k), $.onPointerOver == null || $.onPointerOver(k), $.onPointerEnter == null || $.onPointerEnter(k));
            }
            $.onPointerMove == null || $.onPointerMove(k);
          } else {
            const Y = $[h];
            Y ? (!R || b.initialHits.includes(H)) && (l(y, b.interaction.filter((J) => !b.initialHits.includes(J))), Y(k)) : R && b.initialHits.includes(H) && l(y, b.interaction.filter((J) => !b.initialHits.includes(J)));
          }
      }
      i(L, y, A, F);
    };
  }
  return {
    handlePointer: c
  };
}
const PB = (n) => !!(n != null && n.render), UB = /* @__PURE__ */ Cn.createContext(null), rq = (n, e) => {
  const t = TB((c, h) => {
    const p = new Te(), y = new Te(), x = new Te();
    function b(A = h().camera, F = y, k = h().size) {
      const {
        width: H,
        height: B,
        top: $,
        left: Y
      } = k, J = H / B;
      F instanceof Te ? x.copy(F) : x.set(...F);
      const K = A.getWorldPosition(p).distanceTo(x);
      if (MB(A))
        return {
          width: H / A.zoom,
          height: B / A.zoom,
          top: $,
          left: Y,
          factor: 1,
          distance: K,
          aspect: J
        };
      {
        const X = A.fov * Math.PI / 180, le = 2 * Math.tan(X / 2) * K, oe = le * (H / B);
        return {
          width: oe,
          height: le,
          top: $,
          left: Y,
          factor: H / oe,
          distance: K,
          aspect: J
        };
      }
    }
    let w;
    const R = (A) => c((F) => ({
      performance: {
        ...F.performance,
        current: A
      }
    })), U = new Ht();
    return {
      set: c,
      get: h,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (A = 1) => n(h(), A),
      advance: (A, F) => e(A, F, h()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new e3(),
      pointer: U,
      mouse: U,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const A = h();
          w && clearTimeout(w), A.performance.current !== A.performance.min && R(A.performance.min), w = setTimeout(() => R(h().performance.max), A.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: b
      },
      setEvents: (A) => c((F) => ({
        ...F,
        events: {
          ...F.events,
          ...A
        }
      })),
      setSize: (A, F, k, H, B) => {
        const $ = h().camera, Y = {
          width: A,
          height: F,
          top: H || 0,
          left: B || 0,
          updateStyle: k
        };
        c((J) => ({
          size: Y,
          viewport: {
            ...J.viewport,
            ...b($, y, Y)
          }
        }));
      },
      setDpr: (A) => c((F) => {
        const k = DB(A);
        return {
          viewport: {
            ...F.viewport,
            dpr: k,
            initialDpr: F.viewport.initialDpr || k
          }
        };
      }),
      setFrameloop: (A = "always") => {
        const F = h().clock;
        F.stop(), F.elapsedTime = 0, A !== "never" && (F.start(), F.elapsedTime = 0), c(() => ({
          frameloop: A
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Cn.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (A, F, k) => {
          const H = h().internal;
          return H.priority = H.priority + (F > 0 ? 1 : 0), H.subscribers.push({
            ref: A,
            priority: F,
            store: k
          }), H.subscribers = H.subscribers.sort((B, $) => B.priority - $.priority), () => {
            const B = h().internal;
            B != null && B.subscribers && (B.priority = B.priority - (F > 0 ? 1 : 0), B.subscribers = B.subscribers.filter(($) => $.ref !== A));
          };
        }
      }
    };
  }), r = t.getState();
  let i = r.size, o = r.viewport.dpr, l = r.camera;
  return t.subscribe(() => {
    const {
      camera: c,
      size: h,
      viewport: p,
      gl: y,
      set: x
    } = t.getState();
    if (h.width !== i.width || h.height !== i.height || p.dpr !== o) {
      var b;
      i = h, o = p.dpr, JX(c, h), y.setPixelRatio(p.dpr);
      const w = (b = h.updateStyle) != null ? b : typeof HTMLCanvasElement < "u" && y.domElement instanceof HTMLCanvasElement;
      y.setSize(h.width, h.height, w);
    }
    c !== l && (l = c, x((w) => ({
      viewport: {
        ...w.viewport,
        ...w.viewport.getCurrentViewport(c)
      }
    })));
  }), t.subscribe((c) => n(c)), t;
};
let QC, iq = /* @__PURE__ */ new Set(), aq = /* @__PURE__ */ new Set(), oq = /* @__PURE__ */ new Set();
function hL(n, e) {
  if (n.size)
    for (const {
      callback: t
    } of n.values())
      t(e);
}
function pT(n, e) {
  switch (n) {
    case "before":
      return hL(iq, e);
    case "after":
      return hL(aq, e);
    case "tail":
      return hL(oq, e);
  }
}
let pL, mL;
function vL(n, e, t) {
  let r = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), pL = e.internal.subscribers, QC = 0; QC < pL.length; QC++)
    mL = pL[QC], mL.ref.current(mL.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function sq(n) {
  let e = !1, t, r, i;
  function o(h) {
    r = requestAnimationFrame(o), e = !0, t = 0, pT("before", h);
    for (const y of n.values()) {
      var p;
      i = y.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((p = i.gl.xr) != null && p.isPresenting) && (t += vL(h, i));
    }
    if (pT("after", h), t === 0)
      return pT("tail", h), e = !1, cancelAnimationFrame(r);
  }
  function l(h, p = 1) {
    var y;
    if (!h)
      return n.forEach((x) => l(x.store.getState()), p);
    (y = h.gl.xr) != null && y.isPresenting || !h.internal.active || h.frameloop === "never" || (h.internal.frames = Math.min(60, h.internal.frames + p), e || (e = !0, requestAnimationFrame(o)));
  }
  function c(h, p = !0, y, x) {
    if (p && pT("before", h), y)
      vL(h, y, x);
    else
      for (const b of n.values())
        vL(h, b.store.getState());
    p && pT("after", h);
  }
  return {
    loop: o,
    /**
     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate
     */
    invalidate: l,
    /**
     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop="never"`.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance
     */
    advance: c
  };
}
function NB() {
  const n = Cn.useContext(UB);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function cm(n = (t) => t, e) {
  return NB()(n, e);
}
function a3(n, e = 0) {
  const t = NB(), r = t.getState().internal.subscribe, i = CB(n);
  return hw(() => r(i, e, t), [e, r, t]), null;
}
const Q1 = /* @__PURE__ */ new Map(), {
  invalidate: lk,
  advance: uk
} = sq(Q1), {
  reconciler: AR,
  applyProps: R1
} = YX(Q1, eq), A1 = {
  objects: "shallow",
  strict: !1
}, lq = (n, e) => {
  const t = typeof n == "function" ? n(e) : n;
  return PB(t) ? t : new NP({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...n
  });
};
function uq(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: r,
      height: i,
      top: o,
      left: l,
      updateStyle: c = t
    } = e;
    return {
      width: r,
      height: i,
      top: o,
      left: l,
      updateStyle: c
    };
  } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
    const {
      width: r,
      height: i,
      top: o,
      left: l
    } = n.parentElement.getBoundingClientRect();
    return {
      width: r,
      height: i,
      top: o,
      left: l,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function cq(n) {
  const e = Q1.get(n), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), o = r || rq(lk, uk), l = t || AR.createContainer(o, B1.ConcurrentRoot, null, !1, null, "", i, null);
  e || Q1.set(n, {
    fiber: l,
    store: o
  });
  let c, h = !1, p;
  return {
    configure(y = {}) {
      let {
        gl: x,
        size: b,
        scene: w,
        events: R,
        onCreated: U,
        shadows: L = !1,
        linear: A = !1,
        flat: F = !1,
        legacy: k = !1,
        orthographic: H = !1,
        frameloop: B = "always",
        dpr: $ = [1, 2],
        performance: Y,
        raycaster: J,
        camera: K,
        onPointerMissed: X
      } = y, le = o.getState(), oe = le.gl;
      le.gl || le.set({
        gl: oe = lq(x, n)
      });
      let fe = le.raycaster;
      fe || le.set({
        raycaster: fe = new EB()
      });
      const {
        params: de,
        ...xe
      } = J || {};
      if (Go.equ(xe, fe, A1) || R1(fe, {
        ...xe
      }), Go.equ(de, fe.params, A1) || R1(fe, {
        params: {
          ...fe.params,
          ...de
        }
      }), !le.camera || le.camera === p && !Go.equ(p, K, A1)) {
        p = K;
        const he = K instanceof sw, Me = he ? K : H ? new Vg(0, 0, 0, 0, 0.1, 1e3) : new Ps(75, 0, 0.1, 1e3);
        he || (Me.position.z = 5, K && R1(Me, K), !le.camera && !(K != null && K.rotation) && Me.lookAt(0, 0, 0)), le.set({
          camera: Me
        }), fe.camera = Me;
      }
      if (!le.scene) {
        let he;
        w instanceof CR ? he = w : (he = new CR(), w && R1(he, w)), le.set({
          scene: U1(he)
        });
      }
      if (!le.xr) {
        var _e;
        const he = (Ae, Ue) => {
          const Ne = o.getState();
          Ne.frameloop !== "never" && uk(Ae, !0, Ne, Ue);
        }, Me = () => {
          const Ae = o.getState();
          Ae.gl.xr.enabled = Ae.gl.xr.isPresenting, Ae.gl.xr.setAnimationLoop(Ae.gl.xr.isPresenting ? he : null), Ae.gl.xr.isPresenting || lk(Ae);
        }, Le = {
          connect() {
            const Ae = o.getState().gl;
            Ae.xr.addEventListener("sessionstart", Me), Ae.xr.addEventListener("sessionend", Me);
          },
          disconnect() {
            const Ae = o.getState().gl;
            Ae.xr.removeEventListener("sessionstart", Me), Ae.xr.removeEventListener("sessionend", Me);
          }
        };
        typeof ((_e = oe.xr) == null ? void 0 : _e.addEventListener) == "function" && Le.connect(), le.set({
          xr: Le
        });
      }
      if (oe.shadowMap) {
        const he = oe.shadowMap.enabled, Me = oe.shadowMap.type;
        if (oe.shadowMap.enabled = !!L, Go.boo(L))
          oe.shadowMap.type = bT;
        else if (Go.str(L)) {
          var Pe;
          const Le = {
            basic: _I,
            percentage: $R,
            soft: bT,
            variance: um
          };
          oe.shadowMap.type = (Pe = Le[L]) != null ? Pe : bT;
        } else
          Go.obj(L) && Object.assign(oe.shadowMap, L);
        (he !== oe.shadowMap.enabled || Me !== oe.shadowMap.type) && (oe.shadowMap.needsUpdate = !0);
      }
      const ce = wB();
      ce && ("enabled" in ce ? ce.enabled = !k : "legacyMode" in ce && (ce.legacyMode = k)), R1(oe, {
        outputEncoding: A ? 3e3 : 3001,
        toneMapping: F ? Ev : gP
      }), le.legacy !== k && le.set(() => ({
        legacy: k
      })), le.linear !== A && le.set(() => ({
        linear: A
      })), le.flat !== F && le.set(() => ({
        flat: F
      })), x && !Go.fun(x) && !PB(x) && !Go.equ(x, oe, A1) && R1(oe, x), R && !le.events.handlers && le.set({
        events: R(o)
      });
      const ee = uq(n, b);
      return Go.equ(ee, le.size, A1) || le.setSize(ee.width, ee.height, ee.updateStyle, ee.top, ee.left), $ && le.viewport.dpr !== DB($) && le.setDpr($), le.frameloop !== B && le.setFrameloop(B), le.onPointerMissed || le.set({
        onPointerMissed: X
      }), Y && !Go.equ(Y, le.performance, A1) && le.set((he) => ({
        performance: {
          ...he.performance,
          ...Y
        }
      })), c = U, h = !0, this;
    },
    render(y) {
      return h || this.configure(), AR.updateContainer(/* @__PURE__ */ Cn.createElement(fq, {
        store: o,
        children: y,
        onCreated: c,
        rootElement: n
      }), l, null, () => {
      }), o;
    },
    unmount() {
      FB(n);
    }
  };
}
function fq({
  store: n,
  children: e,
  onCreated: t,
  rootElement: r
}) {
  return hw(() => {
    const i = n.getState();
    i.set((o) => ({
      internal: {
        ...o.internal,
        active: !0
      }
    })), t && t(i), n.getState().events.connected || i.events.connect == null || i.events.connect(r);
  }, []), /* @__PURE__ */ Cn.createElement(UB.Provider, {
    value: n
  }, e);
}
function FB(n, e) {
  const t = Q1.get(n), r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1), AR.updateContainer(null, r, null, () => {
      i && setTimeout(() => {
        try {
          var o, l, c, h;
          i.events.disconnect == null || i.events.disconnect(), (o = i.gl) == null || (l = o.renderLists) == null || l.dispose == null || l.dispose(), (c = i.gl) == null || c.forceContextLoss == null || c.forceContextLoss(), (h = i.gl) != null && h.xr && i.xr.disconnect(), QX(i), Q1.delete(n), e && e(n);
        } catch {
        }
      }, 500);
    });
  }
}
AR.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Cn.version
});
function fs() {
  return fs = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, fs.apply(this, arguments);
}
function NO(n, e, t) {
  var r, i, o, l, c;
  e == null && (e = 100);
  function h() {
    var y = Date.now() - l;
    y < e && y >= 0 ? r = setTimeout(h, e - y) : (r = null, t || (c = n.apply(o, i), o = i = null));
  }
  var p = function() {
    o = this, i = arguments, l = Date.now();
    var y = t && !r;
    return r || (r = setTimeout(h, e)), y && (c = n.apply(o, i), o = i = null), c;
  };
  return p.clear = function() {
    r && (clearTimeout(r), r = null);
  }, p.flush = function() {
    r && (c = n.apply(o, i), o = i = null, clearTimeout(r), r = null);
  }, p;
}
NO.debounce = NO;
var dq = NO;
const ck = /* @__PURE__ */ rw(dq);
function hq(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i
  } = n === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : n;
  const o = r || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!o)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [l, c] = Ni({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), h = Sn({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: l
  }), p = e ? typeof e == "number" ? e : e.scroll : null, y = e ? typeof e == "number" ? e : e.resize : null, x = Sn(!1);
  tr(() => (x.current = !0, () => void (x.current = !1)));
  const [b, w, R] = Rl(() => {
    const F = () => {
      if (!h.current.element)
        return;
      const {
        left: k,
        top: H,
        width: B,
        height: $,
        bottom: Y,
        right: J,
        x: K,
        y: X
      } = h.current.element.getBoundingClientRect(), le = {
        left: k,
        top: H,
        width: B,
        height: $,
        bottom: Y,
        right: J,
        x: K,
        y: X
      };
      h.current.element instanceof HTMLElement && i && (le.height = h.current.element.offsetHeight, le.width = h.current.element.offsetWidth), Object.freeze(le), x.current && !gq(h.current.lastBounds, le) && c(h.current.lastBounds = le);
    };
    return [F, y ? ck(F, y) : F, p ? ck(F, p) : F];
  }, [c, i, p, y]);
  function U() {
    h.current.scrollContainers && (h.current.scrollContainers.forEach((F) => F.removeEventListener("scroll", R, !0)), h.current.scrollContainers = null), h.current.resizeObserver && (h.current.resizeObserver.disconnect(), h.current.resizeObserver = null);
  }
  function L() {
    h.current.element && (h.current.resizeObserver = new o(R), h.current.resizeObserver.observe(h.current.element), t && h.current.scrollContainers && h.current.scrollContainers.forEach((F) => F.addEventListener("scroll", R, {
      capture: !0,
      passive: !0
    })));
  }
  const A = (F) => {
    !F || F === h.current.element || (U(), h.current.element = F, h.current.scrollContainers = kB(F), L());
  };
  return mq(R, !!t), pq(w), tr(() => {
    U(), L();
  }, [t, R, w]), tr(() => U, []), [A, l, b];
}
function pq(n) {
  tr(() => {
    const e = n;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n]);
}
function mq(n, e) {
  tr(() => {
    if (e) {
      const t = n;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [n, e]);
}
function kB(n) {
  const e = [];
  if (!n || n === document.body)
    return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i
  } = window.getComputedStyle(n);
  return [t, r, i].some((o) => o === "auto" || o === "scroll") && e.push(n), [...e, ...kB(n.parentElement)];
}
const vq = ["x", "y", "top", "bottom", "left", "right", "width", "height"], gq = (n, e) => vq.every((t) => n[t] === e[t]);
var yq = Object.defineProperty, Sq = Object.defineProperties, xq = Object.getOwnPropertyDescriptors, fk = Object.getOwnPropertySymbols, _q = Object.prototype.hasOwnProperty, Eq = Object.prototype.propertyIsEnumerable, dk = (n, e, t) => e in n ? yq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, hk = (n, e) => {
  for (var t in e || (e = {}))
    _q.call(e, t) && dk(n, t, e[t]);
  if (fk)
    for (var t of fk(e))
      Eq.call(e, t) && dk(n, t, e[t]);
  return n;
}, bq = (n, e) => Sq(n, xq(e));
function zB(n, e, t) {
  if (!n)
    return;
  if (t(n) === !0)
    return n;
  let r = e ? n.return : n.child;
  for (; r; ) {
    const i = zB(r, e, t);
    if (i)
      return i;
    r = e ? null : r.sibling;
  }
}
function IB(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return n;
  }
}
const o3 = IB(Cn.createContext(null));
class BB extends Cn.Component {
  render() {
    return /* @__PURE__ */ Cn.createElement(o3.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
const { ReactCurrentOwner: pk, ReactCurrentDispatcher: mk } = Cn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function Tq() {
  const n = Cn.useContext(o3);
  if (n === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = Cn.useId();
  return Cn.useMemo(() => {
    for (const r of [pk == null ? void 0 : pk.current, n, n == null ? void 0 : n.alternate]) {
      if (!r)
        continue;
      const i = zB(r, !1, (o) => {
        let l = o.memoizedState;
        for (; l; ) {
          if (l.memoizedState === e)
            return !0;
          l = l.next;
        }
      });
      if (i)
        return i;
    }
  }, [n, e]);
}
function wq() {
  var n, e;
  const t = Tq(), [r] = Cn.useState(() => /* @__PURE__ */ new Map());
  r.clear();
  let i = t;
  for (; i; ) {
    const o = (n = i.type) == null ? void 0 : n._context;
    o && o !== o3 && !r.has(o) && r.set(o, (e = mk == null ? void 0 : mk.current) == null ? void 0 : e.readContext(IB(o))), i = i.return;
  }
  return r;
}
function Mq() {
  const n = wq();
  return Cn.useMemo(
    () => Array.from(n.keys()).reduce(
      (e, t) => (r) => /* @__PURE__ */ Cn.createElement(e, null, /* @__PURE__ */ Cn.createElement(t.Provider, bq(hk({}, r), {
        value: n.get(t)
      }))),
      (e) => /* @__PURE__ */ Cn.createElement(BB, hk({}, e))
    ),
    [n]
  );
}
const gL = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function Cq(n) {
  const {
    handlePointer: e
  } = nq(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(gL).reduce((t, r) => ({
      ...t,
      [r]: e(r)
    }), {}),
    update: () => {
      var t;
      const {
        events: r,
        internal: i
      } = n.getState();
      (t = i.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const {
        set: i,
        events: o
      } = n.getState();
      o.disconnect == null || o.disconnect(), i((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((r = o.handlers) != null ? r : []).forEach(([l, c]) => {
        const [h, p] = gL[l];
        t.addEventListener(h, c, {
          passive: p
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: r
      } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, l]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [c] = gL[o];
            r.connected.removeEventListener(c, l);
          }
        }), t((o) => ({
          events: {
            ...o.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const Rq = /* @__PURE__ */ Cn.forwardRef(function({
  children: e,
  fallback: t,
  resize: r,
  style: i,
  gl: o,
  events: l = Cq,
  eventSource: c,
  eventPrefix: h,
  shadows: p,
  linear: y,
  flat: x,
  legacy: b,
  orthographic: w,
  frameloop: R,
  dpr: U,
  performance: L,
  raycaster: A,
  camera: F,
  scene: k,
  onPointerMissed: H,
  onCreated: B,
  ...$
}, Y) {
  Cn.useMemo(() => $X(LX), []);
  const J = Mq(), [K, X] = hq({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...r
  }), le = Cn.useRef(null), oe = Cn.useRef(null);
  Cn.useImperativeHandle(Y, () => le.current);
  const fe = CB(H), [de, xe] = Cn.useState(!1), [_e, Pe] = Cn.useState(!1);
  if (de)
    throw de;
  if (_e)
    throw _e;
  const ce = Cn.useRef(null);
  hw(() => {
    const re = le.current;
    X.width > 0 && X.height > 0 && re && (ce.current || (ce.current = cq(re)), ce.current.configure({
      gl: o,
      events: l,
      shadows: p,
      linear: y,
      flat: x,
      legacy: b,
      orthographic: w,
      frameloop: R,
      dpr: U,
      performance: L,
      raycaster: A,
      camera: F,
      scene: k,
      size: X,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...ee) => fe.current == null ? void 0 : fe.current(...ee),
      onCreated: (ee) => {
        ee.events.connect == null || ee.events.connect(c ? XX(c) ? c.current : c : oe.current), h && ee.setEvents({
          compute: (he, Me) => {
            const Le = he[h + "X"], Ae = he[h + "Y"];
            Me.pointer.set(Le / Me.size.width * 2 - 1, -(Ae / Me.size.height) * 2 + 1), Me.raycaster.setFromCamera(Me.pointer, Me.camera);
          }
        }), B == null || B(ee);
      }
    }), ce.current.render(/* @__PURE__ */ Cn.createElement(J, null, /* @__PURE__ */ Cn.createElement(RB, {
      set: Pe
    }, /* @__PURE__ */ Cn.createElement(Cn.Suspense, {
      fallback: /* @__PURE__ */ Cn.createElement(qX, {
        set: xe
      })
    }, e)))));
  }), Cn.useEffect(() => {
    const re = le.current;
    if (re)
      return () => FB(re);
  }, []);
  const ve = c ? "none" : "auto";
  return /* @__PURE__ */ Cn.createElement("div", fs({
    ref: oe,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: ve,
      ...i
    }
  }, $), /* @__PURE__ */ Cn.createElement("div", {
    ref: K,
    style: {
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ Cn.createElement("canvas", {
    ref: le,
    style: {
      display: "block"
    }
  }, t)));
}), Aq = /* @__PURE__ */ Cn.forwardRef(function(e, t) {
  return /* @__PURE__ */ Cn.createElement(BB, null, /* @__PURE__ */ Cn.createElement(Rq, fs({}, e, {
    ref: t
  })));
});
function Dq() {
  return new Worker("/assets/splat-sort-worker-9932a6b9.js");
}
const Lq = `
precision mediump float;

attribute vec3 position;

attribute vec4 color;
attribute vec4 quat;
attribute vec3 scale;
attribute vec3 center;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec2 focal;
uniform vec2 viewport;

varying vec4 vColor;
varying vec3 vConic;
varying vec2 vCenter;
varying vec2 vPosition;

mat3 transpose(mat3 m) { return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]); }

mat3 compute_cov3d(vec3 scale, vec4 rot) {
    mat3 S = mat3(
        scale.x, 0.0, 0.0,
        0.0, scale.y, 0.0,
        0.0, 0.0, scale.z
    );
    mat3 R = mat3(
        1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),
        2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),
        2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z)
    );
    mat3 M = S * R;
    return transpose(M) * M;
}

vec3 compute_cov2d(vec3 center, vec3 scale, vec4 rot){
    mat3 Vrk = compute_cov3d(scale, rot);
    vec4 t = modelViewMatrix * vec4(center, 1.0);
    vec2 lims = 1.3 * 0.5 * viewport / focal;
    t.xy = min(lims, max(-lims, t.xy / t.z)) * t.z;
    mat3 J = mat3(
        focal.x / t.z, 0., -(focal.x * t.x) / (t.z * t.z), 
        0., focal.y / t.z, -(focal.y * t.y) / (t.z * t.z), 
        0., 0., 0.
    );
    mat3 W = transpose(mat3(modelViewMatrix));
    mat3 T = W * J;
    mat3 cov = transpose(T) * transpose(Vrk) * T;
    return vec3(cov[0][0] + 0.3, cov[0][1], cov[1][1] + 0.3);
}

void main () {
    vec4 camspace = modelViewMatrix * vec4(center, 1);
    
    vec4 pos2d = projectionMatrix  * camspace;

    vec3 cov2d = compute_cov2d(center, scale, quat);
    float det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;
    vec3 conic = vec3(cov2d.z, cov2d.y, cov2d.x) / det;
    float mid = 0.5 * (cov2d.x + cov2d.z);
    float lambda1 = mid + sqrt(max(0.1, mid * mid - det));
    float lambda2 = mid - sqrt(max(0.1, mid * mid - det));
    vec2 v1 = 7.0 * sqrt(lambda1) * normalize(vec2(cov2d.y, lambda1 - cov2d.x));
    vec2 v2 = 7.0 * sqrt(lambda2) * normalize(vec2(-(lambda1 - cov2d.x),cov2d.y));

    vColor = color;
    vConic = conic;
    vCenter = vec2(pos2d) / pos2d.w;

    vPosition = vec2(vCenter + position.x * (position.y < 0.0 ? v1 : v2) / viewport);
    gl_Position = vec4(vPosition, pos2d.z / pos2d.w, 1);
}
`, Oq = `
precision mediump float;

varying vec4 vColor;
varying vec3 vConic;
varying vec2 vCenter;

uniform vec2 viewport;
uniform vec2 focal;

void main () {    
	vec2 d = (vCenter - 2.0 * (gl_FragCoord.xy/viewport - vec2(0.5, 0.5))) * viewport * 0.5;
    
	float power = -0.5 * (vConic.x * d.x * d.x + vConic.z * d.y * d.y) + vConic.y * d.x * d.y;

	if (power > 0.0) discard;
	float alpha = min(0.99, vColor.a * exp(power));
	if(alpha < 0.02) discard;

    gl_FragColor = vec4(vColor.rgb, alpha);
}
`;
var FO = { exports: {} }, Sd = {}, ZC = { exports: {} }, yL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vk;
function Pq() {
  return vk || (vk = 1, function(n) {
    function e(ce, ve) {
      var re = ce.length;
      ce.push(ve);
      e:
        for (; 0 < re; ) {
          var ee = re - 1 >>> 1, he = ce[ee];
          if (0 < i(he, ve))
            ce[ee] = ve, ce[re] = he, re = ee;
          else
            break e;
        }
    }
    function t(ce) {
      return ce.length === 0 ? null : ce[0];
    }
    function r(ce) {
      if (ce.length === 0)
        return null;
      var ve = ce[0], re = ce.pop();
      if (re !== ve) {
        ce[0] = re;
        e:
          for (var ee = 0, he = ce.length, Me = he >>> 1; ee < Me; ) {
            var Le = 2 * (ee + 1) - 1, Ae = ce[Le], Ue = Le + 1, Ne = ce[Ue];
            if (0 > i(Ae, re))
              Ue < he && 0 > i(Ne, Ae) ? (ce[ee] = Ne, ce[Ue] = re, ee = Ue) : (ce[ee] = Ae, ce[Le] = re, ee = Le);
            else if (Ue < he && 0 > i(Ne, re))
              ce[ee] = Ne, ce[Ue] = re, ee = Ue;
            else
              break e;
          }
      }
      return ve;
    }
    function i(ce, ve) {
      var re = ce.sortIndex - ve.sortIndex;
      return re !== 0 ? re : ce.id - ve.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      n.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, c = l.now();
      n.unstable_now = function() {
        return l.now() - c;
      };
    }
    var h = [], p = [], y = 1, x = null, b = 3, w = !1, R = !1, U = !1, L = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function k(ce) {
      for (var ve = t(p); ve !== null; ) {
        if (ve.callback === null)
          r(p);
        else if (ve.startTime <= ce)
          r(p), ve.sortIndex = ve.expirationTime, e(h, ve);
        else
          break;
        ve = t(p);
      }
    }
    function H(ce) {
      if (U = !1, k(ce), !R)
        if (t(h) !== null)
          R = !0, _e(B);
        else {
          var ve = t(p);
          ve !== null && Pe(H, ve.startTime - ce);
        }
    }
    function B(ce, ve) {
      R = !1, U && (U = !1, A(J), J = -1), w = !0;
      var re = b;
      try {
        for (k(ve), x = t(h); x !== null && (!(x.expirationTime > ve) || ce && !le()); ) {
          var ee = x.callback;
          if (typeof ee == "function") {
            x.callback = null, b = x.priorityLevel;
            var he = ee(x.expirationTime <= ve);
            ve = n.unstable_now(), typeof he == "function" ? x.callback = he : x === t(h) && r(h), k(ve);
          } else
            r(h);
          x = t(h);
        }
        if (x !== null)
          var Me = !0;
        else {
          var Le = t(p);
          Le !== null && Pe(H, Le.startTime - ve), Me = !1;
        }
        return Me;
      } finally {
        x = null, b = re, w = !1;
      }
    }
    var $ = !1, Y = null, J = -1, K = 5, X = -1;
    function le() {
      return !(n.unstable_now() - X < K);
    }
    function oe() {
      if (Y !== null) {
        var ce = n.unstable_now();
        X = ce;
        var ve = !0;
        try {
          ve = Y(!0, ce);
        } finally {
          ve ? fe() : ($ = !1, Y = null);
        }
      } else
        $ = !1;
    }
    var fe;
    if (typeof F == "function")
      fe = function() {
        F(oe);
      };
    else if (typeof MessageChannel < "u") {
      var de = new MessageChannel(), xe = de.port2;
      de.port1.onmessage = oe, fe = function() {
        xe.postMessage(null);
      };
    } else
      fe = function() {
        L(oe, 0);
      };
    function _e(ce) {
      Y = ce, $ || ($ = !0, fe());
    }
    function Pe(ce, ve) {
      J = L(function() {
        ce(n.unstable_now());
      }, ve);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(ce) {
      ce.callback = null;
    }, n.unstable_continueExecution = function() {
      R || w || (R = !0, _e(B));
    }, n.unstable_forceFrameRate = function(ce) {
      0 > ce || 125 < ce ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < ce ? Math.floor(1e3 / ce) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, n.unstable_next = function(ce) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var ve = 3;
          break;
        default:
          ve = b;
      }
      var re = b;
      b = ve;
      try {
        return ce();
      } finally {
        b = re;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(ce, ve) {
      switch (ce) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ce = 3;
      }
      var re = b;
      b = ce;
      try {
        return ve();
      } finally {
        b = re;
      }
    }, n.unstable_scheduleCallback = function(ce, ve, re) {
      var ee = n.unstable_now();
      switch (typeof re == "object" && re !== null ? (re = re.delay, re = typeof re == "number" && 0 < re ? ee + re : ee) : re = ee, ce) {
        case 1:
          var he = -1;
          break;
        case 2:
          he = 250;
          break;
        case 5:
          he = 1073741823;
          break;
        case 4:
          he = 1e4;
          break;
        default:
          he = 5e3;
      }
      return he = re + he, ce = { id: y++, callback: ve, priorityLevel: ce, startTime: re, expirationTime: he, sortIndex: -1 }, re > ee ? (ce.sortIndex = re, e(p, ce), t(h) === null && ce === t(p) && (U ? (A(J), J = -1) : U = !0, Pe(H, re - ee))) : (ce.sortIndex = he, e(h, ce), R || w || (R = !0, _e(B))), ce;
    }, n.unstable_shouldYield = le, n.unstable_wrapCallback = function(ce) {
      var ve = b;
      return function() {
        var re = b;
        b = ve;
        try {
          return ce.apply(this, arguments);
        } finally {
          b = re;
        }
      };
    };
  }(yL)), yL;
}
var SL = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gk;
function Uq() {
  return gk || (gk = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(Se, He) {
        var lt = Se.length;
        Se.push(He), c(Se, He, lt);
      }
      function o(Se) {
        return Se.length === 0 ? null : Se[0];
      }
      function l(Se) {
        if (Se.length === 0)
          return null;
        var He = Se[0], lt = Se.pop();
        return lt !== He && (Se[0] = lt, h(Se, lt, 0)), He;
      }
      function c(Se, He, lt) {
        for (var St = lt; St > 0; ) {
          var Je = St - 1 >>> 1, be = Se[Je];
          if (p(be, He) > 0)
            Se[Je] = He, Se[St] = be, St = Je;
          else
            return;
        }
      }
      function h(Se, He, lt) {
        for (var St = lt, Je = Se.length, be = Je >>> 1; St < be; ) {
          var Ze = (St + 1) * 2 - 1, ct = Se[Ze], pe = Ze + 1, Rt = Se[pe];
          if (p(ct, He) < 0)
            pe < Je && p(Rt, ct) < 0 ? (Se[St] = Rt, Se[pe] = He, St = pe) : (Se[St] = ct, Se[Ze] = He, St = Ze);
          else if (pe < Je && p(Rt, He) < 0)
            Se[St] = Rt, Se[pe] = He, St = pe;
          else
            return;
        }
      }
      function p(Se, He) {
        var lt = Se.sortIndex - He.sortIndex;
        return lt !== 0 ? lt : Se.id - He.id;
      }
      var y = 1, x = 2, b = 3, w = 4, R = 5;
      function U(Se, He) {
      }
      var L = typeof performance == "object" && typeof performance.now == "function";
      if (L) {
        var A = performance;
        n.unstable_now = function() {
          return A.now();
        };
      } else {
        var F = Date, k = F.now();
        n.unstable_now = function() {
          return F.now() - k;
        };
      }
      var H = 1073741823, B = -1, $ = 250, Y = 5e3, J = 1e4, K = H, X = [], le = [], oe = 1, fe = null, de = b, xe = !1, _e = !1, Pe = !1, ce = typeof setTimeout == "function" ? setTimeout : null, ve = typeof clearTimeout == "function" ? clearTimeout : null, re = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ee(Se) {
        for (var He = o(le); He !== null; ) {
          if (He.callback === null)
            l(le);
          else if (He.startTime <= Se)
            l(le), He.sortIndex = He.expirationTime, i(X, He);
          else
            return;
          He = o(le);
        }
      }
      function he(Se) {
        if (Pe = !1, ee(Se), !_e)
          if (o(X) !== null)
            _e = !0, _t(Me);
          else {
            var He = o(le);
            He !== null && ot(he, He.startTime - Se);
          }
      }
      function Me(Se, He) {
        _e = !1, Pe && (Pe = !1, at()), xe = !0;
        var lt = de;
        try {
          var St;
          if (!t)
            return Le(Se, He);
        } finally {
          fe = null, de = lt, xe = !1;
        }
      }
      function Le(Se, He) {
        var lt = He;
        for (ee(lt), fe = o(X); fe !== null && !e && !(fe.expirationTime > lt && (!Se || Ct())); ) {
          var St = fe.callback;
          if (typeof St == "function") {
            fe.callback = null, de = fe.priorityLevel;
            var Je = fe.expirationTime <= lt, be = St(Je);
            lt = n.unstable_now(), typeof be == "function" ? fe.callback = be : fe === o(X) && l(X), ee(lt);
          } else
            l(X);
          fe = o(X);
        }
        if (fe !== null)
          return !0;
        var Ze = o(le);
        return Ze !== null && ot(he, Ze.startTime - lt), !1;
      }
      function Ae(Se, He) {
        switch (Se) {
          case y:
          case x:
          case b:
          case w:
          case R:
            break;
          default:
            Se = b;
        }
        var lt = de;
        de = Se;
        try {
          return He();
        } finally {
          de = lt;
        }
      }
      function Ue(Se) {
        var He;
        switch (de) {
          case y:
          case x:
          case b:
            He = b;
            break;
          default:
            He = de;
            break;
        }
        var lt = de;
        de = He;
        try {
          return Se();
        } finally {
          de = lt;
        }
      }
      function Ne(Se) {
        var He = de;
        return function() {
          var lt = de;
          de = He;
          try {
            return Se.apply(this, arguments);
          } finally {
            de = lt;
          }
        };
      }
      function ke(Se, He, lt) {
        var St = n.unstable_now(), Je;
        if (typeof lt == "object" && lt !== null) {
          var be = lt.delay;
          typeof be == "number" && be > 0 ? Je = St + be : Je = St;
        } else
          Je = St;
        var Ze;
        switch (Se) {
          case y:
            Ze = B;
            break;
          case x:
            Ze = $;
            break;
          case R:
            Ze = K;
            break;
          case w:
            Ze = J;
            break;
          case b:
          default:
            Ze = Y;
            break;
        }
        var ct = Je + Ze, pe = {
          id: oe++,
          callback: He,
          priorityLevel: Se,
          startTime: Je,
          expirationTime: ct,
          sortIndex: -1
        };
        return Je > St ? (pe.sortIndex = Je, i(le, pe), o(X) === null && pe === o(le) && (Pe ? at() : Pe = !0, ot(he, Je - St))) : (pe.sortIndex = ct, i(X, pe), !_e && !xe && (_e = !0, _t(Me))), pe;
      }
      function it() {
      }
      function At() {
        !_e && !xe && (_e = !0, _t(Me));
      }
      function rt() {
        return o(X);
      }
      function ae(Se) {
        Se.callback = null;
      }
      function et() {
        return de;
      }
      var Ye = !1, Ge = null, $e = -1, Ut = r, nt = -1;
      function Ct() {
        var Se = n.unstable_now() - nt;
        return !(Se < Ut);
      }
      function Pt() {
      }
      function vt(Se) {
        if (Se < 0 || Se > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Se > 0 ? Ut = Math.floor(1e3 / Se) : Ut = r;
      }
      var Zt = function() {
        if (Ge !== null) {
          var Se = n.unstable_now();
          nt = Se;
          var He = !0, lt = !0;
          try {
            lt = Ge(He, Se);
          } finally {
            lt ? ie() : (Ye = !1, Ge = null);
          }
        } else
          Ye = !1;
      }, ie;
      if (typeof re == "function")
        ie = function() {
          re(Zt);
        };
      else if (typeof MessageChannel < "u") {
        var ne = new MessageChannel(), Oe = ne.port2;
        ne.port1.onmessage = Zt, ie = function() {
          Oe.postMessage(null);
        };
      } else
        ie = function() {
          ce(Zt, 0);
        };
      function _t(Se) {
        Ge = Se, Ye || (Ye = !0, ie());
      }
      function ot(Se, He) {
        $e = ce(function() {
          Se(n.unstable_now());
        }, He);
      }
      function at() {
        ve($e), $e = -1;
      }
      var Wt = Pt, Dt = null;
      n.unstable_IdlePriority = R, n.unstable_ImmediatePriority = y, n.unstable_LowPriority = w, n.unstable_NormalPriority = b, n.unstable_Profiling = Dt, n.unstable_UserBlockingPriority = x, n.unstable_cancelCallback = ae, n.unstable_continueExecution = At, n.unstable_forceFrameRate = vt, n.unstable_getCurrentPriorityLevel = et, n.unstable_getFirstCallbackNode = rt, n.unstable_next = Ue, n.unstable_pauseExecution = it, n.unstable_requestPaint = Wt, n.unstable_runWithPriority = Ae, n.unstable_scheduleCallback = ke, n.unstable_shouldYield = Ct, n.unstable_wrapCallback = Ne, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(SL)), SL;
}
var yk;
function HB() {
  return yk || (yk = 1, process.env.NODE_ENV === "production" ? ZC.exports = Pq() : ZC.exports = Uq()), ZC.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Sk;
function Nq() {
  if (Sk)
    return Sd;
  Sk = 1;
  var n = Fe, e = HB();
  function t(f) {
    for (var m = "https://reactjs.org/docs/error-decoder.html?invariant=" + f, E = 1; E < arguments.length; E++)
      m += "&args[]=" + encodeURIComponent(arguments[E]);
    return "Minified React error #" + f + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function o(f, m) {
    l(f, m), l(f + "Capture", m);
  }
  function l(f, m) {
    for (i[f] = m, f = 0; f < m.length; f++)
      r.add(m[f]);
  }
  var c = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, p = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, x = {};
  function b(f) {
    return h.call(x, f) ? !0 : h.call(y, f) ? !1 : p.test(f) ? x[f] = !0 : (y[f] = !0, !1);
  }
  function w(f, m, E, O) {
    if (E !== null && E.type === 0)
      return !1;
    switch (typeof m) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return O ? !1 : E !== null ? !E.acceptsBooleans : (f = f.toLowerCase().slice(0, 5), f !== "data-" && f !== "aria-");
      default:
        return !1;
    }
  }
  function R(f, m, E, O) {
    if (m === null || typeof m > "u" || w(f, m, E, O))
      return !0;
    if (O)
      return !1;
    if (E !== null)
      switch (E.type) {
        case 3:
          return !m;
        case 4:
          return m === !1;
        case 5:
          return isNaN(m);
        case 6:
          return isNaN(m) || 1 > m;
      }
    return !1;
  }
  function U(f, m, E, O, I, j, ue) {
    this.acceptsBooleans = m === 2 || m === 3 || m === 4, this.attributeName = O, this.attributeNamespace = I, this.mustUseProperty = E, this.propertyName = f, this.type = m, this.sanitizeURL = j, this.removeEmptyString = ue;
  }
  var L = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(f) {
    L[f] = new U(f, 0, !1, f, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(f) {
    var m = f[0];
    L[m] = new U(m, 1, !1, f[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(f) {
    L[f] = new U(f, 2, !1, f.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(f) {
    L[f] = new U(f, 2, !1, f, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(f) {
    L[f] = new U(f, 3, !1, f.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(f) {
    L[f] = new U(f, 3, !0, f, null, !1, !1);
  }), ["capture", "download"].forEach(function(f) {
    L[f] = new U(f, 4, !1, f, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(f) {
    L[f] = new U(f, 6, !1, f, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(f) {
    L[f] = new U(f, 5, !1, f.toLowerCase(), null, !1, !1);
  });
  var A = /[\-:]([a-z])/g;
  function F(f) {
    return f[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(f) {
    var m = f.replace(
      A,
      F
    );
    L[m] = new U(m, 1, !1, f, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(f) {
    var m = f.replace(A, F);
    L[m] = new U(m, 1, !1, f, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(f) {
    var m = f.replace(A, F);
    L[m] = new U(m, 1, !1, f, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(f) {
    L[f] = new U(f, 1, !1, f.toLowerCase(), null, !1, !1);
  }), L.xlinkHref = new U("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(f) {
    L[f] = new U(f, 1, !1, f.toLowerCase(), null, !0, !0);
  });
  function k(f, m, E, O) {
    var I = L.hasOwnProperty(m) ? L[m] : null;
    (I !== null ? I.type !== 0 : O || !(2 < m.length) || m[0] !== "o" && m[0] !== "O" || m[1] !== "n" && m[1] !== "N") && (R(m, E, I, O) && (E = null), O || I === null ? b(m) && (E === null ? f.removeAttribute(m) : f.setAttribute(m, "" + E)) : I.mustUseProperty ? f[I.propertyName] = E === null ? I.type === 3 ? !1 : "" : E : (m = I.attributeName, O = I.attributeNamespace, E === null ? f.removeAttribute(m) : (I = I.type, E = I === 3 || I === 4 && E === !0 ? "" : "" + E, O ? f.setAttributeNS(O, m, E) : f.setAttribute(m, E))));
  }
  var H = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, B = Symbol.for("react.element"), $ = Symbol.for("react.portal"), Y = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), K = Symbol.for("react.profiler"), X = Symbol.for("react.provider"), le = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), fe = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), xe = Symbol.for("react.memo"), _e = Symbol.for("react.lazy"), Pe = Symbol.for("react.offscreen"), ce = Symbol.iterator;
  function ve(f) {
    return f === null || typeof f != "object" ? null : (f = ce && f[ce] || f["@@iterator"], typeof f == "function" ? f : null);
  }
  var re = Object.assign, ee;
  function he(f) {
    if (ee === void 0)
      try {
        throw Error();
      } catch (E) {
        var m = E.stack.trim().match(/\n( *(at )?)/);
        ee = m && m[1] || "";
      }
    return `
` + ee + f;
  }
  var Me = !1;
  function Le(f, m) {
    if (!f || Me)
      return "";
    Me = !0;
    var E = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (m)
        if (m = function() {
          throw Error();
        }, Object.defineProperty(m.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(m, []);
          } catch (Tt) {
            var O = Tt;
          }
          Reflect.construct(f, [], m);
        } else {
          try {
            m.call();
          } catch (Tt) {
            O = Tt;
          }
          f.call(m.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Tt) {
          O = Tt;
        }
        f();
      }
    } catch (Tt) {
      if (Tt && O && typeof Tt.stack == "string") {
        for (var I = Tt.stack.split(`
`), j = O.stack.split(`
`), ue = I.length - 1, Re = j.length - 1; 1 <= ue && 0 <= Re && I[ue] !== j[Re]; )
          Re--;
        for (; 1 <= ue && 0 <= Re; ue--, Re--)
          if (I[ue] !== j[Re]) {
            if (ue !== 1 || Re !== 1)
              do
                if (ue--, Re--, 0 > Re || I[ue] !== j[Re]) {
                  var Ie = `
` + I[ue].replace(" at new ", " at ");
                  return f.displayName && Ie.includes("<anonymous>") && (Ie = Ie.replace("<anonymous>", f.displayName)), Ie;
                }
              while (1 <= ue && 0 <= Re);
            break;
          }
      }
    } finally {
      Me = !1, Error.prepareStackTrace = E;
    }
    return (f = f ? f.displayName || f.name : "") ? he(f) : "";
  }
  function Ae(f) {
    switch (f.tag) {
      case 5:
        return he(f.type);
      case 16:
        return he("Lazy");
      case 13:
        return he("Suspense");
      case 19:
        return he("SuspenseList");
      case 0:
      case 2:
      case 15:
        return f = Le(f.type, !1), f;
      case 11:
        return f = Le(f.type.render, !1), f;
      case 1:
        return f = Le(f.type, !0), f;
      default:
        return "";
    }
  }
  function Ue(f) {
    if (f == null)
      return null;
    if (typeof f == "function")
      return f.displayName || f.name || null;
    if (typeof f == "string")
      return f;
    switch (f) {
      case Y:
        return "Fragment";
      case $:
        return "Portal";
      case K:
        return "Profiler";
      case J:
        return "StrictMode";
      case fe:
        return "Suspense";
      case de:
        return "SuspenseList";
    }
    if (typeof f == "object")
      switch (f.$$typeof) {
        case le:
          return (f.displayName || "Context") + ".Consumer";
        case X:
          return (f._context.displayName || "Context") + ".Provider";
        case oe:
          var m = f.render;
          return f = f.displayName, f || (f = m.displayName || m.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f;
        case xe:
          return m = f.displayName || null, m !== null ? m : Ue(f.type) || "Memo";
        case _e:
          m = f._payload, f = f._init;
          try {
            return Ue(f(m));
          } catch {
          }
      }
    return null;
  }
  function Ne(f) {
    var m = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (m.displayName || "Context") + ".Consumer";
      case 10:
        return (m._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return f = m.render, f = f.displayName || f.name || "", m.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return m;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ue(m);
      case 8:
        return m === J ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof m == "function")
          return m.displayName || m.name || null;
        if (typeof m == "string")
          return m;
    }
    return null;
  }
  function ke(f) {
    switch (typeof f) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return f;
      case "object":
        return f;
      default:
        return "";
    }
  }
  function it(f) {
    var m = f.type;
    return (f = f.nodeName) && f.toLowerCase() === "input" && (m === "checkbox" || m === "radio");
  }
  function At(f) {
    var m = it(f) ? "checked" : "value", E = Object.getOwnPropertyDescriptor(f.constructor.prototype, m), O = "" + f[m];
    if (!f.hasOwnProperty(m) && typeof E < "u" && typeof E.get == "function" && typeof E.set == "function") {
      var I = E.get, j = E.set;
      return Object.defineProperty(f, m, { configurable: !0, get: function() {
        return I.call(this);
      }, set: function(ue) {
        O = "" + ue, j.call(this, ue);
      } }), Object.defineProperty(f, m, { enumerable: E.enumerable }), { getValue: function() {
        return O;
      }, setValue: function(ue) {
        O = "" + ue;
      }, stopTracking: function() {
        f._valueTracker = null, delete f[m];
      } };
    }
  }
  function rt(f) {
    f._valueTracker || (f._valueTracker = At(f));
  }
  function ae(f) {
    if (!f)
      return !1;
    var m = f._valueTracker;
    if (!m)
      return !0;
    var E = m.getValue(), O = "";
    return f && (O = it(f) ? f.checked ? "true" : "false" : f.value), f = O, f !== E ? (m.setValue(f), !0) : !1;
  }
  function et(f) {
    if (f = f || (typeof document < "u" ? document : void 0), typeof f > "u")
      return null;
    try {
      return f.activeElement || f.body;
    } catch {
      return f.body;
    }
  }
  function Ye(f, m) {
    var E = m.checked;
    return re({}, m, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: E ?? f._wrapperState.initialChecked });
  }
  function Ge(f, m) {
    var E = m.defaultValue == null ? "" : m.defaultValue, O = m.checked != null ? m.checked : m.defaultChecked;
    E = ke(m.value != null ? m.value : E), f._wrapperState = { initialChecked: O, initialValue: E, controlled: m.type === "checkbox" || m.type === "radio" ? m.checked != null : m.value != null };
  }
  function $e(f, m) {
    m = m.checked, m != null && k(f, "checked", m, !1);
  }
  function Ut(f, m) {
    $e(f, m);
    var E = ke(m.value), O = m.type;
    if (E != null)
      O === "number" ? (E === 0 && f.value === "" || f.value != E) && (f.value = "" + E) : f.value !== "" + E && (f.value = "" + E);
    else if (O === "submit" || O === "reset") {
      f.removeAttribute("value");
      return;
    }
    m.hasOwnProperty("value") ? Ct(f, m.type, E) : m.hasOwnProperty("defaultValue") && Ct(f, m.type, ke(m.defaultValue)), m.checked == null && m.defaultChecked != null && (f.defaultChecked = !!m.defaultChecked);
  }
  function nt(f, m, E) {
    if (m.hasOwnProperty("value") || m.hasOwnProperty("defaultValue")) {
      var O = m.type;
      if (!(O !== "submit" && O !== "reset" || m.value !== void 0 && m.value !== null))
        return;
      m = "" + f._wrapperState.initialValue, E || m === f.value || (f.value = m), f.defaultValue = m;
    }
    E = f.name, E !== "" && (f.name = ""), f.defaultChecked = !!f._wrapperState.initialChecked, E !== "" && (f.name = E);
  }
  function Ct(f, m, E) {
    (m !== "number" || et(f.ownerDocument) !== f) && (E == null ? f.defaultValue = "" + f._wrapperState.initialValue : f.defaultValue !== "" + E && (f.defaultValue = "" + E));
  }
  var Pt = Array.isArray;
  function vt(f, m, E, O) {
    if (f = f.options, m) {
      m = {};
      for (var I = 0; I < E.length; I++)
        m["$" + E[I]] = !0;
      for (E = 0; E < f.length; E++)
        I = m.hasOwnProperty("$" + f[E].value), f[E].selected !== I && (f[E].selected = I), I && O && (f[E].defaultSelected = !0);
    } else {
      for (E = "" + ke(E), m = null, I = 0; I < f.length; I++) {
        if (f[I].value === E) {
          f[I].selected = !0, O && (f[I].defaultSelected = !0);
          return;
        }
        m !== null || f[I].disabled || (m = f[I]);
      }
      m !== null && (m.selected = !0);
    }
  }
  function Zt(f, m) {
    if (m.dangerouslySetInnerHTML != null)
      throw Error(t(91));
    return re({}, m, { value: void 0, defaultValue: void 0, children: "" + f._wrapperState.initialValue });
  }
  function ie(f, m) {
    var E = m.value;
    if (E == null) {
      if (E = m.children, m = m.defaultValue, E != null) {
        if (m != null)
          throw Error(t(92));
        if (Pt(E)) {
          if (1 < E.length)
            throw Error(t(93));
          E = E[0];
        }
        m = E;
      }
      m == null && (m = ""), E = m;
    }
    f._wrapperState = { initialValue: ke(E) };
  }
  function ne(f, m) {
    var E = ke(m.value), O = ke(m.defaultValue);
    E != null && (E = "" + E, E !== f.value && (f.value = E), m.defaultValue == null && f.defaultValue !== E && (f.defaultValue = E)), O != null && (f.defaultValue = "" + O);
  }
  function Oe(f) {
    var m = f.textContent;
    m === f._wrapperState.initialValue && m !== "" && m !== null && (f.value = m);
  }
  function _t(f) {
    switch (f) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function ot(f, m) {
    return f == null || f === "http://www.w3.org/1999/xhtml" ? _t(m) : f === "http://www.w3.org/2000/svg" && m === "foreignObject" ? "http://www.w3.org/1999/xhtml" : f;
  }
  var at, Wt = function(f) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(m, E, O, I) {
      MSApp.execUnsafeLocalFunction(function() {
        return f(m, E, O, I);
      });
    } : f;
  }(function(f, m) {
    if (f.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in f)
      f.innerHTML = m;
    else {
      for (at = at || document.createElement("div"), at.innerHTML = "<svg>" + m.valueOf().toString() + "</svg>", m = at.firstChild; f.firstChild; )
        f.removeChild(f.firstChild);
      for (; m.firstChild; )
        f.appendChild(m.firstChild);
    }
  });
  function Dt(f, m) {
    if (m) {
      var E = f.firstChild;
      if (E && E === f.lastChild && E.nodeType === 3) {
        E.nodeValue = m;
        return;
      }
    }
    f.textContent = m;
  }
  var Se = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, He = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Se).forEach(function(f) {
    He.forEach(function(m) {
      m = m + f.charAt(0).toUpperCase() + f.substring(1), Se[m] = Se[f];
    });
  });
  function lt(f, m, E) {
    return m == null || typeof m == "boolean" || m === "" ? "" : E || typeof m != "number" || m === 0 || Se.hasOwnProperty(f) && Se[f] ? ("" + m).trim() : m + "px";
  }
  function St(f, m) {
    f = f.style;
    for (var E in m)
      if (m.hasOwnProperty(E)) {
        var O = E.indexOf("--") === 0, I = lt(E, m[E], O);
        E === "float" && (E = "cssFloat"), O ? f.setProperty(E, I) : f[E] = I;
      }
  }
  var Je = re({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function be(f, m) {
    if (m) {
      if (Je[f] && (m.children != null || m.dangerouslySetInnerHTML != null))
        throw Error(t(137, f));
      if (m.dangerouslySetInnerHTML != null) {
        if (m.children != null)
          throw Error(t(60));
        if (typeof m.dangerouslySetInnerHTML != "object" || !("__html" in m.dangerouslySetInnerHTML))
          throw Error(t(61));
      }
      if (m.style != null && typeof m.style != "object")
        throw Error(t(62));
    }
  }
  function Ze(f, m) {
    if (f.indexOf("-") === -1)
      return typeof m.is == "string";
    switch (f) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ct = null;
  function pe(f) {
    return f = f.target || f.srcElement || window, f.correspondingUseElement && (f = f.correspondingUseElement), f.nodeType === 3 ? f.parentNode : f;
  }
  var Rt = null, Be = null, ut = null;
  function on(f) {
    if (f = js(f)) {
      if (typeof Rt != "function")
        throw Error(t(280));
      var m = f.stateNode;
      m && (m = Xn(m), Rt(f.stateNode, f.type, m));
    }
  }
  function zn(f) {
    Be ? ut ? ut.push(f) : ut = [f] : Be = f;
  }
  function Gn() {
    if (Be) {
      var f = Be, m = ut;
      if (ut = Be = null, on(f), m)
        for (f = 0; f < m.length; f++)
          on(m[f]);
    }
  }
  function rr(f, m) {
    return f(m);
  }
  function mn() {
  }
  var er = !1;
  function ir(f, m, E) {
    if (er)
      return f(m, E);
    er = !0;
    try {
      return rr(f, m, E);
    } finally {
      er = !1, (Be !== null || ut !== null) && (mn(), Gn());
    }
  }
  function Wn(f, m) {
    var E = f.stateNode;
    if (E === null)
      return null;
    var O = Xn(E);
    if (O === null)
      return null;
    E = O[m];
    e:
      switch (m) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (O = !O.disabled) || (f = f.type, O = !(f === "button" || f === "input" || f === "select" || f === "textarea")), f = !O;
          break e;
        default:
          f = !1;
      }
    if (f)
      return null;
    if (E && typeof E != "function")
      throw Error(t(231, m, typeof E));
    return E;
  }
  var Ei = !1;
  if (c)
    try {
      var Wr = {};
      Object.defineProperty(Wr, "passive", { get: function() {
        Ei = !0;
      } }), window.addEventListener("test", Wr, Wr), window.removeEventListener("test", Wr, Wr);
    } catch {
      Ei = !1;
    }
  function Br(f, m, E, O, I, j, ue, Re, Ie) {
    var Tt = Array.prototype.slice.call(arguments, 3);
    try {
      m.apply(E, Tt);
    } catch (Kt) {
      this.onError(Kt);
    }
  }
  var Mr = !1, Ri = null, si = !1, De = null, Ft = { onError: function(f) {
    Mr = !0, Ri = f;
  } };
  function qt(f, m, E, O, I, j, ue, Re, Ie) {
    Mr = !1, Ri = null, Br.apply(Ft, arguments);
  }
  function En(f, m, E, O, I, j, ue, Re, Ie) {
    if (qt.apply(this, arguments), Mr) {
      if (Mr) {
        var Tt = Ri;
        Mr = !1, Ri = null;
      } else
        throw Error(t(198));
      si || (si = !0, De = Tt);
    }
  }
  function ye(f) {
    var m = f, E = f;
    if (f.alternate)
      for (; m.return; )
        m = m.return;
    else {
      f = m;
      do
        m = f, m.flags & 4098 && (E = m.return), f = m.return;
      while (f);
    }
    return m.tag === 3 ? E : null;
  }
  function qe(f) {
    if (f.tag === 13) {
      var m = f.memoizedState;
      if (m === null && (f = f.alternate, f !== null && (m = f.memoizedState)), m !== null)
        return m.dehydrated;
    }
    return null;
  }
  function tt(f) {
    if (ye(f) !== f)
      throw Error(t(188));
  }
  function Ve(f) {
    var m = f.alternate;
    if (!m) {
      if (m = ye(f), m === null)
        throw Error(t(188));
      return m !== f ? null : f;
    }
    for (var E = f, O = m; ; ) {
      var I = E.return;
      if (I === null)
        break;
      var j = I.alternate;
      if (j === null) {
        if (O = I.return, O !== null) {
          E = O;
          continue;
        }
        break;
      }
      if (I.child === j.child) {
        for (j = I.child; j; ) {
          if (j === E)
            return tt(I), f;
          if (j === O)
            return tt(I), m;
          j = j.sibling;
        }
        throw Error(t(188));
      }
      if (E.return !== O.return)
        E = I, O = j;
      else {
        for (var ue = !1, Re = I.child; Re; ) {
          if (Re === E) {
            ue = !0, E = I, O = j;
            break;
          }
          if (Re === O) {
            ue = !0, O = I, E = j;
            break;
          }
          Re = Re.sibling;
        }
        if (!ue) {
          for (Re = j.child; Re; ) {
            if (Re === E) {
              ue = !0, E = j, O = I;
              break;
            }
            if (Re === O) {
              ue = !0, O = j, E = I;
              break;
            }
            Re = Re.sibling;
          }
          if (!ue)
            throw Error(t(189));
        }
      }
      if (E.alternate !== O)
        throw Error(t(190));
    }
    if (E.tag !== 3)
      throw Error(t(188));
    return E.stateNode.current === E ? f : m;
  }
  function pt(f) {
    return f = Ve(f), f !== null ? en(f) : null;
  }
  function en(f) {
    if (f.tag === 5 || f.tag === 6)
      return f;
    for (f = f.child; f !== null; ) {
      var m = en(f);
      if (m !== null)
        return m;
      f = f.sibling;
    }
    return null;
  }
  var cn = e.unstable_scheduleCallback, xn = e.unstable_cancelCallback, Nn = e.unstable_shouldYield, lr = e.unstable_requestPaint, bt = e.unstable_now, ar = e.unstable_getCurrentPriorityLevel, Hr = e.unstable_ImmediatePriority, Tn = e.unstable_UserBlockingPriority, Ji = e.unstable_NormalPriority, Do = e.unstable_LowPriority, li = e.unstable_IdlePriority, $n = null, _r = null;
  function ur(f) {
    if (_r && typeof _r.onCommitFiberRoot == "function")
      try {
        _r.onCommitFiberRoot($n, f, void 0, (f.current.flags & 128) === 128);
      } catch {
      }
  }
  var di = Math.clz32 ? Math.clz32 : ds, xa = Math.log, Xr = Math.LN2;
  function ds(f) {
    return f >>>= 0, f === 0 ? 32 : 31 - (xa(f) / Xr | 0) | 0;
  }
  var bi = 64, Ti = 4194304;
  function Xa(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function Ai(f, m) {
    var E = f.pendingLanes;
    if (E === 0)
      return 0;
    var O = 0, I = f.suspendedLanes, j = f.pingedLanes, ue = E & 268435455;
    if (ue !== 0) {
      var Re = ue & ~I;
      Re !== 0 ? O = Xa(Re) : (j &= ue, j !== 0 && (O = Xa(j)));
    } else
      ue = E & ~I, ue !== 0 ? O = Xa(ue) : j !== 0 && (O = Xa(j));
    if (O === 0)
      return 0;
    if (m !== 0 && m !== O && !(m & I) && (I = O & -O, j = m & -m, I >= j || I === 16 && (j & 4194240) !== 0))
      return m;
    if (O & 4 && (O |= E & 16), m = f.entangledLanes, m !== 0)
      for (f = f.entanglements, m &= O; 0 < m; )
        E = 31 - di(m), I = 1 << E, O |= f[E], m &= ~I;
    return O;
  }
  function ru(f, m) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return m + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return m + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ns(f, m) {
    for (var E = f.suspendedLanes, O = f.pingedLanes, I = f.expirationTimes, j = f.pendingLanes; 0 < j; ) {
      var ue = 31 - di(j), Re = 1 << ue, Ie = I[ue];
      Ie === -1 ? (!(Re & E) || Re & O) && (I[ue] = ru(Re, m)) : Ie <= m && (f.expiredLanes |= Re), j &= ~Re;
    }
  }
  function yo(f) {
    return f = f.pendingLanes & -1073741825, f !== 0 ? f : f & 1073741824 ? 1073741824 : 0;
  }
  function Wo() {
    var f = bi;
    return bi <<= 1, !(bi & 4194240) && (bi = 64), f;
  }
  function ac(f) {
    for (var m = [], E = 0; 31 > E; E++)
      m.push(f);
    return m;
  }
  function sl(f, m, E) {
    f.pendingLanes |= m, m !== 536870912 && (f.suspendedLanes = 0, f.pingedLanes = 0), f = f.eventTimes, m = 31 - di(m), f[m] = E;
  }
  function yp(f, m) {
    var E = f.pendingLanes & ~m;
    f.pendingLanes = m, f.suspendedLanes = 0, f.pingedLanes = 0, f.expiredLanes &= m, f.mutableReadLanes &= m, f.entangledLanes &= m, m = f.entanglements;
    var O = f.eventTimes;
    for (f = f.expirationTimes; 0 < E; ) {
      var I = 31 - di(E), j = 1 << I;
      m[I] = 0, O[I] = -1, f[I] = -1, E &= ~j;
    }
  }
  function Dl(f, m) {
    var E = f.entangledLanes |= m;
    for (f = f.entanglements; E; ) {
      var O = 31 - di(E), I = 1 << O;
      I & m | f[O] & m && (f[O] |= m), E &= ~I;
    }
  }
  var Vr = 0;
  function ll(f) {
    return f &= -f, 1 < f ? 4 < f ? f & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var kf, jo, ei, Ra, zf, nr = !1, iu = [], Fi = null, dr = null, hs = null, Lo = /* @__PURE__ */ new Map(), fa = /* @__PURE__ */ new Map(), gi = [], Sm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function qr(f, m) {
    switch (f) {
      case "focusin":
      case "focusout":
        Fi = null;
        break;
      case "dragenter":
      case "dragleave":
        dr = null;
        break;
      case "mouseover":
      case "mouseout":
        hs = null;
        break;
      case "pointerover":
      case "pointerout":
        Lo.delete(m.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        fa.delete(m.pointerId);
    }
  }
  function Aa(f, m, E, O, I, j) {
    return f === null || f.nativeEvent !== j ? (f = { blockedOn: m, domEventName: E, eventSystemFlags: O, nativeEvent: j, targetContainers: [I] }, m !== null && (m = js(m), m !== null && jo(m)), f) : (f.eventSystemFlags |= O, m = f.targetContainers, I !== null && m.indexOf(I) === -1 && m.push(I), f);
  }
  function Ru(f, m, E, O, I) {
    switch (m) {
      case "focusin":
        return Fi = Aa(Fi, f, m, E, O, I), !0;
      case "dragenter":
        return dr = Aa(dr, f, m, E, O, I), !0;
      case "mouseover":
        return hs = Aa(hs, f, m, E, O, I), !0;
      case "pointerover":
        var j = I.pointerId;
        return Lo.set(j, Aa(Lo.get(j) || null, f, m, E, O, I)), !0;
      case "gotpointercapture":
        return j = I.pointerId, fa.set(j, Aa(fa.get(j) || null, f, m, E, O, I)), !0;
    }
    return !1;
  }
  function ps(f) {
    var m = Xo(f.target);
    if (m !== null) {
      var E = ye(m);
      if (E !== null) {
        if (m = E.tag, m === 13) {
          if (m = qe(E), m !== null) {
            f.blockedOn = m, zf(f.priority, function() {
              ei(E);
            });
            return;
          }
        } else if (m === 3 && E.stateNode.current.memoizedState.isDehydrated) {
          f.blockedOn = E.tag === 3 ? E.stateNode.containerInfo : null;
          return;
        }
      }
    }
    f.blockedOn = null;
  }
  function oc(f) {
    if (f.blockedOn !== null)
      return !1;
    for (var m = f.targetContainers; 0 < m.length; ) {
      var E = $o(f.domEventName, f.eventSystemFlags, m[0], f.nativeEvent);
      if (E === null) {
        E = f.nativeEvent;
        var O = new E.constructor(E.type, E);
        ct = O, E.target.dispatchEvent(O), ct = null;
      } else
        return m = js(E), m !== null && jo(m), f.blockedOn = E, !1;
      m.shift();
    }
    return !0;
  }
  function Vc(f, m, E) {
    oc(f) && E.delete(m);
  }
  function ul() {
    nr = !1, Fi !== null && oc(Fi) && (Fi = null), dr !== null && oc(dr) && (dr = null), hs !== null && oc(hs) && (hs = null), Lo.forEach(Vc), fa.forEach(Vc);
  }
  function Gc(f, m) {
    f.blockedOn === m && (f.blockedOn = null, nr || (nr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, ul)));
  }
  function If(f) {
    function m(I) {
      return Gc(I, f);
    }
    if (0 < iu.length) {
      Gc(iu[0], f);
      for (var E = 1; E < iu.length; E++) {
        var O = iu[E];
        O.blockedOn === f && (O.blockedOn = null);
      }
    }
    for (Fi !== null && Gc(Fi, f), dr !== null && Gc(dr, f), hs !== null && Gc(hs, f), Lo.forEach(m), fa.forEach(m), E = 0; E < gi.length; E++)
      O = gi[E], O.blockedOn === f && (O.blockedOn = null);
    for (; 0 < gi.length && (E = gi[0], E.blockedOn === null); )
      ps(E), E.blockedOn === null && gi.shift();
  }
  var Oo = H.ReactCurrentBatchConfig, qa = !0;
  function Au(f, m, E, O) {
    var I = Vr, j = Oo.transition;
    Oo.transition = null;
    try {
      Vr = 1, Wc(f, m, E, O);
    } finally {
      Vr = I, Oo.transition = j;
    }
  }
  function Fs(f, m, E, O) {
    var I = Vr, j = Oo.transition;
    Oo.transition = null;
    try {
      Vr = 4, Wc(f, m, E, O);
    } finally {
      Vr = I, Oo.transition = j;
    }
  }
  function Wc(f, m, E, O) {
    if (qa) {
      var I = $o(f, m, E, O);
      if (I === null)
        Ul(f, m, O, jc, E), qr(f, O);
      else if (Ru(I, f, m, E, O))
        O.stopPropagation();
      else if (qr(f, O), m & 4 && -1 < Sm.indexOf(f)) {
        for (; I !== null; ) {
          var j = js(I);
          if (j !== null && kf(j), j = $o(f, m, E, O), j === null && Ul(f, m, O, jc, E), j === I)
            break;
          I = j;
        }
        I !== null && O.stopPropagation();
      } else
        Ul(f, m, O, null, E);
    }
  }
  var jc = null;
  function $o(f, m, E, O) {
    if (jc = null, f = pe(O), f = Xo(f), f !== null)
      if (m = ye(f), m === null)
        f = null;
      else if (E = m.tag, E === 13) {
        if (f = qe(m), f !== null)
          return f;
        f = null;
      } else if (E === 3) {
        if (m.stateNode.current.memoizedState.isDehydrated)
          return m.tag === 3 ? m.stateNode.containerInfo : null;
        f = null;
      } else
        m !== f && (f = null);
    return jc = f, null;
  }
  function $c(f) {
    switch (f) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ar()) {
          case Hr:
            return 1;
          case Tn:
            return 4;
          case Ji:
          case Do:
            return 16;
          case li:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var ks = null, Du = null, So = null;
  function Ka() {
    if (So)
      return So;
    var f, m = Du, E = m.length, O, I = "value" in ks ? ks.value : ks.textContent, j = I.length;
    for (f = 0; f < E && m[f] === I[f]; f++)
      ;
    var ue = E - f;
    for (O = 1; O <= ue && m[E - O] === I[j - O]; O++)
      ;
    return So = I.slice(f, 1 < O ? 1 - O : void 0);
  }
  function au(f) {
    var m = f.keyCode;
    return "charCode" in f ? (f = f.charCode, f === 0 && m === 13 && (f = 13)) : f = m, f === 10 && (f = 13), 32 <= f || f === 13 ? f : 0;
  }
  function zs() {
    return !0;
  }
  function sc() {
    return !1;
  }
  function Po(f) {
    function m(E, O, I, j, ue) {
      this._reactName = E, this._targetInst = I, this.type = O, this.nativeEvent = j, this.target = ue, this.currentTarget = null;
      for (var Re in f)
        f.hasOwnProperty(Re) && (E = f[Re], this[Re] = E ? E(j) : j[Re]);
      return this.isDefaultPrevented = (j.defaultPrevented != null ? j.defaultPrevented : j.returnValue === !1) ? zs : sc, this.isPropagationStopped = sc, this;
    }
    return re(m.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var E = this.nativeEvent;
      E && (E.preventDefault ? E.preventDefault() : typeof E.returnValue != "unknown" && (E.returnValue = !1), this.isDefaultPrevented = zs);
    }, stopPropagation: function() {
      var E = this.nativeEvent;
      E && (E.stopPropagation ? E.stopPropagation() : typeof E.cancelBubble != "unknown" && (E.cancelBubble = !0), this.isPropagationStopped = zs);
    }, persist: function() {
    }, isPersistent: zs }), m;
  }
  var ou = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(f) {
    return f.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Da = Po(ou), ao = re({}, ou, { view: 0, detail: 0 }), La = Po(ao), da, ms, cl, oo = re({}, ao, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Hf, button: 0, buttons: 0, relatedTarget: function(f) {
    return f.relatedTarget === void 0 ? f.fromElement === f.srcElement ? f.toElement : f.fromElement : f.relatedTarget;
  }, movementX: function(f) {
    return "movementX" in f ? f.movementX : (f !== cl && (cl && f.type === "mousemove" ? (da = f.screenX - cl.screenX, ms = f.screenY - cl.screenY) : ms = da = 0, cl = f), da);
  }, movementY: function(f) {
    return "movementY" in f ? f.movementY : ms;
  } }), Bf = Po(oo), lc = re({}, oo, { dataTransfer: 0 }), Yc = Po(lc), xm = re({}, ao, { relatedTarget: 0 }), Xc = Po(xm), xh = re({}, ou, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Lv = Po(xh), ey = re({}, ou, { clipboardData: function(f) {
    return "clipboardData" in f ? f.clipboardData : window.clipboardData;
  } }), _m = Po(ey), Em = re({}, ou, { data: 0 }), bm = Po(Em), Tm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Ov = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, wm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Rd(f) {
    var m = this.nativeEvent;
    return m.getModifierState ? m.getModifierState(f) : (f = wm[f]) ? !!m[f] : !1;
  }
  function Hf() {
    return Rd;
  }
  var su = re({}, ao, { key: function(f) {
    if (f.key) {
      var m = Tm[f.key] || f.key;
      if (m !== "Unidentified")
        return m;
    }
    return f.type === "keypress" ? (f = au(f), f === 13 ? "Enter" : String.fromCharCode(f)) : f.type === "keydown" || f.type === "keyup" ? Ov[f.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Hf, charCode: function(f) {
    return f.type === "keypress" ? au(f) : 0;
  }, keyCode: function(f) {
    return f.type === "keydown" || f.type === "keyup" ? f.keyCode : 0;
  }, which: function(f) {
    return f.type === "keypress" ? au(f) : f.type === "keydown" || f.type === "keyup" ? f.keyCode : 0;
  } }), Mm = Po(su), fl = re({}, oo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Is = Po(fl), qc = re({}, ao, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Hf }), Kc = Po(qc), lu = re({}, ou, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Vf = Po(lu), Bs = re({}, oo, {
    deltaX: function(f) {
      return "deltaX" in f ? f.deltaX : "wheelDeltaX" in f ? -f.wheelDeltaX : 0;
    },
    deltaY: function(f) {
      return "deltaY" in f ? f.deltaY : "wheelDeltaY" in f ? -f.wheelDeltaY : "wheelDelta" in f ? -f.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Lu = Po(Bs), Oa = [9, 13, 27, 32], _a = c && "CompositionEvent" in window, Ea = null;
  c && "documentMode" in document && (Ea = document.documentMode);
  var Hi = c && "TextEvent" in window && !Ea, Ad = c && (!_a || Ea && 8 < Ea && 11 >= Ea), Yo = String.fromCharCode(32), Cm = !1;
  function Rm(f, m) {
    switch (f) {
      case "keyup":
        return Oa.indexOf(m.keyCode) !== -1;
      case "keydown":
        return m.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Dd(f) {
    return f = f.detail, typeof f == "object" && "data" in f ? f.data : null;
  }
  var Qc = !1;
  function Pv(f, m) {
    switch (f) {
      case "compositionend":
        return Dd(m);
      case "keypress":
        return m.which !== 32 ? null : (Cm = !0, Yo);
      case "textInput":
        return f = m.data, f === Yo && Cm ? null : f;
      default:
        return null;
    }
  }
  function Sp(f, m) {
    if (Qc)
      return f === "compositionend" || !_a && Rm(f, m) ? (f = Ka(), So = Du = ks = null, Qc = !1, f) : null;
    switch (f) {
      case "paste":
        return null;
      case "keypress":
        if (!(m.ctrlKey || m.altKey || m.metaKey) || m.ctrlKey && m.altKey) {
          if (m.char && 1 < m.char.length)
            return m.char;
          if (m.which)
            return String.fromCharCode(m.which);
        }
        return null;
      case "compositionend":
        return Ad && m.locale !== "ko" ? null : m.data;
      default:
        return null;
    }
  }
  var Ld = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function _h(f) {
    var m = f && f.nodeName && f.nodeName.toLowerCase();
    return m === "input" ? !!Ld[f.type] : m === "textarea";
  }
  function Gf(f, m, E, O) {
    zn(O), m = hc(m, "onChange"), 0 < m.length && (E = new Da("onChange", "change", null, E, O), f.push({ event: E, listeners: m }));
  }
  var Hs = null, Zc = null;
  function uc(f) {
    Yt(f, 0);
  }
  function Ou(f) {
    var m = hi(f);
    if (ae(m))
      return f;
  }
  function xp(f, m) {
    if (f === "change")
      return m;
  }
  var Od = !1;
  if (c) {
    var vs;
    if (c) {
      var Pd = "oninput" in document;
      if (!Pd) {
        var Jc = document.createElement("div");
        Jc.setAttribute("oninput", "return;"), Pd = typeof Jc.oninput == "function";
      }
      vs = Pd;
    } else
      vs = !1;
    Od = vs && (!document.documentMode || 9 < document.documentMode);
  }
  function uu() {
    Hs && (Hs.detachEvent("onpropertychange", _p), Zc = Hs = null);
  }
  function _p(f) {
    if (f.propertyName === "value" && Ou(Zc)) {
      var m = [];
      Gf(m, Zc, f, pe(f)), ir(uc, m);
    }
  }
  function Ud(f, m, E) {
    f === "focusin" ? (uu(), Hs = m, Zc = E, Hs.attachEvent("onpropertychange", _p)) : f === "focusout" && uu();
  }
  function Ep(f) {
    if (f === "selectionchange" || f === "keyup" || f === "keydown")
      return Ou(Zc);
  }
  function Ll(f, m) {
    if (f === "click")
      return Ou(m);
  }
  function ea(f, m) {
    if (f === "input" || f === "change")
      return Ou(m);
  }
  function Nd(f, m) {
    return f === m && (f !== 0 || 1 / f === 1 / m) || f !== f && m !== m;
  }
  var Pa = typeof Object.is == "function" ? Object.is : Nd;
  function dl(f, m) {
    if (Pa(f, m))
      return !0;
    if (typeof f != "object" || f === null || typeof m != "object" || m === null)
      return !1;
    var E = Object.keys(f), O = Object.keys(m);
    if (E.length !== O.length)
      return !1;
    for (O = 0; O < E.length; O++) {
      var I = E[O];
      if (!h.call(m, I) || !Pa(f[I], m[I]))
        return !1;
    }
    return !0;
  }
  function so(f) {
    for (; f && f.firstChild; )
      f = f.firstChild;
    return f;
  }
  function ki(f, m) {
    var E = so(f);
    f = 0;
    for (var O; E; ) {
      if (E.nodeType === 3) {
        if (O = f + E.textContent.length, f <= m && O >= m)
          return { node: E, offset: m - f };
        f = O;
      }
      e: {
        for (; E; ) {
          if (E.nextSibling) {
            E = E.nextSibling;
            break e;
          }
          E = E.parentNode;
        }
        E = void 0;
      }
      E = so(E);
    }
  }
  function ef(f, m) {
    return f && m ? f === m ? !0 : f && f.nodeType === 3 ? !1 : m && m.nodeType === 3 ? ef(f, m.parentNode) : "contains" in f ? f.contains(m) : f.compareDocumentPosition ? !!(f.compareDocumentPosition(m) & 16) : !1 : !1;
  }
  function Kr() {
    for (var f = window, m = et(); m instanceof f.HTMLIFrameElement; ) {
      try {
        var E = typeof m.contentWindow.location.href == "string";
      } catch {
        E = !1;
      }
      if (E)
        f = m.contentWindow;
      else
        break;
      m = et(f.document);
    }
    return m;
  }
  function yi(f) {
    var m = f && f.nodeName && f.nodeName.toLowerCase();
    return m && (m === "input" && (f.type === "text" || f.type === "search" || f.type === "tel" || f.type === "url" || f.type === "password") || m === "textarea" || f.contentEditable === "true");
  }
  function Di(f) {
    var m = Kr(), E = f.focusedElem, O = f.selectionRange;
    if (m !== E && E && E.ownerDocument && ef(E.ownerDocument.documentElement, E)) {
      if (O !== null && yi(E)) {
        if (m = O.start, f = O.end, f === void 0 && (f = m), "selectionStart" in E)
          E.selectionStart = m, E.selectionEnd = Math.min(f, E.value.length);
        else if (f = (m = E.ownerDocument || document) && m.defaultView || window, f.getSelection) {
          f = f.getSelection();
          var I = E.textContent.length, j = Math.min(O.start, I);
          O = O.end === void 0 ? j : Math.min(O.end, I), !f.extend && j > O && (I = O, O = j, j = I), I = ki(E, j);
          var ue = ki(
            E,
            O
          );
          I && ue && (f.rangeCount !== 1 || f.anchorNode !== I.node || f.anchorOffset !== I.offset || f.focusNode !== ue.node || f.focusOffset !== ue.offset) && (m = m.createRange(), m.setStart(I.node, I.offset), f.removeAllRanges(), j > O ? (f.addRange(m), f.extend(ue.node, ue.offset)) : (m.setEnd(ue.node, ue.offset), f.addRange(m)));
        }
      }
      for (m = [], f = E; f = f.parentNode; )
        f.nodeType === 1 && m.push({ element: f, left: f.scrollLeft, top: f.scrollTop });
      for (typeof E.focus == "function" && E.focus(), E = 0; E < m.length; E++)
        f = m[E], f.element.scrollLeft = f.left, f.element.scrollTop = f.top;
    }
  }
  var Fd = c && "documentMode" in document && 11 >= document.documentMode, lo = null, Wf = null, cc = null, Qa = !1;
  function Ol(f, m, E) {
    var O = E.window === E ? E.document : E.nodeType === 9 ? E : E.ownerDocument;
    Qa || lo == null || lo !== et(O) || (O = lo, "selectionStart" in O && yi(O) ? O = { start: O.selectionStart, end: O.selectionEnd } : (O = (O.ownerDocument && O.ownerDocument.defaultView || window).getSelection(), O = { anchorNode: O.anchorNode, anchorOffset: O.anchorOffset, focusNode: O.focusNode, focusOffset: O.focusOffset }), cc && dl(cc, O) || (cc = O, O = hc(Wf, "onSelect"), 0 < O.length && (m = new Da("onSelect", "select", null, m, E), f.push({ event: m, listeners: O }), m.target = lo)));
  }
  function tf(f, m) {
    var E = {};
    return E[f.toLowerCase()] = m.toLowerCase(), E["Webkit" + f] = "webkit" + m, E["Moz" + f] = "moz" + m, E;
  }
  var Pu = { animationend: tf("Animation", "AnimationEnd"), animationiteration: tf("Animation", "AnimationIteration"), animationstart: tf("Animation", "AnimationStart"), transitionend: tf("Transition", "TransitionEnd") }, cu = {}, Pl = {};
  c && (Pl = document.createElement("div").style, "AnimationEvent" in window || (delete Pu.animationend.animation, delete Pu.animationiteration.animation, delete Pu.animationstart.animation), "TransitionEvent" in window || delete Pu.transitionend.transition);
  function Yi(f) {
    if (cu[f])
      return cu[f];
    if (!Pu[f])
      return f;
    var m = Pu[f], E;
    for (E in m)
      if (m.hasOwnProperty(E) && E in Pl)
        return cu[f] = m[E];
    return f;
  }
  var kd = Yi("animationend"), bp = Yi("animationiteration"), jf = Yi("animationstart"), Am = Yi("transitionend"), mr = /* @__PURE__ */ new Map(), Li = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Dr(f, m) {
    mr.set(f, m), o(m, [f]);
  }
  for (var oa = 0; oa < Li.length; oa++) {
    var Uo = Li[oa], Eh = Uo.toLowerCase(), bh = Uo[0].toUpperCase() + Uo.slice(1);
    Dr(Eh, "on" + bh);
  }
  Dr(kd, "onAnimationEnd"), Dr(bp, "onAnimationIteration"), Dr(jf, "onAnimationStart"), Dr("dblclick", "onDoubleClick"), Dr("focusin", "onFocus"), Dr("focusout", "onBlur"), Dr(Am, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var $f = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Dm = new Set("cancel close invalid load scroll toggle".split(" ").concat($f));
  function Th(f, m, E) {
    var O = f.type || "unknown-event";
    f.currentTarget = E, En(O, m, void 0, f), f.currentTarget = null;
  }
  function Yt(f, m) {
    m = (m & 4) !== 0;
    for (var E = 0; E < f.length; E++) {
      var O = f[E], I = O.event;
      O = O.listeners;
      e: {
        var j = void 0;
        if (m)
          for (var ue = O.length - 1; 0 <= ue; ue--) {
            var Re = O[ue], Ie = Re.instance, Tt = Re.currentTarget;
            if (Re = Re.listener, Ie !== j && I.isPropagationStopped())
              break e;
            Th(I, Re, Tt), j = Ie;
          }
        else
          for (ue = 0; ue < O.length; ue++) {
            if (Re = O[ue], Ie = Re.instance, Tt = Re.currentTarget, Re = Re.listener, Ie !== j && I.isPropagationStopped())
              break e;
            Th(I, Re, Tt), j = Ie;
          }
      }
    }
    if (si)
      throw f = De, si = !1, De = null, f;
  }
  function Er(f, m) {
    var E = m[Xf];
    E === void 0 && (E = m[Xf] = /* @__PURE__ */ new Set());
    var O = f + "__bubble";
    E.has(O) || (fc(m, f, 2, !1), E.add(O));
  }
  function wr(f, m, E) {
    var O = 0;
    m && (O |= 4), fc(E, f, O, m);
  }
  var Vs = "_reactListening" + Math.random().toString(36).slice(2);
  function hl(f) {
    if (!f[Vs]) {
      f[Vs] = !0, r.forEach(function(E) {
        E !== "selectionchange" && (Dm.has(E) || wr(E, !1, f), wr(E, !0, f));
      });
      var m = f.nodeType === 9 ? f : f.ownerDocument;
      m === null || m[Vs] || (m[Vs] = !0, wr("selectionchange", !1, m));
    }
  }
  function fc(f, m, E, O) {
    switch ($c(m)) {
      case 1:
        var I = Au;
        break;
      case 4:
        I = Fs;
        break;
      default:
        I = Wc;
    }
    E = I.bind(null, m, E, f), I = void 0, !Ei || m !== "touchstart" && m !== "touchmove" && m !== "wheel" || (I = !0), O ? I !== void 0 ? f.addEventListener(m, E, { capture: !0, passive: I }) : f.addEventListener(m, E, !0) : I !== void 0 ? f.addEventListener(m, E, { passive: I }) : f.addEventListener(m, E, !1);
  }
  function Ul(f, m, E, O, I) {
    var j = O;
    if (!(m & 1) && !(m & 2) && O !== null)
      e:
        for (; ; ) {
          if (O === null)
            return;
          var ue = O.tag;
          if (ue === 3 || ue === 4) {
            var Re = O.stateNode.containerInfo;
            if (Re === I || Re.nodeType === 8 && Re.parentNode === I)
              break;
            if (ue === 4)
              for (ue = O.return; ue !== null; ) {
                var Ie = ue.tag;
                if ((Ie === 3 || Ie === 4) && (Ie = ue.stateNode.containerInfo, Ie === I || Ie.nodeType === 8 && Ie.parentNode === I))
                  return;
                ue = ue.return;
              }
            for (; Re !== null; ) {
              if (ue = Xo(Re), ue === null)
                return;
              if (Ie = ue.tag, Ie === 5 || Ie === 6) {
                O = j = ue;
                continue e;
              }
              Re = Re.parentNode;
            }
          }
          O = O.return;
        }
    ir(function() {
      var Tt = j, Kt = pe(E), Xt = [];
      e: {
        var $t = mr.get(f);
        if ($t !== void 0) {
          var bn = Da, Pn = f;
          switch (f) {
            case "keypress":
              if (au(E) === 0)
                break e;
            case "keydown":
            case "keyup":
              bn = Mm;
              break;
            case "focusin":
              Pn = "focus", bn = Xc;
              break;
            case "focusout":
              Pn = "blur", bn = Xc;
              break;
            case "beforeblur":
            case "afterblur":
              bn = Xc;
              break;
            case "click":
              if (E.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              bn = Bf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              bn = Yc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              bn = Kc;
              break;
            case kd:
            case bp:
            case jf:
              bn = Lv;
              break;
            case Am:
              bn = Vf;
              break;
            case "scroll":
              bn = La;
              break;
            case "wheel":
              bn = Lu;
              break;
            case "copy":
            case "cut":
            case "paste":
              bn = _m;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              bn = Is;
          }
          var Fn = (m & 4) !== 0, eo = !Fn && f === "scroll", st = Fn ? $t !== null ? $t + "Capture" : null : $t;
          Fn = [];
          for (var Xe = Tt, gt; Xe !== null; ) {
            gt = Xe;
            var an = gt.stateNode;
            if (gt.tag === 5 && an !== null && (gt = an, st !== null && (an = Wn(Xe, st), an != null && Fn.push(dc(Xe, an, gt)))), eo)
              break;
            Xe = Xe.return;
          }
          0 < Fn.length && ($t = new bn($t, Pn, null, E, Kt), Xt.push({ event: $t, listeners: Fn }));
        }
      }
      if (!(m & 7)) {
        e: {
          if ($t = f === "mouseover" || f === "pointerover", bn = f === "mouseout" || f === "pointerout", $t && E !== ct && (Pn = E.relatedTarget || E.fromElement) && (Xo(Pn) || Pn[Ws]))
            break e;
          if ((bn || $t) && ($t = Kt.window === Kt ? Kt : ($t = Kt.ownerDocument) ? $t.defaultView || $t.parentWindow : window, bn ? (Pn = E.relatedTarget || E.toElement, bn = Tt, Pn = Pn ? Xo(Pn) : null, Pn !== null && (eo = ye(Pn), Pn !== eo || Pn.tag !== 5 && Pn.tag !== 6) && (Pn = null)) : (bn = null, Pn = Tt), bn !== Pn)) {
            if (Fn = Bf, an = "onMouseLeave", st = "onMouseEnter", Xe = "mouse", (f === "pointerout" || f === "pointerover") && (Fn = Is, an = "onPointerLeave", st = "onPointerEnter", Xe = "pointer"), eo = bn == null ? $t : hi(bn), gt = Pn == null ? $t : hi(Pn), $t = new Fn(an, Xe + "leave", bn, E, Kt), $t.target = eo, $t.relatedTarget = gt, an = null, Xo(Kt) === Tt && (Fn = new Fn(st, Xe + "enter", Pn, E, Kt), Fn.target = gt, Fn.relatedTarget = eo, an = Fn), eo = an, bn && Pn)
              t: {
                for (Fn = bn, st = Pn, Xe = 0, gt = Fn; gt; gt = fu(gt))
                  Xe++;
                for (gt = 0, an = st; an; an = fu(an))
                  gt++;
                for (; 0 < Xe - gt; )
                  Fn = fu(Fn), Xe--;
                for (; 0 < gt - Xe; )
                  st = fu(st), gt--;
                for (; Xe--; ) {
                  if (Fn === st || st !== null && Fn === st.alternate)
                    break t;
                  Fn = fu(Fn), st = fu(st);
                }
                Fn = null;
              }
            else
              Fn = null;
            bn !== null && Tp(Xt, $t, bn, Fn, !1), Pn !== null && eo !== null && Tp(Xt, eo, Pn, Fn, !0);
          }
        }
        e: {
          if ($t = Tt ? hi(Tt) : window, bn = $t.nodeName && $t.nodeName.toLowerCase(), bn === "select" || bn === "input" && $t.type === "file")
            var kn = xp;
          else if (_h($t))
            if (Od)
              kn = ea;
            else {
              kn = Ep;
              var Un = Ud;
            }
          else
            (bn = $t.nodeName) && bn.toLowerCase() === "input" && ($t.type === "checkbox" || $t.type === "radio") && (kn = Ll);
          if (kn && (kn = kn(f, Tt))) {
            Gf(Xt, kn, E, Kt);
            break e;
          }
          Un && Un(f, $t, Tt), f === "focusout" && (Un = $t._wrapperState) && Un.controlled && $t.type === "number" && Ct($t, "number", $t.value);
        }
        switch (Un = Tt ? hi(Tt) : window, f) {
          case "focusin":
            (_h(Un) || Un.contentEditable === "true") && (lo = Un, Wf = Tt, cc = null);
            break;
          case "focusout":
            cc = Wf = lo = null;
            break;
          case "mousedown":
            Qa = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Qa = !1, Ol(Xt, E, Kt);
            break;
          case "selectionchange":
            if (Fd)
              break;
          case "keydown":
          case "keyup":
            Ol(Xt, E, Kt);
        }
        var Zn;
        if (_a)
          e: {
            switch (f) {
              case "compositionstart":
                var vr = "onCompositionStart";
                break e;
              case "compositionend":
                vr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                vr = "onCompositionUpdate";
                break e;
            }
            vr = void 0;
          }
        else
          Qc ? Rm(f, E) && (vr = "onCompositionEnd") : f === "keydown" && E.keyCode === 229 && (vr = "onCompositionStart");
        vr && (Ad && E.locale !== "ko" && (Qc || vr !== "onCompositionStart" ? vr === "onCompositionEnd" && Qc && (Zn = Ka()) : (ks = Kt, Du = "value" in ks ? ks.value : ks.textContent, Qc = !0)), Un = hc(Tt, vr), 0 < Un.length && (vr = new bm(vr, f, null, E, Kt), Xt.push({ event: vr, listeners: Un }), Zn ? vr.data = Zn : (Zn = Dd(E), Zn !== null && (vr.data = Zn)))), (Zn = Hi ? Pv(f, E) : Sp(f, E)) && (Tt = hc(Tt, "onBeforeInput"), 0 < Tt.length && (Kt = new bm("onBeforeInput", "beforeinput", null, E, Kt), Xt.push({ event: Kt, listeners: Tt }), Kt.data = Zn));
      }
      Yt(Xt, m);
    });
  }
  function dc(f, m, E) {
    return { instance: f, listener: m, currentTarget: E };
  }
  function hc(f, m) {
    for (var E = m + "Capture", O = []; f !== null; ) {
      var I = f, j = I.stateNode;
      I.tag === 5 && j !== null && (I = j, j = Wn(f, E), j != null && O.unshift(dc(f, j, I)), j = Wn(f, m), j != null && O.push(dc(f, j, I))), f = f.return;
    }
    return O;
  }
  function fu(f) {
    if (f === null)
      return null;
    do
      f = f.return;
    while (f && f.tag !== 5);
    return f || null;
  }
  function Tp(f, m, E, O, I) {
    for (var j = m._reactName, ue = []; E !== null && E !== O; ) {
      var Re = E, Ie = Re.alternate, Tt = Re.stateNode;
      if (Ie !== null && Ie === O)
        break;
      Re.tag === 5 && Tt !== null && (Re = Tt, I ? (Ie = Wn(E, j), Ie != null && ue.unshift(dc(E, Ie, Re))) : I || (Ie = Wn(E, j), Ie != null && ue.push(dc(E, Ie, Re)))), E = E.return;
    }
    ue.length !== 0 && f.push({ event: m, listeners: ue });
  }
  var wp = /\r\n?/g, Lm = /\u0000|\uFFFD/g;
  function wh(f) {
    return (typeof f == "string" ? f : "" + f).replace(wp, `
`).replace(Lm, "");
  }
  function zd(f, m, E) {
    if (m = wh(m), wh(f) !== m && E)
      throw Error(t(425));
  }
  function Id() {
  }
  var Yf = null, nf = null;
  function Bd(f, m) {
    return f === "textarea" || f === "noscript" || typeof m.children == "string" || typeof m.children == "number" || typeof m.dangerouslySetInnerHTML == "object" && m.dangerouslySetInnerHTML !== null && m.dangerouslySetInnerHTML.__html != null;
  }
  var rf = typeof setTimeout == "function" ? setTimeout : void 0, Mh = typeof clearTimeout == "function" ? clearTimeout : void 0, Hd = typeof Promise == "function" ? Promise : void 0, Mp = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hd < "u" ? function(f) {
    return Hd.resolve(null).then(f).catch(Om);
  } : rf;
  function Om(f) {
    setTimeout(function() {
      throw f;
    });
  }
  function Uu(f, m) {
    var E = m, O = 0;
    do {
      var I = E.nextSibling;
      if (f.removeChild(E), I && I.nodeType === 8)
        if (E = I.data, E === "/$") {
          if (O === 0) {
            f.removeChild(I), If(m);
            return;
          }
          O--;
        } else
          E !== "$" && E !== "$?" && E !== "$!" || O++;
      E = I;
    } while (E);
    If(m);
  }
  function Gs(f) {
    for (; f != null; f = f.nextSibling) {
      var m = f.nodeType;
      if (m === 1 || m === 3)
        break;
      if (m === 8) {
        if (m = f.data, m === "$" || m === "$!" || m === "$?")
          break;
        if (m === "/$")
          return null;
      }
    }
    return f;
  }
  function Nu(f) {
    f = f.previousSibling;
    for (var m = 0; f; ) {
      if (f.nodeType === 8) {
        var E = f.data;
        if (E === "$" || E === "$!" || E === "$?") {
          if (m === 0)
            return f;
          m--;
        } else
          E === "/$" && m++;
      }
      f = f.previousSibling;
    }
    return null;
  }
  var Fu = Math.random().toString(36).slice(2), Za = "__reactFiber$" + Fu, pc = "__reactProps$" + Fu, Ws = "__reactContainer$" + Fu, Xf = "__reactEvents$" + Fu, qf = "__reactListeners$" + Fu, Vd = "__reactHandles$" + Fu;
  function Xo(f) {
    var m = f[Za];
    if (m)
      return m;
    for (var E = f.parentNode; E; ) {
      if (m = E[Ws] || E[Za]) {
        if (E = m.alternate, m.child !== null || E !== null && E.child !== null)
          for (f = Nu(f); f !== null; ) {
            if (E = f[Za])
              return E;
            f = Nu(f);
          }
        return m;
      }
      f = E, E = f.parentNode;
    }
    return null;
  }
  function js(f) {
    return f = f[Za] || f[Ws], !f || f.tag !== 5 && f.tag !== 6 && f.tag !== 13 && f.tag !== 3 ? null : f;
  }
  function hi(f) {
    if (f.tag === 5 || f.tag === 6)
      return f.stateNode;
    throw Error(t(33));
  }
  function Xn(f) {
    return f[pc] || null;
  }
  var pi = [], Nr = -1;
  function In(f) {
    return { current: f };
  }
  function Zr(f) {
    0 > Nr || (f.current = pi[Nr], pi[Nr] = null, Nr--);
  }
  function ui(f, m) {
    Nr++, pi[Nr] = f.current, f.current = m;
  }
  var ku = {}, hr = In(ku), ba = In(!1), gs = ku;
  function $s(f, m) {
    var E = f.type.contextTypes;
    if (!E)
      return ku;
    var O = f.stateNode;
    if (O && O.__reactInternalMemoizedUnmaskedChildContext === m)
      return O.__reactInternalMemoizedMaskedChildContext;
    var I = {}, j;
    for (j in E)
      I[j] = m[j];
    return O && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = m, f.__reactInternalMemoizedMaskedChildContext = I), I;
  }
  function ta(f) {
    return f = f.childContextTypes, f != null;
  }
  function Ys() {
    Zr(ba), Zr(hr);
  }
  function mc(f, m, E) {
    if (hr.current !== ku)
      throw Error(t(168));
    ui(hr, m), ui(ba, E);
  }
  function Kf(f, m, E) {
    var O = f.stateNode;
    if (m = m.childContextTypes, typeof O.getChildContext != "function")
      return E;
    O = O.getChildContext();
    for (var I in O)
      if (!(I in m))
        throw Error(t(108, Ne(f) || "Unknown", I));
    return re({}, E, O);
  }
  function vc(f) {
    return f = (f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext || ku, gs = hr.current, ui(hr, f), ui(ba, ba.current), !0;
  }
  function Uv(f, m, E) {
    var O = f.stateNode;
    if (!O)
      throw Error(t(169));
    E ? (f = Kf(f, m, gs), O.__reactInternalMemoizedMergedChildContext = f, Zr(ba), Zr(hr), ui(hr, f)) : Zr(ba), ui(ba, E);
  }
  var ys = null, xo = !1, Ch = !1;
  function du(f) {
    ys === null ? ys = [f] : ys.push(f);
  }
  function Qf(f) {
    xo = !0, du(f);
  }
  function Ua() {
    if (!Ch && ys !== null) {
      Ch = !0;
      var f = 0, m = Vr;
      try {
        var E = ys;
        for (Vr = 1; f < E.length; f++) {
          var O = E[f];
          do
            O = O(!0);
          while (O !== null);
        }
        ys = null, xo = !1;
      } catch (I) {
        throw ys !== null && (ys = ys.slice(f + 1)), cn(Hr, Ua), I;
      } finally {
        Vr = m, Ch = !1;
      }
    }
    return null;
  }
  var zu = [], ci = 0, hu = null, gr = 0, uo = [], Ta = 0, Iu = null, nn = 1, pl = "";
  function _o(f, m) {
    zu[ci++] = gr, zu[ci++] = hu, hu = f, gr = m;
  }
  function Pm(f, m, E) {
    uo[Ta++] = nn, uo[Ta++] = pl, uo[Ta++] = Iu, Iu = f;
    var O = nn;
    f = pl;
    var I = 32 - di(O) - 1;
    O &= ~(1 << I), E += 1;
    var j = 32 - di(m) + I;
    if (30 < j) {
      var ue = I - I % 5;
      j = (O & (1 << ue) - 1).toString(32), O >>= ue, I -= ue, nn = 1 << 32 - di(m) + I | E << I | O, pl = j + f;
    } else
      nn = 1 << j | E << I | O, pl = f;
  }
  function Cp(f) {
    f.return !== null && (_o(f, 1), Pm(f, 1, 0));
  }
  function af(f) {
    for (; f === hu; )
      hu = zu[--ci], zu[ci] = null, gr = zu[--ci], zu[ci] = null;
    for (; f === Iu; )
      Iu = uo[--Ta], uo[Ta] = null, pl = uo[--Ta], uo[Ta] = null, nn = uo[--Ta], uo[Ta] = null;
  }
  var Eo = null, Ss = null, Xi = !1, ml = null;
  function Nl(f, m) {
    var E = Js(5, null, null, 0);
    E.elementType = "DELETED", E.stateNode = m, E.return = f, m = f.deletions, m === null ? (f.deletions = [E], f.flags |= 16) : m.push(E);
  }
  function Gd(f, m) {
    switch (f.tag) {
      case 5:
        var E = f.type;
        return m = m.nodeType !== 1 || E.toLowerCase() !== m.nodeName.toLowerCase() ? null : m, m !== null ? (f.stateNode = m, Eo = f, Ss = Gs(m.firstChild), !0) : !1;
      case 6:
        return m = f.pendingProps === "" || m.nodeType !== 3 ? null : m, m !== null ? (f.stateNode = m, Eo = f, Ss = null, !0) : !1;
      case 13:
        return m = m.nodeType !== 8 ? null : m, m !== null ? (E = Iu !== null ? { id: nn, overflow: pl } : null, f.memoizedState = { dehydrated: m, treeContext: E, retryLane: 1073741824 }, E = Js(18, null, null, 0), E.stateNode = m, E.return = f, f.child = E, Eo = f, Ss = null, !0) : !1;
      default:
        return !1;
    }
  }
  function of(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function Wd(f) {
    if (Xi) {
      var m = Ss;
      if (m) {
        var E = m;
        if (!Gd(f, m)) {
          if (of(f))
            throw Error(t(418));
          m = Gs(E.nextSibling);
          var O = Eo;
          m && Gd(f, m) ? Nl(O, E) : (f.flags = f.flags & -4097 | 2, Xi = !1, Eo = f);
        }
      } else {
        if (of(f))
          throw Error(t(418));
        f.flags = f.flags & -4097 | 2, Xi = !1, Eo = f;
      }
    }
  }
  function Zf(f) {
    for (f = f.return; f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13; )
      f = f.return;
    Eo = f;
  }
  function xs(f) {
    if (f !== Eo)
      return !1;
    if (!Xi)
      return Zf(f), Xi = !0, !1;
    var m;
    if ((m = f.tag !== 3) && !(m = f.tag !== 5) && (m = f.type, m = m !== "head" && m !== "body" && !Bd(f.type, f.memoizedProps)), m && (m = Ss)) {
      if (of(f))
        throw co(), Error(t(418));
      for (; m; )
        Nl(f, m), m = Gs(m.nextSibling);
    }
    if (Zf(f), f.tag === 13) {
      if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f)
        throw Error(t(317));
      e: {
        for (f = f.nextSibling, m = 0; f; ) {
          if (f.nodeType === 8) {
            var E = f.data;
            if (E === "/$") {
              if (m === 0) {
                Ss = Gs(f.nextSibling);
                break e;
              }
              m--;
            } else
              E !== "$" && E !== "$!" && E !== "$?" || m++;
          }
          f = f.nextSibling;
        }
        Ss = null;
      }
    } else
      Ss = Eo ? Gs(f.stateNode.nextSibling) : null;
    return !0;
  }
  function co() {
    for (var f = Ss; f; )
      f = Gs(f.nextSibling);
  }
  function sa() {
    Ss = Eo = null, Xi = !1;
  }
  function Rh(f) {
    ml === null ? ml = [f] : ml.push(f);
  }
  var Um = H.ReactCurrentBatchConfig;
  function vl(f, m) {
    if (f && f.defaultProps) {
      m = re({}, m), f = f.defaultProps;
      for (var E in f)
        m[E] === void 0 && (m[E] = f[E]);
      return m;
    }
    return m;
  }
  var pu = In(null), Ah = null, sf = null, Nm = null;
  function Dh() {
    Nm = sf = Ah = null;
  }
  function Vi(f) {
    var m = pu.current;
    Zr(pu), f._currentValue = m;
  }
  function ha(f, m, E) {
    for (; f !== null; ) {
      var O = f.alternate;
      if ((f.childLanes & m) !== m ? (f.childLanes |= m, O !== null && (O.childLanes |= m)) : O !== null && (O.childLanes & m) !== m && (O.childLanes |= m), f === E)
        break;
      f = f.return;
    }
  }
  function un(f, m) {
    Ah = f, Nm = sf = null, f = f.dependencies, f !== null && f.firstContext !== null && (f.lanes & m && (hn = !0), f.firstContext = null);
  }
  function zi(f) {
    var m = f._currentValue;
    if (Nm !== f)
      if (f = { context: f, memoizedValue: m, next: null }, sf === null) {
        if (Ah === null)
          throw Error(t(308));
        sf = f, Ah.dependencies = { lanes: 0, firstContext: f };
      } else
        sf = sf.next = f;
    return m;
  }
  var Na = null;
  function Rp(f) {
    Na === null ? Na = [f] : Na.push(f);
  }
  function Fm(f, m, E, O) {
    var I = m.interleaved;
    return I === null ? (E.next = E, Rp(m)) : (E.next = I.next, I.next = E), m.interleaved = E, _s(f, O);
  }
  function _s(f, m) {
    f.lanes |= m;
    var E = f.alternate;
    for (E !== null && (E.lanes |= m), E = f, f = f.return; f !== null; )
      f.childLanes |= m, E = f.alternate, E !== null && (E.childLanes |= m), E = f, f = f.return;
    return E.tag === 3 ? E.stateNode : null;
  }
  var pa = !1;
  function dn(f) {
    f.updateQueue = { baseState: f.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Gi(f, m) {
    f = f.updateQueue, m.updateQueue === f && (m.updateQueue = { baseState: f.baseState, firstBaseUpdate: f.firstBaseUpdate, lastBaseUpdate: f.lastBaseUpdate, shared: f.shared, effects: f.effects });
  }
  function Fa(f, m) {
    return { eventTime: f, lane: m, tag: 0, payload: null, callback: null, next: null };
  }
  function gc(f, m, E) {
    var O = f.updateQueue;
    if (O === null)
      return null;
    if (O = O.shared, yr & 2) {
      var I = O.pending;
      return I === null ? m.next = m : (m.next = I.next, I.next = m), O.pending = m, _s(f, E);
    }
    return I = O.interleaved, I === null ? (m.next = m, Rp(O)) : (m.next = I.next, I.next = m), O.interleaved = m, _s(f, E);
  }
  function ma(f, m, E) {
    if (m = m.updateQueue, m !== null && (m = m.shared, (E & 4194240) !== 0)) {
      var O = m.lanes;
      O &= f.pendingLanes, E |= O, m.lanes = E, Dl(f, E);
    }
  }
  function Lr(f, m) {
    var E = f.updateQueue, O = f.alternate;
    if (O !== null && (O = O.updateQueue, E === O)) {
      var I = null, j = null;
      if (E = E.firstBaseUpdate, E !== null) {
        do {
          var ue = { eventTime: E.eventTime, lane: E.lane, tag: E.tag, payload: E.payload, callback: E.callback, next: null };
          j === null ? I = j = ue : j = j.next = ue, E = E.next;
        } while (E !== null);
        j === null ? I = j = m : j = j.next = m;
      } else
        I = j = m;
      E = { baseState: O.baseState, firstBaseUpdate: I, lastBaseUpdate: j, shared: O.shared, effects: O.effects }, f.updateQueue = E;
      return;
    }
    f = E.lastBaseUpdate, f === null ? E.firstBaseUpdate = m : f.next = m, E.lastBaseUpdate = m;
  }
  function qi(f, m, E, O) {
    var I = f.updateQueue;
    pa = !1;
    var j = I.firstBaseUpdate, ue = I.lastBaseUpdate, Re = I.shared.pending;
    if (Re !== null) {
      I.shared.pending = null;
      var Ie = Re, Tt = Ie.next;
      Ie.next = null, ue === null ? j = Tt : ue.next = Tt, ue = Ie;
      var Kt = f.alternate;
      Kt !== null && (Kt = Kt.updateQueue, Re = Kt.lastBaseUpdate, Re !== ue && (Re === null ? Kt.firstBaseUpdate = Tt : Re.next = Tt, Kt.lastBaseUpdate = Ie));
    }
    if (j !== null) {
      var Xt = I.baseState;
      ue = 0, Kt = Tt = Ie = null, Re = j;
      do {
        var $t = Re.lane, bn = Re.eventTime;
        if ((O & $t) === $t) {
          Kt !== null && (Kt = Kt.next = {
            eventTime: bn,
            lane: 0,
            tag: Re.tag,
            payload: Re.payload,
            callback: Re.callback,
            next: null
          });
          e: {
            var Pn = f, Fn = Re;
            switch ($t = m, bn = E, Fn.tag) {
              case 1:
                if (Pn = Fn.payload, typeof Pn == "function") {
                  Xt = Pn.call(bn, Xt, $t);
                  break e;
                }
                Xt = Pn;
                break e;
              case 3:
                Pn.flags = Pn.flags & -65537 | 128;
              case 0:
                if (Pn = Fn.payload, $t = typeof Pn == "function" ? Pn.call(bn, Xt, $t) : Pn, $t == null)
                  break e;
                Xt = re({}, Xt, $t);
                break e;
              case 2:
                pa = !0;
            }
          }
          Re.callback !== null && Re.lane !== 0 && (f.flags |= 64, $t = I.effects, $t === null ? I.effects = [Re] : $t.push(Re));
        } else
          bn = { eventTime: bn, lane: $t, tag: Re.tag, payload: Re.payload, callback: Re.callback, next: null }, Kt === null ? (Tt = Kt = bn, Ie = Xt) : Kt = Kt.next = bn, ue |= $t;
        if (Re = Re.next, Re === null) {
          if (Re = I.shared.pending, Re === null)
            break;
          $t = Re, Re = $t.next, $t.next = null, I.lastBaseUpdate = $t, I.shared.pending = null;
        }
      } while (1);
      if (Kt === null && (Ie = Xt), I.baseState = Ie, I.firstBaseUpdate = Tt, I.lastBaseUpdate = Kt, m = I.shared.interleaved, m !== null) {
        I = m;
        do
          ue |= I.lane, I = I.next;
        while (I !== m);
      } else
        j === null && (I.shared.lanes = 0);
      sd |= ue, f.lanes = ue, f.memoizedState = Xt;
    }
  }
  function na(f, m, E) {
    if (f = m.effects, m.effects = null, f !== null)
      for (m = 0; m < f.length; m++) {
        var O = f[m], I = O.callback;
        if (I !== null) {
          if (O.callback = null, O = E, typeof I != "function")
            throw Error(t(191, I));
          I.call(O);
        }
      }
  }
  var ti = new n.Component().refs;
  function Xs(f, m, E, O) {
    m = f.memoizedState, E = E(O, m), E = E == null ? m : re({}, m, E), f.memoizedState = E, f.lanes === 0 && (f.updateQueue.baseState = E);
  }
  var lf = { isMounted: function(f) {
    return (f = f._reactInternals) ? ye(f) === f : !1;
  }, enqueueSetState: function(f, m, E) {
    f = f._reactInternals;
    var O = Ii(), I = mo(f), j = Fa(O, I);
    j.payload = m, E != null && (j.callback = E), m = gc(f, j, I), m !== null && (ws(m, f, I, O), ma(m, f, I));
  }, enqueueReplaceState: function(f, m, E) {
    f = f._reactInternals;
    var O = Ii(), I = mo(f), j = Fa(O, I);
    j.tag = 1, j.payload = m, E != null && (j.callback = E), m = gc(f, j, I), m !== null && (ws(m, f, I, O), ma(m, f, I));
  }, enqueueForceUpdate: function(f, m) {
    f = f._reactInternals;
    var E = Ii(), O = mo(f), I = Fa(E, O);
    I.tag = 2, m != null && (I.callback = m), m = gc(f, I, O), m !== null && (ws(m, f, O, E), ma(m, f, O));
  } };
  function fo(f, m, E, O, I, j, ue) {
    return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(O, j, ue) : m.prototype && m.prototype.isPureReactComponent ? !dl(E, O) || !dl(I, j) : !0;
  }
  function jd(f, m, E) {
    var O = !1, I = ku, j = m.contextType;
    return typeof j == "object" && j !== null ? j = zi(j) : (I = ta(m) ? gs : hr.current, O = m.contextTypes, j = (O = O != null) ? $s(f, I) : ku), m = new m(E, j), f.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = lf, f.stateNode = m, m._reactInternals = f, O && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = I, f.__reactInternalMemoizedMaskedChildContext = j), m;
  }
  function Bu(f, m, E, O) {
    f = m.state, typeof m.componentWillReceiveProps == "function" && m.componentWillReceiveProps(E, O), typeof m.UNSAFE_componentWillReceiveProps == "function" && m.UNSAFE_componentWillReceiveProps(E, O), m.state !== f && lf.enqueueReplaceState(m, m.state, null);
  }
  function mu(f, m, E, O) {
    var I = f.stateNode;
    I.props = E, I.state = f.memoizedState, I.refs = ti, dn(f);
    var j = m.contextType;
    typeof j == "object" && j !== null ? I.context = zi(j) : (j = ta(m) ? gs : hr.current, I.context = $s(f, j)), I.state = f.memoizedState, j = m.getDerivedStateFromProps, typeof j == "function" && (Xs(f, m, j, E), I.state = f.memoizedState), typeof m.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (m = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), m !== I.state && lf.enqueueReplaceState(I, I.state, null), qi(f, E, I, O), I.state = f.memoizedState), typeof I.componentDidMount == "function" && (f.flags |= 4194308);
  }
  function Jf(f, m, E) {
    if (f = E.ref, f !== null && typeof f != "function" && typeof f != "object") {
      if (E._owner) {
        if (E = E._owner, E) {
          if (E.tag !== 1)
            throw Error(t(309));
          var O = E.stateNode;
        }
        if (!O)
          throw Error(t(147, f));
        var I = O, j = "" + f;
        return m !== null && m.ref !== null && typeof m.ref == "function" && m.ref._stringRef === j ? m.ref : (m = function(ue) {
          var Re = I.refs;
          Re === ti && (Re = I.refs = {}), ue === null ? delete Re[j] : Re[j] = ue;
        }, m._stringRef = j, m);
      }
      if (typeof f != "string")
        throw Error(t(284));
      if (!E._owner)
        throw Error(t(290, f));
    }
    return f;
  }
  function ed(f, m) {
    throw f = Object.prototype.toString.call(m), Error(t(31, f === "[object Object]" ? "object with keys {" + Object.keys(m).join(", ") + "}" : f));
  }
  function qs(f) {
    var m = f._init;
    return m(f._payload);
  }
  function km(f) {
    function m(st, Xe) {
      if (f) {
        var gt = st.deletions;
        gt === null ? (st.deletions = [Xe], st.flags |= 16) : gt.push(Xe);
      }
    }
    function E(st, Xe) {
      if (!f)
        return null;
      for (; Xe !== null; )
        m(st, Xe), Xe = Xe.sibling;
      return null;
    }
    function O(st, Xe) {
      for (st = /* @__PURE__ */ new Map(); Xe !== null; )
        Xe.key !== null ? st.set(Xe.key, Xe) : st.set(Xe.index, Xe), Xe = Xe.sibling;
      return st;
    }
    function I(st, Xe) {
      return st = Bl(st, Xe), st.index = 0, st.sibling = null, st;
    }
    function j(st, Xe, gt) {
      return st.index = gt, f ? (gt = st.alternate, gt !== null ? (gt = gt.index, gt < Xe ? (st.flags |= 2, Xe) : gt) : (st.flags |= 2, Xe)) : (st.flags |= 1048576, Xe);
    }
    function ue(st) {
      return f && st.alternate === null && (st.flags |= 2), st;
    }
    function Re(st, Xe, gt, an) {
      return Xe === null || Xe.tag !== 6 ? (Xe = _u(gt, st.mode, an), Xe.return = st, Xe) : (Xe = I(Xe, gt), Xe.return = st, Xe);
    }
    function Ie(st, Xe, gt, an) {
      var kn = gt.type;
      return kn === Y ? Kt(st, Xe, gt.props.children, an, gt.key) : Xe !== null && (Xe.elementType === kn || typeof kn == "object" && kn !== null && kn.$$typeof === _e && qs(kn) === Xe.type) ? (an = I(Xe, gt.props), an.ref = Jf(st, Xe, gt), an.return = st, an) : (an = nh(gt.type, gt.key, gt.props, null, st.mode, an), an.ref = Jf(st, Xe, gt), an.return = st, an);
    }
    function Tt(st, Xe, gt, an) {
      return Xe === null || Xe.tag !== 4 || Xe.stateNode.containerInfo !== gt.containerInfo || Xe.stateNode.implementation !== gt.implementation ? (Xe = Qi(gt, st.mode, an), Xe.return = st, Xe) : (Xe = I(Xe, gt.children || []), Xe.return = st, Xe);
    }
    function Kt(st, Xe, gt, an, kn) {
      return Xe === null || Xe.tag !== 7 ? (Xe = Ip(gt, st.mode, an, kn), Xe.return = st, Xe) : (Xe = I(Xe, gt), Xe.return = st, Xe);
    }
    function Xt(st, Xe, gt) {
      if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number")
        return Xe = _u("" + Xe, st.mode, gt), Xe.return = st, Xe;
      if (typeof Xe == "object" && Xe !== null) {
        switch (Xe.$$typeof) {
          case B:
            return gt = nh(Xe.type, Xe.key, Xe.props, null, st.mode, gt), gt.ref = Jf(st, null, Xe), gt.return = st, gt;
          case $:
            return Xe = Qi(Xe, st.mode, gt), Xe.return = st, Xe;
          case _e:
            var an = Xe._init;
            return Xt(st, an(Xe._payload), gt);
        }
        if (Pt(Xe) || ve(Xe))
          return Xe = Ip(Xe, st.mode, gt, null), Xe.return = st, Xe;
        ed(st, Xe);
      }
      return null;
    }
    function $t(st, Xe, gt, an) {
      var kn = Xe !== null ? Xe.key : null;
      if (typeof gt == "string" && gt !== "" || typeof gt == "number")
        return kn !== null ? null : Re(st, Xe, "" + gt, an);
      if (typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case B:
            return gt.key === kn ? Ie(st, Xe, gt, an) : null;
          case $:
            return gt.key === kn ? Tt(st, Xe, gt, an) : null;
          case _e:
            return kn = gt._init, $t(
              st,
              Xe,
              kn(gt._payload),
              an
            );
        }
        if (Pt(gt) || ve(gt))
          return kn !== null ? null : Kt(st, Xe, gt, an, null);
        ed(st, gt);
      }
      return null;
    }
    function bn(st, Xe, gt, an, kn) {
      if (typeof an == "string" && an !== "" || typeof an == "number")
        return st = st.get(gt) || null, Re(Xe, st, "" + an, kn);
      if (typeof an == "object" && an !== null) {
        switch (an.$$typeof) {
          case B:
            return st = st.get(an.key === null ? gt : an.key) || null, Ie(Xe, st, an, kn);
          case $:
            return st = st.get(an.key === null ? gt : an.key) || null, Tt(Xe, st, an, kn);
          case _e:
            var Un = an._init;
            return bn(st, Xe, gt, Un(an._payload), kn);
        }
        if (Pt(an) || ve(an))
          return st = st.get(gt) || null, Kt(Xe, st, an, kn, null);
        ed(Xe, an);
      }
      return null;
    }
    function Pn(st, Xe, gt, an) {
      for (var kn = null, Un = null, Zn = Xe, vr = Xe = 0, Jo = null; Zn !== null && vr < gt.length; vr++) {
        Zn.index > vr ? (Jo = Zn, Zn = null) : Jo = Zn.sibling;
        var xi = $t(st, Zn, gt[vr], an);
        if (xi === null) {
          Zn === null && (Zn = Jo);
          break;
        }
        f && Zn && xi.alternate === null && m(st, Zn), Xe = j(xi, Xe, vr), Un === null ? kn = xi : Un.sibling = xi, Un = xi, Zn = Jo;
      }
      if (vr === gt.length)
        return E(st, Zn), Xi && _o(st, vr), kn;
      if (Zn === null) {
        for (; vr < gt.length; vr++)
          Zn = Xt(st, gt[vr], an), Zn !== null && (Xe = j(Zn, Xe, vr), Un === null ? kn = Zn : Un.sibling = Zn, Un = Zn);
        return Xi && _o(st, vr), kn;
      }
      for (Zn = O(st, Zn); vr < gt.length; vr++)
        Jo = bn(Zn, st, vr, gt[vr], an), Jo !== null && (f && Jo.alternate !== null && Zn.delete(Jo.key === null ? vr : Jo.key), Xe = j(Jo, Xe, vr), Un === null ? kn = Jo : Un.sibling = Jo, Un = Jo);
      return f && Zn.forEach(function(Tc) {
        return m(st, Tc);
      }), Xi && _o(st, vr), kn;
    }
    function Fn(st, Xe, gt, an) {
      var kn = ve(gt);
      if (typeof kn != "function")
        throw Error(t(150));
      if (gt = kn.call(gt), gt == null)
        throw Error(t(151));
      for (var Un = kn = null, Zn = Xe, vr = Xe = 0, Jo = null, xi = gt.next(); Zn !== null && !xi.done; vr++, xi = gt.next()) {
        Zn.index > vr ? (Jo = Zn, Zn = null) : Jo = Zn.sibling;
        var Tc = $t(st, Zn, xi.value, an);
        if (Tc === null) {
          Zn === null && (Zn = Jo);
          break;
        }
        f && Zn && Tc.alternate === null && m(st, Zn), Xe = j(Tc, Xe, vr), Un === null ? kn = Tc : Un.sibling = Tc, Un = Tc, Zn = Jo;
      }
      if (xi.done)
        return E(
          st,
          Zn
        ), Xi && _o(st, vr), kn;
      if (Zn === null) {
        for (; !xi.done; vr++, xi = gt.next())
          xi = Xt(st, xi.value, an), xi !== null && (Xe = j(xi, Xe, vr), Un === null ? kn = xi : Un.sibling = xi, Un = xi);
        return Xi && _o(st, vr), kn;
      }
      for (Zn = O(st, Zn); !xi.done; vr++, xi = gt.next())
        xi = bn(Zn, st, vr, xi.value, an), xi !== null && (f && xi.alternate !== null && Zn.delete(xi.key === null ? vr : xi.key), Xe = j(xi, Xe, vr), Un === null ? kn = xi : Un.sibling = xi, Un = xi);
      return f && Zn.forEach(function(my) {
        return m(st, my);
      }), Xi && _o(st, vr), kn;
    }
    function eo(st, Xe, gt, an) {
      if (typeof gt == "object" && gt !== null && gt.type === Y && gt.key === null && (gt = gt.props.children), typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case B:
            e: {
              for (var kn = gt.key, Un = Xe; Un !== null; ) {
                if (Un.key === kn) {
                  if (kn = gt.type, kn === Y) {
                    if (Un.tag === 7) {
                      E(st, Un.sibling), Xe = I(Un, gt.props.children), Xe.return = st, st = Xe;
                      break e;
                    }
                  } else if (Un.elementType === kn || typeof kn == "object" && kn !== null && kn.$$typeof === _e && qs(kn) === Un.type) {
                    E(st, Un.sibling), Xe = I(Un, gt.props), Xe.ref = Jf(st, Un, gt), Xe.return = st, st = Xe;
                    break e;
                  }
                  E(st, Un);
                  break;
                } else
                  m(st, Un);
                Un = Un.sibling;
              }
              gt.type === Y ? (Xe = Ip(gt.props.children, st.mode, an, gt.key), Xe.return = st, st = Xe) : (an = nh(gt.type, gt.key, gt.props, null, st.mode, an), an.ref = Jf(st, Xe, gt), an.return = st, st = an);
            }
            return ue(st);
          case $:
            e: {
              for (Un = gt.key; Xe !== null; ) {
                if (Xe.key === Un)
                  if (Xe.tag === 4 && Xe.stateNode.containerInfo === gt.containerInfo && Xe.stateNode.implementation === gt.implementation) {
                    E(st, Xe.sibling), Xe = I(Xe, gt.children || []), Xe.return = st, st = Xe;
                    break e;
                  } else {
                    E(st, Xe);
                    break;
                  }
                else
                  m(st, Xe);
                Xe = Xe.sibling;
              }
              Xe = Qi(gt, st.mode, an), Xe.return = st, st = Xe;
            }
            return ue(st);
          case _e:
            return Un = gt._init, eo(st, Xe, Un(gt._payload), an);
        }
        if (Pt(gt))
          return Pn(st, Xe, gt, an);
        if (ve(gt))
          return Fn(st, Xe, gt, an);
        ed(st, gt);
      }
      return typeof gt == "string" && gt !== "" || typeof gt == "number" ? (gt = "" + gt, Xe !== null && Xe.tag === 6 ? (E(st, Xe.sibling), Xe = I(Xe, gt), Xe.return = st, st = Xe) : (E(st, Xe), Xe = _u(gt, st.mode, an), Xe.return = st, st = Xe), ue(st)) : E(st, Xe);
    }
    return eo;
  }
  var td = km(!0), $d = km(!1), uf = {}, gl = In(uf), vu = In(uf), cf = In(uf);
  function yl(f) {
    if (f === uf)
      throw Error(t(174));
    return f;
  }
  function Lh(f, m) {
    switch (ui(cf, m), ui(vu, f), ui(gl, uf), f = m.nodeType, f) {
      case 9:
      case 11:
        m = (m = m.documentElement) ? m.namespaceURI : ot(null, "");
        break;
      default:
        f = f === 8 ? m.parentNode : m, m = f.namespaceURI || null, f = f.tagName, m = ot(m, f);
    }
    Zr(gl), ui(gl, m);
  }
  function gu() {
    Zr(gl), Zr(vu), Zr(cf);
  }
  function qn(f) {
    yl(cf.current);
    var m = yl(gl.current), E = ot(m, f.type);
    m !== E && (ui(vu, f), ui(gl, E));
  }
  function Cr(f) {
    vu.current === f && (Zr(gl), Zr(vu));
  }
  var Kn = In(0);
  function jr(f) {
    for (var m = f; m !== null; ) {
      if (m.tag === 13) {
        var E = m.memoizedState;
        if (E !== null && (E = E.dehydrated, E === null || E.data === "$?" || E.data === "$!"))
          return m;
      } else if (m.tag === 19 && m.memoizedProps.revealOrder !== void 0) {
        if (m.flags & 128)
          return m;
      } else if (m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === f)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === f)
          return null;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
    return null;
  }
  var bo = [];
  function Ks() {
    for (var f = 0; f < bo.length; f++)
      bo[f]._workInProgressVersionPrimary = null;
    bo.length = 0;
  }
  var ff = H.ReactCurrentDispatcher, Es = H.ReactCurrentBatchConfig, To = 0, ni = null, Nt = null, Qr = null, Hn = !1, Hu = !1, Qs = 0, No = 0;
  function Si() {
    throw Error(t(321));
  }
  function nd(f, m) {
    if (m === null)
      return !1;
    for (var E = 0; E < m.length && E < f.length; E++)
      if (!Pa(f[E], m[E]))
        return !1;
    return !0;
  }
  function df(f, m, E, O, I, j) {
    if (To = j, ni = m, m.memoizedState = null, m.updateQueue = null, m.lanes = 0, ff.current = f === null || f.memoizedState === null ? S : D, f = E(O, I), Hu) {
      j = 0;
      do {
        if (Hu = !1, Qs = 0, 25 <= j)
          throw Error(t(301));
        j += 1, Qr = Nt = null, m.updateQueue = null, ff.current = z, f = E(O, I);
      } while (Hu);
    }
    if (ff.current = g, m = Nt !== null && Nt.next !== null, To = 0, Qr = Nt = ni = null, Hn = !1, m)
      throw Error(t(300));
    return f;
  }
  function hf() {
    var f = Qs !== 0;
    return Qs = 0, f;
  }
  function Fo() {
    var f = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Qr === null ? ni.memoizedState = Qr = f : Qr = Qr.next = f, Qr;
  }
  function Sl() {
    if (Nt === null) {
      var f = ni.alternate;
      f = f !== null ? f.memoizedState : null;
    } else
      f = Nt.next;
    var m = Qr === null ? ni.memoizedState : Qr.next;
    if (m !== null)
      Qr = m, Nt = f;
    else {
      if (f === null)
        throw Error(t(310));
      Nt = f, f = { memoizedState: Nt.memoizedState, baseState: Nt.baseState, baseQueue: Nt.baseQueue, queue: Nt.queue, next: null }, Qr === null ? ni.memoizedState = Qr = f : Qr = Qr.next = f;
    }
    return Qr;
  }
  function rd(f, m) {
    return typeof m == "function" ? m(f) : m;
  }
  function Yd(f) {
    var m = Sl(), E = m.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = f;
    var O = Nt, I = O.baseQueue, j = E.pending;
    if (j !== null) {
      if (I !== null) {
        var ue = I.next;
        I.next = j.next, j.next = ue;
      }
      O.baseQueue = I = j, E.pending = null;
    }
    if (I !== null) {
      j = I.next, O = O.baseState;
      var Re = ue = null, Ie = null, Tt = j;
      do {
        var Kt = Tt.lane;
        if ((To & Kt) === Kt)
          Ie !== null && (Ie = Ie.next = { lane: 0, action: Tt.action, hasEagerState: Tt.hasEagerState, eagerState: Tt.eagerState, next: null }), O = Tt.hasEagerState ? Tt.eagerState : f(O, Tt.action);
        else {
          var Xt = {
            lane: Kt,
            action: Tt.action,
            hasEagerState: Tt.hasEagerState,
            eagerState: Tt.eagerState,
            next: null
          };
          Ie === null ? (Re = Ie = Xt, ue = O) : Ie = Ie.next = Xt, ni.lanes |= Kt, sd |= Kt;
        }
        Tt = Tt.next;
      } while (Tt !== null && Tt !== j);
      Ie === null ? ue = O : Ie.next = Re, Pa(O, m.memoizedState) || (hn = !0), m.memoizedState = O, m.baseState = ue, m.baseQueue = Ie, E.lastRenderedState = O;
    }
    if (f = E.interleaved, f !== null) {
      I = f;
      do
        j = I.lane, ni.lanes |= j, sd |= j, I = I.next;
      while (I !== f);
    } else
      I === null && (E.lanes = 0);
    return [m.memoizedState, E.dispatch];
  }
  function qo(f) {
    var m = Sl(), E = m.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = f;
    var O = E.dispatch, I = E.pending, j = m.memoizedState;
    if (I !== null) {
      E.pending = null;
      var ue = I = I.next;
      do
        j = f(j, ue.action), ue = ue.next;
      while (ue !== I);
      Pa(j, m.memoizedState) || (hn = !0), m.memoizedState = j, m.baseQueue === null && (m.baseState = j), E.lastRenderedState = j;
    }
    return [j, O];
  }
  function xl() {
  }
  function zm(f, m) {
    var E = ni, O = Sl(), I = m(), j = !Pa(O.memoizedState, I);
    if (j && (O.memoizedState = I, hn = !0), O = O.queue, Vu(fi.bind(null, E, O, f), [f]), O.getSnapshot !== m || j || Qr !== null && Qr.memoizedState.tag & 1) {
      if (E.flags |= 2048, kl(9, ho.bind(null, E, O, I, m), void 0, null), wi === null)
        throw Error(t(349));
      To & 30 || yc(E, m, I);
    }
    return I;
  }
  function yc(f, m, E) {
    f.flags |= 16384, f = { getSnapshot: m, value: E }, m = ni.updateQueue, m === null ? (m = { lastEffect: null, stores: null }, ni.updateQueue = m, m.stores = [f]) : (E = m.stores, E === null ? m.stores = [f] : E.push(f));
  }
  function ho(f, m, E, O) {
    m.value = E, m.getSnapshot = O, Fl(m) && Zs(f);
  }
  function fi(f, m, E) {
    return E(function() {
      Fl(m) && Zs(f);
    });
  }
  function Fl(f) {
    var m = f.getSnapshot;
    f = f.value;
    try {
      var E = m();
      return !Pa(f, E);
    } catch {
      return !0;
    }
  }
  function Zs(f) {
    var m = _s(f, 1);
    m !== null && ws(m, f, 1, -1);
  }
  function Im(f) {
    var m = Fo();
    return typeof f == "function" && (f = f()), m.memoizedState = m.baseState = f, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: rd, lastRenderedState: f }, m.queue = f, f = f.dispatch = gf.bind(null, ni, f), [m.memoizedState, f];
  }
  function kl(f, m, E, O) {
    return f = { tag: f, create: m, destroy: E, deps: O, next: null }, m = ni.updateQueue, m === null ? (m = { lastEffect: null, stores: null }, ni.updateQueue = m, m.lastEffect = f.next = f) : (E = m.lastEffect, E === null ? m.lastEffect = f.next = f : (O = E.next, E.next = f, f.next = O, m.lastEffect = f)), f;
  }
  function pf() {
    return Sl().memoizedState;
  }
  function yu(f, m, E, O) {
    var I = Fo();
    ni.flags |= f, I.memoizedState = kl(1 | m, E, void 0, O === void 0 ? null : O);
  }
  function zl(f, m, E, O) {
    var I = Sl();
    O = O === void 0 ? null : O;
    var j = void 0;
    if (Nt !== null) {
      var ue = Nt.memoizedState;
      if (j = ue.destroy, O !== null && nd(O, ue.deps)) {
        I.memoizedState = kl(m, E, j, O);
        return;
      }
    }
    ni.flags |= f, I.memoizedState = kl(1 | m, E, j, O);
  }
  function wo(f, m) {
    return yu(8390656, 8, f, m);
  }
  function Vu(f, m) {
    return zl(2048, 8, f, m);
  }
  function id(f, m) {
    return zl(4, 2, f, m);
  }
  function Ko(f, m) {
    return zl(4, 4, f, m);
  }
  function mf(f, m) {
    if (typeof m == "function")
      return f = f(), m(f), function() {
        m(null);
      };
    if (m != null)
      return f = f(), m.current = f, function() {
        m.current = null;
      };
  }
  function Il(f, m, E) {
    return E = E != null ? E.concat([f]) : null, zl(4, 4, mf.bind(null, m, f), E);
  }
  function ad() {
  }
  function vf(f, m) {
    var E = Sl();
    m = m === void 0 ? null : m;
    var O = E.memoizedState;
    return O !== null && m !== null && nd(m, O[1]) ? O[0] : (E.memoizedState = [f, m], f);
  }
  function Su(f, m) {
    var E = Sl();
    m = m === void 0 ? null : m;
    var O = E.memoizedState;
    return O !== null && m !== null && nd(m, O[1]) ? O[0] : (f = f(), E.memoizedState = [f, m], f);
  }
  function _l(f, m, E) {
    return To & 21 ? (Pa(E, m) || (E = Wo(), ni.lanes |= E, sd |= E, f.baseState = !0), m) : (f.baseState && (f.baseState = !1, hn = !0), f.memoizedState = E);
  }
  function ty(f, m) {
    var E = Vr;
    Vr = E !== 0 && 4 > E ? E : 4, f(!0);
    var O = Es.transition;
    Es.transition = {};
    try {
      f(!1), m();
    } finally {
      Vr = E, Es.transition = O;
    }
  }
  function $r() {
    return Sl().memoizedState;
  }
  function od(f, m, E) {
    var O = mo(f);
    if (E = { lane: O, action: E, hasEagerState: !1, eagerState: null, next: null }, Gu(f))
      Sc(m, E);
    else if (E = Fm(f, m, E, O), E !== null) {
      var I = Ii();
      ws(E, f, O, I), Bm(E, m, O);
    }
  }
  function gf(f, m, E) {
    var O = mo(f), I = { lane: O, action: E, hasEagerState: !1, eagerState: null, next: null };
    if (Gu(f))
      Sc(m, I);
    else {
      var j = f.alternate;
      if (f.lanes === 0 && (j === null || j.lanes === 0) && (j = m.lastRenderedReducer, j !== null))
        try {
          var ue = m.lastRenderedState, Re = j(ue, E);
          if (I.hasEagerState = !0, I.eagerState = Re, Pa(Re, ue)) {
            var Ie = m.interleaved;
            Ie === null ? (I.next = I, Rp(m)) : (I.next = Ie.next, Ie.next = I), m.interleaved = I;
            return;
          }
        } catch {
        } finally {
        }
      E = Fm(f, m, I, O), E !== null && (I = Ii(), ws(E, f, O, I), Bm(E, m, O));
    }
  }
  function Gu(f) {
    var m = f.alternate;
    return f === ni || m !== null && m === ni;
  }
  function Sc(f, m) {
    Hu = Hn = !0;
    var E = f.pending;
    E === null ? m.next = m : (m.next = E.next, E.next = m), f.pending = m;
  }
  function Bm(f, m, E) {
    if (E & 4194240) {
      var O = m.lanes;
      O &= f.pendingLanes, E |= O, m.lanes = E, Dl(f, E);
    }
  }
  var g = { readContext: zi, useCallback: Si, useContext: Si, useEffect: Si, useImperativeHandle: Si, useInsertionEffect: Si, useLayoutEffect: Si, useMemo: Si, useReducer: Si, useRef: Si, useState: Si, useDebugValue: Si, useDeferredValue: Si, useTransition: Si, useMutableSource: Si, useSyncExternalStore: Si, useId: Si, unstable_isNewReconciler: !1 }, S = { readContext: zi, useCallback: function(f, m) {
    return Fo().memoizedState = [f, m === void 0 ? null : m], f;
  }, useContext: zi, useEffect: wo, useImperativeHandle: function(f, m, E) {
    return E = E != null ? E.concat([f]) : null, yu(
      4194308,
      4,
      mf.bind(null, m, f),
      E
    );
  }, useLayoutEffect: function(f, m) {
    return yu(4194308, 4, f, m);
  }, useInsertionEffect: function(f, m) {
    return yu(4, 2, f, m);
  }, useMemo: function(f, m) {
    var E = Fo();
    return m = m === void 0 ? null : m, f = f(), E.memoizedState = [f, m], f;
  }, useReducer: function(f, m, E) {
    var O = Fo();
    return m = E !== void 0 ? E(m) : m, O.memoizedState = O.baseState = m, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: f, lastRenderedState: m }, O.queue = f, f = f.dispatch = od.bind(null, ni, f), [O.memoizedState, f];
  }, useRef: function(f) {
    var m = Fo();
    return f = { current: f }, m.memoizedState = f;
  }, useState: Im, useDebugValue: ad, useDeferredValue: function(f) {
    return Fo().memoizedState = f;
  }, useTransition: function() {
    var f = Im(!1), m = f[0];
    return f = ty.bind(null, f[1]), Fo().memoizedState = f, [m, f];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(f, m, E) {
    var O = ni, I = Fo();
    if (Xi) {
      if (E === void 0)
        throw Error(t(407));
      E = E();
    } else {
      if (E = m(), wi === null)
        throw Error(t(349));
      To & 30 || yc(O, m, E);
    }
    I.memoizedState = E;
    var j = { value: E, getSnapshot: m };
    return I.queue = j, wo(fi.bind(
      null,
      O,
      j,
      f
    ), [f]), O.flags |= 2048, kl(9, ho.bind(null, O, j, E, m), void 0, null), E;
  }, useId: function() {
    var f = Fo(), m = wi.identifierPrefix;
    if (Xi) {
      var E = pl, O = nn;
      E = (O & ~(1 << 32 - di(O) - 1)).toString(32) + E, m = ":" + m + "R" + E, E = Qs++, 0 < E && (m += "H" + E.toString(32)), m += ":";
    } else
      E = No++, m = ":" + m + "r" + E.toString(32) + ":";
    return f.memoizedState = m;
  }, unstable_isNewReconciler: !1 }, D = {
    readContext: zi,
    useCallback: vf,
    useContext: zi,
    useEffect: Vu,
    useImperativeHandle: Il,
    useInsertionEffect: id,
    useLayoutEffect: Ko,
    useMemo: Su,
    useReducer: Yd,
    useRef: pf,
    useState: function() {
      return Yd(rd);
    },
    useDebugValue: ad,
    useDeferredValue: function(f) {
      var m = Sl();
      return _l(m, Nt.memoizedState, f);
    },
    useTransition: function() {
      var f = Yd(rd)[0], m = Sl().memoizedState;
      return [f, m];
    },
    useMutableSource: xl,
    useSyncExternalStore: zm,
    useId: $r,
    unstable_isNewReconciler: !1
  }, z = { readContext: zi, useCallback: vf, useContext: zi, useEffect: Vu, useImperativeHandle: Il, useInsertionEffect: id, useLayoutEffect: Ko, useMemo: Su, useReducer: qo, useRef: pf, useState: function() {
    return qo(rd);
  }, useDebugValue: ad, useDeferredValue: function(f) {
    var m = Sl();
    return Nt === null ? m.memoizedState = f : _l(m, Nt.memoizedState, f);
  }, useTransition: function() {
    var f = qo(rd)[0], m = Sl().memoizedState;
    return [f, m];
  }, useMutableSource: xl, useSyncExternalStore: zm, useId: $r, unstable_isNewReconciler: !1 };
  function W(f, m) {
    try {
      var E = "", O = m;
      do
        E += Ae(O), O = O.return;
      while (O);
      var I = E;
    } catch (j) {
      I = `
Error generating stack: ` + j.message + `
` + j.stack;
    }
    return { value: f, source: m, stack: I, digest: null };
  }
  function Z(f, m, E) {
    return { value: f, source: null, stack: E ?? null, digest: m ?? null };
  }
  function we(f, m) {
    try {
      console.error(m.value);
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  var Qe = typeof WeakMap == "function" ? WeakMap : Map;
  function Ot(f, m, E) {
    E = Fa(-1, E), E.tag = 3, E.payload = { element: null };
    var O = m.value;
    return E.callback = function() {
      ly || (ly = !0, kp = O), we(f, m);
    }, E;
  }
  function Jt(f, m, E) {
    E = Fa(-1, E), E.tag = 3;
    var O = f.type.getDerivedStateFromError;
    if (typeof O == "function") {
      var I = m.value;
      E.payload = function() {
        return O(I);
      }, E.callback = function() {
        we(f, m);
      };
    }
    var j = f.stateNode;
    return j !== null && typeof j.componentDidCatch == "function" && (E.callback = function() {
      we(f, m), typeof O != "function" && (ld === null ? ld = /* @__PURE__ */ new Set([this]) : ld.add(this));
      var ue = m.stack;
      this.componentDidCatch(m.value, { componentStack: ue !== null ? ue : "" });
    }), E;
  }
  function ln(f, m, E) {
    var O = f.pingCache;
    if (O === null) {
      O = f.pingCache = new Qe();
      var I = /* @__PURE__ */ new Set();
      O.set(m, I);
    } else
      I = O.get(m), I === void 0 && (I = /* @__PURE__ */ new Set(), O.set(m, I));
    I.has(E) || (I.add(E), f = H0.bind(null, f, m, E), m.then(f, f));
  }
  function cr(f) {
    do {
      var m;
      if ((m = f.tag === 13) && (m = f.memoizedState, m = m !== null ? m.dehydrated !== null : !0), m)
        return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function Qn(f, m, E, O, I) {
    return f.mode & 1 ? (f.flags |= 65536, f.lanes = I, f) : (f === m ? f.flags |= 65536 : (f.flags |= 128, E.flags |= 131072, E.flags &= -52805, E.tag === 1 && (E.alternate === null ? E.tag = 17 : (m = Fa(-1, 1), m.tag = 2, gc(E, m, 1))), E.lanes |= 1), f);
  }
  var Ki = H.ReactCurrentOwner, hn = !1;
  function ri(f, m, E, O) {
    m.child = f === null ? $d(m, null, E, O) : td(m, f.child, E, O);
  }
  function ka(f, m, E, O, I) {
    E = E.render;
    var j = m.ref;
    return un(m, I), O = df(f, m, E, O, j, I), E = hf(), f !== null && !hn ? (m.updateQueue = f.updateQueue, m.flags &= -2053, f.lanes &= ~I, Qo(f, m, I)) : (Xi && E && Cp(m), m.flags |= 1, ri(f, m, O, I), m.child);
  }
  function mt(f, m, E, O, I) {
    if (f === null) {
      var j = E.type;
      return typeof j == "function" && !$v(j) && j.defaultProps === void 0 && E.compare === null && E.defaultProps === void 0 ? (m.tag = 15, m.type = j, We(f, m, j, O, I)) : (f = nh(E.type, null, O, m, m.mode, I), f.ref = m.ref, f.return = m, m.child = f);
    }
    if (j = f.child, !(f.lanes & I)) {
      var ue = j.memoizedProps;
      if (E = E.compare, E = E !== null ? E : dl, E(ue, O) && f.ref === m.ref)
        return Qo(f, m, I);
    }
    return m.flags |= 1, f = Bl(j, O), f.ref = m.ref, f.return = m, m.child = f;
  }
  function We(f, m, E, O, I) {
    if (f !== null) {
      var j = f.memoizedProps;
      if (dl(j, O) && f.ref === m.ref)
        if (hn = !1, m.pendingProps = O = j, (f.lanes & I) !== 0)
          f.flags & 131072 && (hn = !0);
        else
          return m.lanes = f.lanes, Qo(f, m, I);
    }
    return An(f, m, E, O, I);
  }
  function Mt(f, m, E) {
    var O = m.pendingProps, I = O.children, j = f !== null ? f.memoizedState : null;
    if (O.mode === "hidden")
      if (!(m.mode & 1))
        m.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ui(Gm, ju), ju |= E;
      else {
        if (!(E & 1073741824))
          return f = j !== null ? j.baseLanes | E : E, m.lanes = m.childLanes = 1073741824, m.memoizedState = { baseLanes: f, cachePool: null, transitions: null }, m.updateQueue = null, ui(Gm, ju), ju |= f, null;
        m.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, O = j !== null ? j.baseLanes : E, ui(Gm, ju), ju |= O;
      }
    else
      j !== null ? (O = j.baseLanes | E, m.memoizedState = null) : O = E, ui(Gm, ju), ju |= O;
    return ri(f, m, I, E), m.child;
  }
  function Vt(f, m) {
    var E = m.ref;
    (f === null && E !== null || f !== null && f.ref !== E) && (m.flags |= 512, m.flags |= 2097152);
  }
  function An(f, m, E, O, I) {
    var j = ta(E) ? gs : hr.current;
    return j = $s(m, j), un(m, I), E = df(f, m, E, O, j, I), O = hf(), f !== null && !hn ? (m.updateQueue = f.updateQueue, m.flags &= -2053, f.lanes &= ~I, Qo(f, m, I)) : (Xi && O && Cp(m), m.flags |= 1, ri(f, m, E, I), m.child);
  }
  function Rr(f, m, E, O, I) {
    if (ta(E)) {
      var j = !0;
      vc(m);
    } else
      j = !1;
    if (un(m, I), m.stateNode === null)
      bs(f, m), jd(m, E, O), mu(m, E, O, I), O = !0;
    else if (f === null) {
      var ue = m.stateNode, Re = m.memoizedProps;
      ue.props = Re;
      var Ie = ue.context, Tt = E.contextType;
      typeof Tt == "object" && Tt !== null ? Tt = zi(Tt) : (Tt = ta(E) ? gs : hr.current, Tt = $s(m, Tt));
      var Kt = E.getDerivedStateFromProps, Xt = typeof Kt == "function" || typeof ue.getSnapshotBeforeUpdate == "function";
      Xt || typeof ue.UNSAFE_componentWillReceiveProps != "function" && typeof ue.componentWillReceiveProps != "function" || (Re !== O || Ie !== Tt) && Bu(m, ue, O, Tt), pa = !1;
      var $t = m.memoizedState;
      ue.state = $t, qi(m, O, ue, I), Ie = m.memoizedState, Re !== O || $t !== Ie || ba.current || pa ? (typeof Kt == "function" && (Xs(m, E, Kt, O), Ie = m.memoizedState), (Re = pa || fo(m, E, Re, O, $t, Ie, Tt)) ? (Xt || typeof ue.UNSAFE_componentWillMount != "function" && typeof ue.componentWillMount != "function" || (typeof ue.componentWillMount == "function" && ue.componentWillMount(), typeof ue.UNSAFE_componentWillMount == "function" && ue.UNSAFE_componentWillMount()), typeof ue.componentDidMount == "function" && (m.flags |= 4194308)) : (typeof ue.componentDidMount == "function" && (m.flags |= 4194308), m.memoizedProps = O, m.memoizedState = Ie), ue.props = O, ue.state = Ie, ue.context = Tt, O = Re) : (typeof ue.componentDidMount == "function" && (m.flags |= 4194308), O = !1);
    } else {
      ue = m.stateNode, Gi(f, m), Re = m.memoizedProps, Tt = m.type === m.elementType ? Re : vl(m.type, Re), ue.props = Tt, Xt = m.pendingProps, $t = ue.context, Ie = E.contextType, typeof Ie == "object" && Ie !== null ? Ie = zi(Ie) : (Ie = ta(E) ? gs : hr.current, Ie = $s(m, Ie));
      var bn = E.getDerivedStateFromProps;
      (Kt = typeof bn == "function" || typeof ue.getSnapshotBeforeUpdate == "function") || typeof ue.UNSAFE_componentWillReceiveProps != "function" && typeof ue.componentWillReceiveProps != "function" || (Re !== Xt || $t !== Ie) && Bu(m, ue, O, Ie), pa = !1, $t = m.memoizedState, ue.state = $t, qi(m, O, ue, I);
      var Pn = m.memoizedState;
      Re !== Xt || $t !== Pn || ba.current || pa ? (typeof bn == "function" && (Xs(m, E, bn, O), Pn = m.memoizedState), (Tt = pa || fo(m, E, Tt, O, $t, Pn, Ie) || !1) ? (Kt || typeof ue.UNSAFE_componentWillUpdate != "function" && typeof ue.componentWillUpdate != "function" || (typeof ue.componentWillUpdate == "function" && ue.componentWillUpdate(O, Pn, Ie), typeof ue.UNSAFE_componentWillUpdate == "function" && ue.UNSAFE_componentWillUpdate(O, Pn, Ie)), typeof ue.componentDidUpdate == "function" && (m.flags |= 4), typeof ue.getSnapshotBeforeUpdate == "function" && (m.flags |= 1024)) : (typeof ue.componentDidUpdate != "function" || Re === f.memoizedProps && $t === f.memoizedState || (m.flags |= 4), typeof ue.getSnapshotBeforeUpdate != "function" || Re === f.memoizedProps && $t === f.memoizedState || (m.flags |= 1024), m.memoizedProps = O, m.memoizedState = Pn), ue.props = O, ue.state = Pn, ue.context = Ie, O = Tt) : (typeof ue.componentDidUpdate != "function" || Re === f.memoizedProps && $t === f.memoizedState || (m.flags |= 4), typeof ue.getSnapshotBeforeUpdate != "function" || Re === f.memoizedProps && $t === f.memoizedState || (m.flags |= 1024), O = !1);
    }
    return or(f, m, E, O, j, I);
  }
  function or(f, m, E, O, I, j) {
    Vt(f, m);
    var ue = (m.flags & 128) !== 0;
    if (!O && !ue)
      return I && Uv(m, E, !1), Qo(f, m, j);
    O = m.stateNode, Ki.current = m;
    var Re = ue && typeof E.getDerivedStateFromError != "function" ? null : O.render();
    return m.flags |= 1, f !== null && ue ? (m.child = td(m, f.child, null, j), m.child = td(m, null, Re, j)) : ri(f, m, Re, j), m.memoizedState = O.state, I && Uv(m, E, !0), m.child;
  }
  function Fr(f) {
    var m = f.stateNode;
    m.pendingContext ? mc(f, m.pendingContext, m.pendingContext !== m.context) : m.context && mc(f, m.context, !1), Lh(f, m.containerInfo);
  }
  function va(f, m, E, O, I) {
    return sa(), Rh(I), m.flags |= 256, ri(f, m, E, O), m.child;
  }
  var kr = { dehydrated: null, treeContext: null, retryLane: 0 };
  function xc(f) {
    return { baseLanes: f, cachePool: null, transitions: null };
  }
  function Oh(f, m, E) {
    var O = m.pendingProps, I = Kn.current, j = !1, ue = (m.flags & 128) !== 0, Re;
    if ((Re = ue) || (Re = f !== null && f.memoizedState === null ? !1 : (I & 2) !== 0), Re ? (j = !0, m.flags &= -129) : (f === null || f.memoizedState !== null) && (I |= 1), ui(Kn, I & 1), f === null)
      return Wd(m), f = m.memoizedState, f !== null && (f = f.dehydrated, f !== null) ? (m.mode & 1 ? f.data === "$!" ? m.lanes = 8 : m.lanes = 1073741824 : m.lanes = 1, null) : (ue = O.children, f = O.fallback, j ? (O = m.mode, j = m.child, ue = { mode: "hidden", children: ue }, !(O & 1) && j !== null ? (j.childLanes = 0, j.pendingProps = ue) : j = Wh(ue, O, 0, null), f = Ip(f, O, E, null), j.return = m, f.return = m, j.sibling = f, m.child = j, m.child.memoizedState = xc(E), m.memoizedState = kr, f) : L0(m, ue));
    if (I = f.memoizedState, I !== null && (Re = I.dehydrated, Re !== null))
      return ny(f, m, ue, O, Re, I, E);
    if (j) {
      j = O.fallback, ue = m.mode, I = f.child, Re = I.sibling;
      var Ie = { mode: "hidden", children: O.children };
      return !(ue & 1) && m.child !== I ? (O = m.child, O.childLanes = 0, O.pendingProps = Ie, m.deletions = null) : (O = Bl(I, Ie), O.subtreeFlags = I.subtreeFlags & 14680064), Re !== null ? j = Bl(Re, j) : (j = Ip(j, ue, E, null), j.flags |= 2), j.return = m, O.return = m, O.sibling = j, m.child = O, O = j, j = m.child, ue = f.child.memoizedState, ue = ue === null ? xc(E) : { baseLanes: ue.baseLanes | E, cachePool: null, transitions: ue.transitions }, j.memoizedState = ue, j.childLanes = f.childLanes & ~E, m.memoizedState = kr, O;
    }
    return j = f.child, f = j.sibling, O = Bl(j, { mode: "visible", children: O.children }), !(m.mode & 1) && (O.lanes = E), O.return = m, O.sibling = null, f !== null && (E = m.deletions, E === null ? (m.deletions = [f], m.flags |= 16) : E.push(f)), m.child = O, m.memoizedState = null, O;
  }
  function L0(f, m) {
    return m = Wh({ mode: "visible", children: m }, f.mode, 0, null), m.return = f, f.child = m;
  }
  function Ap(f, m, E, O) {
    return O !== null && Rh(O), td(m, f.child, null, E), f = L0(m, m.pendingProps.children), f.flags |= 2, m.memoizedState = null, f;
  }
  function ny(f, m, E, O, I, j, ue) {
    if (E)
      return m.flags & 256 ? (m.flags &= -257, O = Z(Error(t(422))), Ap(f, m, ue, O)) : m.memoizedState !== null ? (m.child = f.child, m.flags |= 128, null) : (j = O.fallback, I = m.mode, O = Wh({ mode: "visible", children: O.children }, I, 0, null), j = Ip(j, I, ue, null), j.flags |= 2, O.return = m, j.return = m, O.sibling = j, m.child = O, m.mode & 1 && td(m, f.child, null, ue), m.child.memoizedState = xc(ue), m.memoizedState = kr, j);
    if (!(m.mode & 1))
      return Ap(f, m, ue, null);
    if (I.data === "$!") {
      if (O = I.nextSibling && I.nextSibling.dataset, O)
        var Re = O.dgst;
      return O = Re, j = Error(t(419)), O = Z(j, O, void 0), Ap(f, m, ue, O);
    }
    if (Re = (ue & f.childLanes) !== 0, hn || Re) {
      if (O = wi, O !== null) {
        switch (ue & -ue) {
          case 4:
            I = 2;
            break;
          case 16:
            I = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            I = 32;
            break;
          case 536870912:
            I = 268435456;
            break;
          default:
            I = 0;
        }
        I = I & (O.suspendedLanes | ue) ? 0 : I, I !== 0 && I !== j.retryLane && (j.retryLane = I, _s(f, I), ws(O, f, I, -1));
      }
      return I0(), O = Z(Error(t(421))), Ap(f, m, ue, O);
    }
    return I.data === "$?" ? (m.flags |= 128, m.child = f.child, m = Ox.bind(null, f), I._reactRetry = m, null) : (f = j.treeContext, Ss = Gs(I.nextSibling), Eo = m, Xi = !0, ml = null, f !== null && (uo[Ta++] = nn, uo[Ta++] = pl, uo[Ta++] = Iu, nn = f.id, pl = f.overflow, Iu = m), m = L0(m, O.children), m.flags |= 4096, m);
  }
  function ry(f, m, E) {
    f.lanes |= m;
    var O = f.alternate;
    O !== null && (O.lanes |= m), ha(f.return, m, E);
  }
  function Hm(f, m, E, O, I) {
    var j = f.memoizedState;
    j === null ? f.memoizedState = { isBackwards: m, rendering: null, renderingStartTime: 0, last: O, tail: E, tailMode: I } : (j.isBackwards = m, j.rendering = null, j.renderingStartTime = 0, j.last = O, j.tail = E, j.tailMode = I);
  }
  function iy(f, m, E) {
    var O = m.pendingProps, I = O.revealOrder, j = O.tail;
    if (ri(f, m, O.children, E), O = Kn.current, O & 2)
      O = O & 1 | 2, m.flags |= 128;
    else {
      if (f !== null && f.flags & 128)
        e:
          for (f = m.child; f !== null; ) {
            if (f.tag === 13)
              f.memoizedState !== null && ry(f, E, m);
            else if (f.tag === 19)
              ry(f, E, m);
            else if (f.child !== null) {
              f.child.return = f, f = f.child;
              continue;
            }
            if (f === m)
              break e;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === m)
                break e;
              f = f.return;
            }
            f.sibling.return = f.return, f = f.sibling;
          }
      O &= 1;
    }
    if (ui(Kn, O), !(m.mode & 1))
      m.memoizedState = null;
    else
      switch (I) {
        case "forwards":
          for (E = m.child, I = null; E !== null; )
            f = E.alternate, f !== null && jr(f) === null && (I = E), E = E.sibling;
          E = I, E === null ? (I = m.child, m.child = null) : (I = E.sibling, E.sibling = null), Hm(m, !1, I, E, j);
          break;
        case "backwards":
          for (E = null, I = m.child, m.child = null; I !== null; ) {
            if (f = I.alternate, f !== null && jr(f) === null) {
              m.child = I;
              break;
            }
            f = I.sibling, I.sibling = E, E = I, I = f;
          }
          Hm(m, !0, E, null, j);
          break;
        case "together":
          Hm(m, !1, null, null, void 0);
          break;
        default:
          m.memoizedState = null;
      }
    return m.child;
  }
  function bs(f, m) {
    !(m.mode & 1) && f !== null && (f.alternate = null, m.alternate = null, m.flags |= 2);
  }
  function Qo(f, m, E) {
    if (f !== null && (m.dependencies = f.dependencies), sd |= m.lanes, !(E & m.childLanes))
      return null;
    if (f !== null && m.child !== f.child)
      throw Error(t(153));
    if (m.child !== null) {
      for (f = m.child, E = Bl(f, f.pendingProps), m.child = E, E.return = m; f.sibling !== null; )
        f = f.sibling, E = E.sibling = Bl(f, f.pendingProps), E.return = m;
      E.sibling = null;
    }
    return m.child;
  }
  function yf(f, m, E) {
    switch (m.tag) {
      case 3:
        Fr(m), sa();
        break;
      case 5:
        qn(m);
        break;
      case 1:
        ta(m.type) && vc(m);
        break;
      case 4:
        Lh(m, m.stateNode.containerInfo);
        break;
      case 10:
        var O = m.type._context, I = m.memoizedProps.value;
        ui(pu, O._currentValue), O._currentValue = I;
        break;
      case 13:
        if (O = m.memoizedState, O !== null)
          return O.dehydrated !== null ? (ui(Kn, Kn.current & 1), m.flags |= 128, null) : E & m.child.childLanes ? Oh(f, m, E) : (ui(Kn, Kn.current & 1), f = Qo(f, m, E), f !== null ? f.sibling : null);
        ui(Kn, Kn.current & 1);
        break;
      case 19:
        if (O = (E & m.childLanes) !== 0, f.flags & 128) {
          if (O)
            return iy(f, m, E);
          m.flags |= 128;
        }
        if (I = m.memoizedState, I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), ui(Kn, Kn.current), O)
          break;
        return null;
      case 22:
      case 23:
        return m.lanes = 0, Mt(f, m, E);
    }
    return Qo(f, m, E);
  }
  var Dp, Xd, Wu, po;
  Dp = function(f, m) {
    for (var E = m.child; E !== null; ) {
      if (E.tag === 5 || E.tag === 6)
        f.appendChild(E.stateNode);
      else if (E.tag !== 4 && E.child !== null) {
        E.child.return = E, E = E.child;
        continue;
      }
      if (E === m)
        break;
      for (; E.sibling === null; ) {
        if (E.return === null || E.return === m)
          return;
        E = E.return;
      }
      E.sibling.return = E.return, E = E.sibling;
    }
  }, Xd = function() {
  }, Wu = function(f, m, E, O) {
    var I = f.memoizedProps;
    if (I !== O) {
      f = m.stateNode, yl(gl.current);
      var j = null;
      switch (E) {
        case "input":
          I = Ye(f, I), O = Ye(f, O), j = [];
          break;
        case "select":
          I = re({}, I, { value: void 0 }), O = re({}, O, { value: void 0 }), j = [];
          break;
        case "textarea":
          I = Zt(f, I), O = Zt(f, O), j = [];
          break;
        default:
          typeof I.onClick != "function" && typeof O.onClick == "function" && (f.onclick = Id);
      }
      be(E, O);
      var ue;
      E = null;
      for (Tt in I)
        if (!O.hasOwnProperty(Tt) && I.hasOwnProperty(Tt) && I[Tt] != null)
          if (Tt === "style") {
            var Re = I[Tt];
            for (ue in Re)
              Re.hasOwnProperty(ue) && (E || (E = {}), E[ue] = "");
          } else
            Tt !== "dangerouslySetInnerHTML" && Tt !== "children" && Tt !== "suppressContentEditableWarning" && Tt !== "suppressHydrationWarning" && Tt !== "autoFocus" && (i.hasOwnProperty(Tt) ? j || (j = []) : (j = j || []).push(Tt, null));
      for (Tt in O) {
        var Ie = O[Tt];
        if (Re = I != null ? I[Tt] : void 0, O.hasOwnProperty(Tt) && Ie !== Re && (Ie != null || Re != null))
          if (Tt === "style")
            if (Re) {
              for (ue in Re)
                !Re.hasOwnProperty(ue) || Ie && Ie.hasOwnProperty(ue) || (E || (E = {}), E[ue] = "");
              for (ue in Ie)
                Ie.hasOwnProperty(ue) && Re[ue] !== Ie[ue] && (E || (E = {}), E[ue] = Ie[ue]);
            } else
              E || (j || (j = []), j.push(
                Tt,
                E
              )), E = Ie;
          else
            Tt === "dangerouslySetInnerHTML" ? (Ie = Ie ? Ie.__html : void 0, Re = Re ? Re.__html : void 0, Ie != null && Re !== Ie && (j = j || []).push(Tt, Ie)) : Tt === "children" ? typeof Ie != "string" && typeof Ie != "number" || (j = j || []).push(Tt, "" + Ie) : Tt !== "suppressContentEditableWarning" && Tt !== "suppressHydrationWarning" && (i.hasOwnProperty(Tt) ? (Ie != null && Tt === "onScroll" && Er("scroll", f), j || Re === Ie || (j = [])) : (j = j || []).push(Tt, Ie));
      }
      E && (j = j || []).push("style", E);
      var Tt = j;
      (m.updateQueue = Tt) && (m.flags |= 4);
    }
  }, po = function(f, m, E, O) {
    E !== O && (m.flags |= 4);
  };
  function Lp(f, m) {
    if (!Xi)
      switch (f.tailMode) {
        case "hidden":
          m = f.tail;
          for (var E = null; m !== null; )
            m.alternate !== null && (E = m), m = m.sibling;
          E === null ? f.tail = null : E.sibling = null;
          break;
        case "collapsed":
          E = f.tail;
          for (var O = null; E !== null; )
            E.alternate !== null && (O = E), E = E.sibling;
          O === null ? m || f.tail === null ? f.tail = null : f.tail.sibling = null : O.sibling = null;
      }
  }
  function Ts(f) {
    var m = f.alternate !== null && f.alternate.child === f.child, E = 0, O = 0;
    if (m)
      for (var I = f.child; I !== null; )
        E |= I.lanes | I.childLanes, O |= I.subtreeFlags & 14680064, O |= I.flags & 14680064, I.return = f, I = I.sibling;
    else
      for (I = f.child; I !== null; )
        E |= I.lanes | I.childLanes, O |= I.subtreeFlags, O |= I.flags, I.return = f, I = I.sibling;
    return f.subtreeFlags |= O, f.childLanes = E, m;
  }
  function O0(f, m, E) {
    var O = m.pendingProps;
    switch (af(m), m.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ts(m), null;
      case 1:
        return ta(m.type) && Ys(), Ts(m), null;
      case 3:
        return O = m.stateNode, gu(), Zr(ba), Zr(hr), Ks(), O.pendingContext && (O.context = O.pendingContext, O.pendingContext = null), (f === null || f.child === null) && (xs(m) ? m.flags |= 4 : f === null || f.memoizedState.isDehydrated && !(m.flags & 256) || (m.flags |= 1024, ml !== null && (zp(ml), ml = null))), Xd(f, m), Ts(m), null;
      case 5:
        Cr(m);
        var I = yl(cf.current);
        if (E = m.type, f !== null && m.stateNode != null)
          Wu(f, m, E, O, I), f.ref !== m.ref && (m.flags |= 512, m.flags |= 2097152);
        else {
          if (!O) {
            if (m.stateNode === null)
              throw Error(t(166));
            return Ts(m), null;
          }
          if (f = yl(gl.current), xs(m)) {
            O = m.stateNode, E = m.type;
            var j = m.memoizedProps;
            switch (O[Za] = m, O[pc] = j, f = (m.mode & 1) !== 0, E) {
              case "dialog":
                Er("cancel", O), Er("close", O);
                break;
              case "iframe":
              case "object":
              case "embed":
                Er("load", O);
                break;
              case "video":
              case "audio":
                for (I = 0; I < $f.length; I++)
                  Er($f[I], O);
                break;
              case "source":
                Er("error", O);
                break;
              case "img":
              case "image":
              case "link":
                Er(
                  "error",
                  O
                ), Er("load", O);
                break;
              case "details":
                Er("toggle", O);
                break;
              case "input":
                Ge(O, j), Er("invalid", O);
                break;
              case "select":
                O._wrapperState = { wasMultiple: !!j.multiple }, Er("invalid", O);
                break;
              case "textarea":
                ie(O, j), Er("invalid", O);
            }
            be(E, j), I = null;
            for (var ue in j)
              if (j.hasOwnProperty(ue)) {
                var Re = j[ue];
                ue === "children" ? typeof Re == "string" ? O.textContent !== Re && (j.suppressHydrationWarning !== !0 && zd(O.textContent, Re, f), I = ["children", Re]) : typeof Re == "number" && O.textContent !== "" + Re && (j.suppressHydrationWarning !== !0 && zd(
                  O.textContent,
                  Re,
                  f
                ), I = ["children", "" + Re]) : i.hasOwnProperty(ue) && Re != null && ue === "onScroll" && Er("scroll", O);
              }
            switch (E) {
              case "input":
                rt(O), nt(O, j, !0);
                break;
              case "textarea":
                rt(O), Oe(O);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof j.onClick == "function" && (O.onclick = Id);
            }
            O = I, m.updateQueue = O, O !== null && (m.flags |= 4);
          } else {
            ue = I.nodeType === 9 ? I : I.ownerDocument, f === "http://www.w3.org/1999/xhtml" && (f = _t(E)), f === "http://www.w3.org/1999/xhtml" ? E === "script" ? (f = ue.createElement("div"), f.innerHTML = "<script><\/script>", f = f.removeChild(f.firstChild)) : typeof O.is == "string" ? f = ue.createElement(E, { is: O.is }) : (f = ue.createElement(E), E === "select" && (ue = f, O.multiple ? ue.multiple = !0 : O.size && (ue.size = O.size))) : f = ue.createElementNS(f, E), f[Za] = m, f[pc] = O, Dp(f, m, !1, !1), m.stateNode = f;
            e: {
              switch (ue = Ze(E, O), E) {
                case "dialog":
                  Er("cancel", f), Er("close", f), I = O;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Er("load", f), I = O;
                  break;
                case "video":
                case "audio":
                  for (I = 0; I < $f.length; I++)
                    Er($f[I], f);
                  I = O;
                  break;
                case "source":
                  Er("error", f), I = O;
                  break;
                case "img":
                case "image":
                case "link":
                  Er(
                    "error",
                    f
                  ), Er("load", f), I = O;
                  break;
                case "details":
                  Er("toggle", f), I = O;
                  break;
                case "input":
                  Ge(f, O), I = Ye(f, O), Er("invalid", f);
                  break;
                case "option":
                  I = O;
                  break;
                case "select":
                  f._wrapperState = { wasMultiple: !!O.multiple }, I = re({}, O, { value: void 0 }), Er("invalid", f);
                  break;
                case "textarea":
                  ie(f, O), I = Zt(f, O), Er("invalid", f);
                  break;
                default:
                  I = O;
              }
              be(E, I), Re = I;
              for (j in Re)
                if (Re.hasOwnProperty(j)) {
                  var Ie = Re[j];
                  j === "style" ? St(f, Ie) : j === "dangerouslySetInnerHTML" ? (Ie = Ie ? Ie.__html : void 0, Ie != null && Wt(f, Ie)) : j === "children" ? typeof Ie == "string" ? (E !== "textarea" || Ie !== "") && Dt(f, Ie) : typeof Ie == "number" && Dt(f, "" + Ie) : j !== "suppressContentEditableWarning" && j !== "suppressHydrationWarning" && j !== "autoFocus" && (i.hasOwnProperty(j) ? Ie != null && j === "onScroll" && Er("scroll", f) : Ie != null && k(f, j, Ie, ue));
                }
              switch (E) {
                case "input":
                  rt(f), nt(f, O, !1);
                  break;
                case "textarea":
                  rt(f), Oe(f);
                  break;
                case "option":
                  O.value != null && f.setAttribute("value", "" + ke(O.value));
                  break;
                case "select":
                  f.multiple = !!O.multiple, j = O.value, j != null ? vt(f, !!O.multiple, j, !1) : O.defaultValue != null && vt(
                    f,
                    !!O.multiple,
                    O.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof I.onClick == "function" && (f.onclick = Id);
              }
              switch (E) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  O = !!O.autoFocus;
                  break e;
                case "img":
                  O = !0;
                  break e;
                default:
                  O = !1;
              }
            }
            O && (m.flags |= 4);
          }
          m.ref !== null && (m.flags |= 512, m.flags |= 2097152);
        }
        return Ts(m), null;
      case 6:
        if (f && m.stateNode != null)
          po(f, m, f.memoizedProps, O);
        else {
          if (typeof O != "string" && m.stateNode === null)
            throw Error(t(166));
          if (E = yl(cf.current), yl(gl.current), xs(m)) {
            if (O = m.stateNode, E = m.memoizedProps, O[Za] = m, (j = O.nodeValue !== E) && (f = Eo, f !== null))
              switch (f.tag) {
                case 3:
                  zd(O.nodeValue, E, (f.mode & 1) !== 0);
                  break;
                case 5:
                  f.memoizedProps.suppressHydrationWarning !== !0 && zd(O.nodeValue, E, (f.mode & 1) !== 0);
              }
            j && (m.flags |= 4);
          } else
            O = (E.nodeType === 9 ? E : E.ownerDocument).createTextNode(O), O[Za] = m, m.stateNode = O;
        }
        return Ts(m), null;
      case 13:
        if (Zr(Kn), O = m.memoizedState, f === null || f.memoizedState !== null && f.memoizedState.dehydrated !== null) {
          if (Xi && Ss !== null && m.mode & 1 && !(m.flags & 128))
            co(), sa(), m.flags |= 98560, j = !1;
          else if (j = xs(m), O !== null && O.dehydrated !== null) {
            if (f === null) {
              if (!j)
                throw Error(t(318));
              if (j = m.memoizedState, j = j !== null ? j.dehydrated : null, !j)
                throw Error(t(317));
              j[Za] = m;
            } else
              sa(), !(m.flags & 128) && (m.memoizedState = null), m.flags |= 4;
            Ts(m), j = !1;
          } else
            ml !== null && (zp(ml), ml = null), j = !0;
          if (!j)
            return m.flags & 65536 ? m : null;
        }
        return m.flags & 128 ? (m.lanes = E, m) : (O = O !== null, O !== (f !== null && f.memoizedState !== null) && O && (m.child.flags |= 8192, m.mode & 1 && (f === null || Kn.current & 1 ? Zo === 0 && (Zo = 3) : I0())), m.updateQueue !== null && (m.flags |= 4), Ts(m), null);
      case 4:
        return gu(), Xd(f, m), f === null && hl(m.stateNode.containerInfo), Ts(m), null;
      case 10:
        return Vi(m.type._context), Ts(m), null;
      case 17:
        return ta(m.type) && Ys(), Ts(m), null;
      case 19:
        if (Zr(Kn), j = m.memoizedState, j === null)
          return Ts(m), null;
        if (O = (m.flags & 128) !== 0, ue = j.rendering, ue === null)
          if (O)
            Lp(j, !1);
          else {
            if (Zo !== 0 || f !== null && f.flags & 128)
              for (f = m.child; f !== null; ) {
                if (ue = jr(f), ue !== null) {
                  for (m.flags |= 128, Lp(j, !1), O = ue.updateQueue, O !== null && (m.updateQueue = O, m.flags |= 4), m.subtreeFlags = 0, O = E, E = m.child; E !== null; )
                    j = E, f = O, j.flags &= 14680066, ue = j.alternate, ue === null ? (j.childLanes = 0, j.lanes = f, j.child = null, j.subtreeFlags = 0, j.memoizedProps = null, j.memoizedState = null, j.updateQueue = null, j.dependencies = null, j.stateNode = null) : (j.childLanes = ue.childLanes, j.lanes = ue.lanes, j.child = ue.child, j.subtreeFlags = 0, j.deletions = null, j.memoizedProps = ue.memoizedProps, j.memoizedState = ue.memoizedState, j.updateQueue = ue.updateQueue, j.type = ue.type, f = ue.dependencies, j.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }), E = E.sibling;
                  return ui(Kn, Kn.current & 1 | 2), m.child;
                }
                f = f.sibling;
              }
            j.tail !== null && bt() > kh && (m.flags |= 128, O = !0, Lp(j, !1), m.lanes = 4194304);
          }
        else {
          if (!O)
            if (f = jr(ue), f !== null) {
              if (m.flags |= 128, O = !0, E = f.updateQueue, E !== null && (m.updateQueue = E, m.flags |= 4), Lp(j, !0), j.tail === null && j.tailMode === "hidden" && !ue.alternate && !Xi)
                return Ts(m), null;
            } else
              2 * bt() - j.renderingStartTime > kh && E !== 1073741824 && (m.flags |= 128, O = !0, Lp(j, !1), m.lanes = 4194304);
          j.isBackwards ? (ue.sibling = m.child, m.child = ue) : (E = j.last, E !== null ? E.sibling = ue : m.child = ue, j.last = ue);
        }
        return j.tail !== null ? (m = j.tail, j.rendering = m, j.tail = m.sibling, j.renderingStartTime = bt(), m.sibling = null, E = Kn.current, ui(Kn, O ? E & 1 | 2 : E & 1), m) : (Ts(m), null);
      case 22:
      case 23:
        return cy(), O = m.memoizedState !== null, f !== null && f.memoizedState !== null !== O && (m.flags |= 8192), O && m.mode & 1 ? ju & 1073741824 && (Ts(m), m.subtreeFlags & 6 && (m.flags |= 8192)) : Ts(m), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, m.tag));
  }
  function ay(f, m) {
    switch (af(m), m.tag) {
      case 1:
        return ta(m.type) && Ys(), f = m.flags, f & 65536 ? (m.flags = f & -65537 | 128, m) : null;
      case 3:
        return gu(), Zr(ba), Zr(hr), Ks(), f = m.flags, f & 65536 && !(f & 128) ? (m.flags = f & -65537 | 128, m) : null;
      case 5:
        return Cr(m), null;
      case 13:
        if (Zr(Kn), f = m.memoizedState, f !== null && f.dehydrated !== null) {
          if (m.alternate === null)
            throw Error(t(340));
          sa();
        }
        return f = m.flags, f & 65536 ? (m.flags = f & -65537 | 128, m) : null;
      case 19:
        return Zr(Kn), null;
      case 4:
        return gu(), null;
      case 10:
        return Vi(m.type._context), null;
      case 22:
      case 23:
        return cy(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Op = !1, Mo = !1, P0 = typeof WeakSet == "function" ? WeakSet : Set, On = null;
  function Pp(f, m) {
    var E = f.ref;
    if (E !== null)
      if (typeof E == "function")
        try {
          E(null);
        } catch (O) {
          Ja(f, m, O);
        }
      else
        E.current = null;
  }
  function Vm(f, m, E) {
    try {
      E();
    } catch (O) {
      Ja(f, m, O);
    }
  }
  var Dx = !1;
  function U0(f, m) {
    if (Yf = qa, f = Kr(), yi(f)) {
      if ("selectionStart" in f)
        var E = { start: f.selectionStart, end: f.selectionEnd };
      else
        e: {
          E = (E = f.ownerDocument) && E.defaultView || window;
          var O = E.getSelection && E.getSelection();
          if (O && O.rangeCount !== 0) {
            E = O.anchorNode;
            var I = O.anchorOffset, j = O.focusNode;
            O = O.focusOffset;
            try {
              E.nodeType, j.nodeType;
            } catch {
              E = null;
              break e;
            }
            var ue = 0, Re = -1, Ie = -1, Tt = 0, Kt = 0, Xt = f, $t = null;
            t:
              for (; ; ) {
                for (var bn; Xt !== E || I !== 0 && Xt.nodeType !== 3 || (Re = ue + I), Xt !== j || O !== 0 && Xt.nodeType !== 3 || (Ie = ue + O), Xt.nodeType === 3 && (ue += Xt.nodeValue.length), (bn = Xt.firstChild) !== null; )
                  $t = Xt, Xt = bn;
                for (; ; ) {
                  if (Xt === f)
                    break t;
                  if ($t === E && ++Tt === I && (Re = ue), $t === j && ++Kt === O && (Ie = ue), (bn = Xt.nextSibling) !== null)
                    break;
                  Xt = $t, $t = Xt.parentNode;
                }
                Xt = bn;
              }
            E = Re === -1 || Ie === -1 ? null : { start: Re, end: Ie };
          } else
            E = null;
        }
      E = E || { start: 0, end: 0 };
    } else
      E = null;
    for (nf = { focusedElem: f, selectionRange: E }, qa = !1, On = m; On !== null; )
      if (m = On, f = m.child, (m.subtreeFlags & 1028) !== 0 && f !== null)
        f.return = m, On = f;
      else
        for (; On !== null; ) {
          m = On;
          try {
            var Pn = m.alternate;
            if (m.flags & 1024)
              switch (m.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Pn !== null) {
                    var Fn = Pn.memoizedProps, eo = Pn.memoizedState, st = m.stateNode, Xe = st.getSnapshotBeforeUpdate(m.elementType === m.type ? Fn : vl(m.type, Fn), eo);
                    st.__reactInternalSnapshotBeforeUpdate = Xe;
                  }
                  break;
                case 3:
                  var gt = m.stateNode.containerInfo;
                  gt.nodeType === 1 ? gt.textContent = "" : gt.nodeType === 9 && gt.documentElement && gt.removeChild(gt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (an) {
            Ja(m, m.return, an);
          }
          if (f = m.sibling, f !== null) {
            f.return = m.return, On = f;
            break;
          }
          On = m.return;
        }
    return Pn = Dx, Dx = !1, Pn;
  }
  function Up(f, m, E) {
    var O = m.updateQueue;
    if (O = O !== null ? O.lastEffect : null, O !== null) {
      var I = O = O.next;
      do {
        if ((I.tag & f) === f) {
          var j = I.destroy;
          I.destroy = void 0, j !== void 0 && Vm(m, E, j);
        }
        I = I.next;
      } while (I !== O);
    }
  }
  function Nv(f, m) {
    if (m = m.updateQueue, m = m !== null ? m.lastEffect : null, m !== null) {
      var E = m = m.next;
      do {
        if ((E.tag & f) === f) {
          var O = E.create;
          E.destroy = O();
        }
        E = E.next;
      } while (E !== m);
    }
  }
  function N0(f) {
    var m = f.ref;
    if (m !== null) {
      var E = f.stateNode;
      switch (f.tag) {
        case 5:
          f = E;
          break;
        default:
          f = E;
      }
      typeof m == "function" ? m(f) : m.current = f;
    }
  }
  function Ph(f) {
    var m = f.alternate;
    m !== null && (f.alternate = null, Ph(m)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (m = f.stateNode, m !== null && (delete m[Za], delete m[pc], delete m[Xf], delete m[qf], delete m[Vd])), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null;
  }
  function Np(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function Fp(f) {
    e:
      for (; ; ) {
        for (; f.sibling === null; ) {
          if (f.return === null || Np(f.return))
            return null;
          f = f.return;
        }
        for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && f.tag !== 18; ) {
          if (f.flags & 2 || f.child === null || f.tag === 4)
            continue e;
          f.child.return = f, f = f.child;
        }
        if (!(f.flags & 2))
          return f.stateNode;
      }
  }
  function qd(f, m, E) {
    var O = f.tag;
    if (O === 5 || O === 6)
      f = f.stateNode, m ? E.nodeType === 8 ? E.parentNode.insertBefore(f, m) : E.insertBefore(f, m) : (E.nodeType === 8 ? (m = E.parentNode, m.insertBefore(f, E)) : (m = E, m.appendChild(f)), E = E._reactRootContainer, E != null || m.onclick !== null || (m.onclick = Id));
    else if (O !== 4 && (f = f.child, f !== null))
      for (qd(f, m, E), f = f.sibling; f !== null; )
        qd(f, m, E), f = f.sibling;
  }
  function Co(f, m, E) {
    var O = f.tag;
    if (O === 5 || O === 6)
      f = f.stateNode, m ? E.insertBefore(f, m) : E.appendChild(f);
    else if (O !== 4 && (f = f.child, f !== null))
      for (Co(f, m, E), f = f.sibling; f !== null; )
        Co(f, m, E), f = f.sibling;
  }
  var mi = null, za = !1;
  function ko(f, m, E) {
    for (E = E.child; E !== null; )
      xu(f, m, E), E = E.sibling;
  }
  function xu(f, m, E) {
    if (_r && typeof _r.onCommitFiberUnmount == "function")
      try {
        _r.onCommitFiberUnmount($n, E);
      } catch {
      }
    switch (E.tag) {
      case 5:
        Mo || Pp(E, m);
      case 6:
        var O = mi, I = za;
        mi = null, ko(f, m, E), mi = O, za = I, mi !== null && (za ? (f = mi, E = E.stateNode, f.nodeType === 8 ? f.parentNode.removeChild(E) : f.removeChild(E)) : mi.removeChild(E.stateNode));
        break;
      case 18:
        mi !== null && (za ? (f = mi, E = E.stateNode, f.nodeType === 8 ? Uu(f.parentNode, E) : f.nodeType === 1 && Uu(f, E), If(f)) : Uu(mi, E.stateNode));
        break;
      case 4:
        O = mi, I = za, mi = E.stateNode.containerInfo, za = !0, ko(f, m, E), mi = O, za = I;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Mo && (O = E.updateQueue, O !== null && (O = O.lastEffect, O !== null))) {
          I = O = O.next;
          do {
            var j = I, ue = j.destroy;
            j = j.tag, ue !== void 0 && (j & 2 || j & 4) && Vm(E, m, ue), I = I.next;
          } while (I !== O);
        }
        ko(f, m, E);
        break;
      case 1:
        if (!Mo && (Pp(E, m), O = E.stateNode, typeof O.componentWillUnmount == "function"))
          try {
            O.props = E.memoizedProps, O.state = E.memoizedState, O.componentWillUnmount();
          } catch (Re) {
            Ja(E, m, Re);
          }
        ko(f, m, E);
        break;
      case 21:
        ko(f, m, E);
        break;
      case 22:
        E.mode & 1 ? (Mo = (O = Mo) || E.memoizedState !== null, ko(f, m, E), Mo = O) : ko(f, m, E);
        break;
      default:
        ko(f, m, E);
    }
  }
  function Kd(f) {
    var m = f.updateQueue;
    if (m !== null) {
      f.updateQueue = null;
      var E = f.stateNode;
      E === null && (E = f.stateNode = new P0()), m.forEach(function(O) {
        var I = Px.bind(null, f, O);
        E.has(O) || (E.add(O), O.then(I, I));
      });
    }
  }
  function Sf(f, m) {
    var E = m.deletions;
    if (E !== null)
      for (var O = 0; O < E.length; O++) {
        var I = E[O];
        try {
          var j = f, ue = m, Re = ue;
          e:
            for (; Re !== null; ) {
              switch (Re.tag) {
                case 5:
                  mi = Re.stateNode, za = !1;
                  break e;
                case 3:
                  mi = Re.stateNode.containerInfo, za = !0;
                  break e;
                case 4:
                  mi = Re.stateNode.containerInfo, za = !0;
                  break e;
              }
              Re = Re.return;
            }
          if (mi === null)
            throw Error(t(160));
          xu(j, ue, I), mi = null, za = !1;
          var Ie = I.alternate;
          Ie !== null && (Ie.return = null), I.return = null;
        } catch (Tt) {
          Ja(I, m, Tt);
        }
      }
    if (m.subtreeFlags & 12854)
      for (m = m.child; m !== null; )
        Lx(m, f), m = m.sibling;
  }
  function Lx(f, m) {
    var E = f.alternate, O = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Sf(m, f), El(f), O & 4) {
          try {
            Up(3, f, f.return), Nv(3, f);
          } catch (Fn) {
            Ja(f, f.return, Fn);
          }
          try {
            Up(5, f, f.return);
          } catch (Fn) {
            Ja(f, f.return, Fn);
          }
        }
        break;
      case 1:
        Sf(m, f), El(f), O & 512 && E !== null && Pp(E, E.return);
        break;
      case 5:
        if (Sf(m, f), El(f), O & 512 && E !== null && Pp(E, E.return), f.flags & 32) {
          var I = f.stateNode;
          try {
            Dt(I, "");
          } catch (Fn) {
            Ja(f, f.return, Fn);
          }
        }
        if (O & 4 && (I = f.stateNode, I != null)) {
          var j = f.memoizedProps, ue = E !== null ? E.memoizedProps : j, Re = f.type, Ie = f.updateQueue;
          if (f.updateQueue = null, Ie !== null)
            try {
              Re === "input" && j.type === "radio" && j.name != null && $e(I, j), Ze(Re, ue);
              var Tt = Ze(Re, j);
              for (ue = 0; ue < Ie.length; ue += 2) {
                var Kt = Ie[ue], Xt = Ie[ue + 1];
                Kt === "style" ? St(I, Xt) : Kt === "dangerouslySetInnerHTML" ? Wt(I, Xt) : Kt === "children" ? Dt(I, Xt) : k(I, Kt, Xt, Tt);
              }
              switch (Re) {
                case "input":
                  Ut(I, j);
                  break;
                case "textarea":
                  ne(I, j);
                  break;
                case "select":
                  var $t = I._wrapperState.wasMultiple;
                  I._wrapperState.wasMultiple = !!j.multiple;
                  var bn = j.value;
                  bn != null ? vt(I, !!j.multiple, bn, !1) : $t !== !!j.multiple && (j.defaultValue != null ? vt(
                    I,
                    !!j.multiple,
                    j.defaultValue,
                    !0
                  ) : vt(I, !!j.multiple, j.multiple ? [] : "", !1));
              }
              I[pc] = j;
            } catch (Fn) {
              Ja(f, f.return, Fn);
            }
        }
        break;
      case 6:
        if (Sf(m, f), El(f), O & 4) {
          if (f.stateNode === null)
            throw Error(t(162));
          I = f.stateNode, j = f.memoizedProps;
          try {
            I.nodeValue = j;
          } catch (Fn) {
            Ja(f, f.return, Fn);
          }
        }
        break;
      case 3:
        if (Sf(m, f), El(f), O & 4 && E !== null && E.memoizedState.isDehydrated)
          try {
            If(m.containerInfo);
          } catch (Fn) {
            Ja(f, f.return, Fn);
          }
        break;
      case 4:
        Sf(m, f), El(f);
        break;
      case 13:
        Sf(m, f), El(f), I = f.child, I.flags & 8192 && (j = I.memoizedState !== null, I.stateNode.isHidden = j, !j || I.alternate !== null && I.alternate.memoizedState !== null || (Bv = bt())), O & 4 && Kd(f);
        break;
      case 22:
        if (Kt = E !== null && E.memoizedState !== null, f.mode & 1 ? (Mo = (Tt = Mo) || Kt, Sf(m, f), Mo = Tt) : Sf(m, f), El(f), O & 8192) {
          if (Tt = f.memoizedState !== null, (f.stateNode.isHidden = Tt) && !Kt && f.mode & 1)
            for (On = f, Kt = f.child; Kt !== null; ) {
              for (Xt = On = Kt; On !== null; ) {
                switch ($t = On, bn = $t.child, $t.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Up(4, $t, $t.return);
                    break;
                  case 1:
                    Pp($t, $t.return);
                    var Pn = $t.stateNode;
                    if (typeof Pn.componentWillUnmount == "function") {
                      O = $t, E = $t.return;
                      try {
                        m = O, Pn.props = m.memoizedProps, Pn.state = m.memoizedState, Pn.componentWillUnmount();
                      } catch (Fn) {
                        Ja(O, E, Fn);
                      }
                    }
                    break;
                  case 5:
                    Pp($t, $t.return);
                    break;
                  case 22:
                    if ($t.memoizedState !== null) {
                      k0(Xt);
                      continue;
                    }
                }
                bn !== null ? (bn.return = $t, On = bn) : k0(Xt);
              }
              Kt = Kt.sibling;
            }
          e:
            for (Kt = null, Xt = f; ; ) {
              if (Xt.tag === 5) {
                if (Kt === null) {
                  Kt = Xt;
                  try {
                    I = Xt.stateNode, Tt ? (j = I.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none") : (Re = Xt.stateNode, Ie = Xt.memoizedProps.style, ue = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null, Re.style.display = lt("display", ue));
                  } catch (Fn) {
                    Ja(f, f.return, Fn);
                  }
                }
              } else if (Xt.tag === 6) {
                if (Kt === null)
                  try {
                    Xt.stateNode.nodeValue = Tt ? "" : Xt.memoizedProps;
                  } catch (Fn) {
                    Ja(f, f.return, Fn);
                  }
              } else if ((Xt.tag !== 22 && Xt.tag !== 23 || Xt.memoizedState === null || Xt === f) && Xt.child !== null) {
                Xt.child.return = Xt, Xt = Xt.child;
                continue;
              }
              if (Xt === f)
                break e;
              for (; Xt.sibling === null; ) {
                if (Xt.return === null || Xt.return === f)
                  break e;
                Kt === Xt && (Kt = null), Xt = Xt.return;
              }
              Kt === Xt && (Kt = null), Xt.sibling.return = Xt.return, Xt = Xt.sibling;
            }
        }
        break;
      case 19:
        Sf(m, f), El(f), O & 4 && Kd(f);
        break;
      case 21:
        break;
      default:
        Sf(
          m,
          f
        ), El(f);
    }
  }
  function El(f) {
    var m = f.flags;
    if (m & 2) {
      try {
        e: {
          for (var E = f.return; E !== null; ) {
            if (Np(E)) {
              var O = E;
              break e;
            }
            E = E.return;
          }
          throw Error(t(160));
        }
        switch (O.tag) {
          case 5:
            var I = O.stateNode;
            O.flags & 32 && (Dt(I, ""), O.flags &= -33);
            var j = Fp(f);
            Co(f, j, I);
            break;
          case 3:
          case 4:
            var ue = O.stateNode.containerInfo, Re = Fp(f);
            qd(f, Re, ue);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Ie) {
        Ja(f, f.return, Ie);
      }
      f.flags &= -3;
    }
    m & 4096 && (f.flags &= -4097);
  }
  function F0(f, m, E) {
    On = f, Uh(f);
  }
  function Uh(f, m, E) {
    for (var O = (f.mode & 1) !== 0; On !== null; ) {
      var I = On, j = I.child;
      if (I.tag === 22 && O) {
        var ue = I.memoizedState !== null || Op;
        if (!ue) {
          var Re = I.alternate, Ie = Re !== null && Re.memoizedState !== null || Mo;
          Re = Op;
          var Tt = Mo;
          if (Op = ue, (Mo = Ie) && !Tt)
            for (On = I; On !== null; )
              ue = On, Ie = ue.child, ue.tag === 22 && ue.memoizedState !== null ? oy(I) : Ie !== null ? (Ie.return = ue, On = Ie) : oy(I);
          for (; j !== null; )
            On = j, Uh(j), j = j.sibling;
          On = I, Op = Re, Mo = Tt;
        }
        Fv(f);
      } else
        I.subtreeFlags & 8772 && j !== null ? (j.return = I, On = j) : Fv(f);
    }
  }
  function Fv(f) {
    for (; On !== null; ) {
      var m = On;
      if (m.flags & 8772) {
        var E = m.alternate;
        try {
          if (m.flags & 8772)
            switch (m.tag) {
              case 0:
              case 11:
              case 15:
                Mo || Nv(5, m);
                break;
              case 1:
                var O = m.stateNode;
                if (m.flags & 4 && !Mo)
                  if (E === null)
                    O.componentDidMount();
                  else {
                    var I = m.elementType === m.type ? E.memoizedProps : vl(m.type, E.memoizedProps);
                    O.componentDidUpdate(I, E.memoizedState, O.__reactInternalSnapshotBeforeUpdate);
                  }
                var j = m.updateQueue;
                j !== null && na(m, j, O);
                break;
              case 3:
                var ue = m.updateQueue;
                if (ue !== null) {
                  if (E = null, m.child !== null)
                    switch (m.child.tag) {
                      case 5:
                        E = m.child.stateNode;
                        break;
                      case 1:
                        E = m.child.stateNode;
                    }
                  na(m, ue, E);
                }
                break;
              case 5:
                var Re = m.stateNode;
                if (E === null && m.flags & 4) {
                  E = Re;
                  var Ie = m.memoizedProps;
                  switch (m.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ie.autoFocus && E.focus();
                      break;
                    case "img":
                      Ie.src && (E.src = Ie.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (m.memoizedState === null) {
                  var Tt = m.alternate;
                  if (Tt !== null) {
                    var Kt = Tt.memoizedState;
                    if (Kt !== null) {
                      var Xt = Kt.dehydrated;
                      Xt !== null && If(Xt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Mo || m.flags & 512 && N0(m);
        } catch ($t) {
          Ja(m, m.return, $t);
        }
      }
      if (m === f) {
        On = null;
        break;
      }
      if (E = m.sibling, E !== null) {
        E.return = m.return, On = E;
        break;
      }
      On = m.return;
    }
  }
  function k0(f) {
    for (; On !== null; ) {
      var m = On;
      if (m === f) {
        On = null;
        break;
      }
      var E = m.sibling;
      if (E !== null) {
        E.return = m.return, On = E;
        break;
      }
      On = m.return;
    }
  }
  function oy(f) {
    for (; On !== null; ) {
      var m = On;
      try {
        switch (m.tag) {
          case 0:
          case 11:
          case 15:
            var E = m.return;
            try {
              Nv(4, m);
            } catch (Ie) {
              Ja(m, E, Ie);
            }
            break;
          case 1:
            var O = m.stateNode;
            if (typeof O.componentDidMount == "function") {
              var I = m.return;
              try {
                O.componentDidMount();
              } catch (Ie) {
                Ja(m, I, Ie);
              }
            }
            var j = m.return;
            try {
              N0(m);
            } catch (Ie) {
              Ja(m, j, Ie);
            }
            break;
          case 5:
            var ue = m.return;
            try {
              N0(m);
            } catch (Ie) {
              Ja(m, ue, Ie);
            }
        }
      } catch (Ie) {
        Ja(m, m.return, Ie);
      }
      if (m === f) {
        On = null;
        break;
      }
      var Re = m.sibling;
      if (Re !== null) {
        Re.return = m.return, On = Re;
        break;
      }
      On = m.return;
    }
  }
  var sy = Math.ceil, kv = H.ReactCurrentDispatcher, Qd = H.ReactCurrentOwner, Oi = H.ReactCurrentBatchConfig, yr = 0, wi = null, ra = null, wa = 0, ju = 0, Gm = In(0), Zo = 0, zv = null, sd = 0, Iv = 0, Nh = 0, Fh = null, bl = null, Bv = 0, kh = 1 / 0, xf = null, ly = !1, kp = null, ld = null, zh = !1, Zd = null, Ih = 0, Wm = 0, Hv = null, _c = -1, Bh = 0;
  function Ii() {
    return yr & 6 ? bt() : _c !== -1 ? _c : _c = bt();
  }
  function mo(f) {
    return f.mode & 1 ? yr & 2 && wa !== 0 ? wa & -wa : Um.transition !== null ? (Bh === 0 && (Bh = Wo()), Bh) : (f = Vr, f !== 0 || (f = window.event, f = f === void 0 ? 16 : $c(f.type)), f) : 1;
  }
  function ws(f, m, E, O) {
    if (50 < Wm)
      throw Wm = 0, Hv = null, Error(t(185));
    sl(f, E, O), (!(yr & 2) || f !== wi) && (f === wi && (!(yr & 2) && (Iv |= E), Zo === 4 && Tl(f, wa)), Ms(f, O), E === 1 && yr === 0 && !(m.mode & 1) && (kh = bt() + 500, xo && Ua()));
  }
  function Ms(f, m) {
    var E = f.callbackNode;
    Ns(f, m);
    var O = Ai(f, f === wi ? wa : 0);
    if (O === 0)
      E !== null && xn(E), f.callbackNode = null, f.callbackPriority = 0;
    else if (m = O & -O, f.callbackPriority !== m) {
      if (E != null && xn(E), m === 1)
        f.tag === 0 ? Qf(Gv.bind(null, f)) : du(Gv.bind(null, f)), Mp(function() {
          !(yr & 6) && Ua();
        }), E = null;
      else {
        switch (ll(O)) {
          case 1:
            E = Hr;
            break;
          case 4:
            E = Tn;
            break;
          case 16:
            E = Ji;
            break;
          case 536870912:
            E = li;
            break;
          default:
            E = Ji;
        }
        E = $u(E, Hh.bind(null, f));
      }
      f.callbackPriority = m, f.callbackNode = E;
    }
  }
  function Hh(f, m) {
    if (_c = -1, Bh = 0, yr & 6)
      throw Error(t(327));
    var E = f.callbackNode;
    if (_f() && f.callbackNode !== E)
      return null;
    var O = Ai(f, f === wi ? wa : 0);
    if (O === 0)
      return null;
    if (O & 30 || O & f.expiredLanes || m)
      m = Vh(f, O);
    else {
      m = O;
      var I = yr;
      yr |= 2;
      var j = fy();
      (wi !== f || wa !== m) && (xf = null, kh = bt() + 500, Ec(f, m));
      do
        try {
          Wv();
          break;
        } catch (Re) {
          z0(f, Re);
        }
      while (1);
      Dh(), kv.current = j, yr = I, ra !== null ? m = 0 : (wi = null, wa = 0, m = Zo);
    }
    if (m !== 0) {
      if (m === 2 && (I = yo(f), I !== 0 && (O = I, m = Vv(f, I))), m === 1)
        throw E = zv, Ec(f, 0), Tl(f, O), Ms(f, bt()), E;
      if (m === 6)
        Tl(f, O);
      else {
        if (I = f.current.alternate, !(O & 30) && !uy(I) && (m = Vh(f, O), m === 2 && (j = yo(f), j !== 0 && (O = j, m = Vv(f, j))), m === 1))
          throw E = zv, Ec(f, 0), Tl(f, O), Ms(f, bt()), E;
        switch (f.finishedWork = I, f.finishedLanes = O, m) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            th(f, bl, xf);
            break;
          case 3:
            if (Tl(f, O), (O & 130023424) === O && (m = Bv + 500 - bt(), 10 < m)) {
              if (Ai(f, 0) !== 0)
                break;
              if (I = f.suspendedLanes, (I & O) !== O) {
                Ii(), f.pingedLanes |= f.suspendedLanes & I;
                break;
              }
              f.timeoutHandle = rf(th.bind(null, f, bl, xf), m);
              break;
            }
            th(f, bl, xf);
            break;
          case 4:
            if (Tl(f, O), (O & 4194240) === O)
              break;
            for (m = f.eventTimes, I = -1; 0 < O; ) {
              var ue = 31 - di(O);
              j = 1 << ue, ue = m[ue], ue > I && (I = ue), O &= ~j;
            }
            if (O = I, O = bt() - O, O = (120 > O ? 120 : 480 > O ? 480 : 1080 > O ? 1080 : 1920 > O ? 1920 : 3e3 > O ? 3e3 : 4320 > O ? 4320 : 1960 * sy(O / 1960)) - O, 10 < O) {
              f.timeoutHandle = rf(th.bind(null, f, bl, xf), O);
              break;
            }
            th(f, bl, xf);
            break;
          case 5:
            th(f, bl, xf);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Ms(f, bt()), f.callbackNode === E ? Hh.bind(null, f) : null;
  }
  function Vv(f, m) {
    var E = Fh;
    return f.current.memoizedState.isDehydrated && (Ec(f, m).flags |= 256), f = Vh(f, m), f !== 2 && (m = bl, bl = E, m !== null && zp(m)), f;
  }
  function zp(f) {
    bl === null ? bl = f : bl.push.apply(bl, f);
  }
  function uy(f) {
    for (var m = f; ; ) {
      if (m.flags & 16384) {
        var E = m.updateQueue;
        if (E !== null && (E = E.stores, E !== null))
          for (var O = 0; O < E.length; O++) {
            var I = E[O], j = I.getSnapshot;
            I = I.value;
            try {
              if (!Pa(j(), I))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (E = m.child, m.subtreeFlags & 16384 && E !== null)
        E.return = m, m = E;
      else {
        if (m === f)
          break;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === f)
            return !0;
          m = m.return;
        }
        m.sibling.return = m.return, m = m.sibling;
      }
    }
    return !0;
  }
  function Tl(f, m) {
    for (m &= ~Nh, m &= ~Iv, f.suspendedLanes |= m, f.pingedLanes &= ~m, f = f.expirationTimes; 0 < m; ) {
      var E = 31 - di(m), O = 1 << E;
      f[E] = -1, m &= ~O;
    }
  }
  function Gv(f) {
    if (yr & 6)
      throw Error(t(327));
    _f();
    var m = Ai(f, 0);
    if (!(m & 1))
      return Ms(f, bt()), null;
    var E = Vh(f, m);
    if (f.tag !== 0 && E === 2) {
      var O = yo(f);
      O !== 0 && (m = O, E = Vv(f, O));
    }
    if (E === 1)
      throw E = zv, Ec(f, 0), Tl(f, m), Ms(f, bt()), E;
    if (E === 6)
      throw Error(t(345));
    return f.finishedWork = f.current.alternate, f.finishedLanes = m, th(f, bl, xf), Ms(f, bt()), null;
  }
  function Jd(f, m) {
    var E = yr;
    yr |= 1;
    try {
      return f(m);
    } finally {
      yr = E, yr === 0 && (kh = bt() + 500, xo && Ua());
    }
  }
  function eh(f) {
    Zd !== null && Zd.tag === 0 && !(yr & 6) && _f();
    var m = yr;
    yr |= 1;
    var E = Oi.transition, O = Vr;
    try {
      if (Oi.transition = null, Vr = 1, f)
        return f();
    } finally {
      Vr = O, Oi.transition = E, yr = m, !(yr & 6) && Ua();
    }
  }
  function cy() {
    ju = Gm.current, Zr(Gm);
  }
  function Ec(f, m) {
    f.finishedWork = null, f.finishedLanes = 0;
    var E = f.timeoutHandle;
    if (E !== -1 && (f.timeoutHandle = -1, Mh(E)), ra !== null)
      for (E = ra.return; E !== null; ) {
        var O = E;
        switch (af(O), O.tag) {
          case 1:
            O = O.type.childContextTypes, O != null && Ys();
            break;
          case 3:
            gu(), Zr(ba), Zr(hr), Ks();
            break;
          case 5:
            Cr(O);
            break;
          case 4:
            gu();
            break;
          case 13:
            Zr(Kn);
            break;
          case 19:
            Zr(Kn);
            break;
          case 10:
            Vi(O.type._context);
            break;
          case 22:
          case 23:
            cy();
        }
        E = E.return;
      }
    if (wi = f, ra = f = Bl(f.current, null), wa = ju = m, Zo = 0, zv = null, Nh = Iv = sd = 0, bl = Fh = null, Na !== null) {
      for (m = 0; m < Na.length; m++)
        if (E = Na[m], O = E.interleaved, O !== null) {
          E.interleaved = null;
          var I = O.next, j = E.pending;
          if (j !== null) {
            var ue = j.next;
            j.next = I, O.next = ue;
          }
          E.pending = O;
        }
      Na = null;
    }
    return f;
  }
  function z0(f, m) {
    do {
      var E = ra;
      try {
        if (Dh(), ff.current = g, Hn) {
          for (var O = ni.memoizedState; O !== null; ) {
            var I = O.queue;
            I !== null && (I.pending = null), O = O.next;
          }
          Hn = !1;
        }
        if (To = 0, Qr = Nt = ni = null, Hu = !1, Qs = 0, Qd.current = null, E === null || E.return === null) {
          Zo = 1, zv = m, ra = null;
          break;
        }
        e: {
          var j = f, ue = E.return, Re = E, Ie = m;
          if (m = wa, Re.flags |= 32768, Ie !== null && typeof Ie == "object" && typeof Ie.then == "function") {
            var Tt = Ie, Kt = Re, Xt = Kt.tag;
            if (!(Kt.mode & 1) && (Xt === 0 || Xt === 11 || Xt === 15)) {
              var $t = Kt.alternate;
              $t ? (Kt.updateQueue = $t.updateQueue, Kt.memoizedState = $t.memoizedState, Kt.lanes = $t.lanes) : (Kt.updateQueue = null, Kt.memoizedState = null);
            }
            var bn = cr(ue);
            if (bn !== null) {
              bn.flags &= -257, Qn(bn, ue, Re, j, m), bn.mode & 1 && ln(j, Tt, m), m = bn, Ie = Tt;
              var Pn = m.updateQueue;
              if (Pn === null) {
                var Fn = /* @__PURE__ */ new Set();
                Fn.add(Ie), m.updateQueue = Fn;
              } else
                Pn.add(Ie);
              break e;
            } else {
              if (!(m & 1)) {
                ln(j, Tt, m), I0();
                break e;
              }
              Ie = Error(t(426));
            }
          } else if (Xi && Re.mode & 1) {
            var eo = cr(ue);
            if (eo !== null) {
              !(eo.flags & 65536) && (eo.flags |= 256), Qn(eo, ue, Re, j, m), Rh(W(Ie, Re));
              break e;
            }
          }
          j = Ie = W(Ie, Re), Zo !== 4 && (Zo = 2), Fh === null ? Fh = [j] : Fh.push(j), j = ue;
          do {
            switch (j.tag) {
              case 3:
                j.flags |= 65536, m &= -m, j.lanes |= m;
                var st = Ot(j, Ie, m);
                Lr(j, st);
                break e;
              case 1:
                Re = Ie;
                var Xe = j.type, gt = j.stateNode;
                if (!(j.flags & 128) && (typeof Xe.getDerivedStateFromError == "function" || gt !== null && typeof gt.componentDidCatch == "function" && (ld === null || !ld.has(gt)))) {
                  j.flags |= 65536, m &= -m, j.lanes |= m;
                  var an = Jt(j, Re, m);
                  Lr(j, an);
                  break e;
                }
            }
            j = j.return;
          } while (j !== null);
        }
        jm(E);
      } catch (kn) {
        m = kn, ra === E && E !== null && (ra = E = E.return);
        continue;
      }
      break;
    } while (1);
  }
  function fy() {
    var f = kv.current;
    return kv.current = g, f === null ? g : f;
  }
  function I0() {
    (Zo === 0 || Zo === 3 || Zo === 2) && (Zo = 4), wi === null || !(sd & 268435455) && !(Iv & 268435455) || Tl(wi, wa);
  }
  function Vh(f, m) {
    var E = yr;
    yr |= 2;
    var O = fy();
    (wi !== f || wa !== m) && (xf = null, Ec(f, m));
    do
      try {
        Gh();
        break;
      } catch (I) {
        z0(f, I);
      }
    while (1);
    if (Dh(), yr = E, kv.current = O, ra !== null)
      throw Error(t(261));
    return wi = null, wa = 0, Zo;
  }
  function Gh() {
    for (; ra !== null; )
      jv(ra);
  }
  function Wv() {
    for (; ra !== null && !Nn(); )
      jv(ra);
  }
  function jv(f) {
    var m = Ym(f.alternate, f, ju);
    f.memoizedProps = f.pendingProps, m === null ? jm(f) : ra = m, Qd.current = null;
  }
  function jm(f) {
    var m = f;
    do {
      var E = m.alternate;
      if (f = m.return, m.flags & 32768) {
        if (E = ay(E, m), E !== null) {
          E.flags &= 32767, ra = E;
          return;
        }
        if (f !== null)
          f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null;
        else {
          Zo = 6, ra = null;
          return;
        }
      } else if (E = O0(E, m, ju), E !== null) {
        ra = E;
        return;
      }
      if (m = m.sibling, m !== null) {
        ra = m;
        return;
      }
      ra = m = f;
    } while (m !== null);
    Zo === 0 && (Zo = 5);
  }
  function th(f, m, E) {
    var O = Vr, I = Oi.transition;
    try {
      Oi.transition = null, Vr = 1, B0(f, m, E, O);
    } finally {
      Oi.transition = I, Vr = O;
    }
    return null;
  }
  function B0(f, m, E, O) {
    do
      _f();
    while (Zd !== null);
    if (yr & 6)
      throw Error(t(327));
    E = f.finishedWork;
    var I = f.finishedLanes;
    if (E === null)
      return null;
    if (f.finishedWork = null, f.finishedLanes = 0, E === f.current)
      throw Error(t(177));
    f.callbackNode = null, f.callbackPriority = 0;
    var j = E.lanes | E.childLanes;
    if (yp(f, j), f === wi && (ra = wi = null, wa = 0), !(E.subtreeFlags & 2064) && !(E.flags & 2064) || zh || (zh = !0, $u(Ji, function() {
      return _f(), null;
    })), j = (E.flags & 15990) !== 0, E.subtreeFlags & 15990 || j) {
      j = Oi.transition, Oi.transition = null;
      var ue = Vr;
      Vr = 1;
      var Re = yr;
      yr |= 4, Qd.current = null, U0(f, E), Lx(E, f), Di(nf), qa = !!Yf, nf = Yf = null, f.current = E, F0(E), lr(), yr = Re, Vr = ue, Oi.transition = j;
    } else
      f.current = E;
    if (zh && (zh = !1, Zd = f, Ih = I), j = f.pendingLanes, j === 0 && (ld = null), ur(E.stateNode), Ms(f, bt()), m !== null)
      for (O = f.onRecoverableError, E = 0; E < m.length; E++)
        I = m[E], O(I.value, { componentStack: I.stack, digest: I.digest });
    if (ly)
      throw ly = !1, f = kp, kp = null, f;
    return Ih & 1 && f.tag !== 0 && _f(), j = f.pendingLanes, j & 1 ? f === Hv ? Wm++ : (Wm = 0, Hv = f) : Wm = 0, Ua(), null;
  }
  function _f() {
    if (Zd !== null) {
      var f = ll(Ih), m = Oi.transition, E = Vr;
      try {
        if (Oi.transition = null, Vr = 16 > f ? 16 : f, Zd === null)
          var O = !1;
        else {
          if (f = Zd, Zd = null, Ih = 0, yr & 6)
            throw Error(t(331));
          var I = yr;
          for (yr |= 4, On = f.current; On !== null; ) {
            var j = On, ue = j.child;
            if (On.flags & 16) {
              var Re = j.deletions;
              if (Re !== null) {
                for (var Ie = 0; Ie < Re.length; Ie++) {
                  var Tt = Re[Ie];
                  for (On = Tt; On !== null; ) {
                    var Kt = On;
                    switch (Kt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Up(8, Kt, j);
                    }
                    var Xt = Kt.child;
                    if (Xt !== null)
                      Xt.return = Kt, On = Xt;
                    else
                      for (; On !== null; ) {
                        Kt = On;
                        var $t = Kt.sibling, bn = Kt.return;
                        if (Ph(Kt), Kt === Tt) {
                          On = null;
                          break;
                        }
                        if ($t !== null) {
                          $t.return = bn, On = $t;
                          break;
                        }
                        On = bn;
                      }
                  }
                }
                var Pn = j.alternate;
                if (Pn !== null) {
                  var Fn = Pn.child;
                  if (Fn !== null) {
                    Pn.child = null;
                    do {
                      var eo = Fn.sibling;
                      Fn.sibling = null, Fn = eo;
                    } while (Fn !== null);
                  }
                }
                On = j;
              }
            }
            if (j.subtreeFlags & 2064 && ue !== null)
              ue.return = j, On = ue;
            else
              e:
                for (; On !== null; ) {
                  if (j = On, j.flags & 2048)
                    switch (j.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Up(9, j, j.return);
                    }
                  var st = j.sibling;
                  if (st !== null) {
                    st.return = j.return, On = st;
                    break e;
                  }
                  On = j.return;
                }
          }
          var Xe = f.current;
          for (On = Xe; On !== null; ) {
            ue = On;
            var gt = ue.child;
            if (ue.subtreeFlags & 2064 && gt !== null)
              gt.return = ue, On = gt;
            else
              e:
                for (ue = Xe; On !== null; ) {
                  if (Re = On, Re.flags & 2048)
                    try {
                      switch (Re.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Nv(9, Re);
                      }
                    } catch (kn) {
                      Ja(Re, Re.return, kn);
                    }
                  if (Re === ue) {
                    On = null;
                    break e;
                  }
                  var an = Re.sibling;
                  if (an !== null) {
                    an.return = Re.return, On = an;
                    break e;
                  }
                  On = Re.return;
                }
          }
          if (yr = I, Ua(), _r && typeof _r.onPostCommitFiberRoot == "function")
            try {
              _r.onPostCommitFiberRoot($n, f);
            } catch {
            }
          O = !0;
        }
        return O;
      } finally {
        Vr = E, Oi.transition = m;
      }
    }
    return !1;
  }
  function $m(f, m, E) {
    m = W(E, m), m = Ot(f, m, 1), f = gc(f, m, 1), m = Ii(), f !== null && (sl(f, 1, m), Ms(f, m));
  }
  function Ja(f, m, E) {
    if (f.tag === 3)
      $m(f, f, E);
    else
      for (; m !== null; ) {
        if (m.tag === 3) {
          $m(m, f, E);
          break;
        } else if (m.tag === 1) {
          var O = m.stateNode;
          if (typeof m.type.getDerivedStateFromError == "function" || typeof O.componentDidCatch == "function" && (ld === null || !ld.has(O))) {
            f = W(E, f), f = Jt(m, f, 1), m = gc(m, f, 1), f = Ii(), m !== null && (sl(m, 1, f), Ms(m, f));
            break;
          }
        }
        m = m.return;
      }
  }
  function H0(f, m, E) {
    var O = f.pingCache;
    O !== null && O.delete(m), m = Ii(), f.pingedLanes |= f.suspendedLanes & E, wi === f && (wa & E) === E && (Zo === 4 || Zo === 3 && (wa & 130023424) === wa && 500 > bt() - Bv ? Ec(f, 0) : Nh |= E), Ms(f, m);
  }
  function dy(f, m) {
    m === 0 && (f.mode & 1 ? (m = Ti, Ti <<= 1, !(Ti & 130023424) && (Ti = 4194304)) : m = 1);
    var E = Ii();
    f = _s(f, m), f !== null && (sl(f, m, E), Ms(f, E));
  }
  function Ox(f) {
    var m = f.memoizedState, E = 0;
    m !== null && (E = m.retryLane), dy(f, E);
  }
  function Px(f, m) {
    var E = 0;
    switch (f.tag) {
      case 13:
        var O = f.stateNode, I = f.memoizedState;
        I !== null && (E = I.retryLane);
        break;
      case 19:
        O = f.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    O !== null && O.delete(m), dy(f, E);
  }
  var Ym;
  Ym = function(f, m, E) {
    if (f !== null)
      if (f.memoizedProps !== m.pendingProps || ba.current)
        hn = !0;
      else {
        if (!(f.lanes & E) && !(m.flags & 128))
          return hn = !1, yf(f, m, E);
        hn = !!(f.flags & 131072);
      }
    else
      hn = !1, Xi && m.flags & 1048576 && Pm(m, gr, m.index);
    switch (m.lanes = 0, m.tag) {
      case 2:
        var O = m.type;
        bs(f, m), f = m.pendingProps;
        var I = $s(m, hr.current);
        un(m, E), I = df(null, m, O, f, I, E);
        var j = hf();
        return m.flags |= 1, typeof I == "object" && I !== null && typeof I.render == "function" && I.$$typeof === void 0 ? (m.tag = 1, m.memoizedState = null, m.updateQueue = null, ta(O) ? (j = !0, vc(m)) : j = !1, m.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, dn(m), I.updater = lf, m.stateNode = I, I._reactInternals = m, mu(m, O, f, E), m = or(null, m, O, !0, j, E)) : (m.tag = 0, Xi && j && Cp(m), ri(null, m, I, E), m = m.child), m;
      case 16:
        O = m.elementType;
        e: {
          switch (bs(f, m), f = m.pendingProps, I = O._init, O = I(O._payload), m.type = O, I = m.tag = hE(O), f = vl(O, f), I) {
            case 0:
              m = An(null, m, O, f, E);
              break e;
            case 1:
              m = Rr(null, m, O, f, E);
              break e;
            case 11:
              m = ka(null, m, O, f, E);
              break e;
            case 14:
              m = mt(null, m, O, vl(O.type, f), E);
              break e;
          }
          throw Error(t(
            306,
            O,
            ""
          ));
        }
        return m;
      case 0:
        return O = m.type, I = m.pendingProps, I = m.elementType === O ? I : vl(O, I), An(f, m, O, I, E);
      case 1:
        return O = m.type, I = m.pendingProps, I = m.elementType === O ? I : vl(O, I), Rr(f, m, O, I, E);
      case 3:
        e: {
          if (Fr(m), f === null)
            throw Error(t(387));
          O = m.pendingProps, j = m.memoizedState, I = j.element, Gi(f, m), qi(m, O, null, E);
          var ue = m.memoizedState;
          if (O = ue.element, j.isDehydrated)
            if (j = { element: O, isDehydrated: !1, cache: ue.cache, pendingSuspenseBoundaries: ue.pendingSuspenseBoundaries, transitions: ue.transitions }, m.updateQueue.baseState = j, m.memoizedState = j, m.flags & 256) {
              I = W(Error(t(423)), m), m = va(f, m, O, E, I);
              break e;
            } else if (O !== I) {
              I = W(Error(t(424)), m), m = va(f, m, O, E, I);
              break e;
            } else
              for (Ss = Gs(m.stateNode.containerInfo.firstChild), Eo = m, Xi = !0, ml = null, E = $d(m, null, O, E), m.child = E; E; )
                E.flags = E.flags & -3 | 4096, E = E.sibling;
          else {
            if (sa(), O === I) {
              m = Qo(f, m, E);
              break e;
            }
            ri(f, m, O, E);
          }
          m = m.child;
        }
        return m;
      case 5:
        return qn(m), f === null && Wd(m), O = m.type, I = m.pendingProps, j = f !== null ? f.memoizedProps : null, ue = I.children, Bd(O, I) ? ue = null : j !== null && Bd(O, j) && (m.flags |= 32), Vt(f, m), ri(f, m, ue, E), m.child;
      case 6:
        return f === null && Wd(m), null;
      case 13:
        return Oh(f, m, E);
      case 4:
        return Lh(m, m.stateNode.containerInfo), O = m.pendingProps, f === null ? m.child = td(m, null, O, E) : ri(f, m, O, E), m.child;
      case 11:
        return O = m.type, I = m.pendingProps, I = m.elementType === O ? I : vl(O, I), ka(f, m, O, I, E);
      case 7:
        return ri(f, m, m.pendingProps, E), m.child;
      case 8:
        return ri(f, m, m.pendingProps.children, E), m.child;
      case 12:
        return ri(f, m, m.pendingProps.children, E), m.child;
      case 10:
        e: {
          if (O = m.type._context, I = m.pendingProps, j = m.memoizedProps, ue = I.value, ui(pu, O._currentValue), O._currentValue = ue, j !== null)
            if (Pa(j.value, ue)) {
              if (j.children === I.children && !ba.current) {
                m = Qo(f, m, E);
                break e;
              }
            } else
              for (j = m.child, j !== null && (j.return = m); j !== null; ) {
                var Re = j.dependencies;
                if (Re !== null) {
                  ue = j.child;
                  for (var Ie = Re.firstContext; Ie !== null; ) {
                    if (Ie.context === O) {
                      if (j.tag === 1) {
                        Ie = Fa(-1, E & -E), Ie.tag = 2;
                        var Tt = j.updateQueue;
                        if (Tt !== null) {
                          Tt = Tt.shared;
                          var Kt = Tt.pending;
                          Kt === null ? Ie.next = Ie : (Ie.next = Kt.next, Kt.next = Ie), Tt.pending = Ie;
                        }
                      }
                      j.lanes |= E, Ie = j.alternate, Ie !== null && (Ie.lanes |= E), ha(
                        j.return,
                        E,
                        m
                      ), Re.lanes |= E;
                      break;
                    }
                    Ie = Ie.next;
                  }
                } else if (j.tag === 10)
                  ue = j.type === m.type ? null : j.child;
                else if (j.tag === 18) {
                  if (ue = j.return, ue === null)
                    throw Error(t(341));
                  ue.lanes |= E, Re = ue.alternate, Re !== null && (Re.lanes |= E), ha(ue, E, m), ue = j.sibling;
                } else
                  ue = j.child;
                if (ue !== null)
                  ue.return = j;
                else
                  for (ue = j; ue !== null; ) {
                    if (ue === m) {
                      ue = null;
                      break;
                    }
                    if (j = ue.sibling, j !== null) {
                      j.return = ue.return, ue = j;
                      break;
                    }
                    ue = ue.return;
                  }
                j = ue;
              }
          ri(f, m, I.children, E), m = m.child;
        }
        return m;
      case 9:
        return I = m.type, O = m.pendingProps.children, un(m, E), I = zi(I), O = O(I), m.flags |= 1, ri(f, m, O, E), m.child;
      case 14:
        return O = m.type, I = vl(O, m.pendingProps), I = vl(O.type, I), mt(f, m, O, I, E);
      case 15:
        return We(f, m, m.type, m.pendingProps, E);
      case 17:
        return O = m.type, I = m.pendingProps, I = m.elementType === O ? I : vl(O, I), bs(f, m), m.tag = 1, ta(O) ? (f = !0, vc(m)) : f = !1, un(m, E), jd(m, O, I), mu(m, O, I, E), or(null, m, O, !0, f, E);
      case 19:
        return iy(f, m, E);
      case 22:
        return Mt(f, m, E);
    }
    throw Error(t(156, m.tag));
  };
  function $u(f, m) {
    return cn(f, m);
  }
  function V0(f, m, E, O) {
    this.tag = f, this.key = E, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = m, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = O, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Js(f, m, E, O) {
    return new V0(f, m, E, O);
  }
  function $v(f) {
    return f = f.prototype, !(!f || !f.isReactComponent);
  }
  function hE(f) {
    if (typeof f == "function")
      return $v(f) ? 1 : 0;
    if (f != null) {
      if (f = f.$$typeof, f === oe)
        return 11;
      if (f === xe)
        return 14;
    }
    return 2;
  }
  function Bl(f, m) {
    var E = f.alternate;
    return E === null ? (E = Js(f.tag, m, f.key, f.mode), E.elementType = f.elementType, E.type = f.type, E.stateNode = f.stateNode, E.alternate = f, f.alternate = E) : (E.pendingProps = m, E.type = f.type, E.flags = 0, E.subtreeFlags = 0, E.deletions = null), E.flags = f.flags & 14680064, E.childLanes = f.childLanes, E.lanes = f.lanes, E.child = f.child, E.memoizedProps = f.memoizedProps, E.memoizedState = f.memoizedState, E.updateQueue = f.updateQueue, m = f.dependencies, E.dependencies = m === null ? null : { lanes: m.lanes, firstContext: m.firstContext }, E.sibling = f.sibling, E.index = f.index, E.ref = f.ref, E;
  }
  function nh(f, m, E, O, I, j) {
    var ue = 2;
    if (O = f, typeof f == "function")
      $v(f) && (ue = 1);
    else if (typeof f == "string")
      ue = 5;
    else
      e:
        switch (f) {
          case Y:
            return Ip(E.children, I, j, m);
          case J:
            ue = 8, I |= 8;
            break;
          case K:
            return f = Js(12, E, m, I | 2), f.elementType = K, f.lanes = j, f;
          case fe:
            return f = Js(13, E, m, I), f.elementType = fe, f.lanes = j, f;
          case de:
            return f = Js(19, E, m, I), f.elementType = de, f.lanes = j, f;
          case Pe:
            return Wh(E, I, j, m);
          default:
            if (typeof f == "object" && f !== null)
              switch (f.$$typeof) {
                case X:
                  ue = 10;
                  break e;
                case le:
                  ue = 9;
                  break e;
                case oe:
                  ue = 11;
                  break e;
                case xe:
                  ue = 14;
                  break e;
                case _e:
                  ue = 16, O = null;
                  break e;
              }
            throw Error(t(130, f == null ? f : typeof f, ""));
        }
    return m = Js(ue, E, m, I), m.elementType = f, m.type = O, m.lanes = j, m;
  }
  function Ip(f, m, E, O) {
    return f = Js(7, f, O, m), f.lanes = E, f;
  }
  function Wh(f, m, E, O) {
    return f = Js(22, f, O, m), f.elementType = Pe, f.lanes = E, f.stateNode = { isHidden: !1 }, f;
  }
  function _u(f, m, E) {
    return f = Js(6, f, null, m), f.lanes = E, f;
  }
  function Qi(f, m, E) {
    return m = Js(4, f.children !== null ? f.children : [], f.key, m), m.lanes = E, m.stateNode = { containerInfo: f.containerInfo, pendingChildren: null, implementation: f.implementation }, m;
  }
  function jh(f, m, E, O, I) {
    this.tag = m, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ac(0), this.expirationTimes = ac(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ac(0), this.identifierPrefix = O, this.onRecoverableError = I, this.mutableSourceEagerHydrationData = null;
  }
  function Ia(f, m, E, O, I, j, ue, Re, Ie) {
    return f = new jh(f, m, E, Re, Ie), m === 1 ? (m = 1, j === !0 && (m |= 8)) : m = 0, j = Js(3, null, null, m), f.current = j, j.stateNode = f, j.memoizedState = { element: O, isDehydrated: E, cache: null, transitions: null, pendingSuspenseBoundaries: null }, dn(j), f;
  }
  function Cs(f, m, E) {
    var O = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: $, key: O == null ? null : "" + O, children: f, containerInfo: m, implementation: E };
  }
  function Yv(f) {
    if (!f)
      return ku;
    f = f._reactInternals;
    e: {
      if (ye(f) !== f || f.tag !== 1)
        throw Error(t(170));
      var m = f;
      do {
        switch (m.tag) {
          case 3:
            m = m.stateNode.context;
            break e;
          case 1:
            if (ta(m.type)) {
              m = m.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        m = m.return;
      } while (m !== null);
      throw Error(t(171));
    }
    if (f.tag === 1) {
      var E = f.type;
      if (ta(E))
        return Kf(f, E, m);
    }
    return m;
  }
  function hy(f, m, E, O, I, j, ue, Re, Ie) {
    return f = Ia(E, O, !0, f, I, j, ue, Re, Ie), f.context = Yv(null), E = f.current, O = Ii(), I = mo(E), j = Fa(O, I), j.callback = m ?? null, gc(E, j, I), f.current.lanes = I, sl(f, I, O), Ms(f, O), f;
  }
  function Xv(f, m, E, O) {
    var I = m.current, j = Ii(), ue = mo(I);
    return E = Yv(E), m.context === null ? m.context = E : m.pendingContext = E, m = Fa(j, ue), m.payload = { element: f }, O = O === void 0 ? null : O, O !== null && (m.callback = O), f = gc(I, m, ue), f !== null && (ws(f, I, ue, j), ma(f, I, ue)), ue;
  }
  function gn(f) {
    if (f = f.current, !f.child)
      return null;
    switch (f.child.tag) {
      case 5:
        return f.child.stateNode;
      default:
        return f.child.stateNode;
    }
  }
  function Hl(f, m) {
    if (f = f.memoizedState, f !== null && f.dehydrated !== null) {
      var E = f.retryLane;
      f.retryLane = E !== 0 && E < m ? E : m;
    }
  }
  function qv(f, m) {
    Hl(f, m), (f = f.alternate) && Hl(f, m);
  }
  function Bp() {
    return null;
  }
  var $h = typeof reportError == "function" ? reportError : function(f) {
    console.error(f);
  };
  function Bi(f) {
    this._internalRoot = f;
  }
  Ba.prototype.render = Bi.prototype.render = function(f) {
    var m = this._internalRoot;
    if (m === null)
      throw Error(t(409));
    Xv(f, m, null, null);
  }, Ba.prototype.unmount = Bi.prototype.unmount = function() {
    var f = this._internalRoot;
    if (f !== null) {
      this._internalRoot = null;
      var m = f.containerInfo;
      eh(function() {
        Xv(null, f, null, null);
      }), m[Ws] = null;
    }
  };
  function Ba(f) {
    this._internalRoot = f;
  }
  Ba.prototype.unstable_scheduleHydration = function(f) {
    if (f) {
      var m = Ra();
      f = { blockedOn: null, target: f, priority: m };
      for (var E = 0; E < gi.length && m !== 0 && m < gi[E].priority; E++)
        ;
      gi.splice(E, 0, f), E === 0 && ps(f);
    }
  };
  function Ro(f) {
    return !(!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11);
  }
  function Hp(f) {
    return !(!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11 && (f.nodeType !== 8 || f.nodeValue !== " react-mount-point-unstable "));
  }
  function Xm() {
  }
  function Kv(f, m, E, O, I) {
    if (I) {
      if (typeof O == "function") {
        var j = O;
        O = function() {
          var Tt = gn(ue);
          j.call(Tt);
        };
      }
      var ue = hy(m, O, f, 0, null, !1, !1, "", Xm);
      return f._reactRootContainer = ue, f[Ws] = ue.current, hl(f.nodeType === 8 ? f.parentNode : f), eh(), ue;
    }
    for (; I = f.lastChild; )
      f.removeChild(I);
    if (typeof O == "function") {
      var Re = O;
      O = function() {
        var Tt = gn(Ie);
        Re.call(Tt);
      };
    }
    var Ie = Ia(f, 0, !1, null, null, !1, !1, "", Xm);
    return f._reactRootContainer = Ie, f[Ws] = Ie.current, hl(f.nodeType === 8 ? f.parentNode : f), eh(function() {
      Xv(m, Ie, E, O);
    }), Ie;
  }
  function py(f, m, E, O, I) {
    var j = E._reactRootContainer;
    if (j) {
      var ue = j;
      if (typeof I == "function") {
        var Re = I;
        I = function() {
          var Ie = gn(ue);
          Re.call(Ie);
        };
      }
      Xv(m, ue, f, I);
    } else
      ue = Kv(E, m, f, I, O);
    return gn(ue);
  }
  kf = function(f) {
    switch (f.tag) {
      case 3:
        var m = f.stateNode;
        if (m.current.memoizedState.isDehydrated) {
          var E = Xa(m.pendingLanes);
          E !== 0 && (Dl(m, E | 1), Ms(m, bt()), !(yr & 6) && (kh = bt() + 500, Ua()));
        }
        break;
      case 13:
        eh(function() {
          var O = _s(f, 1);
          if (O !== null) {
            var I = Ii();
            ws(O, f, 1, I);
          }
        }), qv(f, 1);
    }
  }, jo = function(f) {
    if (f.tag === 13) {
      var m = _s(f, 134217728);
      if (m !== null) {
        var E = Ii();
        ws(m, f, 134217728, E);
      }
      qv(f, 134217728);
    }
  }, ei = function(f) {
    if (f.tag === 13) {
      var m = mo(f), E = _s(f, m);
      if (E !== null) {
        var O = Ii();
        ws(E, f, m, O);
      }
      qv(f, m);
    }
  }, Ra = function() {
    return Vr;
  }, zf = function(f, m) {
    var E = Vr;
    try {
      return Vr = f, m();
    } finally {
      Vr = E;
    }
  }, Rt = function(f, m, E) {
    switch (m) {
      case "input":
        if (Ut(f, E), m = E.name, E.type === "radio" && m != null) {
          for (E = f; E.parentNode; )
            E = E.parentNode;
          for (E = E.querySelectorAll("input[name=" + JSON.stringify("" + m) + '][type="radio"]'), m = 0; m < E.length; m++) {
            var O = E[m];
            if (O !== f && O.form === f.form) {
              var I = Xn(O);
              if (!I)
                throw Error(t(90));
              ae(O), Ut(O, I);
            }
          }
        }
        break;
      case "textarea":
        ne(f, E);
        break;
      case "select":
        m = E.value, m != null && vt(f, !!E.multiple, m, !1);
    }
  }, rr = Jd, mn = eh;
  var pE = { usingClientEntryPoint: !1, Events: [js, hi, Xn, zn, Gn, Jd] }, kt = { findFiberByHostInstance: Xo, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, bc = { bundleType: kt.bundleType, version: kt.version, rendererPackageName: kt.rendererPackageName, rendererConfig: kt.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: H.ReactCurrentDispatcher, findHostInstanceByFiber: function(f) {
    return f = pt(f), f === null ? null : f.stateNode;
  }, findFiberByHostInstance: kt.findFiberByHostInstance || Bp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ef = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ef.isDisabled && Ef.supportsFiber)
      try {
        $n = Ef.inject(bc), _r = Ef;
      } catch {
      }
  }
  return Sd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = pE, Sd.createPortal = function(f, m) {
    var E = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Ro(m))
      throw Error(t(200));
    return Cs(f, m, null, E);
  }, Sd.createRoot = function(f, m) {
    if (!Ro(f))
      throw Error(t(299));
    var E = !1, O = "", I = $h;
    return m != null && (m.unstable_strictMode === !0 && (E = !0), m.identifierPrefix !== void 0 && (O = m.identifierPrefix), m.onRecoverableError !== void 0 && (I = m.onRecoverableError)), m = Ia(f, 1, !1, null, null, E, !1, O, I), f[Ws] = m.current, hl(f.nodeType === 8 ? f.parentNode : f), new Bi(m);
  }, Sd.findDOMNode = function(f) {
    if (f == null)
      return null;
    if (f.nodeType === 1)
      return f;
    var m = f._reactInternals;
    if (m === void 0)
      throw typeof f.render == "function" ? Error(t(188)) : (f = Object.keys(f).join(","), Error(t(268, f)));
    return f = pt(m), f = f === null ? null : f.stateNode, f;
  }, Sd.flushSync = function(f) {
    return eh(f);
  }, Sd.hydrate = function(f, m, E) {
    if (!Hp(m))
      throw Error(t(200));
    return py(null, f, m, !0, E);
  }, Sd.hydrateRoot = function(f, m, E) {
    if (!Ro(f))
      throw Error(t(405));
    var O = E != null && E.hydratedSources || null, I = !1, j = "", ue = $h;
    if (E != null && (E.unstable_strictMode === !0 && (I = !0), E.identifierPrefix !== void 0 && (j = E.identifierPrefix), E.onRecoverableError !== void 0 && (ue = E.onRecoverableError)), m = hy(m, null, f, 1, E ?? null, I, !1, j, ue), f[Ws] = m.current, hl(f), O)
      for (f = 0; f < O.length; f++)
        E = O[f], I = E._getVersion, I = I(E._source), m.mutableSourceEagerHydrationData == null ? m.mutableSourceEagerHydrationData = [E, I] : m.mutableSourceEagerHydrationData.push(
          E,
          I
        );
    return new Ba(m);
  }, Sd.render = function(f, m, E) {
    if (!Hp(m))
      throw Error(t(200));
    return py(null, f, m, !1, E);
  }, Sd.unmountComponentAtNode = function(f) {
    if (!Hp(f))
      throw Error(t(40));
    return f._reactRootContainer ? (eh(function() {
      py(null, null, f, !1, function() {
        f._reactRootContainer = null, f[Ws] = null;
      });
    }), !0) : !1;
  }, Sd.unstable_batchedUpdates = Jd, Sd.unstable_renderSubtreeIntoContainer = function(f, m, E, O) {
    if (!Hp(E))
      throw Error(t(200));
    if (f == null || f._reactInternals === void 0)
      throw Error(t(38));
    return py(f, m, E, !1, O);
  }, Sd.version = "18.2.0-next-9e3b772b8-20220608", Sd;
}
var xd = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xk;
function Fq() {
  return xk || (xk = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = Fe, e = HB(), t = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(a) {
      r = a;
    }
    function o(a) {
      if (!r) {
        for (var s = arguments.length, v = new Array(s > 1 ? s - 1 : 0), _ = 1; _ < s; _++)
          v[_ - 1] = arguments[_];
        c("warn", a, v);
      }
    }
    function l(a) {
      if (!r) {
        for (var s = arguments.length, v = new Array(s > 1 ? s - 1 : 0), _ = 1; _ < s; _++)
          v[_ - 1] = arguments[_];
        c("error", a, v);
      }
    }
    function c(a, s, v) {
      {
        var _ = t.ReactDebugCurrentFrame, M = _.getStackAddendum();
        M !== "" && (s += "%s", v = v.concat([M]));
        var N = v.map(function(G) {
          return String(G);
        });
        N.unshift("Warning: " + s), Function.prototype.apply.call(console[a], console, N);
      }
    }
    var h = 0, p = 1, y = 2, x = 3, b = 4, w = 5, R = 6, U = 7, L = 8, A = 9, F = 10, k = 11, H = 12, B = 13, $ = 14, Y = 15, J = 16, K = 17, X = 18, le = 19, oe = 21, fe = 22, de = 23, xe = 24, _e = 25, Pe = !0, ce = !1, ve = !1, re = !1, ee = !1, he = !0, Me = !1, Le = !1, Ae = !0, Ue = !0, Ne = !0, ke = /* @__PURE__ */ new Set(), it = {}, At = {};
    function rt(a, s) {
      ae(a, s), ae(a + "Capture", s);
    }
    function ae(a, s) {
      it[a] && l("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", a), it[a] = s;
      {
        var v = a.toLowerCase();
        At[v] = a, a === "onDoubleClick" && (At.ondblclick = a);
      }
      for (var _ = 0; _ < s.length; _++)
        ke.add(s[_]);
    }
    var et = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ye = Object.prototype.hasOwnProperty;
    function Ge(a) {
      {
        var s = typeof Symbol == "function" && Symbol.toStringTag, v = s && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return v;
      }
    }
    function $e(a) {
      try {
        return Ut(a), !1;
      } catch {
        return !0;
      }
    }
    function Ut(a) {
      return "" + a;
    }
    function nt(a, s) {
      if ($e(a))
        return l("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Ge(a)), Ut(a);
    }
    function Ct(a) {
      if ($e(a))
        return l("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ge(a)), Ut(a);
    }
    function Pt(a, s) {
      if ($e(a))
        return l("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Ge(a)), Ut(a);
    }
    function vt(a, s) {
      if ($e(a))
        return l("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", s, Ge(a)), Ut(a);
    }
    function Zt(a) {
      if ($e(a))
        return l("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Ge(a)), Ut(a);
    }
    function ie(a) {
      if ($e(a))
        return l("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Ge(a)), Ut(a);
    }
    var ne = 0, Oe = 1, _t = 2, ot = 3, at = 4, Wt = 5, Dt = 6, Se = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", He = Se + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", lt = new RegExp("^[" + Se + "][" + He + "]*$"), St = {}, Je = {};
    function be(a) {
      return Ye.call(Je, a) ? !0 : Ye.call(St, a) ? !1 : lt.test(a) ? (Je[a] = !0, !0) : (St[a] = !0, l("Invalid attribute name: `%s`", a), !1);
    }
    function Ze(a, s, v) {
      return s !== null ? s.type === ne : v ? !1 : a.length > 2 && (a[0] === "o" || a[0] === "O") && (a[1] === "n" || a[1] === "N");
    }
    function ct(a, s, v, _) {
      if (v !== null && v.type === ne)
        return !1;
      switch (typeof s) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (_)
            return !1;
          if (v !== null)
            return !v.acceptsBooleans;
          var M = a.toLowerCase().slice(0, 5);
          return M !== "data-" && M !== "aria-";
        }
        default:
          return !1;
      }
    }
    function pe(a, s, v, _) {
      if (s === null || typeof s > "u" || ct(a, s, v, _))
        return !0;
      if (_)
        return !1;
      if (v !== null)
        switch (v.type) {
          case ot:
            return !s;
          case at:
            return s === !1;
          case Wt:
            return isNaN(s);
          case Dt:
            return isNaN(s) || s < 1;
        }
      return !1;
    }
    function Rt(a) {
      return ut.hasOwnProperty(a) ? ut[a] : null;
    }
    function Be(a, s, v, _, M, N, G) {
      this.acceptsBooleans = s === _t || s === ot || s === at, this.attributeName = _, this.attributeNamespace = M, this.mustUseProperty = v, this.propertyName = a, this.type = s, this.sanitizeURL = N, this.removeEmptyString = G;
    }
    var ut = {}, on = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    on.forEach(function(a) {
      ut[a] = new Be(
        a,
        ne,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var s = a[0], v = a[1];
      ut[s] = new Be(
        s,
        Oe,
        !1,
        // mustUseProperty
        v,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      ut[a] = new Be(
        a,
        _t,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      ut[a] = new Be(
        a,
        _t,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(a) {
      ut[a] = new Be(
        a,
        ot,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      ut[a] = new Be(
        a,
        ot,
        !0,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      ut[a] = new Be(
        a,
        at,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      ut[a] = new Be(
        a,
        Dt,
        !1,
        // mustUseProperty
        a,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(a) {
      ut[a] = new Be(
        a,
        Wt,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var zn = /[\-\:]([a-z])/g, Gn = function(a) {
      return a[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(zn, Gn);
      ut[s] = new Be(
        s,
        Oe,
        !1,
        // mustUseProperty
        a,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(zn, Gn);
      ut[s] = new Be(
        s,
        Oe,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(a) {
      var s = a.replace(zn, Gn);
      ut[s] = new Be(
        s,
        Oe,
        !1,
        // mustUseProperty
        a,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(a) {
      ut[a] = new Be(
        a,
        Oe,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var rr = "xlinkHref";
    ut[rr] = new Be(
      "xlinkHref",
      Oe,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(a) {
      ut[a] = new Be(
        a,
        Oe,
        !1,
        // mustUseProperty
        a.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var mn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, er = !1;
    function ir(a) {
      !er && mn.test(a) && (er = !0, l("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(a)));
    }
    function Wn(a, s, v, _) {
      if (_.mustUseProperty) {
        var M = _.propertyName;
        return a[M];
      } else {
        nt(v, s), _.sanitizeURL && ir("" + v);
        var N = _.attributeName, G = null;
        if (_.type === at) {
          if (a.hasAttribute(N)) {
            var q = a.getAttribute(N);
            return q === "" ? !0 : pe(s, v, _, !1) ? q : q === "" + v ? v : q;
          }
        } else if (a.hasAttribute(N)) {
          if (pe(s, v, _, !1))
            return a.getAttribute(N);
          if (_.type === ot)
            return v;
          G = a.getAttribute(N);
        }
        return pe(s, v, _, !1) ? G === null ? v : G : G === "" + v ? v : G;
      }
    }
    function Ei(a, s, v, _) {
      {
        if (!be(s))
          return;
        if (!a.hasAttribute(s))
          return v === void 0 ? void 0 : null;
        var M = a.getAttribute(s);
        return nt(v, s), M === "" + v ? v : M;
      }
    }
    function Wr(a, s, v, _) {
      var M = Rt(s);
      if (!Ze(s, M, _)) {
        if (pe(s, v, M, _) && (v = null), _ || M === null) {
          if (be(s)) {
            var N = s;
            v === null ? a.removeAttribute(N) : (nt(v, s), a.setAttribute(N, "" + v));
          }
          return;
        }
        var G = M.mustUseProperty;
        if (G) {
          var q = M.propertyName;
          if (v === null) {
            var te = M.type;
            a[q] = te === ot ? !1 : "";
          } else
            a[q] = v;
          return;
        }
        var ge = M.attributeName, Ee = M.attributeNamespace;
        if (v === null)
          a.removeAttribute(ge);
        else {
          var Ke = M.type, je;
          Ke === ot || Ke === at && v === !0 ? je = "" : (nt(v, ge), je = "" + v, M.sanitizeURL && ir(je.toString())), Ee ? a.setAttributeNS(Ee, ge, je) : a.setAttribute(ge, je);
        }
      }
    }
    var Br = Symbol.for("react.element"), Mr = Symbol.for("react.portal"), Ri = Symbol.for("react.fragment"), si = Symbol.for("react.strict_mode"), De = Symbol.for("react.profiler"), Ft = Symbol.for("react.provider"), qt = Symbol.for("react.context"), En = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), qe = Symbol.for("react.suspense_list"), tt = Symbol.for("react.memo"), Ve = Symbol.for("react.lazy"), pt = Symbol.for("react.scope"), en = Symbol.for("react.debug_trace_mode"), cn = Symbol.for("react.offscreen"), xn = Symbol.for("react.legacy_hidden"), Nn = Symbol.for("react.cache"), lr = Symbol.for("react.tracing_marker"), bt = Symbol.iterator, ar = "@@iterator";
    function Hr(a) {
      if (a === null || typeof a != "object")
        return null;
      var s = bt && a[bt] || a[ar];
      return typeof s == "function" ? s : null;
    }
    var Tn = Object.assign, Ji = 0, Do, li, $n, _r, ur, di, xa;
    function Xr() {
    }
    Xr.__reactDisabledLog = !0;
    function ds() {
      {
        if (Ji === 0) {
          Do = console.log, li = console.info, $n = console.warn, _r = console.error, ur = console.group, di = console.groupCollapsed, xa = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: Xr,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        Ji++;
      }
    }
    function bi() {
      {
        if (Ji--, Ji === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Tn({}, a, {
              value: Do
            }),
            info: Tn({}, a, {
              value: li
            }),
            warn: Tn({}, a, {
              value: $n
            }),
            error: Tn({}, a, {
              value: _r
            }),
            group: Tn({}, a, {
              value: ur
            }),
            groupCollapsed: Tn({}, a, {
              value: di
            }),
            groupEnd: Tn({}, a, {
              value: xa
            })
          });
        }
        Ji < 0 && l("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ti = t.ReactCurrentDispatcher, Xa;
    function Ai(a, s, v) {
      {
        if (Xa === void 0)
          try {
            throw Error();
          } catch (M) {
            var _ = M.stack.trim().match(/\n( *(at )?)/);
            Xa = _ && _[1] || "";
          }
        return `
` + Xa + a;
      }
    }
    var ru = !1, Ns;
    {
      var yo = typeof WeakMap == "function" ? WeakMap : Map;
      Ns = new yo();
    }
    function Wo(a, s) {
      if (!a || ru)
        return "";
      {
        var v = Ns.get(a);
        if (v !== void 0)
          return v;
      }
      var _;
      ru = !0;
      var M = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var N;
      N = Ti.current, Ti.current = null, ds();
      try {
        if (s) {
          var G = function() {
            throw Error();
          };
          if (Object.defineProperty(G.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(G, []);
            } catch (wt) {
              _ = wt;
            }
            Reflect.construct(a, [], G);
          } else {
            try {
              G.call();
            } catch (wt) {
              _ = wt;
            }
            a.call(G.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (wt) {
            _ = wt;
          }
          a();
        }
      } catch (wt) {
        if (wt && _ && typeof wt.stack == "string") {
          for (var q = wt.stack.split(`
`), te = _.stack.split(`
`), ge = q.length - 1, Ee = te.length - 1; ge >= 1 && Ee >= 0 && q[ge] !== te[Ee]; )
            Ee--;
          for (; ge >= 1 && Ee >= 0; ge--, Ee--)
            if (q[ge] !== te[Ee]) {
              if (ge !== 1 || Ee !== 1)
                do
                  if (ge--, Ee--, Ee < 0 || q[ge] !== te[Ee]) {
                    var Ke = `
` + q[ge].replace(" at new ", " at ");
                    return a.displayName && Ke.includes("<anonymous>") && (Ke = Ke.replace("<anonymous>", a.displayName)), typeof a == "function" && Ns.set(a, Ke), Ke;
                  }
                while (ge >= 1 && Ee >= 0);
              break;
            }
        }
      } finally {
        ru = !1, Ti.current = N, bi(), Error.prepareStackTrace = M;
      }
      var je = a ? a.displayName || a.name : "", Et = je ? Ai(je) : "";
      return typeof a == "function" && Ns.set(a, Et), Et;
    }
    function ac(a, s, v) {
      return Wo(a, !0);
    }
    function sl(a, s, v) {
      return Wo(a, !1);
    }
    function yp(a) {
      var s = a.prototype;
      return !!(s && s.isReactComponent);
    }
    function Dl(a, s, v) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Wo(a, yp(a));
      if (typeof a == "string")
        return Ai(a);
      switch (a) {
        case ye:
          return Ai("Suspense");
        case qe:
          return Ai("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case En:
            return sl(a.render);
          case tt:
            return Dl(a.type, s, v);
          case Ve: {
            var _ = a, M = _._payload, N = _._init;
            try {
              return Dl(N(M), s, v);
            } catch {
            }
          }
        }
      return "";
    }
    function Vr(a) {
      switch (a._debugOwner && a._debugOwner.type, a._debugSource, a.tag) {
        case w:
          return Ai(a.type);
        case J:
          return Ai("Lazy");
        case B:
          return Ai("Suspense");
        case le:
          return Ai("SuspenseList");
        case h:
        case y:
        case Y:
          return sl(a.type);
        case k:
          return sl(a.type.render);
        case p:
          return ac(a.type);
        default:
          return "";
      }
    }
    function ll(a) {
      try {
        var s = "", v = a;
        do
          s += Vr(v), v = v.return;
        while (v);
        return s;
      } catch (_) {
        return `
Error generating stack: ` + _.message + `
` + _.stack;
      }
    }
    function kf(a, s, v) {
      var _ = a.displayName;
      if (_)
        return _;
      var M = s.displayName || s.name || "";
      return M !== "" ? v + "(" + M + ")" : v;
    }
    function jo(a) {
      return a.displayName || "Context";
    }
    function ei(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && l("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Ri:
          return "Fragment";
        case Mr:
          return "Portal";
        case De:
          return "Profiler";
        case si:
          return "StrictMode";
        case ye:
          return "Suspense";
        case qe:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case qt:
            var s = a;
            return jo(s) + ".Consumer";
          case Ft:
            var v = a;
            return jo(v._context) + ".Provider";
          case En:
            return kf(a, a.render, "ForwardRef");
          case tt:
            var _ = a.displayName || null;
            return _ !== null ? _ : ei(a.type) || "Memo";
          case Ve: {
            var M = a, N = M._payload, G = M._init;
            try {
              return ei(G(N));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ra(a, s, v) {
      var _ = s.displayName || s.name || "";
      return a.displayName || (_ !== "" ? v + "(" + _ + ")" : v);
    }
    function zf(a) {
      return a.displayName || "Context";
    }
    function nr(a) {
      var s = a.tag, v = a.type;
      switch (s) {
        case xe:
          return "Cache";
        case A:
          var _ = v;
          return zf(_) + ".Consumer";
        case F:
          var M = v;
          return zf(M._context) + ".Provider";
        case X:
          return "DehydratedFragment";
        case k:
          return Ra(v, v.render, "ForwardRef");
        case U:
          return "Fragment";
        case w:
          return v;
        case b:
          return "Portal";
        case x:
          return "Root";
        case R:
          return "Text";
        case J:
          return ei(v);
        case L:
          return v === si ? "StrictMode" : "Mode";
        case fe:
          return "Offscreen";
        case H:
          return "Profiler";
        case oe:
          return "Scope";
        case B:
          return "Suspense";
        case le:
          return "SuspenseList";
        case _e:
          return "TracingMarker";
        case p:
        case h:
        case K:
        case y:
        case $:
        case Y:
          if (typeof v == "function")
            return v.displayName || v.name || null;
          if (typeof v == "string")
            return v;
          break;
      }
      return null;
    }
    var iu = t.ReactDebugCurrentFrame, Fi = null, dr = !1;
    function hs() {
      {
        if (Fi === null)
          return null;
        var a = Fi._debugOwner;
        if (a !== null && typeof a < "u")
          return nr(a);
      }
      return null;
    }
    function Lo() {
      return Fi === null ? "" : ll(Fi);
    }
    function fa() {
      iu.getCurrentStack = null, Fi = null, dr = !1;
    }
    function gi(a) {
      iu.getCurrentStack = a === null ? null : Lo, Fi = a, dr = !1;
    }
    function Sm() {
      return Fi;
    }
    function qr(a) {
      dr = a;
    }
    function Aa(a) {
      return "" + a;
    }
    function Ru(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return ie(a), a;
        default:
          return "";
      }
    }
    var ps = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function oc(a, s) {
      ps[s.type] || s.onChange || s.onInput || s.readOnly || s.disabled || s.value == null || l("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), s.onChange || s.readOnly || s.disabled || s.checked == null || l("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Vc(a) {
      var s = a.type, v = a.nodeName;
      return v && v.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
    }
    function ul(a) {
      return a._valueTracker;
    }
    function Gc(a) {
      a._valueTracker = null;
    }
    function If(a) {
      var s = "";
      return a && (Vc(a) ? s = a.checked ? "true" : "false" : s = a.value), s;
    }
    function Oo(a) {
      var s = Vc(a) ? "checked" : "value", v = Object.getOwnPropertyDescriptor(a.constructor.prototype, s);
      ie(a[s]);
      var _ = "" + a[s];
      if (!(a.hasOwnProperty(s) || typeof v > "u" || typeof v.get != "function" || typeof v.set != "function")) {
        var M = v.get, N = v.set;
        Object.defineProperty(a, s, {
          configurable: !0,
          get: function() {
            return M.call(this);
          },
          set: function(q) {
            ie(q), _ = "" + q, N.call(this, q);
          }
        }), Object.defineProperty(a, s, {
          enumerable: v.enumerable
        });
        var G = {
          getValue: function() {
            return _;
          },
          setValue: function(q) {
            ie(q), _ = "" + q;
          },
          stopTracking: function() {
            Gc(a), delete a[s];
          }
        };
        return G;
      }
    }
    function qa(a) {
      ul(a) || (a._valueTracker = Oo(a));
    }
    function Au(a) {
      if (!a)
        return !1;
      var s = ul(a);
      if (!s)
        return !0;
      var v = s.getValue(), _ = If(a);
      return _ !== v ? (s.setValue(_), !0) : !1;
    }
    function Fs(a) {
      if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
        return null;
      try {
        return a.activeElement || a.body;
      } catch {
        return a.body;
      }
    }
    var Wc = !1, jc = !1, $o = !1, $c = !1;
    function ks(a) {
      var s = a.type === "checkbox" || a.type === "radio";
      return s ? a.checked != null : a.value != null;
    }
    function Du(a, s) {
      var v = a, _ = s.checked, M = Tn({}, s, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: _ ?? v._wrapperState.initialChecked
      });
      return M;
    }
    function So(a, s) {
      oc("input", s), s.checked !== void 0 && s.defaultChecked !== void 0 && !jc && (l("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", hs() || "A component", s.type), jc = !0), s.value !== void 0 && s.defaultValue !== void 0 && !Wc && (l("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", hs() || "A component", s.type), Wc = !0);
      var v = a, _ = s.defaultValue == null ? "" : s.defaultValue;
      v._wrapperState = {
        initialChecked: s.checked != null ? s.checked : s.defaultChecked,
        initialValue: Ru(s.value != null ? s.value : _),
        controlled: ks(s)
      };
    }
    function Ka(a, s) {
      var v = a, _ = s.checked;
      _ != null && Wr(v, "checked", _, !1);
    }
    function au(a, s) {
      var v = a;
      {
        var _ = ks(s);
        !v._wrapperState.controlled && _ && !$c && (l("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), $c = !0), v._wrapperState.controlled && !_ && !$o && (l("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), $o = !0);
      }
      Ka(a, s);
      var M = Ru(s.value), N = s.type;
      if (M != null)
        N === "number" ? (M === 0 && v.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        v.value != M) && (v.value = Aa(M)) : v.value !== Aa(M) && (v.value = Aa(M));
      else if (N === "submit" || N === "reset") {
        v.removeAttribute("value");
        return;
      }
      s.hasOwnProperty("value") ? ou(v, s.type, M) : s.hasOwnProperty("defaultValue") && ou(v, s.type, Ru(s.defaultValue)), s.checked == null && s.defaultChecked != null && (v.defaultChecked = !!s.defaultChecked);
    }
    function zs(a, s, v) {
      var _ = a;
      if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
        var M = s.type, N = M === "submit" || M === "reset";
        if (N && (s.value === void 0 || s.value === null))
          return;
        var G = Aa(_._wrapperState.initialValue);
        v || G !== _.value && (_.value = G), _.defaultValue = G;
      }
      var q = _.name;
      q !== "" && (_.name = ""), _.defaultChecked = !_.defaultChecked, _.defaultChecked = !!_._wrapperState.initialChecked, q !== "" && (_.name = q);
    }
    function sc(a, s) {
      var v = a;
      au(v, s), Po(v, s);
    }
    function Po(a, s) {
      var v = s.name;
      if (s.type === "radio" && v != null) {
        for (var _ = a; _.parentNode; )
          _ = _.parentNode;
        nt(v, "name");
        for (var M = _.querySelectorAll("input[name=" + JSON.stringify("" + v) + '][type="radio"]'), N = 0; N < M.length; N++) {
          var G = M[N];
          if (!(G === a || G.form !== a.form)) {
            var q = cd(G);
            if (!q)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Au(G), au(G, q);
          }
        }
      }
    }
    function ou(a, s, v) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (s !== "number" || Fs(a.ownerDocument) !== a) && (v == null ? a.defaultValue = Aa(a._wrapperState.initialValue) : a.defaultValue !== Aa(v) && (a.defaultValue = Aa(v)));
    }
    var Da = !1, ao = !1, La = !1;
    function da(a, s) {
      s.value == null && (typeof s.children == "object" && s.children !== null ? n.Children.forEach(s.children, function(v) {
        v != null && (typeof v == "string" || typeof v == "number" || ao || (ao = !0, l("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : s.dangerouslySetInnerHTML != null && (La || (La = !0, l("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), s.selected != null && !Da && (l("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Da = !0);
    }
    function ms(a, s) {
      s.value != null && a.setAttribute("value", Aa(Ru(s.value)));
    }
    var cl = Array.isArray;
    function oo(a) {
      return cl(a);
    }
    var Bf;
    Bf = !1;
    function lc() {
      var a = hs();
      return a ? `

Check the render method of \`` + a + "`." : "";
    }
    var Yc = ["value", "defaultValue"];
    function xm(a) {
      {
        oc("select", a);
        for (var s = 0; s < Yc.length; s++) {
          var v = Yc[s];
          if (a[v] != null) {
            var _ = oo(a[v]);
            a.multiple && !_ ? l("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", v, lc()) : !a.multiple && _ && l("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", v, lc());
          }
        }
      }
    }
    function Xc(a, s, v, _) {
      var M = a.options;
      if (s) {
        for (var N = v, G = {}, q = 0; q < N.length; q++)
          G["$" + N[q]] = !0;
        for (var te = 0; te < M.length; te++) {
          var ge = G.hasOwnProperty("$" + M[te].value);
          M[te].selected !== ge && (M[te].selected = ge), ge && _ && (M[te].defaultSelected = !0);
        }
      } else {
        for (var Ee = Aa(Ru(v)), Ke = null, je = 0; je < M.length; je++) {
          if (M[je].value === Ee) {
            M[je].selected = !0, _ && (M[je].defaultSelected = !0);
            return;
          }
          Ke === null && !M[je].disabled && (Ke = M[je]);
        }
        Ke !== null && (Ke.selected = !0);
      }
    }
    function xh(a, s) {
      return Tn({}, s, {
        value: void 0
      });
    }
    function Lv(a, s) {
      var v = a;
      xm(s), v._wrapperState = {
        wasMultiple: !!s.multiple
      }, s.value !== void 0 && s.defaultValue !== void 0 && !Bf && (l("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Bf = !0);
    }
    function ey(a, s) {
      var v = a;
      v.multiple = !!s.multiple;
      var _ = s.value;
      _ != null ? Xc(v, !!s.multiple, _, !1) : s.defaultValue != null && Xc(v, !!s.multiple, s.defaultValue, !0);
    }
    function _m(a, s) {
      var v = a, _ = v._wrapperState.wasMultiple;
      v._wrapperState.wasMultiple = !!s.multiple;
      var M = s.value;
      M != null ? Xc(v, !!s.multiple, M, !1) : _ !== !!s.multiple && (s.defaultValue != null ? Xc(v, !!s.multiple, s.defaultValue, !0) : Xc(v, !!s.multiple, s.multiple ? [] : "", !1));
    }
    function Em(a, s) {
      var v = a, _ = s.value;
      _ != null && Xc(v, !!s.multiple, _, !1);
    }
    var bm = !1;
    function Tm(a, s) {
      var v = a;
      if (s.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var _ = Tn({}, s, {
        value: void 0,
        defaultValue: void 0,
        children: Aa(v._wrapperState.initialValue)
      });
      return _;
    }
    function Ov(a, s) {
      var v = a;
      oc("textarea", s), s.value !== void 0 && s.defaultValue !== void 0 && !bm && (l("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", hs() || "A component"), bm = !0);
      var _ = s.value;
      if (_ == null) {
        var M = s.children, N = s.defaultValue;
        if (M != null) {
          l("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (N != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (oo(M)) {
              if (M.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              M = M[0];
            }
            N = M;
          }
        }
        N == null && (N = ""), _ = N;
      }
      v._wrapperState = {
        initialValue: Ru(_)
      };
    }
    function wm(a, s) {
      var v = a, _ = Ru(s.value), M = Ru(s.defaultValue);
      if (_ != null) {
        var N = Aa(_);
        N !== v.value && (v.value = N), s.defaultValue == null && v.defaultValue !== N && (v.defaultValue = N);
      }
      M != null && (v.defaultValue = Aa(M));
    }
    function Rd(a, s) {
      var v = a, _ = v.textContent;
      _ === v._wrapperState.initialValue && _ !== "" && _ !== null && (v.value = _);
    }
    function Hf(a, s) {
      wm(a, s);
    }
    var su = "http://www.w3.org/1999/xhtml", Mm = "http://www.w3.org/1998/Math/MathML", fl = "http://www.w3.org/2000/svg";
    function Is(a) {
      switch (a) {
        case "svg":
          return fl;
        case "math":
          return Mm;
        default:
          return su;
      }
    }
    function qc(a, s) {
      return a == null || a === su ? Is(s) : a === fl && s === "foreignObject" ? su : a;
    }
    var Kc = function(a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(s, v, _, M) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(s, v, _, M);
        });
      } : a;
    }, lu, Vf = Kc(function(a, s) {
      if (a.namespaceURI === fl && !("innerHTML" in a)) {
        lu = lu || document.createElement("div"), lu.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>";
        for (var v = lu.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; v.firstChild; )
          a.appendChild(v.firstChild);
        return;
      }
      a.innerHTML = s;
    }), Bs = 1, Lu = 3, Oa = 8, _a = 9, Ea = 11, Hi = function(a, s) {
      if (s) {
        var v = a.firstChild;
        if (v && v === a.lastChild && v.nodeType === Lu) {
          v.nodeValue = s;
          return;
        }
      }
      a.textContent = s;
    }, Ad = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Yo = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Cm(a, s) {
      return a + s.charAt(0).toUpperCase() + s.substring(1);
    }
    var Rm = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Yo).forEach(function(a) {
      Rm.forEach(function(s) {
        Yo[Cm(s, a)] = Yo[a];
      });
    });
    function Dd(a, s, v) {
      var _ = s == null || typeof s == "boolean" || s === "";
      return _ ? "" : !v && typeof s == "number" && s !== 0 && !(Yo.hasOwnProperty(a) && Yo[a]) ? s + "px" : (vt(s, a), ("" + s).trim());
    }
    var Qc = /([A-Z])/g, Pv = /^ms-/;
    function Sp(a) {
      return a.replace(Qc, "-$1").toLowerCase().replace(Pv, "-ms-");
    }
    var Ld = function() {
    };
    {
      var _h = /^(?:webkit|moz|o)[A-Z]/, Gf = /^-ms-/, Hs = /-(.)/g, Zc = /;\s*$/, uc = {}, Ou = {}, xp = !1, Od = !1, vs = function(a) {
        return a.replace(Hs, function(s, v) {
          return v.toUpperCase();
        });
      }, Pd = function(a) {
        uc.hasOwnProperty(a) && uc[a] || (uc[a] = !0, l(
          "Unsupported style property %s. Did you mean %s?",
          a,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          vs(a.replace(Gf, "ms-"))
        ));
      }, Jc = function(a) {
        uc.hasOwnProperty(a) && uc[a] || (uc[a] = !0, l("Unsupported vendor-prefixed style property %s. Did you mean %s?", a, a.charAt(0).toUpperCase() + a.slice(1)));
      }, uu = function(a, s) {
        Ou.hasOwnProperty(s) && Ou[s] || (Ou[s] = !0, l(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, a, s.replace(Zc, "")));
      }, _p = function(a, s) {
        xp || (xp = !0, l("`NaN` is an invalid value for the `%s` css style property.", a));
      }, Ud = function(a, s) {
        Od || (Od = !0, l("`Infinity` is an invalid value for the `%s` css style property.", a));
      };
      Ld = function(a, s) {
        a.indexOf("-") > -1 ? Pd(a) : _h.test(a) ? Jc(a) : Zc.test(s) && uu(a, s), typeof s == "number" && (isNaN(s) ? _p(a, s) : isFinite(s) || Ud(a, s));
      };
    }
    var Ep = Ld;
    function Ll(a) {
      {
        var s = "", v = "";
        for (var _ in a)
          if (a.hasOwnProperty(_)) {
            var M = a[_];
            if (M != null) {
              var N = _.indexOf("--") === 0;
              s += v + (N ? _ : Sp(_)) + ":", s += Dd(_, M, N), v = ";";
            }
          }
        return s || null;
      }
    }
    function ea(a, s) {
      var v = a.style;
      for (var _ in s)
        if (s.hasOwnProperty(_)) {
          var M = _.indexOf("--") === 0;
          M || Ep(_, s[_]);
          var N = Dd(_, s[_], M);
          _ === "float" && (_ = "cssFloat"), M ? v.setProperty(_, N) : v[_] = N;
        }
    }
    function Nd(a) {
      return a == null || typeof a == "boolean" || a === "";
    }
    function Pa(a) {
      var s = {};
      for (var v in a)
        for (var _ = Ad[v] || [v], M = 0; M < _.length; M++)
          s[_[M]] = v;
      return s;
    }
    function dl(a, s) {
      {
        if (!s)
          return;
        var v = Pa(a), _ = Pa(s), M = {};
        for (var N in v) {
          var G = v[N], q = _[N];
          if (q && G !== q) {
            var te = G + "," + q;
            if (M[te])
              continue;
            M[te] = !0, l("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Nd(a[G]) ? "Removing" : "Updating", G, q);
          }
        }
      }
    }
    var so = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, ki = Tn({
      menuitem: !0
    }, so), ef = "__html";
    function Kr(a, s) {
      if (s) {
        if (ki[a] && (s.children != null || s.dangerouslySetInnerHTML != null))
          throw new Error(a + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (s.dangerouslySetInnerHTML != null) {
          if (s.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof s.dangerouslySetInnerHTML != "object" || !(ef in s.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!s.suppressContentEditableWarning && s.contentEditable && s.children != null && l("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), s.style != null && typeof s.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function yi(a, s) {
      if (a.indexOf("-") === -1)
        return typeof s.is == "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Di = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Fd = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, lo = {}, Wf = new RegExp("^(aria)-[" + He + "]*$"), cc = new RegExp("^(aria)[A-Z][" + He + "]*$");
    function Qa(a, s) {
      {
        if (Ye.call(lo, s) && lo[s])
          return !0;
        if (cc.test(s)) {
          var v = "aria-" + s.slice(4).toLowerCase(), _ = Fd.hasOwnProperty(v) ? v : null;
          if (_ == null)
            return l("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", s), lo[s] = !0, !0;
          if (s !== _)
            return l("Invalid ARIA attribute `%s`. Did you mean `%s`?", s, _), lo[s] = !0, !0;
        }
        if (Wf.test(s)) {
          var M = s.toLowerCase(), N = Fd.hasOwnProperty(M) ? M : null;
          if (N == null)
            return lo[s] = !0, !1;
          if (s !== N)
            return l("Unknown ARIA attribute `%s`. Did you mean `%s`?", s, N), lo[s] = !0, !0;
        }
      }
      return !0;
    }
    function Ol(a, s) {
      {
        var v = [];
        for (var _ in s) {
          var M = Qa(a, _);
          M || v.push(_);
        }
        var N = v.map(function(G) {
          return "`" + G + "`";
        }).join(", ");
        v.length === 1 ? l("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", N, a) : v.length > 1 && l("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", N, a);
      }
    }
    function tf(a, s) {
      yi(a, s) || Ol(a, s);
    }
    var Pu = !1;
    function cu(a, s) {
      {
        if (a !== "input" && a !== "textarea" && a !== "select")
          return;
        s != null && s.value === null && !Pu && (Pu = !0, a === "select" && s.multiple ? l("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", a) : l("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", a));
      }
    }
    var Pl = function() {
    };
    {
      var Yi = {}, kd = /^on./, bp = /^on[^A-Z]/, jf = new RegExp("^(aria)-[" + He + "]*$"), Am = new RegExp("^(aria)[A-Z][" + He + "]*$");
      Pl = function(a, s, v, _) {
        if (Ye.call(Yi, s) && Yi[s])
          return !0;
        var M = s.toLowerCase();
        if (M === "onfocusin" || M === "onfocusout")
          return l("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Yi[s] = !0, !0;
        if (_ != null) {
          var N = _.registrationNameDependencies, G = _.possibleRegistrationNames;
          if (N.hasOwnProperty(s))
            return !0;
          var q = G.hasOwnProperty(M) ? G[M] : null;
          if (q != null)
            return l("Invalid event handler property `%s`. Did you mean `%s`?", s, q), Yi[s] = !0, !0;
          if (kd.test(s))
            return l("Unknown event handler property `%s`. It will be ignored.", s), Yi[s] = !0, !0;
        } else if (kd.test(s))
          return bp.test(s) && l("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", s), Yi[s] = !0, !0;
        if (jf.test(s) || Am.test(s))
          return !0;
        if (M === "innerhtml")
          return l("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Yi[s] = !0, !0;
        if (M === "aria")
          return l("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Yi[s] = !0, !0;
        if (M === "is" && v !== null && v !== void 0 && typeof v != "string")
          return l("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof v), Yi[s] = !0, !0;
        if (typeof v == "number" && isNaN(v))
          return l("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", s), Yi[s] = !0, !0;
        var te = Rt(s), ge = te !== null && te.type === ne;
        if (Di.hasOwnProperty(M)) {
          var Ee = Di[M];
          if (Ee !== s)
            return l("Invalid DOM property `%s`. Did you mean `%s`?", s, Ee), Yi[s] = !0, !0;
        } else if (!ge && s !== M)
          return l("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", s, M), Yi[s] = !0, !0;
        return typeof v == "boolean" && ct(s, v, te, !1) ? (v ? l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', v, s, s, v, s) : l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', v, s, s, v, s, s, s), Yi[s] = !0, !0) : ge ? !0 : ct(s, v, te, !1) ? (Yi[s] = !0, !1) : ((v === "false" || v === "true") && te !== null && te.type === ot && (l("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", v, s, v === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', s, v), Yi[s] = !0), !0);
      };
    }
    var mr = function(a, s, v) {
      {
        var _ = [];
        for (var M in s) {
          var N = Pl(a, M, s[M], v);
          N || _.push(M);
        }
        var G = _.map(function(q) {
          return "`" + q + "`";
        }).join(", ");
        _.length === 1 ? l("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", G, a) : _.length > 1 && l("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", G, a);
      }
    };
    function Li(a, s, v) {
      yi(a, s) || mr(a, s, v);
    }
    var Dr = 1, oa = 2, Uo = 4, Eh = Dr | oa | Uo, bh = null;
    function $f(a) {
      bh !== null && l("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), bh = a;
    }
    function Dm() {
      bh === null && l("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), bh = null;
    }
    function Th(a) {
      return a === bh;
    }
    function Yt(a) {
      var s = a.target || a.srcElement || window;
      return s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === Lu ? s.parentNode : s;
    }
    var Er = null, wr = null, Vs = null;
    function hl(a) {
      var s = ev(a);
      if (s) {
        if (typeof Er != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var v = s.stateNode;
        if (v) {
          var _ = cd(v);
          Er(s.stateNode, s.type, _);
        }
      }
    }
    function fc(a) {
      Er = a;
    }
    function Ul(a) {
      wr ? Vs ? Vs.push(a) : Vs = [a] : wr = a;
    }
    function dc() {
      return wr !== null || Vs !== null;
    }
    function hc() {
      if (wr) {
        var a = wr, s = Vs;
        if (wr = null, Vs = null, hl(a), s)
          for (var v = 0; v < s.length; v++)
            hl(s[v]);
      }
    }
    var fu = function(a, s) {
      return a(s);
    }, Tp = function() {
    }, wp = !1;
    function Lm() {
      var a = dc();
      a && (Tp(), hc());
    }
    function wh(a, s, v) {
      if (wp)
        return a(s, v);
      wp = !0;
      try {
        return fu(a, s, v);
      } finally {
        wp = !1, Lm();
      }
    }
    function zd(a, s, v) {
      fu = a, Tp = v;
    }
    function Id(a) {
      return a === "button" || a === "input" || a === "select" || a === "textarea";
    }
    function Yf(a, s, v) {
      switch (a) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(v.disabled && Id(s));
        default:
          return !1;
      }
    }
    function nf(a, s) {
      var v = a.stateNode;
      if (v === null)
        return null;
      var _ = cd(v);
      if (_ === null)
        return null;
      var M = _[s];
      if (Yf(s, a.type, _))
        return null;
      if (M && typeof M != "function")
        throw new Error("Expected `" + s + "` listener to be a function, instead got a value of `" + typeof M + "` type.");
      return M;
    }
    var Bd = !1;
    if (et)
      try {
        var rf = {};
        Object.defineProperty(rf, "passive", {
          get: function() {
            Bd = !0;
          }
        }), window.addEventListener("test", rf, rf), window.removeEventListener("test", rf, rf);
      } catch {
        Bd = !1;
      }
    function Mh(a, s, v, _, M, N, G, q, te) {
      var ge = Array.prototype.slice.call(arguments, 3);
      try {
        s.apply(v, ge);
      } catch (Ee) {
        this.onError(Ee);
      }
    }
    var Hd = Mh;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Mp = document.createElement("react");
      Hd = function(s, v, _, M, N, G, q, te, ge) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Ee = document.createEvent("Event"), Ke = !1, je = !0, Et = window.event, wt = Object.getOwnPropertyDescriptor(window, "event");
        function It() {
          Mp.removeEventListener(Bt, fr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Et);
        }
        var Dn = Array.prototype.slice.call(arguments, 3);
        function fr() {
          Ke = !0, It(), v.apply(_, Dn), je = !1;
        }
        var Jn, Ci = !1, vi = !1;
        function dt(ht) {
          if (Jn = ht.error, Ci = !0, Jn === null && ht.colno === 0 && ht.lineno === 0 && (vi = !0), ht.defaultPrevented && Jn != null && typeof Jn == "object")
            try {
              Jn._suppressLogging = !0;
            } catch {
            }
        }
        var Bt = "react-" + (s || "invokeguardedcallback");
        if (window.addEventListener("error", dt), Mp.addEventListener(Bt, fr, !1), Ee.initEvent(Bt, !1, !1), Mp.dispatchEvent(Ee), wt && Object.defineProperty(window, "event", wt), Ke && je && (Ci ? vi && (Jn = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Jn = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Jn)), window.removeEventListener("error", dt), !Ke)
          return It(), Mh.apply(this, arguments);
      };
    }
    var Om = Hd, Uu = !1, Gs = null, Nu = !1, Fu = null, Za = {
      onError: function(a) {
        Uu = !0, Gs = a;
      }
    };
    function pc(a, s, v, _, M, N, G, q, te) {
      Uu = !1, Gs = null, Om.apply(Za, arguments);
    }
    function Ws(a, s, v, _, M, N, G, q, te) {
      if (pc.apply(this, arguments), Uu) {
        var ge = Vd();
        Nu || (Nu = !0, Fu = ge);
      }
    }
    function Xf() {
      if (Nu) {
        var a = Fu;
        throw Nu = !1, Fu = null, a;
      }
    }
    function qf() {
      return Uu;
    }
    function Vd() {
      if (Uu) {
        var a = Gs;
        return Uu = !1, Gs = null, a;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Xo(a) {
      return a._reactInternals;
    }
    function js(a) {
      return a._reactInternals !== void 0;
    }
    function hi(a, s) {
      a._reactInternals = s;
    }
    var Xn = (
      /*                      */
      0
    ), pi = (
      /*                */
      1
    ), Nr = (
      /*                    */
      2
    ), In = (
      /*                       */
      4
    ), Zr = (
      /*                */
      16
    ), ui = (
      /*                 */
      32
    ), ku = (
      /*                     */
      64
    ), hr = (
      /*                   */
      128
    ), ba = (
      /*            */
      256
    ), gs = (
      /*                          */
      512
    ), $s = (
      /*                     */
      1024
    ), ta = (
      /*                      */
      2048
    ), Ys = (
      /*                    */
      4096
    ), mc = (
      /*                   */
      8192
    ), Kf = (
      /*             */
      16384
    ), vc = ta | In | ku | gs | $s | Kf, Uv = (
      /*               */
      32767
    ), ys = (
      /*                   */
      32768
    ), xo = (
      /*                */
      65536
    ), Ch = (
      /* */
      131072
    ), du = (
      /*                       */
      1048576
    ), Qf = (
      /*                    */
      2097152
    ), Ua = (
      /*                 */
      4194304
    ), zu = (
      /*                */
      8388608
    ), ci = (
      /*               */
      16777216
    ), hu = (
      /*              */
      33554432
    ), gr = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      In | $s | 0
    ), uo = Nr | In | Zr | ui | gs | Ys | mc, Ta = In | ku | gs | mc, Iu = ta | Zr, nn = Ua | zu | Qf, pl = t.ReactCurrentOwner;
    function _o(a) {
      var s = a, v = a;
      if (a.alternate)
        for (; s.return; )
          s = s.return;
      else {
        var _ = s;
        do
          s = _, (s.flags & (Nr | Ys)) !== Xn && (v = s.return), _ = s.return;
        while (_);
      }
      return s.tag === x ? v : null;
    }
    function Pm(a) {
      if (a.tag === B) {
        var s = a.memoizedState;
        if (s === null) {
          var v = a.alternate;
          v !== null && (s = v.memoizedState);
        }
        if (s !== null)
          return s.dehydrated;
      }
      return null;
    }
    function Cp(a) {
      return a.tag === x ? a.stateNode.containerInfo : null;
    }
    function af(a) {
      return _o(a) === a;
    }
    function Eo(a) {
      {
        var s = pl.current;
        if (s !== null && s.tag === p) {
          var v = s, _ = v.stateNode;
          _._warnedAboutRefsInRender || l("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", nr(v) || "A component"), _._warnedAboutRefsInRender = !0;
        }
      }
      var M = Xo(a);
      return M ? _o(M) === M : !1;
    }
    function Ss(a) {
      if (_o(a) !== a)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Xi(a) {
      var s = a.alternate;
      if (!s) {
        var v = _o(a);
        if (v === null)
          throw new Error("Unable to find node on an unmounted component.");
        return v !== a ? null : a;
      }
      for (var _ = a, M = s; ; ) {
        var N = _.return;
        if (N === null)
          break;
        var G = N.alternate;
        if (G === null) {
          var q = N.return;
          if (q !== null) {
            _ = M = q;
            continue;
          }
          break;
        }
        if (N.child === G.child) {
          for (var te = N.child; te; ) {
            if (te === _)
              return Ss(N), a;
            if (te === M)
              return Ss(N), s;
            te = te.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (_.return !== M.return)
          _ = N, M = G;
        else {
          for (var ge = !1, Ee = N.child; Ee; ) {
            if (Ee === _) {
              ge = !0, _ = N, M = G;
              break;
            }
            if (Ee === M) {
              ge = !0, M = N, _ = G;
              break;
            }
            Ee = Ee.sibling;
          }
          if (!ge) {
            for (Ee = G.child; Ee; ) {
              if (Ee === _) {
                ge = !0, _ = G, M = N;
                break;
              }
              if (Ee === M) {
                ge = !0, M = G, _ = N;
                break;
              }
              Ee = Ee.sibling;
            }
            if (!ge)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (_.alternate !== M)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (_.tag !== x)
        throw new Error("Unable to find node on an unmounted component.");
      return _.stateNode.current === _ ? a : s;
    }
    function ml(a) {
      var s = Xi(a);
      return s !== null ? Nl(s) : null;
    }
    function Nl(a) {
      if (a.tag === w || a.tag === R)
        return a;
      for (var s = a.child; s !== null; ) {
        var v = Nl(s);
        if (v !== null)
          return v;
        s = s.sibling;
      }
      return null;
    }
    function Gd(a) {
      var s = Xi(a);
      return s !== null ? of(s) : null;
    }
    function of(a) {
      if (a.tag === w || a.tag === R)
        return a;
      for (var s = a.child; s !== null; ) {
        if (s.tag !== b) {
          var v = of(s);
          if (v !== null)
            return v;
        }
        s = s.sibling;
      }
      return null;
    }
    var Wd = e.unstable_scheduleCallback, Zf = e.unstable_cancelCallback, xs = e.unstable_shouldYield, co = e.unstable_requestPaint, sa = e.unstable_now, Rh = e.unstable_getCurrentPriorityLevel, Um = e.unstable_ImmediatePriority, vl = e.unstable_UserBlockingPriority, pu = e.unstable_NormalPriority, Ah = e.unstable_LowPriority, sf = e.unstable_IdlePriority, Nm = e.unstable_yieldValue, Dh = e.unstable_setDisableYieldValue, Vi = null, ha = null, un = null, zi = !1, Na = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Rp(a) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var s = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (s.isDisabled)
        return !0;
      if (!s.supportsFiber)
        return l("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ae && (a = Tn({}, a, {
          getLaneLabelMap: gc,
          injectProfilingHooks: Fa
        })), Vi = s.inject(a), ha = s;
      } catch (v) {
        l("React instrumentation encountered an error: %s.", v);
      }
      return !!s.checkDCE;
    }
    function Fm(a, s) {
      if (ha && typeof ha.onScheduleFiberRoot == "function")
        try {
          ha.onScheduleFiberRoot(Vi, a, s);
        } catch (v) {
          zi || (zi = !0, l("React instrumentation encountered an error: %s", v));
        }
    }
    function _s(a, s) {
      if (ha && typeof ha.onCommitFiberRoot == "function")
        try {
          var v = (a.current.flags & hr) === hr;
          if (Ue) {
            var _;
            switch (s) {
              case bs:
                _ = Um;
                break;
              case Qo:
                _ = vl;
                break;
              case yf:
                _ = pu;
                break;
              case Dp:
                _ = sf;
                break;
              default:
                _ = pu;
                break;
            }
            ha.onCommitFiberRoot(Vi, a, _, v);
          }
        } catch (M) {
          zi || (zi = !0, l("React instrumentation encountered an error: %s", M));
        }
    }
    function pa(a) {
      if (ha && typeof ha.onPostCommitFiberRoot == "function")
        try {
          ha.onPostCommitFiberRoot(Vi, a);
        } catch (s) {
          zi || (zi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function dn(a) {
      if (ha && typeof ha.onCommitFiberUnmount == "function")
        try {
          ha.onCommitFiberUnmount(Vi, a);
        } catch (s) {
          zi || (zi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function Gi(a) {
      if (typeof Nm == "function" && (Dh(a), i(a)), ha && typeof ha.setStrictMode == "function")
        try {
          ha.setStrictMode(Vi, a);
        } catch (s) {
          zi || (zi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function Fa(a) {
      un = a;
    }
    function gc() {
      {
        for (var a = /* @__PURE__ */ new Map(), s = 1, v = 0; v < ni; v++) {
          var _ = ty(s);
          a.set(s, _), s *= 2;
        }
        return a;
      }
    }
    function ma(a) {
      un !== null && typeof un.markCommitStarted == "function" && un.markCommitStarted(a);
    }
    function Lr() {
      un !== null && typeof un.markCommitStopped == "function" && un.markCommitStopped();
    }
    function qi(a) {
      un !== null && typeof un.markComponentRenderStarted == "function" && un.markComponentRenderStarted(a);
    }
    function na() {
      un !== null && typeof un.markComponentRenderStopped == "function" && un.markComponentRenderStopped();
    }
    function ti(a) {
      un !== null && typeof un.markComponentPassiveEffectMountStarted == "function" && un.markComponentPassiveEffectMountStarted(a);
    }
    function Xs() {
      un !== null && typeof un.markComponentPassiveEffectMountStopped == "function" && un.markComponentPassiveEffectMountStopped();
    }
    function lf(a) {
      un !== null && typeof un.markComponentPassiveEffectUnmountStarted == "function" && un.markComponentPassiveEffectUnmountStarted(a);
    }
    function fo() {
      un !== null && typeof un.markComponentPassiveEffectUnmountStopped == "function" && un.markComponentPassiveEffectUnmountStopped();
    }
    function jd(a) {
      un !== null && typeof un.markComponentLayoutEffectMountStarted == "function" && un.markComponentLayoutEffectMountStarted(a);
    }
    function Bu() {
      un !== null && typeof un.markComponentLayoutEffectMountStopped == "function" && un.markComponentLayoutEffectMountStopped();
    }
    function mu(a) {
      un !== null && typeof un.markComponentLayoutEffectUnmountStarted == "function" && un.markComponentLayoutEffectUnmountStarted(a);
    }
    function Jf() {
      un !== null && typeof un.markComponentLayoutEffectUnmountStopped == "function" && un.markComponentLayoutEffectUnmountStopped();
    }
    function ed(a, s, v) {
      un !== null && typeof un.markComponentErrored == "function" && un.markComponentErrored(a, s, v);
    }
    function qs(a, s, v) {
      un !== null && typeof un.markComponentSuspended == "function" && un.markComponentSuspended(a, s, v);
    }
    function km(a) {
      un !== null && typeof un.markLayoutEffectsStarted == "function" && un.markLayoutEffectsStarted(a);
    }
    function td() {
      un !== null && typeof un.markLayoutEffectsStopped == "function" && un.markLayoutEffectsStopped();
    }
    function $d(a) {
      un !== null && typeof un.markPassiveEffectsStarted == "function" && un.markPassiveEffectsStarted(a);
    }
    function uf() {
      un !== null && typeof un.markPassiveEffectsStopped == "function" && un.markPassiveEffectsStopped();
    }
    function gl(a) {
      un !== null && typeof un.markRenderStarted == "function" && un.markRenderStarted(a);
    }
    function vu() {
      un !== null && typeof un.markRenderYielded == "function" && un.markRenderYielded();
    }
    function cf() {
      un !== null && typeof un.markRenderStopped == "function" && un.markRenderStopped();
    }
    function yl(a) {
      un !== null && typeof un.markRenderScheduled == "function" && un.markRenderScheduled(a);
    }
    function Lh(a, s) {
      un !== null && typeof un.markForceUpdateScheduled == "function" && un.markForceUpdateScheduled(a, s);
    }
    function gu(a, s) {
      un !== null && typeof un.markStateUpdateScheduled == "function" && un.markStateUpdateScheduled(a, s);
    }
    var qn = (
      /*                         */
      0
    ), Cr = (
      /*                 */
      1
    ), Kn = (
      /*                    */
      2
    ), jr = (
      /*               */
      8
    ), bo = (
      /*              */
      16
    ), Ks = Math.clz32 ? Math.clz32 : To, ff = Math.log, Es = Math.LN2;
    function To(a) {
      var s = a >>> 0;
      return s === 0 ? 32 : 31 - (ff(s) / Es | 0) | 0;
    }
    var ni = 31, Nt = (
      /*                        */
      0
    ), Qr = (
      /*                          */
      0
    ), Hn = (
      /*                        */
      1
    ), Hu = (
      /*    */
      2
    ), Qs = (
      /*             */
      4
    ), No = (
      /*            */
      8
    ), Si = (
      /*                     */
      16
    ), nd = (
      /*                */
      32
    ), df = (
      /*                       */
      4194240
    ), hf = (
      /*                        */
      64
    ), Fo = (
      /*                        */
      128
    ), Sl = (
      /*                        */
      256
    ), rd = (
      /*                        */
      512
    ), Yd = (
      /*                        */
      1024
    ), qo = (
      /*                        */
      2048
    ), xl = (
      /*                        */
      4096
    ), zm = (
      /*                        */
      8192
    ), yc = (
      /*                        */
      16384
    ), ho = (
      /*                       */
      32768
    ), fi = (
      /*                       */
      65536
    ), Fl = (
      /*                       */
      131072
    ), Zs = (
      /*                       */
      262144
    ), Im = (
      /*                       */
      524288
    ), kl = (
      /*                       */
      1048576
    ), pf = (
      /*                       */
      2097152
    ), yu = (
      /*                            */
      130023424
    ), zl = (
      /*                             */
      4194304
    ), wo = (
      /*                             */
      8388608
    ), Vu = (
      /*                             */
      16777216
    ), id = (
      /*                             */
      33554432
    ), Ko = (
      /*                             */
      67108864
    ), mf = zl, Il = (
      /*          */
      134217728
    ), ad = (
      /*                          */
      268435455
    ), vf = (
      /*               */
      268435456
    ), Su = (
      /*                        */
      536870912
    ), _l = (
      /*                   */
      1073741824
    );
    function ty(a) {
      {
        if (a & Hn)
          return "Sync";
        if (a & Hu)
          return "InputContinuousHydration";
        if (a & Qs)
          return "InputContinuous";
        if (a & No)
          return "DefaultHydration";
        if (a & Si)
          return "Default";
        if (a & nd)
          return "TransitionHydration";
        if (a & df)
          return "Transition";
        if (a & yu)
          return "Retry";
        if (a & Il)
          return "SelectiveHydration";
        if (a & vf)
          return "IdleHydration";
        if (a & Su)
          return "Idle";
        if (a & _l)
          return "Offscreen";
      }
    }
    var $r = -1, od = hf, gf = zl;
    function Gu(a) {
      switch (hn(a)) {
        case Hn:
          return Hn;
        case Hu:
          return Hu;
        case Qs:
          return Qs;
        case No:
          return No;
        case Si:
          return Si;
        case nd:
          return nd;
        case hf:
        case Fo:
        case Sl:
        case rd:
        case Yd:
        case qo:
        case xl:
        case zm:
        case yc:
        case ho:
        case fi:
        case Fl:
        case Zs:
        case Im:
        case kl:
        case pf:
          return a & df;
        case zl:
        case wo:
        case Vu:
        case id:
        case Ko:
          return a & yu;
        case Il:
          return Il;
        case vf:
          return vf;
        case Su:
          return Su;
        case _l:
          return _l;
        default:
          return l("Should have found matching lanes. This is a bug in React."), a;
      }
    }
    function Sc(a, s) {
      var v = a.pendingLanes;
      if (v === Nt)
        return Nt;
      var _ = Nt, M = a.suspendedLanes, N = a.pingedLanes, G = v & ad;
      if (G !== Nt) {
        var q = G & ~M;
        if (q !== Nt)
          _ = Gu(q);
        else {
          var te = G & N;
          te !== Nt && (_ = Gu(te));
        }
      } else {
        var ge = v & ~M;
        ge !== Nt ? _ = Gu(ge) : N !== Nt && (_ = Gu(N));
      }
      if (_ === Nt)
        return Nt;
      if (s !== Nt && s !== _ && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (s & M) === Nt) {
        var Ee = hn(_), Ke = hn(s);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Ee >= Ke || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Ee === Si && (Ke & df) !== Nt
        )
          return s;
      }
      (_ & Qs) !== Nt && (_ |= v & Si);
      var je = a.entangledLanes;
      if (je !== Nt)
        for (var Et = a.entanglements, wt = _ & je; wt > 0; ) {
          var It = ka(wt), Dn = 1 << It;
          _ |= Et[It], wt &= ~Dn;
        }
      return _;
    }
    function Bm(a, s) {
      for (var v = a.eventTimes, _ = $r; s > 0; ) {
        var M = ka(s), N = 1 << M, G = v[M];
        G > _ && (_ = G), s &= ~N;
      }
      return _;
    }
    function g(a, s) {
      switch (a) {
        case Hn:
        case Hu:
        case Qs:
          return s + 250;
        case No:
        case Si:
        case nd:
        case hf:
        case Fo:
        case Sl:
        case rd:
        case Yd:
        case qo:
        case xl:
        case zm:
        case yc:
        case ho:
        case fi:
        case Fl:
        case Zs:
        case Im:
        case kl:
        case pf:
          return s + 5e3;
        case zl:
        case wo:
        case Vu:
        case id:
        case Ko:
          return $r;
        case Il:
        case vf:
        case Su:
        case _l:
          return $r;
        default:
          return l("Should have found matching lanes. This is a bug in React."), $r;
      }
    }
    function S(a, s) {
      for (var v = a.pendingLanes, _ = a.suspendedLanes, M = a.pingedLanes, N = a.expirationTimes, G = v; G > 0; ) {
        var q = ka(G), te = 1 << q, ge = N[q];
        ge === $r ? ((te & _) === Nt || (te & M) !== Nt) && (N[q] = g(te, s)) : ge <= s && (a.expiredLanes |= te), G &= ~te;
      }
    }
    function D(a) {
      return Gu(a.pendingLanes);
    }
    function z(a) {
      var s = a.pendingLanes & ~_l;
      return s !== Nt ? s : s & _l ? _l : Nt;
    }
    function W(a) {
      return (a & Hn) !== Nt;
    }
    function Z(a) {
      return (a & ad) !== Nt;
    }
    function we(a) {
      return (a & yu) === a;
    }
    function Qe(a) {
      var s = Hn | Qs | Si;
      return (a & s) === Nt;
    }
    function Ot(a) {
      return (a & df) === a;
    }
    function Jt(a, s) {
      var v = Hu | Qs | No | Si;
      return (s & v) !== Nt;
    }
    function ln(a, s) {
      return (s & a.expiredLanes) !== Nt;
    }
    function cr(a) {
      return (a & df) !== Nt;
    }
    function Qn() {
      var a = od;
      return od <<= 1, (od & df) === Nt && (od = hf), a;
    }
    function Ki() {
      var a = gf;
      return gf <<= 1, (gf & yu) === Nt && (gf = zl), a;
    }
    function hn(a) {
      return a & -a;
    }
    function ri(a) {
      return hn(a);
    }
    function ka(a) {
      return 31 - Ks(a);
    }
    function mt(a) {
      return ka(a);
    }
    function We(a, s) {
      return (a & s) !== Nt;
    }
    function Mt(a, s) {
      return (a & s) === s;
    }
    function Vt(a, s) {
      return a | s;
    }
    function An(a, s) {
      return a & ~s;
    }
    function Rr(a, s) {
      return a & s;
    }
    function or(a) {
      return a;
    }
    function Fr(a, s) {
      return a !== Qr && a < s ? a : s;
    }
    function va(a) {
      for (var s = [], v = 0; v < ni; v++)
        s.push(a);
      return s;
    }
    function kr(a, s, v) {
      a.pendingLanes |= s, s !== Su && (a.suspendedLanes = Nt, a.pingedLanes = Nt);
      var _ = a.eventTimes, M = mt(s);
      _[M] = v;
    }
    function xc(a, s) {
      a.suspendedLanes |= s, a.pingedLanes &= ~s;
      for (var v = a.expirationTimes, _ = s; _ > 0; ) {
        var M = ka(_), N = 1 << M;
        v[M] = $r, _ &= ~N;
      }
    }
    function Oh(a, s, v) {
      a.pingedLanes |= a.suspendedLanes & s;
    }
    function L0(a, s) {
      var v = a.pendingLanes & ~s;
      a.pendingLanes = s, a.suspendedLanes = Nt, a.pingedLanes = Nt, a.expiredLanes &= s, a.mutableReadLanes &= s, a.entangledLanes &= s;
      for (var _ = a.entanglements, M = a.eventTimes, N = a.expirationTimes, G = v; G > 0; ) {
        var q = ka(G), te = 1 << q;
        _[q] = Nt, M[q] = $r, N[q] = $r, G &= ~te;
      }
    }
    function Ap(a, s) {
      for (var v = a.entangledLanes |= s, _ = a.entanglements, M = v; M; ) {
        var N = ka(M), G = 1 << N;
        // Is this one of the newly entangled lanes?
        G & s | // Is this lane transitively entangled with the newly entangled lanes?
        _[N] & s && (_[N] |= s), M &= ~G;
      }
    }
    function ny(a, s) {
      var v = hn(s), _;
      switch (v) {
        case Qs:
          _ = Hu;
          break;
        case Si:
          _ = No;
          break;
        case hf:
        case Fo:
        case Sl:
        case rd:
        case Yd:
        case qo:
        case xl:
        case zm:
        case yc:
        case ho:
        case fi:
        case Fl:
        case Zs:
        case Im:
        case kl:
        case pf:
        case zl:
        case wo:
        case Vu:
        case id:
        case Ko:
          _ = nd;
          break;
        case Su:
          _ = vf;
          break;
        default:
          _ = Qr;
          break;
      }
      return (_ & (a.suspendedLanes | s)) !== Qr ? Qr : _;
    }
    function ry(a, s, v) {
      if (Na)
        for (var _ = a.pendingUpdatersLaneMap; v > 0; ) {
          var M = mt(v), N = 1 << M, G = _[M];
          G.add(s), v &= ~N;
        }
    }
    function Hm(a, s) {
      if (Na)
        for (var v = a.pendingUpdatersLaneMap, _ = a.memoizedUpdaters; s > 0; ) {
          var M = mt(s), N = 1 << M, G = v[M];
          G.size > 0 && (G.forEach(function(q) {
            var te = q.alternate;
            (te === null || !_.has(te)) && _.add(q);
          }), G.clear()), s &= ~N;
        }
    }
    function iy(a, s) {
      return null;
    }
    var bs = Hn, Qo = Qs, yf = Si, Dp = Su, Xd = Qr;
    function Wu() {
      return Xd;
    }
    function po(a) {
      Xd = a;
    }
    function Lp(a, s) {
      var v = Xd;
      try {
        return Xd = a, s();
      } finally {
        Xd = v;
      }
    }
    function Ts(a, s) {
      return a !== 0 && a < s ? a : s;
    }
    function O0(a, s) {
      return a === 0 || a > s ? a : s;
    }
    function ay(a, s) {
      return a !== 0 && a < s;
    }
    function Op(a) {
      var s = hn(a);
      return ay(bs, s) ? ay(Qo, s) ? Z(s) ? yf : Dp : Qo : bs;
    }
    function Mo(a) {
      var s = a.current.memoizedState;
      return s.isDehydrated;
    }
    var P0;
    function On(a) {
      P0 = a;
    }
    function Pp(a) {
      P0(a);
    }
    var Vm;
    function Dx(a) {
      Vm = a;
    }
    var U0;
    function Up(a) {
      U0 = a;
    }
    var Nv;
    function N0(a) {
      Nv = a;
    }
    var Ph;
    function Np(a) {
      Ph = a;
    }
    var Fp = !1, qd = [], Co = null, mi = null, za = null, ko = /* @__PURE__ */ new Map(), xu = /* @__PURE__ */ new Map(), Kd = [], Sf = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Lx(a) {
      return Sf.indexOf(a) > -1;
    }
    function El(a, s, v, _, M) {
      return {
        blockedOn: a,
        domEventName: s,
        eventSystemFlags: v,
        nativeEvent: M,
        targetContainers: [_]
      };
    }
    function F0(a, s) {
      switch (a) {
        case "focusin":
        case "focusout":
          Co = null;
          break;
        case "dragenter":
        case "dragleave":
          mi = null;
          break;
        case "mouseover":
        case "mouseout":
          za = null;
          break;
        case "pointerover":
        case "pointerout": {
          var v = s.pointerId;
          ko.delete(v);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var _ = s.pointerId;
          xu.delete(_);
          break;
        }
      }
    }
    function Uh(a, s, v, _, M, N) {
      if (a === null || a.nativeEvent !== N) {
        var G = El(s, v, _, M, N);
        if (s !== null) {
          var q = ev(s);
          q !== null && Vm(q);
        }
        return G;
      }
      a.eventSystemFlags |= _;
      var te = a.targetContainers;
      return M !== null && te.indexOf(M) === -1 && te.push(M), a;
    }
    function Fv(a, s, v, _, M) {
      switch (s) {
        case "focusin": {
          var N = M;
          return Co = Uh(Co, a, s, v, _, N), !0;
        }
        case "dragenter": {
          var G = M;
          return mi = Uh(mi, a, s, v, _, G), !0;
        }
        case "mouseover": {
          var q = M;
          return za = Uh(za, a, s, v, _, q), !0;
        }
        case "pointerover": {
          var te = M, ge = te.pointerId;
          return ko.set(ge, Uh(ko.get(ge) || null, a, s, v, _, te)), !0;
        }
        case "gotpointercapture": {
          var Ee = M, Ke = Ee.pointerId;
          return xu.set(Ke, Uh(xu.get(Ke) || null, a, s, v, _, Ee)), !0;
        }
      }
      return !1;
    }
    function k0(a) {
      var s = ig(a.target);
      if (s !== null) {
        var v = _o(s);
        if (v !== null) {
          var _ = v.tag;
          if (_ === B) {
            var M = Pm(v);
            if (M !== null) {
              a.blockedOn = M, Ph(a.priority, function() {
                U0(v);
              });
              return;
            }
          } else if (_ === x) {
            var N = v.stateNode;
            if (Mo(N)) {
              a.blockedOn = Cp(v);
              return;
            }
          }
        }
      }
      a.blockedOn = null;
    }
    function oy(a) {
      for (var s = Nv(), v = {
        blockedOn: null,
        target: a,
        priority: s
      }, _ = 0; _ < Kd.length && ay(s, Kd[_].priority); _++)
        ;
      Kd.splice(_, 0, v), _ === 0 && k0(v);
    }
    function sy(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var s = a.targetContainers; s.length > 0; ) {
        var v = s[0], _ = Fh(a.domEventName, a.eventSystemFlags, v, a.nativeEvent);
        if (_ === null) {
          var M = a.nativeEvent, N = new M.constructor(M.type, M);
          $f(N), M.target.dispatchEvent(N), Dm();
        } else {
          var G = ev(_);
          return G !== null && Vm(G), a.blockedOn = _, !1;
        }
        s.shift();
      }
      return !0;
    }
    function kv(a, s, v) {
      sy(a) && v.delete(s);
    }
    function Qd() {
      Fp = !1, Co !== null && sy(Co) && (Co = null), mi !== null && sy(mi) && (mi = null), za !== null && sy(za) && (za = null), ko.forEach(kv), xu.forEach(kv);
    }
    function Oi(a, s) {
      a.blockedOn === s && (a.blockedOn = null, Fp || (Fp = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Qd)));
    }
    function yr(a) {
      if (qd.length > 0) {
        Oi(qd[0], a);
        for (var s = 1; s < qd.length; s++) {
          var v = qd[s];
          v.blockedOn === a && (v.blockedOn = null);
        }
      }
      Co !== null && Oi(Co, a), mi !== null && Oi(mi, a), za !== null && Oi(za, a);
      var _ = function(q) {
        return Oi(q, a);
      };
      ko.forEach(_), xu.forEach(_);
      for (var M = 0; M < Kd.length; M++) {
        var N = Kd[M];
        N.blockedOn === a && (N.blockedOn = null);
      }
      for (; Kd.length > 0; ) {
        var G = Kd[0];
        if (G.blockedOn !== null)
          break;
        k0(G), G.blockedOn === null && Kd.shift();
      }
    }
    var wi = t.ReactCurrentBatchConfig, ra = !0;
    function wa(a) {
      ra = !!a;
    }
    function ju() {
      return ra;
    }
    function Gm(a, s, v) {
      var _ = bl(s), M;
      switch (_) {
        case bs:
          M = Zo;
          break;
        case Qo:
          M = zv;
          break;
        case yf:
        default:
          M = sd;
          break;
      }
      return M.bind(null, s, v, a);
    }
    function Zo(a, s, v, _) {
      var M = Wu(), N = wi.transition;
      wi.transition = null;
      try {
        po(bs), sd(a, s, v, _);
      } finally {
        po(M), wi.transition = N;
      }
    }
    function zv(a, s, v, _) {
      var M = Wu(), N = wi.transition;
      wi.transition = null;
      try {
        po(Qo), sd(a, s, v, _);
      } finally {
        po(M), wi.transition = N;
      }
    }
    function sd(a, s, v, _) {
      ra && Iv(a, s, v, _);
    }
    function Iv(a, s, v, _) {
      var M = Fh(a, s, v, _);
      if (M === null) {
        Sr(a, s, _, Nh, v), F0(a, _);
        return;
      }
      if (Fv(M, a, s, v, _)) {
        _.stopPropagation();
        return;
      }
      if (F0(a, _), s & Uo && Lx(a)) {
        for (; M !== null; ) {
          var N = ev(M);
          N !== null && Pp(N);
          var G = Fh(a, s, v, _);
          if (G === null && Sr(a, s, _, Nh, v), G === M)
            break;
          M = G;
        }
        M !== null && _.stopPropagation();
        return;
      }
      Sr(a, s, _, null, v);
    }
    var Nh = null;
    function Fh(a, s, v, _) {
      Nh = null;
      var M = Yt(_), N = ig(M);
      if (N !== null) {
        var G = _o(N);
        if (G === null)
          N = null;
        else {
          var q = G.tag;
          if (q === B) {
            var te = Pm(G);
            if (te !== null)
              return te;
            N = null;
          } else if (q === x) {
            var ge = G.stateNode;
            if (Mo(ge))
              return Cp(G);
            N = null;
          } else
            G !== N && (N = null);
        }
      }
      return Nh = N, null;
    }
    function bl(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return bs;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Qo;
        case "message": {
          var s = Rh();
          switch (s) {
            case Um:
              return bs;
            case vl:
              return Qo;
            case pu:
            case Ah:
              return yf;
            case sf:
              return Dp;
            default:
              return yf;
          }
        }
        default:
          return yf;
      }
    }
    function Bv(a, s, v) {
      return a.addEventListener(s, v, !1), v;
    }
    function kh(a, s, v) {
      return a.addEventListener(s, v, !0), v;
    }
    function xf(a, s, v, _) {
      return a.addEventListener(s, v, {
        capture: !0,
        passive: _
      }), v;
    }
    function ly(a, s, v, _) {
      return a.addEventListener(s, v, {
        passive: _
      }), v;
    }
    var kp = null, ld = null, zh = null;
    function Zd(a) {
      return kp = a, ld = Hv(), !0;
    }
    function Ih() {
      kp = null, ld = null, zh = null;
    }
    function Wm() {
      if (zh)
        return zh;
      var a, s = ld, v = s.length, _, M = Hv(), N = M.length;
      for (a = 0; a < v && s[a] === M[a]; a++)
        ;
      var G = v - a;
      for (_ = 1; _ <= G && s[v - _] === M[N - _]; _++)
        ;
      var q = _ > 1 ? 1 - _ : void 0;
      return zh = M.slice(a, q), zh;
    }
    function Hv() {
      return "value" in kp ? kp.value : kp.textContent;
    }
    function _c(a) {
      var s, v = a.keyCode;
      return "charCode" in a ? (s = a.charCode, s === 0 && v === 13 && (s = 13)) : s = v, s === 10 && (s = 13), s >= 32 || s === 13 ? s : 0;
    }
    function Bh() {
      return !0;
    }
    function Ii() {
      return !1;
    }
    function mo(a) {
      function s(v, _, M, N, G) {
        this._reactName = v, this._targetInst = M, this.type = _, this.nativeEvent = N, this.target = G, this.currentTarget = null;
        for (var q in a)
          if (a.hasOwnProperty(q)) {
            var te = a[q];
            te ? this[q] = te(N) : this[q] = N[q];
          }
        var ge = N.defaultPrevented != null ? N.defaultPrevented : N.returnValue === !1;
        return ge ? this.isDefaultPrevented = Bh : this.isDefaultPrevented = Ii, this.isPropagationStopped = Ii, this;
      }
      return Tn(s.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          v && (v.preventDefault ? v.preventDefault() : typeof v.returnValue != "unknown" && (v.returnValue = !1), this.isDefaultPrevented = Bh);
        },
        stopPropagation: function() {
          var v = this.nativeEvent;
          v && (v.stopPropagation ? v.stopPropagation() : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0), this.isPropagationStopped = Bh);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Bh
      }), s;
    }
    var ws = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(a) {
        return a.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Ms = mo(ws), Hh = Tn({}, ws, {
      view: 0,
      detail: 0
    }), Vv = mo(Hh), zp, uy, Tl;
    function Gv(a) {
      a !== Tl && (Tl && a.type === "mousemove" ? (zp = a.screenX - Tl.screenX, uy = a.screenY - Tl.screenY) : (zp = 0, uy = 0), Tl = a);
    }
    var Jd = Tn({}, Hh, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: dy,
      button: 0,
      buttons: 0,
      relatedTarget: function(a) {
        return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      },
      movementX: function(a) {
        return "movementX" in a ? a.movementX : (Gv(a), zp);
      },
      movementY: function(a) {
        return "movementY" in a ? a.movementY : uy;
      }
    }), eh = mo(Jd), cy = Tn({}, Jd, {
      dataTransfer: 0
    }), Ec = mo(cy), z0 = Tn({}, Hh, {
      relatedTarget: 0
    }), fy = mo(z0), I0 = Tn({}, ws, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Vh = mo(I0), Gh = Tn({}, ws, {
      clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      }
    }), Wv = mo(Gh), jv = Tn({}, ws, {
      data: 0
    }), jm = mo(jv), th = jm, B0 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, _f = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function $m(a) {
      if (a.key) {
        var s = B0[a.key] || a.key;
        if (s !== "Unidentified")
          return s;
      }
      if (a.type === "keypress") {
        var v = _c(a);
        return v === 13 ? "Enter" : String.fromCharCode(v);
      }
      return a.type === "keydown" || a.type === "keyup" ? _f[a.keyCode] || "Unidentified" : "";
    }
    var Ja = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function H0(a) {
      var s = this, v = s.nativeEvent;
      if (v.getModifierState)
        return v.getModifierState(a);
      var _ = Ja[a];
      return _ ? !!v[_] : !1;
    }
    function dy(a) {
      return H0;
    }
    var Ox = Tn({}, Hh, {
      key: $m,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: dy,
      // Legacy Interface
      charCode: function(a) {
        return a.type === "keypress" ? _c(a) : 0;
      },
      keyCode: function(a) {
        return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      },
      which: function(a) {
        return a.type === "keypress" ? _c(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
      }
    }), Px = mo(Ox), Ym = Tn({}, Jd, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), $u = mo(Ym), V0 = Tn({}, Hh, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: dy
    }), Js = mo(V0), $v = Tn({}, ws, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), hE = mo($v), Bl = Tn({}, Jd, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in a ? -a.wheelDeltaX : 0
        );
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in a ? -a.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in a ? -a.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), nh = mo(Bl), Ip = [9, 13, 27, 32], Wh = 229, _u = et && "CompositionEvent" in window, Qi = null;
    et && "documentMode" in document && (Qi = document.documentMode);
    var jh = et && "TextEvent" in window && !Qi, Ia = et && (!_u || Qi && Qi > 8 && Qi <= 11), Cs = 32, Yv = String.fromCharCode(Cs);
    function hy() {
      rt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), rt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), rt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), rt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Xv = !1;
    function gn(a) {
      return (a.ctrlKey || a.altKey || a.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(a.ctrlKey && a.altKey);
    }
    function Hl(a) {
      switch (a) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function qv(a, s) {
      return a === "keydown" && s.keyCode === Wh;
    }
    function Bp(a, s) {
      switch (a) {
        case "keyup":
          return Ip.indexOf(s.keyCode) !== -1;
        case "keydown":
          return s.keyCode !== Wh;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function $h(a) {
      var s = a.detail;
      return typeof s == "object" && "data" in s ? s.data : null;
    }
    function Bi(a) {
      return a.locale === "ko";
    }
    var Ba = !1;
    function Ro(a, s, v, _, M) {
      var N, G;
      if (_u ? N = Hl(s) : Ba ? Bp(s, _) && (N = "onCompositionEnd") : qv(s, _) && (N = "onCompositionStart"), !N)
        return null;
      Ia && !Bi(_) && (!Ba && N === "onCompositionStart" ? Ba = Zd(M) : N === "onCompositionEnd" && Ba && (G = Wm()));
      var q = eg(v, N);
      if (q.length > 0) {
        var te = new jm(N, s, null, _, M);
        if (a.push({
          event: te,
          listeners: q
        }), G)
          te.data = G;
        else {
          var ge = $h(_);
          ge !== null && (te.data = ge);
        }
      }
    }
    function Hp(a, s) {
      switch (a) {
        case "compositionend":
          return $h(s);
        case "keypress":
          var v = s.which;
          return v !== Cs ? null : (Xv = !0, Yv);
        case "textInput":
          var _ = s.data;
          return _ === Yv && Xv ? null : _;
        default:
          return null;
      }
    }
    function Xm(a, s) {
      if (Ba) {
        if (a === "compositionend" || !_u && Bp(a, s)) {
          var v = Wm();
          return Ih(), Ba = !1, v;
        }
        return null;
      }
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!gn(s)) {
            if (s.char && s.char.length > 1)
              return s.char;
            if (s.which)
              return String.fromCharCode(s.which);
          }
          return null;
        case "compositionend":
          return Ia && !Bi(s) ? null : s.data;
        default:
          return null;
      }
    }
    function Kv(a, s, v, _, M) {
      var N;
      if (jh ? N = Hp(s, _) : N = Xm(s, _), !N)
        return null;
      var G = eg(v, "onBeforeInput");
      if (G.length > 0) {
        var q = new th("onBeforeInput", "beforeinput", null, _, M);
        a.push({
          event: q,
          listeners: G
        }), q.data = N;
      }
    }
    function py(a, s, v, _, M, N, G) {
      Ro(a, s, v, _, M), Kv(a, s, v, _, M);
    }
    var pE = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function kt(a) {
      var s = a && a.nodeName && a.nodeName.toLowerCase();
      return s === "input" ? !!pE[a.type] : s === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function bc(a) {
      if (!et)
        return !1;
      var s = "on" + a, v = s in document;
      if (!v) {
        var _ = document.createElement("div");
        _.setAttribute(s, "return;"), v = typeof _[s] == "function";
      }
      return v;
    }
    function Ef() {
      rt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function f(a, s, v, _) {
      Ul(_);
      var M = eg(s, "onChange");
      if (M.length > 0) {
        var N = new Ms("onChange", "change", null, v, _);
        a.push({
          event: N,
          listeners: M
        });
      }
    }
    var m = null, E = null;
    function O(a) {
      var s = a.nodeName && a.nodeName.toLowerCase();
      return s === "select" || s === "input" && a.type === "file";
    }
    function I(a) {
      var s = [];
      f(s, E, a, Yt(a)), wh(j, s);
    }
    function j(a) {
      EE(a, 0);
    }
    function ue(a) {
      var s = tl(a);
      if (Au(s))
        return a;
    }
    function Re(a, s) {
      if (a === "change")
        return s;
    }
    var Ie = !1;
    et && (Ie = bc("input") && (!document.documentMode || document.documentMode > 9));
    function Tt(a, s) {
      m = a, E = s, m.attachEvent("onpropertychange", Xt);
    }
    function Kt() {
      m && (m.detachEvent("onpropertychange", Xt), m = null, E = null);
    }
    function Xt(a) {
      a.propertyName === "value" && ue(E) && I(a);
    }
    function $t(a, s, v) {
      a === "focusin" ? (Kt(), Tt(s, v)) : a === "focusout" && Kt();
    }
    function bn(a, s) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return ue(E);
    }
    function Pn(a) {
      var s = a.nodeName;
      return s && s.toLowerCase() === "input" && (a.type === "checkbox" || a.type === "radio");
    }
    function Fn(a, s) {
      if (a === "click")
        return ue(s);
    }
    function eo(a, s) {
      if (a === "input" || a === "change")
        return ue(s);
    }
    function st(a) {
      var s = a._wrapperState;
      !s || !s.controlled || a.type !== "number" || ou(a, "number", a.value);
    }
    function Xe(a, s, v, _, M, N, G) {
      var q = v ? tl(v) : window, te, ge;
      if (O(q) ? te = Re : kt(q) ? Ie ? te = eo : (te = bn, ge = $t) : Pn(q) && (te = Fn), te) {
        var Ee = te(s, v);
        if (Ee) {
          f(a, Ee, _, M);
          return;
        }
      }
      ge && ge(s, q, v), s === "focusout" && st(q);
    }
    function gt() {
      ae("onMouseEnter", ["mouseout", "mouseover"]), ae("onMouseLeave", ["mouseout", "mouseover"]), ae("onPointerEnter", ["pointerout", "pointerover"]), ae("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function an(a, s, v, _, M, N, G) {
      var q = s === "mouseover" || s === "pointerover", te = s === "mouseout" || s === "pointerout";
      if (q && !Th(_)) {
        var ge = _.relatedTarget || _.fromElement;
        if (ge && (ig(ge) || sS(ge)))
          return;
      }
      if (!(!te && !q)) {
        var Ee;
        if (M.window === M)
          Ee = M;
        else {
          var Ke = M.ownerDocument;
          Ke ? Ee = Ke.defaultView || Ke.parentWindow : Ee = window;
        }
        var je, Et;
        if (te) {
          var wt = _.relatedTarget || _.toElement;
          if (je = v, Et = wt ? ig(wt) : null, Et !== null) {
            var It = _o(Et);
            (Et !== It || Et.tag !== w && Et.tag !== R) && (Et = null);
          }
        } else
          je = null, Et = v;
        if (je !== Et) {
          var Dn = eh, fr = "onMouseLeave", Jn = "onMouseEnter", Ci = "mouse";
          (s === "pointerout" || s === "pointerover") && (Dn = $u, fr = "onPointerLeave", Jn = "onPointerEnter", Ci = "pointer");
          var vi = je == null ? Ee : tl(je), dt = Et == null ? Ee : tl(Et), Bt = new Dn(fr, Ci + "leave", je, _, M);
          Bt.target = vi, Bt.relatedTarget = dt;
          var ht = null, tn = ig(M);
          if (tn === v) {
            var Ln = new Dn(Jn, Ci + "enter", Et, _, M);
            Ln.target = dt, Ln.relatedTarget = vi, ht = Ln;
          }
          Kx(a, Bt, ht, je, Et);
        }
      }
    }
    function kn(a, s) {
      return a === s && (a !== 0 || 1 / a === 1 / s) || a !== a && s !== s;
    }
    var Un = typeof Object.is == "function" ? Object.is : kn;
    function Zn(a, s) {
      if (Un(a, s))
        return !0;
      if (typeof a != "object" || a === null || typeof s != "object" || s === null)
        return !1;
      var v = Object.keys(a), _ = Object.keys(s);
      if (v.length !== _.length)
        return !1;
      for (var M = 0; M < v.length; M++) {
        var N = v[M];
        if (!Ye.call(s, N) || !Un(a[N], s[N]))
          return !1;
      }
      return !0;
    }
    function vr(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Jo(a) {
      for (; a; ) {
        if (a.nextSibling)
          return a.nextSibling;
        a = a.parentNode;
      }
    }
    function xi(a, s) {
      for (var v = vr(a), _ = 0, M = 0; v; ) {
        if (v.nodeType === Lu) {
          if (M = _ + v.textContent.length, _ <= s && M >= s)
            return {
              node: v,
              offset: s - _
            };
          _ = M;
        }
        v = vr(Jo(v));
      }
    }
    function Tc(a) {
      var s = a.ownerDocument, v = s && s.defaultView || window, _ = v.getSelection && v.getSelection();
      if (!_ || _.rangeCount === 0)
        return null;
      var M = _.anchorNode, N = _.anchorOffset, G = _.focusNode, q = _.focusOffset;
      try {
        M.nodeType, G.nodeType;
      } catch {
        return null;
      }
      return my(a, M, N, G, q);
    }
    function my(a, s, v, _, M) {
      var N = 0, G = -1, q = -1, te = 0, ge = 0, Ee = a, Ke = null;
      e:
        for (; ; ) {
          for (var je = null; Ee === s && (v === 0 || Ee.nodeType === Lu) && (G = N + v), Ee === _ && (M === 0 || Ee.nodeType === Lu) && (q = N + M), Ee.nodeType === Lu && (N += Ee.nodeValue.length), (je = Ee.firstChild) !== null; )
            Ke = Ee, Ee = je;
          for (; ; ) {
            if (Ee === a)
              break e;
            if (Ke === s && ++te === v && (G = N), Ke === _ && ++ge === M && (q = N), (je = Ee.nextSibling) !== null)
              break;
            Ee = Ke, Ke = Ee.parentNode;
          }
          Ee = je;
        }
      return G === -1 || q === -1 ? null : {
        start: G,
        end: q
      };
    }
    function Ux(a, s) {
      var v = a.ownerDocument || document, _ = v && v.defaultView || window;
      if (_.getSelection) {
        var M = _.getSelection(), N = a.textContent.length, G = Math.min(s.start, N), q = s.end === void 0 ? G : Math.min(s.end, N);
        if (!M.extend && G > q) {
          var te = q;
          q = G, G = te;
        }
        var ge = xi(a, G), Ee = xi(a, q);
        if (ge && Ee) {
          if (M.rangeCount === 1 && M.anchorNode === ge.node && M.anchorOffset === ge.offset && M.focusNode === Ee.node && M.focusOffset === Ee.offset)
            return;
          var Ke = v.createRange();
          Ke.setStart(ge.node, ge.offset), M.removeAllRanges(), G > q ? (M.addRange(Ke), M.extend(Ee.node, Ee.offset)) : (Ke.setEnd(Ee.node, Ee.offset), M.addRange(Ke));
        }
      }
    }
    function vy(a) {
      return a && a.nodeType === Lu;
    }
    function Nx(a, s) {
      return !a || !s ? !1 : a === s ? !0 : vy(a) ? !1 : vy(s) ? Nx(a, s.parentNode) : "contains" in a ? a.contains(s) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(s) & 16) : !1;
    }
    function Fx(a) {
      return a && a.ownerDocument && Nx(a.ownerDocument.documentElement, a);
    }
    function G0(a) {
      try {
        return typeof a.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function W0() {
      for (var a = window, s = Fs(); s instanceof a.HTMLIFrameElement; ) {
        if (G0(s))
          a = s.contentWindow;
        else
          return s;
        s = Fs(a.document);
      }
      return s;
    }
    function Qv(a) {
      var s = a && a.nodeName && a.nodeName.toLowerCase();
      return s && (s === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || s === "textarea" || a.contentEditable === "true");
    }
    function Zv() {
      var a = W0();
      return {
        focusedElem: a,
        selectionRange: Qv(a) ? kx(a) : null
      };
    }
    function mE(a) {
      var s = W0(), v = a.focusedElem, _ = a.selectionRange;
      if (s !== v && Fx(v)) {
        _ !== null && Qv(v) && vE(v, _);
        for (var M = [], N = v; N = N.parentNode; )
          N.nodeType === Bs && M.push({
            element: N,
            left: N.scrollLeft,
            top: N.scrollTop
          });
        typeof v.focus == "function" && v.focus();
        for (var G = 0; G < M.length; G++) {
          var q = M[G];
          q.element.scrollLeft = q.left, q.element.scrollTop = q.top;
        }
      }
    }
    function kx(a) {
      var s;
      return "selectionStart" in a ? s = {
        start: a.selectionStart,
        end: a.selectionEnd
      } : s = Tc(a), s || {
        start: 0,
        end: 0
      };
    }
    function vE(a, s) {
      var v = s.start, _ = s.end;
      _ === void 0 && (_ = v), "selectionStart" in a ? (a.selectionStart = v, a.selectionEnd = Math.min(_, a.value.length)) : Ux(a, s);
    }
    var zx = et && "documentMode" in document && document.documentMode <= 11;
    function bw() {
      rt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var qm = null, gy = null, j0 = null, yy = !1;
    function gE(a) {
      if ("selectionStart" in a && Qv(a))
        return {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      var s = a.ownerDocument && a.ownerDocument.defaultView || window, v = s.getSelection();
      return {
        anchorNode: v.anchorNode,
        anchorOffset: v.anchorOffset,
        focusNode: v.focusNode,
        focusOffset: v.focusOffset
      };
    }
    function Ix(a) {
      return a.window === a ? a.document : a.nodeType === _a ? a : a.ownerDocument;
    }
    function Bx(a, s, v) {
      var _ = Ix(v);
      if (!(yy || qm == null || qm !== Fs(_))) {
        var M = gE(qm);
        if (!j0 || !Zn(j0, M)) {
          j0 = M;
          var N = eg(gy, "onSelect");
          if (N.length > 0) {
            var G = new Ms("onSelect", "select", null, s, v);
            a.push({
              event: G,
              listeners: N
            }), G.target = qm;
          }
        }
      }
    }
    function Hx(a, s, v, _, M, N, G) {
      var q = v ? tl(v) : window;
      switch (s) {
        case "focusin":
          (kt(q) || q.contentEditable === "true") && (qm = q, gy = v, j0 = null);
          break;
        case "focusout":
          qm = null, gy = null, j0 = null;
          break;
        case "mousedown":
          yy = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          yy = !1, Bx(a, _, M);
          break;
        case "selectionchange":
          if (zx)
            break;
        case "keydown":
        case "keyup":
          Bx(a, _, M);
      }
    }
    function Sy(a, s) {
      var v = {};
      return v[a.toLowerCase()] = s.toLowerCase(), v["Webkit" + a] = "webkit" + s, v["Moz" + a] = "moz" + s, v;
    }
    var Jv = {
      animationend: Sy("Animation", "AnimationEnd"),
      animationiteration: Sy("Animation", "AnimationIteration"),
      animationstart: Sy("Animation", "AnimationStart"),
      transitionend: Sy("Transition", "TransitionEnd")
    }, Vx = {}, Tw = {};
    et && (Tw = document.createElement("div").style, "AnimationEvent" in window || (delete Jv.animationend.animation, delete Jv.animationiteration.animation, delete Jv.animationstart.animation), "TransitionEvent" in window || delete Jv.transitionend.transition);
    function xy(a) {
      if (Vx[a])
        return Vx[a];
      if (!Jv[a])
        return a;
      var s = Jv[a];
      for (var v in s)
        if (s.hasOwnProperty(v) && v in Tw)
          return Vx[a] = s[v];
      return a;
    }
    var yE = xy("animationend"), SE = xy("animationiteration"), xE = xy("animationstart"), ww = xy("transitionend"), Gx = /* @__PURE__ */ new Map(), $0 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Km(a, s) {
      Gx.set(a, s), rt(s, [a]);
    }
    function O2() {
      for (var a = 0; a < $0.length; a++) {
        var s = $0[a], v = s.toLowerCase(), _ = s[0].toUpperCase() + s.slice(1);
        Km(v, "on" + _);
      }
      Km(yE, "onAnimationEnd"), Km(SE, "onAnimationIteration"), Km(xE, "onAnimationStart"), Km("dblclick", "onDoubleClick"), Km("focusin", "onFocus"), Km("focusout", "onBlur"), Km(ww, "onTransitionEnd");
    }
    function Mw(a, s, v, _, M, N, G) {
      var q = Gx.get(s);
      if (q !== void 0) {
        var te = Ms, ge = s;
        switch (s) {
          case "keypress":
            if (_c(_) === 0)
              return;
          case "keydown":
          case "keyup":
            te = Px;
            break;
          case "focusin":
            ge = "focus", te = fy;
            break;
          case "focusout":
            ge = "blur", te = fy;
            break;
          case "beforeblur":
          case "afterblur":
            te = fy;
            break;
          case "click":
            if (_.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            te = eh;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            te = Ec;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            te = Js;
            break;
          case yE:
          case SE:
          case xE:
            te = Vh;
            break;
          case ww:
            te = hE;
            break;
          case "scroll":
            te = Vv;
            break;
          case "wheel":
            te = nh;
            break;
          case "copy":
          case "cut":
          case "paste":
            te = Wv;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            te = $u;
            break;
        }
        var Ee = (N & Uo) !== 0;
        {
          var Ke = !Ee && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          s === "scroll", je = Aw(v, q, _.type, Ee, Ke);
          if (je.length > 0) {
            var Et = new te(q, ge, null, _, M);
            a.push({
              event: Et,
              listeners: je
            });
          }
        }
      }
    }
    O2(), gt(), Ef(), bw(), hy();
    function Cw(a, s, v, _, M, N, G) {
      Mw(a, s, v, _, M, N);
      var q = (N & Eh) === 0;
      q && (an(a, s, v, _, M), Xe(a, s, v, _, M), Hx(a, s, v, _, M), py(a, s, v, _, M));
    }
    var _y = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Wx = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(_y));
    function _E(a, s, v) {
      var _ = a.type || "unknown-event";
      a.currentTarget = v, Ws(_, s, void 0, a), a.currentTarget = null;
    }
    function jx(a, s, v) {
      var _;
      if (v)
        for (var M = s.length - 1; M >= 0; M--) {
          var N = s[M], G = N.instance, q = N.currentTarget, te = N.listener;
          if (G !== _ && a.isPropagationStopped())
            return;
          _E(a, te, q), _ = G;
        }
      else
        for (var ge = 0; ge < s.length; ge++) {
          var Ee = s[ge], Ke = Ee.instance, je = Ee.currentTarget, Et = Ee.listener;
          if (Ke !== _ && a.isPropagationStopped())
            return;
          _E(a, Et, je), _ = Ke;
        }
    }
    function EE(a, s) {
      for (var v = (s & Uo) !== 0, _ = 0; _ < a.length; _++) {
        var M = a[_], N = M.event, G = M.listeners;
        jx(N, G, v);
      }
      Xf();
    }
    function Rw(a, s, v, _, M) {
      var N = Yt(v), G = [];
      Cw(G, a, _, v, N, s), EE(G, s);
    }
    function Ha(a, s) {
      Wx.has(a) || l('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', a);
      var v = !1, _ = oA(s), M = Dw(a, v);
      _.has(M) || (Y0(s, a, oa, v), _.add(M));
    }
    function $x(a, s, v) {
      Wx.has(a) && !s && l('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', a);
      var _ = 0;
      s && (_ |= Uo), Y0(v, a, _, s);
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function Yu(a) {
      if (!a[bf]) {
        a[bf] = !0, ke.forEach(function(v) {
          v !== "selectionchange" && (Wx.has(v) || $x(v, !1, a), $x(v, !0, a));
        });
        var s = a.nodeType === _a ? a : a.ownerDocument;
        s !== null && (s[bf] || (s[bf] = !0, $x("selectionchange", !1, s)));
      }
    }
    function Y0(a, s, v, _, M) {
      var N = Gm(a, s, v), G = void 0;
      Bd && (s === "touchstart" || s === "touchmove" || s === "wheel") && (G = !0), a = a, _ ? G !== void 0 ? xf(a, s, N, G) : kh(a, s, N) : G !== void 0 ? ly(a, s, N, G) : Bv(a, s, N);
    }
    function Yx(a, s) {
      return a === s || a.nodeType === Oa && a.parentNode === s;
    }
    function Sr(a, s, v, _, M) {
      var N = _;
      if (!(s & Dr) && !(s & oa)) {
        var G = M;
        if (_ !== null) {
          var q = _;
          e:
            for (; ; ) {
              if (q === null)
                return;
              var te = q.tag;
              if (te === x || te === b) {
                var ge = q.stateNode.containerInfo;
                if (Yx(ge, G))
                  break;
                if (te === b)
                  for (var Ee = q.return; Ee !== null; ) {
                    var Ke = Ee.tag;
                    if (Ke === x || Ke === b) {
                      var je = Ee.stateNode.containerInfo;
                      if (Yx(je, G))
                        return;
                    }
                    Ee = Ee.return;
                  }
                for (; ge !== null; ) {
                  var Et = ig(ge);
                  if (Et === null)
                    return;
                  var wt = Et.tag;
                  if (wt === w || wt === R) {
                    q = N = Et;
                    continue e;
                  }
                  ge = ge.parentNode;
                }
              }
              q = q.return;
            }
        }
      }
      wh(function() {
        return Rw(a, s, v, N);
      });
    }
    function ud(a, s, v) {
      return {
        instance: a,
        listener: s,
        currentTarget: v
      };
    }
    function Aw(a, s, v, _, M, N) {
      for (var G = s !== null ? s + "Capture" : null, q = _ ? G : s, te = [], ge = a, Ee = null; ge !== null; ) {
        var Ke = ge, je = Ke.stateNode, Et = Ke.tag;
        if (Et === w && je !== null && (Ee = je, q !== null)) {
          var wt = nf(ge, q);
          wt != null && te.push(ud(ge, wt, Ee));
        }
        if (M)
          break;
        ge = ge.return;
      }
      return te;
    }
    function eg(a, s) {
      for (var v = s + "Capture", _ = [], M = a; M !== null; ) {
        var N = M, G = N.stateNode, q = N.tag;
        if (q === w && G !== null) {
          var te = G, ge = nf(M, v);
          ge != null && _.unshift(ud(M, ge, te));
          var Ee = nf(M, s);
          Ee != null && _.push(ud(M, Ee, te));
        }
        M = M.return;
      }
      return _;
    }
    function Yh(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== w);
      return a || null;
    }
    function Xx(a, s) {
      for (var v = a, _ = s, M = 0, N = v; N; N = Yh(N))
        M++;
      for (var G = 0, q = _; q; q = Yh(q))
        G++;
      for (; M - G > 0; )
        v = Yh(v), M--;
      for (; G - M > 0; )
        _ = Yh(_), G--;
      for (var te = M; te--; ) {
        if (v === _ || _ !== null && v === _.alternate)
          return v;
        v = Yh(v), _ = Yh(_);
      }
      return null;
    }
    function qx(a, s, v, _, M) {
      for (var N = s._reactName, G = [], q = v; q !== null && q !== _; ) {
        var te = q, ge = te.alternate, Ee = te.stateNode, Ke = te.tag;
        if (ge !== null && ge === _)
          break;
        if (Ke === w && Ee !== null) {
          var je = Ee;
          if (M) {
            var Et = nf(q, N);
            Et != null && G.unshift(ud(q, Et, je));
          } else if (!M) {
            var wt = nf(q, N);
            wt != null && G.push(ud(q, wt, je));
          }
        }
        q = q.return;
      }
      G.length !== 0 && a.push({
        event: s,
        listeners: G
      });
    }
    function Kx(a, s, v, _, M) {
      var N = _ && M ? Xx(_, M) : null;
      _ !== null && qx(a, s, _, N, !1), M !== null && v !== null && qx(a, v, M, N, !0);
    }
    function Dw(a, s) {
      return a + "__" + (s ? "capture" : "bubble");
    }
    var wc = !1, X0 = "dangerouslySetInnerHTML", Qx = "suppressContentEditableWarning", Vp = "suppressHydrationWarning", bE = "autoFocus", Gp = "children", Qm = "style", tg = "__html", Mc, Ey, Eu, Zx, by, q0, Lw;
    Mc = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Ey = function(a, s) {
      tf(a, s), cu(a, s), Li(a, s, {
        registrationNameDependencies: it,
        possibleRegistrationNames: At
      });
    }, q0 = et && !document.documentMode, Eu = function(a, s, v) {
      if (!wc) {
        var _ = K0(v), M = K0(s);
        M !== _ && (wc = !0, l("Prop `%s` did not match. Server: %s Client: %s", a, JSON.stringify(M), JSON.stringify(_)));
      }
    }, Zx = function(a) {
      if (!wc) {
        wc = !0;
        var s = [];
        a.forEach(function(v) {
          s.push(v);
        }), l("Extra attributes from the server: %s", s);
      }
    }, by = function(a, s) {
      s === !1 ? l("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", a, a, a) : l("Expected `%s` listener to be a function, instead got a value of `%s` type.", a, typeof s);
    }, Lw = function(a, s) {
      var v = a.namespaceURI === su ? a.ownerDocument.createElement(a.tagName) : a.ownerDocument.createElementNS(a.namespaceURI, a.tagName);
      return v.innerHTML = s, v.innerHTML;
    };
    var TE = /\r\n?/g, P2 = /\u0000|\uFFFD/g;
    function K0(a) {
      Zt(a);
      var s = typeof a == "string" ? a : "" + a;
      return s.replace(TE, `
`).replace(P2, "");
    }
    function Ty(a, s, v, _) {
      var M = K0(s), N = K0(a);
      if (N !== M && (_ && (wc || (wc = !0, l('Text content did not match. Server: "%s" Client: "%s"', N, M))), v && Pe))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function wE(a) {
      return a.nodeType === _a ? a : a.ownerDocument;
    }
    function U2() {
    }
    function Jx(a) {
      a.onclick = U2;
    }
    function Ow(a, s, v, _, M) {
      for (var N in _)
        if (_.hasOwnProperty(N)) {
          var G = _[N];
          if (N === Qm)
            G && Object.freeze(G), ea(s, G);
          else if (N === X0) {
            var q = G ? G[tg] : void 0;
            q != null && Vf(s, q);
          } else if (N === Gp)
            if (typeof G == "string") {
              var te = a !== "textarea" || G !== "";
              te && Hi(s, G);
            } else
              typeof G == "number" && Hi(s, "" + G);
          else
            N === Qx || N === Vp || N === bE || (it.hasOwnProperty(N) ? G != null && (typeof G != "function" && by(N, G), N === "onScroll" && Ha("scroll", s)) : G != null && Wr(s, N, G, M));
        }
    }
    function Pw(a, s, v, _) {
      for (var M = 0; M < s.length; M += 2) {
        var N = s[M], G = s[M + 1];
        N === Qm ? ea(a, G) : N === X0 ? Vf(a, G) : N === Gp ? Hi(a, G) : Wr(a, N, G, _);
      }
    }
    function N2(a, s, v, _) {
      var M, N = wE(v), G, q = _;
      if (q === su && (q = Is(a)), q === su) {
        if (M = yi(a, s), !M && a !== a.toLowerCase() && l("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", a), a === "script") {
          var te = N.createElement("div");
          te.innerHTML = "<script><\/script>";
          var ge = te.firstChild;
          G = te.removeChild(ge);
        } else if (typeof s.is == "string")
          G = N.createElement(a, {
            is: s.is
          });
        else if (G = N.createElement(a), a === "select") {
          var Ee = G;
          s.multiple ? Ee.multiple = !0 : s.size && (Ee.size = s.size);
        }
      } else
        G = N.createElementNS(q, a);
      return q === su && !M && Object.prototype.toString.call(G) === "[object HTMLUnknownElement]" && !Ye.call(Mc, a) && (Mc[a] = !0, l("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", a)), G;
    }
    function F2(a, s) {
      return wE(s).createTextNode(a);
    }
    function Xh(a, s, v, _) {
      var M = yi(s, v);
      Ey(s, v);
      var N;
      switch (s) {
        case "dialog":
          Ha("cancel", a), Ha("close", a), N = v;
          break;
        case "iframe":
        case "object":
        case "embed":
          Ha("load", a), N = v;
          break;
        case "video":
        case "audio":
          for (var G = 0; G < _y.length; G++)
            Ha(_y[G], a);
          N = v;
          break;
        case "source":
          Ha("error", a), N = v;
          break;
        case "img":
        case "image":
        case "link":
          Ha("error", a), Ha("load", a), N = v;
          break;
        case "details":
          Ha("toggle", a), N = v;
          break;
        case "input":
          So(a, v), N = Du(a, v), Ha("invalid", a);
          break;
        case "option":
          da(a, v), N = v;
          break;
        case "select":
          Lv(a, v), N = xh(a, v), Ha("invalid", a);
          break;
        case "textarea":
          Ov(a, v), N = Tm(a, v), Ha("invalid", a);
          break;
        default:
          N = v;
      }
      switch (Kr(s, N), Ow(s, a, _, N, M), s) {
        case "input":
          qa(a), zs(a, v, !1);
          break;
        case "textarea":
          qa(a), Rd(a);
          break;
        case "option":
          ms(a, v);
          break;
        case "select":
          ey(a, v);
          break;
        default:
          typeof N.onClick == "function" && Jx(a);
          break;
      }
    }
    function Uw(a, s, v, _, M) {
      Ey(s, _);
      var N = null, G, q;
      switch (s) {
        case "input":
          G = Du(a, v), q = Du(a, _), N = [];
          break;
        case "select":
          G = xh(a, v), q = xh(a, _), N = [];
          break;
        case "textarea":
          G = Tm(a, v), q = Tm(a, _), N = [];
          break;
        default:
          G = v, q = _, typeof G.onClick != "function" && typeof q.onClick == "function" && Jx(a);
          break;
      }
      Kr(s, q);
      var te, ge, Ee = null;
      for (te in G)
        if (!(q.hasOwnProperty(te) || !G.hasOwnProperty(te) || G[te] == null))
          if (te === Qm) {
            var Ke = G[te];
            for (ge in Ke)
              Ke.hasOwnProperty(ge) && (Ee || (Ee = {}), Ee[ge] = "");
          } else
            te === X0 || te === Gp || te === Qx || te === Vp || te === bE || (it.hasOwnProperty(te) ? N || (N = []) : (N = N || []).push(te, null));
      for (te in q) {
        var je = q[te], Et = G != null ? G[te] : void 0;
        if (!(!q.hasOwnProperty(te) || je === Et || je == null && Et == null))
          if (te === Qm)
            if (je && Object.freeze(je), Et) {
              for (ge in Et)
                Et.hasOwnProperty(ge) && (!je || !je.hasOwnProperty(ge)) && (Ee || (Ee = {}), Ee[ge] = "");
              for (ge in je)
                je.hasOwnProperty(ge) && Et[ge] !== je[ge] && (Ee || (Ee = {}), Ee[ge] = je[ge]);
            } else
              Ee || (N || (N = []), N.push(te, Ee)), Ee = je;
          else if (te === X0) {
            var wt = je ? je[tg] : void 0, It = Et ? Et[tg] : void 0;
            wt != null && It !== wt && (N = N || []).push(te, wt);
          } else
            te === Gp ? (typeof je == "string" || typeof je == "number") && (N = N || []).push(te, "" + je) : te === Qx || te === Vp || (it.hasOwnProperty(te) ? (je != null && (typeof je != "function" && by(te, je), te === "onScroll" && Ha("scroll", a)), !N && Et !== je && (N = [])) : (N = N || []).push(te, je));
      }
      return Ee && (dl(Ee, q[Qm]), (N = N || []).push(Qm, Ee)), N;
    }
    function Nw(a, s, v, _, M) {
      v === "input" && M.type === "radio" && M.name != null && Ka(a, M);
      var N = yi(v, _), G = yi(v, M);
      switch (Pw(a, s, N, G), v) {
        case "input":
          au(a, M);
          break;
        case "textarea":
          wm(a, M);
          break;
        case "select":
          _m(a, M);
          break;
      }
    }
    function Q0(a) {
      {
        var s = a.toLowerCase();
        return Di.hasOwnProperty(s) && Di[s] || null;
      }
    }
    function Z0(a, s, v, _, M, N, G) {
      var q, te;
      switch (q = yi(s, v), Ey(s, v), s) {
        case "dialog":
          Ha("cancel", a), Ha("close", a);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ha("load", a);
          break;
        case "video":
        case "audio":
          for (var ge = 0; ge < _y.length; ge++)
            Ha(_y[ge], a);
          break;
        case "source":
          Ha("error", a);
          break;
        case "img":
        case "image":
        case "link":
          Ha("error", a), Ha("load", a);
          break;
        case "details":
          Ha("toggle", a);
          break;
        case "input":
          So(a, v), Ha("invalid", a);
          break;
        case "option":
          da(a, v);
          break;
        case "select":
          Lv(a, v), Ha("invalid", a);
          break;
        case "textarea":
          Ov(a, v), Ha("invalid", a);
          break;
      }
      Kr(s, v);
      {
        te = /* @__PURE__ */ new Set();
        for (var Ee = a.attributes, Ke = 0; Ke < Ee.length; Ke++) {
          var je = Ee[Ke].name.toLowerCase();
          switch (je) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              te.add(Ee[Ke].name);
          }
        }
      }
      var Et = null;
      for (var wt in v)
        if (v.hasOwnProperty(wt)) {
          var It = v[wt];
          if (wt === Gp)
            typeof It == "string" ? a.textContent !== It && (v[Vp] !== !0 && Ty(a.textContent, It, N, G), Et = [Gp, It]) : typeof It == "number" && a.textContent !== "" + It && (v[Vp] !== !0 && Ty(a.textContent, It, N, G), Et = [Gp, "" + It]);
          else if (it.hasOwnProperty(wt))
            It != null && (typeof It != "function" && by(wt, It), wt === "onScroll" && Ha("scroll", a));
          else if (G && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof q == "boolean") {
            var Dn = void 0, fr = q && Me ? null : Rt(wt);
            if (v[Vp] !== !0) {
              if (!(wt === Qx || wt === Vp || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              wt === "value" || wt === "checked" || wt === "selected")) {
                if (wt === X0) {
                  var Jn = a.innerHTML, Ci = It ? It[tg] : void 0;
                  if (Ci != null) {
                    var vi = Lw(a, Ci);
                    vi !== Jn && Eu(wt, Jn, vi);
                  }
                } else if (wt === Qm) {
                  if (te.delete(wt), q0) {
                    var dt = Ll(It);
                    Dn = a.getAttribute("style"), dt !== Dn && Eu(wt, Dn, dt);
                  }
                } else if (q && !Me)
                  te.delete(wt.toLowerCase()), Dn = Ei(a, wt, It), It !== Dn && Eu(wt, Dn, It);
                else if (!Ze(wt, fr, q) && !pe(wt, It, fr, q)) {
                  var Bt = !1;
                  if (fr !== null)
                    te.delete(fr.attributeName), Dn = Wn(a, wt, It, fr);
                  else {
                    var ht = _;
                    if (ht === su && (ht = Is(s)), ht === su)
                      te.delete(wt.toLowerCase());
                    else {
                      var tn = Q0(wt);
                      tn !== null && tn !== wt && (Bt = !0, te.delete(tn)), te.delete(wt);
                    }
                    Dn = Ei(a, wt, It);
                  }
                  var Ln = Me;
                  !Ln && It !== Dn && !Bt && Eu(wt, Dn, It);
                }
              }
            }
          }
        }
      switch (G && // $FlowFixMe - Should be inferred as not undefined.
      te.size > 0 && v[Vp] !== !0 && Zx(te), s) {
        case "input":
          qa(a), zs(a, v, !0);
          break;
        case "textarea":
          qa(a), Rd(a);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof v.onClick == "function" && Jx(a);
          break;
      }
      return Et;
    }
    function e_(a, s, v) {
      var _ = a.nodeValue !== s;
      return _;
    }
    function wy(a, s) {
      {
        if (wc)
          return;
        wc = !0, l("Did not expect server HTML to contain a <%s> in <%s>.", s.nodeName.toLowerCase(), a.nodeName.toLowerCase());
      }
    }
    function t_(a, s) {
      {
        if (wc)
          return;
        wc = !0, l('Did not expect server HTML to contain the text node "%s" in <%s>.', s.nodeValue, a.nodeName.toLowerCase());
      }
    }
    function ng(a, s, v) {
      {
        if (wc)
          return;
        wc = !0, l("Expected server HTML to contain a matching <%s> in <%s>.", s, a.nodeName.toLowerCase());
      }
    }
    function el(a, s) {
      {
        if (s === "" || wc)
          return;
        wc = !0, l('Expected server HTML to contain a matching text node for "%s" in <%s>.', s, a.nodeName.toLowerCase());
      }
    }
    function Fw(a, s, v) {
      switch (s) {
        case "input":
          sc(a, v);
          return;
        case "textarea":
          Hf(a, v);
          return;
        case "select":
          Em(a, v);
          return;
      }
    }
    var Wp = function() {
    }, Xu = function() {
    };
    {
      var ME = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], My = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], CE = My.concat(["button"]), RE = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], n_ = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Xu = function(a, s) {
        var v = Tn({}, a || n_), _ = {
          tag: s
        };
        return My.indexOf(s) !== -1 && (v.aTagInScope = null, v.buttonTagInScope = null, v.nobrTagInScope = null), CE.indexOf(s) !== -1 && (v.pTagInButtonScope = null), ME.indexOf(s) !== -1 && s !== "address" && s !== "div" && s !== "p" && (v.listItemTagAutoclosing = null, v.dlItemTagAutoclosing = null), v.current = _, s === "form" && (v.formTag = _), s === "a" && (v.aTagInScope = _), s === "button" && (v.buttonTagInScope = _), s === "nobr" && (v.nobrTagInScope = _), s === "p" && (v.pTagInButtonScope = _), s === "li" && (v.listItemTagAutoclosing = _), (s === "dd" || s === "dt") && (v.dlItemTagAutoclosing = _), v;
      };
      var rg = function(a, s) {
        switch (s) {
          case "select":
            return a === "option" || a === "optgroup" || a === "#text";
          case "optgroup":
            return a === "option" || a === "#text";
          case "option":
            return a === "#text";
          case "tr":
            return a === "th" || a === "td" || a === "style" || a === "script" || a === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return a === "tr" || a === "style" || a === "script" || a === "template";
          case "colgroup":
            return a === "col" || a === "template";
          case "table":
            return a === "caption" || a === "colgroup" || a === "tbody" || a === "tfoot" || a === "thead" || a === "style" || a === "script" || a === "template";
          case "head":
            return a === "base" || a === "basefont" || a === "bgsound" || a === "link" || a === "meta" || a === "title" || a === "noscript" || a === "noframes" || a === "style" || a === "script" || a === "template";
          case "html":
            return a === "head" || a === "body" || a === "frameset";
          case "frameset":
            return a === "frame";
          case "#document":
            return a === "html";
        }
        switch (a) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s !== "h1" && s !== "h2" && s !== "h3" && s !== "h4" && s !== "h5" && s !== "h6";
          case "rp":
          case "rt":
            return RE.indexOf(s) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return s == null;
        }
        return !0;
      }, AE = function(a, s) {
        switch (a) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s.pTagInButtonScope;
          case "form":
            return s.formTag || s.pTagInButtonScope;
          case "li":
            return s.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return s.dlItemTagAutoclosing;
          case "button":
            return s.buttonTagInScope;
          case "a":
            return s.aTagInScope;
          case "nobr":
            return s.nobrTagInScope;
        }
        return null;
      }, J0 = {};
      Wp = function(a, s, v) {
        v = v || n_;
        var _ = v.current, M = _ && _.tag;
        s != null && (a != null && l("validateDOMNesting: when childText is passed, childTag should be null"), a = "#text");
        var N = rg(a, M) ? null : _, G = N ? null : AE(a, v), q = N || G;
        if (q) {
          var te = q.tag, ge = !!N + "|" + a + "|" + te;
          if (!J0[ge]) {
            J0[ge] = !0;
            var Ee = a, Ke = "";
            if (a === "#text" ? /\S/.test(s) ? Ee = "Text nodes" : (Ee = "Whitespace text nodes", Ke = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Ee = "<" + a + ">", N) {
              var je = "";
              te === "table" && a === "tr" && (je += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), l("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Ee, te, Ke, je);
            } else
              l("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Ee, te);
          }
        }
      };
    }
    var wl = "suppressHydrationWarning", r_ = "$", eS = "/$", Cy = "$?", Ry = "$!", kw = "style", DE = null, LE = null;
    function k2(a) {
      var s, v, _ = a.nodeType;
      switch (_) {
        case _a:
        case Ea: {
          s = _ === _a ? "#document" : "#fragment";
          var M = a.documentElement;
          v = M ? M.namespaceURI : qc(null, "");
          break;
        }
        default: {
          var N = _ === Oa ? a.parentNode : a, G = N.namespaceURI || null;
          s = N.tagName, v = qc(G, s);
          break;
        }
      }
      {
        var q = s.toLowerCase(), te = Xu(null, q);
        return {
          namespace: v,
          ancestorInfo: te
        };
      }
    }
    function zw(a, s, v) {
      {
        var _ = a, M = qc(_.namespace, s), N = Xu(_.ancestorInfo, s);
        return {
          namespace: M,
          ancestorInfo: N
        };
      }
    }
    function Iw(a) {
      return a;
    }
    function Bw(a) {
      DE = ju(), LE = Zv();
      var s = null;
      return wa(!1), s;
    }
    function OE(a) {
      mE(LE), wa(DE), DE = null, LE = null;
    }
    function Hw(a, s, v, _, M) {
      var N;
      {
        var G = _;
        if (Wp(a, null, G.ancestorInfo), typeof s.children == "string" || typeof s.children == "number") {
          var q = "" + s.children, te = Xu(G.ancestorInfo, a);
          Wp(null, q, te);
        }
        N = G.namespace;
      }
      var ge = N2(a, s, v, N);
      return Jm(M, ge), jE(ge, s), ge;
    }
    function z2(a, s) {
      a.appendChild(s);
    }
    function Vw(a, s, v, _, M) {
      switch (Xh(a, s, v, _), s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!v.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function I2(a, s, v, _, M, N) {
      {
        var G = N;
        if (typeof _.children != typeof v.children && (typeof _.children == "string" || typeof _.children == "number")) {
          var q = "" + _.children, te = Xu(G.ancestorInfo, s);
          Wp(null, q, te);
        }
      }
      return Uw(a, s, v, _);
    }
    function PE(a, s) {
      return a === "textarea" || a === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
    }
    function B2(a, s, v, _) {
      {
        var M = v;
        Wp(null, a, M.ancestorInfo);
      }
      var N = F2(a, s);
      return Jm(_, N), N;
    }
    function H2() {
      var a = window.event;
      return a === void 0 ? yf : bl(a.type);
    }
    var UE = typeof setTimeout == "function" ? setTimeout : void 0, NE = typeof clearTimeout == "function" ? clearTimeout : void 0, Ay = -1, tS = typeof Promise == "function" ? Promise : void 0, Gw = typeof queueMicrotask == "function" ? queueMicrotask : typeof tS < "u" ? function(a) {
      return tS.resolve(null).then(a).catch(V2);
    } : UE;
    function V2(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Ww(a, s, v, _) {
      switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          v.autoFocus && a.focus();
          return;
        case "img": {
          v.src && (a.src = v.src);
          return;
        }
      }
    }
    function jw(a, s, v, _, M, N) {
      Nw(a, s, v, _, M), jE(a, M);
    }
    function i_(a) {
      Hi(a, "");
    }
    function G2(a, s, v) {
      a.nodeValue = v;
    }
    function FE(a, s) {
      a.appendChild(s);
    }
    function $w(a, s) {
      var v;
      a.nodeType === Oa ? (v = a.parentNode, v.insertBefore(s, a)) : (v = a, v.appendChild(s));
      var _ = a._reactRootContainer;
      _ == null && v.onclick === null && Jx(v);
    }
    function Yw(a, s, v) {
      a.insertBefore(s, v);
    }
    function Xw(a, s, v) {
      a.nodeType === Oa ? a.parentNode.insertBefore(s, v) : a.insertBefore(s, v);
    }
    function a_(a, s) {
      a.removeChild(s);
    }
    function W2(a, s) {
      a.nodeType === Oa ? a.parentNode.removeChild(s) : a.removeChild(s);
    }
    function kE(a, s) {
      var v = s, _ = 0;
      do {
        var M = v.nextSibling;
        if (a.removeChild(v), M && M.nodeType === Oa) {
          var N = M.data;
          if (N === eS)
            if (_ === 0) {
              a.removeChild(M), yr(s);
              return;
            } else
              _--;
          else
            (N === r_ || N === Cy || N === Ry) && _++;
        }
        v = M;
      } while (v);
      yr(s);
    }
    function j2(a, s) {
      a.nodeType === Oa ? kE(a.parentNode, s) : a.nodeType === Bs && kE(a, s), yr(a);
    }
    function qw(a) {
      a = a;
      var s = a.style;
      typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none";
    }
    function $2(a) {
      a.nodeValue = "";
    }
    function Y2(a, s) {
      a = a;
      var v = s[kw], _ = v != null && v.hasOwnProperty("display") ? v.display : null;
      a.style.display = Dd("display", _);
    }
    function X2(a, s) {
      a.nodeValue = s;
    }
    function q2(a) {
      a.nodeType === Bs ? a.textContent = "" : a.nodeType === _a && a.documentElement && a.removeChild(a.documentElement);
    }
    function Kw(a, s, v) {
      return a.nodeType !== Bs || s.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }
    function K2(a, s) {
      return s === "" || a.nodeType !== Lu ? null : a;
    }
    function zE(a) {
      return a.nodeType !== Oa ? null : a;
    }
    function IE(a) {
      return a.data === Cy;
    }
    function BE(a) {
      return a.data === Ry;
    }
    function Qw(a) {
      var s = a.nextSibling && a.nextSibling.dataset, v, _, M;
      return s && (v = s.dgst, _ = s.msg, M = s.stck), {
        message: _,
        digest: v,
        stack: M
      };
    }
    function Q2(a, s) {
      a._reactRetry = s;
    }
    function nS(a) {
      for (; a != null; a = a.nextSibling) {
        var s = a.nodeType;
        if (s === Bs || s === Lu)
          break;
        if (s === Oa) {
          var v = a.data;
          if (v === r_ || v === Ry || v === Cy)
            break;
          if (v === eS)
            return null;
        }
      }
      return a;
    }
    function rS(a) {
      return nS(a.nextSibling);
    }
    function o_(a) {
      return nS(a.firstChild);
    }
    function jp(a) {
      return nS(a.firstChild);
    }
    function Z2(a) {
      return nS(a.nextSibling);
    }
    function HE(a, s, v, _, M, N, G) {
      Jm(N, a), jE(a, v);
      var q;
      {
        var te = M;
        q = te.namespace;
      }
      var ge = (N.mode & Cr) !== qn;
      return Z0(a, s, v, q, _, ge, G);
    }
    function J2(a, s, v, _) {
      return Jm(v, a), v.mode & Cr, e_(a, s);
    }
    function Zw(a, s) {
      Jm(s, a);
    }
    function eA(a) {
      for (var s = a.nextSibling, v = 0; s; ) {
        if (s.nodeType === Oa) {
          var _ = s.data;
          if (_ === eS) {
            if (v === 0)
              return rS(s);
            v--;
          } else
            (_ === r_ || _ === Ry || _ === Cy) && v++;
        }
        s = s.nextSibling;
      }
      return null;
    }
    function VE(a) {
      for (var s = a.previousSibling, v = 0; s; ) {
        if (s.nodeType === Oa) {
          var _ = s.data;
          if (_ === r_ || _ === Ry || _ === Cy) {
            if (v === 0)
              return s;
            v--;
          } else
            _ === eS && v++;
        }
        s = s.previousSibling;
      }
      return null;
    }
    function Jw(a) {
      yr(a);
    }
    function eM(a) {
      yr(a);
    }
    function GE(a) {
      return a !== "head" && a !== "body";
    }
    function tA(a, s, v, _) {
      var M = !0;
      Ty(s.nodeValue, v, _, M);
    }
    function iS(a, s, v, _, M, N) {
      if (s[wl] !== !0) {
        var G = !0;
        Ty(_.nodeValue, M, N, G);
      }
    }
    function s_(a, s) {
      s.nodeType === Bs ? wy(a, s) : s.nodeType === Oa || t_(a, s);
    }
    function nA(a, s) {
      {
        var v = a.parentNode;
        v !== null && (s.nodeType === Bs ? wy(v, s) : s.nodeType === Oa || t_(v, s));
      }
    }
    function tM(a, s, v, _, M) {
      (M || s[wl] !== !0) && (_.nodeType === Bs ? wy(v, _) : _.nodeType === Oa || t_(v, _));
    }
    function rA(a, s, v) {
      ng(a, s);
    }
    function nM(a, s) {
      el(a, s);
    }
    function rM(a, s, v) {
      {
        var _ = a.parentNode;
        _ !== null && ng(_, s);
      }
    }
    function l_(a, s) {
      {
        var v = a.parentNode;
        v !== null && el(v, s);
      }
    }
    function Zm(a, s, v, _, M, N) {
      (N || s[wl] !== !0) && ng(v, _);
    }
    function iA(a, s, v, _, M) {
      (M || s[wl] !== !0) && el(v, _);
    }
    function _n(a) {
      l("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", a.nodeName.toLowerCase());
    }
    function Dy(a) {
      Yu(a);
    }
    var rh = Math.random().toString(36).slice(2), zo = "__reactFiber$" + rh, WE = "__reactProps$" + rh, Ly = "__reactContainer$" + rh, aS = "__reactEvents$" + rh, aA = "__reactListeners$" + rh, iM = "__reactHandles$" + rh;
    function u_(a) {
      delete a[zo], delete a[WE], delete a[aS], delete a[aA], delete a[iM];
    }
    function Jm(a, s) {
      s[zo] = a;
    }
    function oS(a, s) {
      s[Ly] = a;
    }
    function aM(a) {
      a[Ly] = null;
    }
    function sS(a) {
      return !!a[Ly];
    }
    function ig(a) {
      var s = a[zo];
      if (s)
        return s;
      for (var v = a.parentNode; v; ) {
        if (s = v[Ly] || v[zo], s) {
          var _ = s.alternate;
          if (s.child !== null || _ !== null && _.child !== null)
            for (var M = VE(a); M !== null; ) {
              var N = M[zo];
              if (N)
                return N;
              M = VE(M);
            }
          return s;
        }
        a = v, v = a.parentNode;
      }
      return null;
    }
    function ev(a) {
      var s = a[zo] || a[Ly];
      return s && (s.tag === w || s.tag === R || s.tag === B || s.tag === x) ? s : null;
    }
    function tl(a) {
      if (a.tag === w || a.tag === R)
        return a.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function cd(a) {
      return a[WE] || null;
    }
    function jE(a, s) {
      a[WE] = s;
    }
    function oA(a) {
      var s = a[aS];
      return s === void 0 && (s = a[aS] = /* @__PURE__ */ new Set()), s;
    }
    var oM = {}, sM = t.ReactDebugCurrentFrame;
    function lS(a) {
      if (a) {
        var s = a._owner, v = Dl(a.type, a._source, s ? s.type : null);
        sM.setExtraStackFrame(v);
      } else
        sM.setExtraStackFrame(null);
    }
    function ih(a, s, v, _, M) {
      {
        var N = Function.call.bind(Ye);
        for (var G in a)
          if (N(a, G)) {
            var q = void 0;
            try {
              if (typeof a[G] != "function") {
                var te = Error((_ || "React class") + ": " + v + " type `" + G + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[G] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw te.name = "Invariant Violation", te;
              }
              q = a[G](s, G, _, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ge) {
              q = ge;
            }
            q && !(q instanceof Error) && (lS(M), l("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", v, G, typeof q), lS(null)), q instanceof Error && !(q.message in oM) && (oM[q.message] = !0, lS(M), l("Failed %s type: %s", v, q.message), lS(null));
          }
      }
    }
    var c_ = [], uS;
    uS = [];
    var $p = -1;
    function Yp(a) {
      return {
        current: a
      };
    }
    function bu(a, s) {
      if ($p < 0) {
        l("Unexpected pop.");
        return;
      }
      s !== uS[$p] && l("Unexpected Fiber popped."), a.current = c_[$p], c_[$p] = null, uS[$p] = null, $p--;
    }
    function Tu(a, s, v) {
      $p++, c_[$p] = a.current, uS[$p] = v, a.current = s;
    }
    var $E;
    $E = {};
    var Cc = {};
    Object.freeze(Cc);
    var qh = Yp(Cc), ah = Yp(!1), cS = Cc;
    function tv(a, s, v) {
      return v && oh(s) ? cS : qh.current;
    }
    function YE(a, s, v) {
      {
        var _ = a.stateNode;
        _.__reactInternalMemoizedUnmaskedChildContext = s, _.__reactInternalMemoizedMaskedChildContext = v;
      }
    }
    function Oy(a, s) {
      {
        var v = a.type, _ = v.contextTypes;
        if (!_)
          return Cc;
        var M = a.stateNode;
        if (M && M.__reactInternalMemoizedUnmaskedChildContext === s)
          return M.__reactInternalMemoizedMaskedChildContext;
        var N = {};
        for (var G in _)
          N[G] = s[G];
        {
          var q = nr(a) || "Unknown";
          ih(_, N, "context", q);
        }
        return M && YE(a, s, N), N;
      }
    }
    function Py() {
      return ah.current;
    }
    function oh(a) {
      {
        var s = a.childContextTypes;
        return s != null;
      }
    }
    function f_(a) {
      bu(ah, a), bu(qh, a);
    }
    function Uy(a) {
      bu(ah, a), bu(qh, a);
    }
    function lM(a, s, v) {
      {
        if (qh.current !== Cc)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Tu(qh, s, a), Tu(ah, v, a);
      }
    }
    function uM(a, s, v) {
      {
        var _ = a.stateNode, M = s.childContextTypes;
        if (typeof _.getChildContext != "function") {
          {
            var N = nr(a) || "Unknown";
            $E[N] || ($E[N] = !0, l("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", N, N));
          }
          return v;
        }
        var G = _.getChildContext();
        for (var q in G)
          if (!(q in M))
            throw new Error((nr(a) || "Unknown") + '.getChildContext(): key "' + q + '" is not defined in childContextTypes.');
        {
          var te = nr(a) || "Unknown";
          ih(M, G, "child context", te);
        }
        return Tn({}, v, G);
      }
    }
    function d_(a) {
      {
        var s = a.stateNode, v = s && s.__reactInternalMemoizedMergedChildContext || Cc;
        return cS = qh.current, Tu(qh, v, a), Tu(ah, ah.current, a), !0;
      }
    }
    function cM(a, s, v) {
      {
        var _ = a.stateNode;
        if (!_)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (v) {
          var M = uM(a, s, cS);
          _.__reactInternalMemoizedMergedChildContext = M, bu(ah, a), bu(qh, a), Tu(qh, M, a), Tu(ah, v, a);
        } else
          bu(ah, a), Tu(ah, v, a);
      }
    }
    function sA(a) {
      {
        if (!af(a) || a.tag !== p)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var s = a;
        do {
          switch (s.tag) {
            case x:
              return s.stateNode.context;
            case p: {
              var v = s.type;
              if (oh(v))
                return s.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          s = s.return;
        } while (s !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var nv = 0, fS = 1, sh = null, XE = !1, h_ = !1;
    function fM(a) {
      sh === null ? sh = [a] : sh.push(a);
    }
    function dM(a) {
      XE = !0, fM(a);
    }
    function hM() {
      XE && rv();
    }
    function rv() {
      if (!h_ && sh !== null) {
        h_ = !0;
        var a = 0, s = Wu();
        try {
          var v = !0, _ = sh;
          for (po(bs); a < _.length; a++) {
            var M = _[a];
            do
              M = M(v);
            while (M !== null);
          }
          sh = null, XE = !1;
        } catch (N) {
          throw sh !== null && (sh = sh.slice(a + 1)), Wd(Um, rv), N;
        } finally {
          po(s), h_ = !1;
        }
      }
      return null;
    }
    var Ny = [], Fy = 0, p_ = null, m_ = 0, fd = [], dd = 0, ag = null, Xp = 1, qp = "";
    function pM(a) {
      return lh(), (a.flags & du) !== Xn;
    }
    function hd(a) {
      return lh(), m_;
    }
    function lA() {
      var a = qp, s = Xp, v = s & ~v_(s);
      return v.toString(32) + a;
    }
    function og(a, s) {
      lh(), Ny[Fy++] = m_, Ny[Fy++] = p_, p_ = a, m_ = s;
    }
    function mM(a, s, v) {
      lh(), fd[dd++] = Xp, fd[dd++] = qp, fd[dd++] = ag, ag = a;
      var _ = Xp, M = qp, N = sg(_) - 1, G = _ & ~(1 << N), q = v + 1, te = sg(s) + N;
      if (te > 30) {
        var ge = N - N % 5, Ee = (1 << ge) - 1, Ke = (G & Ee).toString(32), je = G >> ge, Et = N - ge, wt = sg(s) + Et, It = q << Et, Dn = It | je, fr = Ke + M;
        Xp = 1 << wt | Dn, qp = fr;
      } else {
        var Jn = q << N, Ci = Jn | G, vi = M;
        Xp = 1 << te | Ci, qp = vi;
      }
    }
    function qE(a) {
      lh();
      var s = a.return;
      if (s !== null) {
        var v = 1, _ = 0;
        og(a, v), mM(a, v, _);
      }
    }
    function sg(a) {
      return 32 - Ks(a);
    }
    function v_(a) {
      return 1 << sg(a) - 1;
    }
    function ky(a) {
      for (; a === p_; )
        p_ = Ny[--Fy], Ny[Fy] = null, m_ = Ny[--Fy], Ny[Fy] = null;
      for (; a === ag; )
        ag = fd[--dd], fd[dd] = null, qp = fd[--dd], fd[dd] = null, Xp = fd[--dd], fd[dd] = null;
    }
    function g_() {
      return lh(), ag !== null ? {
        id: Xp,
        overflow: qp
      } : null;
    }
    function y_(a, s) {
      lh(), fd[dd++] = Xp, fd[dd++] = qp, fd[dd++] = ag, Xp = s.id, qp = s.overflow, ag = a;
    }
    function lh() {
      Ma() || l("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Vl = null, pd = null, uh = !1, lg = !1, iv = null;
    function KE() {
      uh && l("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function S_() {
      lg = !0;
    }
    function QE() {
      return lg;
    }
    function vM(a) {
      var s = a.stateNode.containerInfo;
      return pd = jp(s), Vl = a, uh = !0, iv = null, lg = !1, !0;
    }
    function uA(a, s, v) {
      return pd = Z2(s), Vl = a, uh = !0, iv = null, lg = !1, v !== null && y_(a, v), !0;
    }
    function dS(a, s) {
      switch (a.tag) {
        case x: {
          s_(a.stateNode.containerInfo, s);
          break;
        }
        case w: {
          var v = (a.mode & Cr) !== qn;
          tM(
            a.type,
            a.memoizedProps,
            a.stateNode,
            s,
            // TODO: Delete this argument when we remove the legacy root API.
            v
          );
          break;
        }
        case B: {
          var _ = a.memoizedState;
          _.dehydrated !== null && nA(_.dehydrated, s);
          break;
        }
      }
    }
    function gM(a, s) {
      dS(a, s);
      var v = o8();
      v.stateNode = s, v.return = a;
      var _ = a.deletions;
      _ === null ? (a.deletions = [v], a.flags |= Zr) : _.push(v);
    }
    function ZE(a, s) {
      {
        if (lg)
          return;
        switch (a.tag) {
          case x: {
            var v = a.stateNode.containerInfo;
            switch (s.tag) {
              case w:
                var _ = s.type;
                s.pendingProps, rA(v, _);
                break;
              case R:
                var M = s.pendingProps;
                nM(v, M);
                break;
            }
            break;
          }
          case w: {
            var N = a.type, G = a.memoizedProps, q = a.stateNode;
            switch (s.tag) {
              case w: {
                var te = s.type, ge = s.pendingProps, Ee = (a.mode & Cr) !== qn;
                Zm(
                  N,
                  G,
                  q,
                  te,
                  ge,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Ee
                );
                break;
              }
              case R: {
                var Ke = s.pendingProps, je = (a.mode & Cr) !== qn;
                iA(
                  N,
                  G,
                  q,
                  Ke,
                  // TODO: Delete this argument when we remove the legacy root API.
                  je
                );
                break;
              }
            }
            break;
          }
          case B: {
            var Et = a.memoizedState, wt = Et.dehydrated;
            if (wt !== null)
              switch (s.tag) {
                case w:
                  var It = s.type;
                  s.pendingProps, rM(wt, It);
                  break;
                case R:
                  var Dn = s.pendingProps;
                  l_(wt, Dn);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function yM(a, s) {
      s.flags = s.flags & ~Ys | Nr, ZE(a, s);
    }
    function hS(a, s) {
      switch (a.tag) {
        case w: {
          var v = a.type;
          a.pendingProps;
          var _ = Kw(s, v);
          return _ !== null ? (a.stateNode = _, Vl = a, pd = o_(_), !0) : !1;
        }
        case R: {
          var M = a.pendingProps, N = K2(s, M);
          return N !== null ? (a.stateNode = N, Vl = a, pd = null, !0) : !1;
        }
        case B: {
          var G = zE(s);
          if (G !== null) {
            var q = {
              dehydrated: G,
              treeContext: g_(),
              retryLane: _l
            };
            a.memoizedState = q;
            var te = s8(G);
            return te.return = a, a.child = te, Vl = a, pd = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function JE(a) {
      return (a.mode & Cr) !== qn && (a.flags & hr) === Xn;
    }
    function eb(a) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function tb(a) {
      if (uh) {
        var s = pd;
        if (!s) {
          JE(a) && (ZE(Vl, a), eb()), yM(Vl, a), uh = !1, Vl = a;
          return;
        }
        var v = s;
        if (!hS(a, s)) {
          JE(a) && (ZE(Vl, a), eb()), s = rS(v);
          var _ = Vl;
          if (!s || !hS(a, s)) {
            yM(Vl, a), uh = !1, Vl = a;
            return;
          }
          gM(_, v);
        }
      }
    }
    function cA(a, s, v) {
      var _ = a.stateNode, M = !lg, N = HE(_, a.type, a.memoizedProps, s, v, a, M);
      return a.updateQueue = N, N !== null;
    }
    function SM(a) {
      var s = a.stateNode, v = a.memoizedProps, _ = J2(s, v, a);
      if (_) {
        var M = Vl;
        if (M !== null)
          switch (M.tag) {
            case x: {
              var N = M.stateNode.containerInfo, G = (M.mode & Cr) !== qn;
              tA(
                N,
                s,
                v,
                // TODO: Delete this argument when we remove the legacy root API.
                G
              );
              break;
            }
            case w: {
              var q = M.type, te = M.memoizedProps, ge = M.stateNode, Ee = (M.mode & Cr) !== qn;
              iS(
                q,
                te,
                ge,
                s,
                v,
                // TODO: Delete this argument when we remove the legacy root API.
                Ee
              );
              break;
            }
          }
      }
      return _;
    }
    function fA(a) {
      var s = a.memoizedState, v = s !== null ? s.dehydrated : null;
      if (!v)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Zw(v, a);
    }
    function nb(a) {
      var s = a.memoizedState, v = s !== null ? s.dehydrated : null;
      if (!v)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return eA(v);
    }
    function x_(a) {
      for (var s = a.return; s !== null && s.tag !== w && s.tag !== x && s.tag !== B; )
        s = s.return;
      Vl = s;
    }
    function Va(a) {
      if (a !== Vl)
        return !1;
      if (!uh)
        return x_(a), uh = !0, !1;
      if (a.tag !== x && (a.tag !== w || GE(a.type) && !PE(a.type, a.memoizedProps))) {
        var s = pd;
        if (s)
          if (JE(a))
            es(a), eb();
          else
            for (; s; )
              gM(a, s), s = rS(s);
      }
      return x_(a), a.tag === B ? pd = nb(a) : pd = Vl ? rS(a.stateNode) : null, !0;
    }
    function ch() {
      return uh && pd !== null;
    }
    function es(a) {
      for (var s = pd; s; )
        dS(a, s), s = rS(s);
    }
    function av() {
      Vl = null, pd = null, uh = !1, lg = !1;
    }
    function Gl() {
      iv !== null && (RU(iv), iv = null);
    }
    function Ma() {
      return uh;
    }
    function fh(a) {
      iv === null ? iv = [a] : iv.push(a);
    }
    var pS = t.ReactCurrentBatchConfig, ug = null;
    function __() {
      return pS.transition;
    }
    var qu = {
      recordUnsafeLifecycleWarnings: function(a, s) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(a, s) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var xM = function(a) {
        for (var s = null, v = a; v !== null; )
          v.mode & jr && (s = v), v = v.return;
        return s;
      }, Kp = function(a) {
        var s = [];
        return a.forEach(function(v) {
          s.push(v);
        }), s.sort().join(", ");
      }, Or = [], Rs = [], Ca = [], Ao = [], Rc = [], cg = [], to = /* @__PURE__ */ new Set();
      qu.recordUnsafeLifecycleWarnings = function(a, s) {
        to.has(a.type) || (typeof s.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        s.componentWillMount.__suppressDeprecationWarning !== !0 && Or.push(a), a.mode & jr && typeof s.UNSAFE_componentWillMount == "function" && Rs.push(a), typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Ca.push(a), a.mode & jr && typeof s.UNSAFE_componentWillReceiveProps == "function" && Ao.push(a), typeof s.componentWillUpdate == "function" && s.componentWillUpdate.__suppressDeprecationWarning !== !0 && Rc.push(a), a.mode & jr && typeof s.UNSAFE_componentWillUpdate == "function" && cg.push(a));
      }, qu.flushPendingUnsafeLifecycleWarnings = function() {
        var a = /* @__PURE__ */ new Set();
        Or.length > 0 && (Or.forEach(function(je) {
          a.add(nr(je) || "Component"), to.add(je.type);
        }), Or = []);
        var s = /* @__PURE__ */ new Set();
        Rs.length > 0 && (Rs.forEach(function(je) {
          s.add(nr(je) || "Component"), to.add(je.type);
        }), Rs = []);
        var v = /* @__PURE__ */ new Set();
        Ca.length > 0 && (Ca.forEach(function(je) {
          v.add(nr(je) || "Component"), to.add(je.type);
        }), Ca = []);
        var _ = /* @__PURE__ */ new Set();
        Ao.length > 0 && (Ao.forEach(function(je) {
          _.add(nr(je) || "Component"), to.add(je.type);
        }), Ao = []);
        var M = /* @__PURE__ */ new Set();
        Rc.length > 0 && (Rc.forEach(function(je) {
          M.add(nr(je) || "Component"), to.add(je.type);
        }), Rc = []);
        var N = /* @__PURE__ */ new Set();
        if (cg.length > 0 && (cg.forEach(function(je) {
          N.add(nr(je) || "Component"), to.add(je.type);
        }), cg = []), s.size > 0) {
          var G = Kp(s);
          l(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, G);
        }
        if (_.size > 0) {
          var q = Kp(_);
          l(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, q);
        }
        if (N.size > 0) {
          var te = Kp(N);
          l(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, te);
        }
        if (a.size > 0) {
          var ge = Kp(a);
          o(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ge);
        }
        if (v.size > 0) {
          var Ee = Kp(v);
          o(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ee);
        }
        if (M.size > 0) {
          var Ke = Kp(M);
          o(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ke);
        }
      };
      var ov = /* @__PURE__ */ new Map(), mS = /* @__PURE__ */ new Set();
      qu.recordLegacyContextWarning = function(a, s) {
        var v = xM(a);
        if (v === null) {
          l("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!mS.has(a.type)) {
          var _ = ov.get(v);
          (a.type.contextTypes != null || a.type.childContextTypes != null || s !== null && typeof s.getChildContext == "function") && (_ === void 0 && (_ = [], ov.set(v, _)), _.push(a));
        }
      }, qu.flushLegacyContextWarning = function() {
        ov.forEach(function(a, s) {
          if (a.length !== 0) {
            var v = a[0], _ = /* @__PURE__ */ new Set();
            a.forEach(function(N) {
              _.add(nr(N) || "Component"), mS.add(N.type);
            });
            var M = Kp(_);
            try {
              gi(v), l(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, M);
            } finally {
              fa();
            }
          }
        });
      }, qu.discardPendingWarnings = function() {
        Or = [], Rs = [], Ca = [], Ao = [], Rc = [], cg = [], ov = /* @__PURE__ */ new Map();
      };
    }
    function Ku(a, s) {
      if (a && a.defaultProps) {
        var v = Tn({}, s), _ = a.defaultProps;
        for (var M in _)
          v[M] === void 0 && (v[M] = _[M]);
        return v;
      }
      return s;
    }
    var zy = Yp(null), fg;
    fg = {};
    var Wl = null, sv = null, E_ = null, vS = !1;
    function b_() {
      Wl = null, sv = null, E_ = null, vS = !1;
    }
    function dg() {
      vS = !0;
    }
    function rb() {
      vS = !1;
    }
    function gS(a, s, v) {
      Tu(zy, s._currentValue, a), s._currentValue = v, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== fg && l("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = fg;
    }
    function yS(a, s) {
      var v = zy.current;
      bu(zy, s), a._currentValue = v;
    }
    function lv(a, s, v) {
      for (var _ = a; _ !== null; ) {
        var M = _.alternate;
        if (Mt(_.childLanes, s) ? M !== null && !Mt(M.childLanes, s) && (M.childLanes = Vt(M.childLanes, s)) : (_.childLanes = Vt(_.childLanes, s), M !== null && (M.childLanes = Vt(M.childLanes, s))), _ === v)
          break;
        _ = _.return;
      }
      _ !== v && l("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hg(a, s, v) {
      Qp(a, s, v);
    }
    function Qp(a, s, v) {
      var _ = a.child;
      for (_ !== null && (_.return = a); _ !== null; ) {
        var M = void 0, N = _.dependencies;
        if (N !== null) {
          M = _.child;
          for (var G = N.firstContext; G !== null; ) {
            if (G.context === s) {
              if (_.tag === p) {
                var q = ri(v), te = Qh($r, q);
                te.tag = Bo;
                var ge = _.updateQueue;
                if (ge !== null) {
                  var Ee = ge.shared, Ke = Ee.pending;
                  Ke === null ? te.next = te : (te.next = Ke.next, Ke.next = te), Ee.pending = te;
                }
              }
              _.lanes = Vt(_.lanes, v);
              var je = _.alternate;
              je !== null && (je.lanes = Vt(je.lanes, v)), lv(_.return, v, a), N.lanes = Vt(N.lanes, v);
              break;
            }
            G = G.next;
          }
        } else if (_.tag === F)
          M = _.type === a.type ? null : _.child;
        else if (_.tag === X) {
          var Et = _.return;
          if (Et === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Et.lanes = Vt(Et.lanes, v);
          var wt = Et.alternate;
          wt !== null && (wt.lanes = Vt(wt.lanes, v)), lv(Et, v, a), M = _.sibling;
        } else
          M = _.child;
        if (M !== null)
          M.return = _;
        else
          for (M = _; M !== null; ) {
            if (M === a) {
              M = null;
              break;
            }
            var It = M.sibling;
            if (It !== null) {
              It.return = M.return, M = It;
              break;
            }
            M = M.return;
          }
        _ = M;
      }
    }
    function Kh(a, s) {
      Wl = a, sv = null, E_ = null;
      var v = a.dependencies;
      if (v !== null) {
        var _ = v.firstContext;
        _ !== null && (We(v.lanes, s) && kb(), v.firstContext = null);
      }
    }
    function Io(a) {
      vS && l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var s = a._currentValue;
      if (E_ !== a) {
        var v = {
          context: a,
          memoizedValue: s,
          next: null
        };
        if (sv === null) {
          if (Wl === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          sv = v, Wl.dependencies = {
            lanes: Nt,
            firstContext: v
          };
        } else
          sv = sv.next = v;
      }
      return s;
    }
    var pg = null;
    function mg(a) {
      pg === null ? pg = [a] : pg.push(a);
    }
    function ib() {
      if (pg !== null) {
        for (var a = 0; a < pg.length; a++) {
          var s = pg[a], v = s.interleaved;
          if (v !== null) {
            s.interleaved = null;
            var _ = v.next, M = s.pending;
            if (M !== null) {
              var N = M.next;
              M.next = _, v.next = N;
            }
            s.pending = v;
          }
        }
        pg = null;
      }
    }
    function _M(a, s, v, _) {
      var M = s.interleaved;
      return M === null ? (v.next = v, mg(s)) : (v.next = M.next, M.next = v), s.interleaved = v, Ml(a, _);
    }
    function T_(a, s, v, _) {
      var M = s.interleaved;
      M === null ? (v.next = v, mg(s)) : (v.next = M.next, M.next = v), s.interleaved = v;
    }
    function SS(a, s, v, _) {
      var M = s.interleaved;
      return M === null ? (v.next = v, mg(s)) : (v.next = M.next, M.next = v), s.interleaved = v, Ml(a, _);
    }
    function jl(a, s) {
      return Ml(a, s);
    }
    var w_ = Ml;
    function Ml(a, s) {
      a.lanes = Vt(a.lanes, s);
      var v = a.alternate;
      v !== null && (v.lanes = Vt(v.lanes, s)), v === null && (a.flags & (Nr | Ys)) !== Xn && BU(a);
      for (var _ = a, M = a.return; M !== null; )
        M.childLanes = Vt(M.childLanes, s), v = M.alternate, v !== null ? v.childLanes = Vt(v.childLanes, s) : (M.flags & (Nr | Ys)) !== Xn && BU(a), _ = M, M = M.return;
      if (_.tag === x) {
        var N = _.stateNode;
        return N;
      } else
        return null;
    }
    var Zp = 0, EM = 1, Bo = 2, ab = 3, vg = !1, M_, $l;
    M_ = !1, $l = null;
    function C_(a) {
      var s = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Nt
        },
        effects: null
      };
      a.updateQueue = s;
    }
    function R_(a, s) {
      var v = s.updateQueue, _ = a.updateQueue;
      if (v === _) {
        var M = {
          baseState: _.baseState,
          firstBaseUpdate: _.firstBaseUpdate,
          lastBaseUpdate: _.lastBaseUpdate,
          shared: _.shared,
          effects: _.effects
        };
        s.updateQueue = M;
      }
    }
    function Qh(a, s) {
      var v = {
        eventTime: a,
        lane: s,
        tag: Zp,
        payload: null,
        callback: null,
        next: null
      };
      return v;
    }
    function uv(a, s, v) {
      var _ = a.updateQueue;
      if (_ === null)
        return null;
      var M = _.shared;
      if ($l === M && !M_ && (l("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), M_ = !0), y6()) {
        var N = M.pending;
        return N === null ? s.next = s : (s.next = N.next, N.next = s), M.pending = s, w_(a, v);
      } else
        return SS(a, M, s, v);
    }
    function A_(a, s, v) {
      var _ = s.updateQueue;
      if (_ !== null) {
        var M = _.shared;
        if (cr(v)) {
          var N = M.lanes;
          N = Rr(N, a.pendingLanes);
          var G = Vt(N, v);
          M.lanes = G, Ap(a, G);
        }
      }
    }
    function Zh(a, s) {
      var v = a.updateQueue, _ = a.alternate;
      if (_ !== null) {
        var M = _.updateQueue;
        if (v === M) {
          var N = null, G = null, q = v.firstBaseUpdate;
          if (q !== null) {
            var te = q;
            do {
              var ge = {
                eventTime: te.eventTime,
                lane: te.lane,
                tag: te.tag,
                payload: te.payload,
                callback: te.callback,
                next: null
              };
              G === null ? N = G = ge : (G.next = ge, G = ge), te = te.next;
            } while (te !== null);
            G === null ? N = G = s : (G.next = s, G = s);
          } else
            N = G = s;
          v = {
            baseState: M.baseState,
            firstBaseUpdate: N,
            lastBaseUpdate: G,
            shared: M.shared,
            effects: M.effects
          }, a.updateQueue = v;
          return;
        }
      }
      var Ee = v.lastBaseUpdate;
      Ee === null ? v.firstBaseUpdate = s : Ee.next = s, v.lastBaseUpdate = s;
    }
    function bM(a, s, v, _, M, N) {
      switch (v.tag) {
        case EM: {
          var G = v.payload;
          if (typeof G == "function") {
            dg();
            var q = G.call(N, _, M);
            {
              if (a.mode & jr) {
                Gi(!0);
                try {
                  G.call(N, _, M);
                } finally {
                  Gi(!1);
                }
              }
              rb();
            }
            return q;
          }
          return G;
        }
        case ab:
          a.flags = a.flags & ~xo | hr;
        case Zp: {
          var te = v.payload, ge;
          if (typeof te == "function") {
            dg(), ge = te.call(N, _, M);
            {
              if (a.mode & jr) {
                Gi(!0);
                try {
                  te.call(N, _, M);
                } finally {
                  Gi(!1);
                }
              }
              rb();
            }
          } else
            ge = te;
          return ge == null ? _ : Tn({}, _, ge);
        }
        case Bo:
          return vg = !0, _;
      }
      return _;
    }
    function D_(a, s, v, _) {
      var M = a.updateQueue;
      vg = !1, $l = M.shared;
      var N = M.firstBaseUpdate, G = M.lastBaseUpdate, q = M.shared.pending;
      if (q !== null) {
        M.shared.pending = null;
        var te = q, ge = te.next;
        te.next = null, G === null ? N = ge : G.next = ge, G = te;
        var Ee = a.alternate;
        if (Ee !== null) {
          var Ke = Ee.updateQueue, je = Ke.lastBaseUpdate;
          je !== G && (je === null ? Ke.firstBaseUpdate = ge : je.next = ge, Ke.lastBaseUpdate = te);
        }
      }
      if (N !== null) {
        var Et = M.baseState, wt = Nt, It = null, Dn = null, fr = null, Jn = N;
        do {
          var Ci = Jn.lane, vi = Jn.eventTime;
          if (Mt(_, Ci)) {
            if (fr !== null) {
              var Bt = {
                eventTime: vi,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Qr,
                tag: Jn.tag,
                payload: Jn.payload,
                callback: Jn.callback,
                next: null
              };
              fr = fr.next = Bt;
            }
            Et = bM(a, M, Jn, Et, s, v);
            var ht = Jn.callback;
            if (ht !== null && // If the update was already committed, we should not queue its
            // callback again.
            Jn.lane !== Qr) {
              a.flags |= ku;
              var tn = M.effects;
              tn === null ? M.effects = [Jn] : tn.push(Jn);
            }
          } else {
            var dt = {
              eventTime: vi,
              lane: Ci,
              tag: Jn.tag,
              payload: Jn.payload,
              callback: Jn.callback,
              next: null
            };
            fr === null ? (Dn = fr = dt, It = Et) : fr = fr.next = dt, wt = Vt(wt, Ci);
          }
          if (Jn = Jn.next, Jn === null) {
            if (q = M.shared.pending, q === null)
              break;
            var Ln = q, Mn = Ln.next;
            Ln.next = null, Jn = Mn, M.lastBaseUpdate = Ln, M.shared.pending = null;
          }
        } while (!0);
        fr === null && (It = Et), M.baseState = It, M.firstBaseUpdate = Dn, M.lastBaseUpdate = fr;
        var br = M.shared.interleaved;
        if (br !== null) {
          var Pr = br;
          do
            wt = Vt(wt, Pr.lane), Pr = Pr.next;
          while (Pr !== br);
        } else
          N === null && (M.shared.lanes = Nt);
        qb(wt), a.lanes = wt, a.memoizedState = Et;
      }
      $l = null;
    }
    function dA(a, s) {
      if (typeof a != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + a));
      a.call(s);
    }
    function TM() {
      vg = !1;
    }
    function L_() {
      return vg;
    }
    function xS(a, s, v) {
      var _ = s.effects;
      if (s.effects = null, _ !== null)
        for (var M = 0; M < _.length; M++) {
          var N = _[M], G = N.callback;
          G !== null && (N.callback = null, dA(G, v));
        }
    }
    var ob = {}, wM = new n.Component().refs, Iy, _S, Jp, O_, P_, sb, U_, By, lb, ES;
    {
      Iy = /* @__PURE__ */ new Set(), _S = /* @__PURE__ */ new Set(), Jp = /* @__PURE__ */ new Set(), O_ = /* @__PURE__ */ new Set(), By = /* @__PURE__ */ new Set(), P_ = /* @__PURE__ */ new Set(), lb = /* @__PURE__ */ new Set(), ES = /* @__PURE__ */ new Set();
      var MM = /* @__PURE__ */ new Set();
      U_ = function(a, s) {
        if (!(a === null || typeof a == "function")) {
          var v = s + "_" + a;
          MM.has(v) || (MM.add(v), l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, a));
        }
      }, sb = function(a, s) {
        if (s === void 0) {
          var v = ei(a) || "Component";
          P_.has(v) || (P_.add(v), l("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", v));
        }
      }, Object.defineProperty(ob, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(ob);
    }
    function ub(a, s, v, _) {
      var M = a.memoizedState, N = v(_, M);
      {
        if (a.mode & jr) {
          Gi(!0);
          try {
            N = v(_, M);
          } finally {
            Gi(!1);
          }
        }
        sb(s, N);
      }
      var G = N == null ? M : Tn({}, M, N);
      if (a.memoizedState = G, a.lanes === Nt) {
        var q = a.updateQueue;
        q.baseState = G;
      }
    }
    var Hy = {
      isMounted: Eo,
      enqueueSetState: function(a, s, v) {
        var _ = Xo(a), M = Rf(), N = i0(_), G = Qh(M, N);
        G.payload = s, v != null && (U_(v, "setState"), G.callback = v);
        var q = uv(_, G, N);
        q !== null && (Jl(q, _, N, M), A_(q, _, N)), gu(_, N);
      },
      enqueueReplaceState: function(a, s, v) {
        var _ = Xo(a), M = Rf(), N = i0(_), G = Qh(M, N);
        G.tag = EM, G.payload = s, v != null && (U_(v, "replaceState"), G.callback = v);
        var q = uv(_, G, N);
        q !== null && (Jl(q, _, N, M), A_(q, _, N)), gu(_, N);
      },
      enqueueForceUpdate: function(a, s) {
        var v = Xo(a), _ = Rf(), M = i0(v), N = Qh(_, M);
        N.tag = Bo, s != null && (U_(s, "forceUpdate"), N.callback = s);
        var G = uv(v, N, M);
        G !== null && (Jl(G, v, M, _), A_(G, v, M)), Lh(v, M);
      }
    };
    function CM(a, s, v, _, M, N, G) {
      var q = a.stateNode;
      if (typeof q.shouldComponentUpdate == "function") {
        var te = q.shouldComponentUpdate(_, N, G);
        {
          if (a.mode & jr) {
            Gi(!0);
            try {
              te = q.shouldComponentUpdate(_, N, G);
            } finally {
              Gi(!1);
            }
          }
          te === void 0 && l("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", ei(s) || "Component");
        }
        return te;
      }
      return s.prototype && s.prototype.isPureReactComponent ? !Zn(v, _) || !Zn(M, N) : !0;
    }
    function hA(a, s, v) {
      var _ = a.stateNode;
      {
        var M = ei(s) || "Component", N = _.render;
        N || (s.prototype && typeof s.prototype.render == "function" ? l("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", M) : l("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", M)), _.getInitialState && !_.getInitialState.isReactClassApproved && !_.state && l("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", M), _.getDefaultProps && !_.getDefaultProps.isReactClassApproved && l("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", M), _.propTypes && l("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", M), _.contextType && l("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", M), _.contextTypes && l("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", M), s.contextType && s.contextTypes && !lb.has(s) && (lb.add(s), l("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", M)), typeof _.componentShouldUpdate == "function" && l("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", M), s.prototype && s.prototype.isPureReactComponent && typeof _.shouldComponentUpdate < "u" && l("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ei(s) || "A pure component"), typeof _.componentDidUnmount == "function" && l("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", M), typeof _.componentDidReceiveProps == "function" && l("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", M), typeof _.componentWillRecieveProps == "function" && l("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", M), typeof _.UNSAFE_componentWillRecieveProps == "function" && l("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", M);
        var G = _.props !== v;
        _.props !== void 0 && G && l("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", M, M), _.defaultProps && l("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", M, M), typeof _.getSnapshotBeforeUpdate == "function" && typeof _.componentDidUpdate != "function" && !Jp.has(s) && (Jp.add(s), l("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ei(s))), typeof _.getDerivedStateFromProps == "function" && l("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof _.getDerivedStateFromError == "function" && l("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof s.getSnapshotBeforeUpdate == "function" && l("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", M);
        var q = _.state;
        q && (typeof q != "object" || oo(q)) && l("%s.state: must be set to an object or null", M), typeof _.getChildContext == "function" && typeof s.childContextTypes != "object" && l("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", M);
      }
    }
    function RM(a, s) {
      s.updater = Hy, a.stateNode = s, hi(s, a), s._reactInternalInstance = ob;
    }
    function cb(a, s, v) {
      var _ = !1, M = Cc, N = Cc, G = s.contextType;
      if ("contextType" in s) {
        var q = (
          // Allow null for conditional declaration
          G === null || G !== void 0 && G.$$typeof === qt && G._context === void 0
        );
        if (!q && !ES.has(s)) {
          ES.add(s);
          var te = "";
          G === void 0 ? te = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof G != "object" ? te = " However, it is set to a " + typeof G + "." : G.$$typeof === Ft ? te = " Did you accidentally pass the Context.Provider instead?" : G._context !== void 0 ? te = " Did you accidentally pass the Context.Consumer instead?" : te = " However, it is set to an object with keys {" + Object.keys(G).join(", ") + "}.", l("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ei(s) || "Component", te);
        }
      }
      if (typeof G == "object" && G !== null)
        N = Io(G);
      else {
        M = tv(a, s, !0);
        var ge = s.contextTypes;
        _ = ge != null, N = _ ? Oy(a, M) : Cc;
      }
      var Ee = new s(v, N);
      if (a.mode & jr) {
        Gi(!0);
        try {
          Ee = new s(v, N);
        } finally {
          Gi(!1);
        }
      }
      var Ke = a.memoizedState = Ee.state !== null && Ee.state !== void 0 ? Ee.state : null;
      RM(a, Ee);
      {
        if (typeof s.getDerivedStateFromProps == "function" && Ke === null) {
          var je = ei(s) || "Component";
          _S.has(je) || (_S.add(je), l("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", je, Ee.state === null ? "null" : "undefined", je));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Ee.getSnapshotBeforeUpdate == "function") {
          var Et = null, wt = null, It = null;
          if (typeof Ee.componentWillMount == "function" && Ee.componentWillMount.__suppressDeprecationWarning !== !0 ? Et = "componentWillMount" : typeof Ee.UNSAFE_componentWillMount == "function" && (Et = "UNSAFE_componentWillMount"), typeof Ee.componentWillReceiveProps == "function" && Ee.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? wt = "componentWillReceiveProps" : typeof Ee.UNSAFE_componentWillReceiveProps == "function" && (wt = "UNSAFE_componentWillReceiveProps"), typeof Ee.componentWillUpdate == "function" && Ee.componentWillUpdate.__suppressDeprecationWarning !== !0 ? It = "componentWillUpdate" : typeof Ee.UNSAFE_componentWillUpdate == "function" && (It = "UNSAFE_componentWillUpdate"), Et !== null || wt !== null || It !== null) {
            var Dn = ei(s) || "Component", fr = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            O_.has(Dn) || (O_.add(Dn), l(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Dn, fr, Et !== null ? `
  ` + Et : "", wt !== null ? `
  ` + wt : "", It !== null ? `
  ` + It : ""));
          }
        }
      }
      return _ && YE(a, M, N), Ee;
    }
    function AM(a, s) {
      var v = s.state;
      typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), v !== s.state && (l("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", nr(a) || "Component"), Hy.enqueueReplaceState(s, s.state, null));
    }
    function cv(a, s, v, _) {
      var M = s.state;
      if (typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(v, _), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(v, _), s.state !== M) {
        {
          var N = nr(a) || "Component";
          Iy.has(N) || (Iy.add(N), l("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", N));
        }
        Hy.enqueueReplaceState(s, s.state, null);
      }
    }
    function fb(a, s, v, _) {
      hA(a, s, v);
      var M = a.stateNode;
      M.props = v, M.state = a.memoizedState, M.refs = wM, C_(a);
      var N = s.contextType;
      if (typeof N == "object" && N !== null)
        M.context = Io(N);
      else {
        var G = tv(a, s, !0);
        M.context = Oy(a, G);
      }
      {
        if (M.state === v) {
          var q = ei(s) || "Component";
          By.has(q) || (By.add(q), l("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", q));
        }
        a.mode & jr && qu.recordLegacyContextWarning(a, M), qu.recordUnsafeLifecycleWarnings(a, M);
      }
      M.state = a.memoizedState;
      var te = s.getDerivedStateFromProps;
      if (typeof te == "function" && (ub(a, s, te, v), M.state = a.memoizedState), typeof s.getDerivedStateFromProps != "function" && typeof M.getSnapshotBeforeUpdate != "function" && (typeof M.UNSAFE_componentWillMount == "function" || typeof M.componentWillMount == "function") && (AM(a, M), D_(a, v, M, _), M.state = a.memoizedState), typeof M.componentDidMount == "function") {
        var ge = In;
        ge |= Ua, (a.mode & bo) !== qn && (ge |= ci), a.flags |= ge;
      }
    }
    function Jh(a, s, v, _) {
      var M = a.stateNode, N = a.memoizedProps;
      M.props = N;
      var G = M.context, q = s.contextType, te = Cc;
      if (typeof q == "object" && q !== null)
        te = Io(q);
      else {
        var ge = tv(a, s, !0);
        te = Oy(a, ge);
      }
      var Ee = s.getDerivedStateFromProps, Ke = typeof Ee == "function" || typeof M.getSnapshotBeforeUpdate == "function";
      !Ke && (typeof M.UNSAFE_componentWillReceiveProps == "function" || typeof M.componentWillReceiveProps == "function") && (N !== v || G !== te) && cv(a, M, v, te), TM();
      var je = a.memoizedState, Et = M.state = je;
      if (D_(a, v, M, _), Et = a.memoizedState, N === v && je === Et && !Py() && !L_()) {
        if (typeof M.componentDidMount == "function") {
          var wt = In;
          wt |= Ua, (a.mode & bo) !== qn && (wt |= ci), a.flags |= wt;
        }
        return !1;
      }
      typeof Ee == "function" && (ub(a, s, Ee, v), Et = a.memoizedState);
      var It = L_() || CM(a, s, N, v, je, Et, te);
      if (It) {
        if (!Ke && (typeof M.UNSAFE_componentWillMount == "function" || typeof M.componentWillMount == "function") && (typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount()), typeof M.componentDidMount == "function") {
          var Dn = In;
          Dn |= Ua, (a.mode & bo) !== qn && (Dn |= ci), a.flags |= Dn;
        }
      } else {
        if (typeof M.componentDidMount == "function") {
          var fr = In;
          fr |= Ua, (a.mode & bo) !== qn && (fr |= ci), a.flags |= fr;
        }
        a.memoizedProps = v, a.memoizedState = Et;
      }
      return M.props = v, M.state = Et, M.context = te, It;
    }
    function pA(a, s, v, _, M) {
      var N = s.stateNode;
      R_(a, s);
      var G = s.memoizedProps, q = s.type === s.elementType ? G : Ku(s.type, G);
      N.props = q;
      var te = s.pendingProps, ge = N.context, Ee = v.contextType, Ke = Cc;
      if (typeof Ee == "object" && Ee !== null)
        Ke = Io(Ee);
      else {
        var je = tv(s, v, !0);
        Ke = Oy(s, je);
      }
      var Et = v.getDerivedStateFromProps, wt = typeof Et == "function" || typeof N.getSnapshotBeforeUpdate == "function";
      !wt && (typeof N.UNSAFE_componentWillReceiveProps == "function" || typeof N.componentWillReceiveProps == "function") && (G !== te || ge !== Ke) && cv(s, N, _, Ke), TM();
      var It = s.memoizedState, Dn = N.state = It;
      if (D_(s, _, N, M), Dn = s.memoizedState, G === te && It === Dn && !Py() && !L_() && !ve)
        return typeof N.componentDidUpdate == "function" && (G !== a.memoizedProps || It !== a.memoizedState) && (s.flags |= In), typeof N.getSnapshotBeforeUpdate == "function" && (G !== a.memoizedProps || It !== a.memoizedState) && (s.flags |= $s), !1;
      typeof Et == "function" && (ub(s, v, Et, _), Dn = s.memoizedState);
      var fr = L_() || CM(s, v, q, _, It, Dn, Ke) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      ve;
      return fr ? (!wt && (typeof N.UNSAFE_componentWillUpdate == "function" || typeof N.componentWillUpdate == "function") && (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(_, Dn, Ke), typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(_, Dn, Ke)), typeof N.componentDidUpdate == "function" && (s.flags |= In), typeof N.getSnapshotBeforeUpdate == "function" && (s.flags |= $s)) : (typeof N.componentDidUpdate == "function" && (G !== a.memoizedProps || It !== a.memoizedState) && (s.flags |= In), typeof N.getSnapshotBeforeUpdate == "function" && (G !== a.memoizedProps || It !== a.memoizedState) && (s.flags |= $s), s.memoizedProps = _, s.memoizedState = Dn), N.props = _, N.state = Dn, N.context = Ke, fr;
    }
    var db, N_, hb, pb, mb, vb = function(a, s) {
    };
    db = !1, N_ = !1, hb = {}, pb = {}, mb = {}, vb = function(a, s) {
      if (!(a === null || typeof a != "object") && !(!a._store || a._store.validated || a.key != null)) {
        if (typeof a._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        a._store.validated = !0;
        var v = nr(s) || "Component";
        pb[v] || (pb[v] = !0, l('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function ts(a, s, v) {
      var _ = v.ref;
      if (_ !== null && typeof _ != "function" && typeof _ != "object") {
        if ((a.mode & jr || Le) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(v._owner && v._self && v._owner.stateNode !== v._self)) {
          var M = nr(a) || "Component";
          hb[M] || (l('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', _), hb[M] = !0);
        }
        if (v._owner) {
          var N = v._owner, G;
          if (N) {
            var q = N;
            if (q.tag !== p)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            G = q.stateNode;
          }
          if (!G)
            throw new Error("Missing owner for string ref " + _ + ". This error is likely caused by a bug in React. Please file an issue.");
          var te = G;
          Pt(_, "ref");
          var ge = "" + _;
          if (s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === ge)
            return s.ref;
          var Ee = function(Ke) {
            var je = te.refs;
            je === wM && (je = te.refs = {}), Ke === null ? delete je[ge] : je[ge] = Ke;
          };
          return Ee._stringRef = ge, Ee;
        } else {
          if (typeof _ != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!v._owner)
            throw new Error("Element ref was specified as a string (" + _ + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return _;
    }
    function F_(a, s) {
      var v = Object.prototype.toString.call(s);
      throw new Error("Objects are not valid as a React child (found: " + (v === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : v) + "). If you meant to render a collection of children, use an array instead.");
    }
    function bS(a) {
      {
        var s = nr(a) || "Component";
        if (mb[s])
          return;
        mb[s] = !0, l("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function DM(a) {
      var s = a._payload, v = a._init;
      return v(s);
    }
    function LM(a) {
      function s(dt, Bt) {
        if (a) {
          var ht = dt.deletions;
          ht === null ? (dt.deletions = [Bt], dt.flags |= Zr) : ht.push(Bt);
        }
      }
      function v(dt, Bt) {
        if (!a)
          return null;
        for (var ht = Bt; ht !== null; )
          s(dt, ht), ht = ht.sibling;
        return null;
      }
      function _(dt, Bt) {
        for (var ht = /* @__PURE__ */ new Map(), tn = Bt; tn !== null; )
          tn.key !== null ? ht.set(tn.key, tn) : ht.set(tn.index, tn), tn = tn.sibling;
        return ht;
      }
      function M(dt, Bt) {
        var ht = VS(dt, Bt);
        return ht.index = 0, ht.sibling = null, ht;
      }
      function N(dt, Bt, ht) {
        if (dt.index = ht, !a)
          return dt.flags |= du, Bt;
        var tn = dt.alternate;
        if (tn !== null) {
          var Ln = tn.index;
          return Ln < Bt ? (dt.flags |= Nr, Bt) : Ln;
        } else
          return dt.flags |= Nr, Bt;
      }
      function G(dt) {
        return a && dt.alternate === null && (dt.flags |= Nr), dt;
      }
      function q(dt, Bt, ht, tn) {
        if (Bt === null || Bt.tag !== R) {
          var Ln = gD(ht, dt.mode, tn);
          return Ln.return = dt, Ln;
        } else {
          var Mn = M(Bt, ht);
          return Mn.return = dt, Mn;
        }
      }
      function te(dt, Bt, ht, tn) {
        var Ln = ht.type;
        if (Ln === Ri)
          return Ee(dt, Bt, ht.props.children, tn, ht.key);
        if (Bt !== null && (Bt.elementType === Ln || // Keep this check inline so it only runs on the false path:
        WU(Bt, ht) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Ln == "object" && Ln !== null && Ln.$$typeof === Ve && DM(Ln) === Bt.type)) {
          var Mn = M(Bt, ht.props);
          return Mn.ref = ts(dt, Bt, ht), Mn.return = dt, Mn._debugSource = ht._source, Mn._debugOwner = ht._owner, Mn;
        }
        var br = vD(ht, dt.mode, tn);
        return br.ref = ts(dt, Bt, ht), br.return = dt, br;
      }
      function ge(dt, Bt, ht, tn) {
        if (Bt === null || Bt.tag !== b || Bt.stateNode.containerInfo !== ht.containerInfo || Bt.stateNode.implementation !== ht.implementation) {
          var Ln = yD(ht, dt.mode, tn);
          return Ln.return = dt, Ln;
        } else {
          var Mn = M(Bt, ht.children || []);
          return Mn.return = dt, Mn;
        }
      }
      function Ee(dt, Bt, ht, tn, Ln) {
        if (Bt === null || Bt.tag !== U) {
          var Mn = o0(ht, dt.mode, tn, Ln);
          return Mn.return = dt, Mn;
        } else {
          var br = M(Bt, ht);
          return br.return = dt, br;
        }
      }
      function Ke(dt, Bt, ht) {
        if (typeof Bt == "string" && Bt !== "" || typeof Bt == "number") {
          var tn = gD("" + Bt, dt.mode, ht);
          return tn.return = dt, tn;
        }
        if (typeof Bt == "object" && Bt !== null) {
          switch (Bt.$$typeof) {
            case Br: {
              var Ln = vD(Bt, dt.mode, ht);
              return Ln.ref = ts(dt, null, Bt), Ln.return = dt, Ln;
            }
            case Mr: {
              var Mn = yD(Bt, dt.mode, ht);
              return Mn.return = dt, Mn;
            }
            case Ve: {
              var br = Bt._payload, Pr = Bt._init;
              return Ke(dt, Pr(br), ht);
            }
          }
          if (oo(Bt) || Hr(Bt)) {
            var ga = o0(Bt, dt.mode, ht, null);
            return ga.return = dt, ga;
          }
          F_(dt, Bt);
        }
        return typeof Bt == "function" && bS(dt), null;
      }
      function je(dt, Bt, ht, tn) {
        var Ln = Bt !== null ? Bt.key : null;
        if (typeof ht == "string" && ht !== "" || typeof ht == "number")
          return Ln !== null ? null : q(dt, Bt, "" + ht, tn);
        if (typeof ht == "object" && ht !== null) {
          switch (ht.$$typeof) {
            case Br:
              return ht.key === Ln ? te(dt, Bt, ht, tn) : null;
            case Mr:
              return ht.key === Ln ? ge(dt, Bt, ht, tn) : null;
            case Ve: {
              var Mn = ht._payload, br = ht._init;
              return je(dt, Bt, br(Mn), tn);
            }
          }
          if (oo(ht) || Hr(ht))
            return Ln !== null ? null : Ee(dt, Bt, ht, tn, null);
          F_(dt, ht);
        }
        return typeof ht == "function" && bS(dt), null;
      }
      function Et(dt, Bt, ht, tn, Ln) {
        if (typeof tn == "string" && tn !== "" || typeof tn == "number") {
          var Mn = dt.get(ht) || null;
          return q(Bt, Mn, "" + tn, Ln);
        }
        if (typeof tn == "object" && tn !== null) {
          switch (tn.$$typeof) {
            case Br: {
              var br = dt.get(tn.key === null ? ht : tn.key) || null;
              return te(Bt, br, tn, Ln);
            }
            case Mr: {
              var Pr = dt.get(tn.key === null ? ht : tn.key) || null;
              return ge(Bt, Pr, tn, Ln);
            }
            case Ve:
              var ga = tn._payload, ji = tn._init;
              return Et(dt, Bt, ht, ji(ga), Ln);
          }
          if (oo(tn) || Hr(tn)) {
            var il = dt.get(ht) || null;
            return Ee(Bt, il, tn, Ln, null);
          }
          F_(Bt, tn);
        }
        return typeof tn == "function" && bS(Bt), null;
      }
      function wt(dt, Bt, ht) {
        {
          if (typeof dt != "object" || dt === null)
            return Bt;
          switch (dt.$$typeof) {
            case Br:
            case Mr:
              vb(dt, ht);
              var tn = dt.key;
              if (typeof tn != "string")
                break;
              if (Bt === null) {
                Bt = /* @__PURE__ */ new Set(), Bt.add(tn);
                break;
              }
              if (!Bt.has(tn)) {
                Bt.add(tn);
                break;
              }
              l("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", tn);
              break;
            case Ve:
              var Ln = dt._payload, Mn = dt._init;
              wt(Mn(Ln), Bt, ht);
              break;
          }
        }
        return Bt;
      }
      function It(dt, Bt, ht, tn) {
        for (var Ln = null, Mn = 0; Mn < ht.length; Mn++) {
          var br = ht[Mn];
          Ln = wt(br, Ln, dt);
        }
        for (var Pr = null, ga = null, ji = Bt, il = 0, $i = 0, Ds = null; ji !== null && $i < ht.length; $i++) {
          ji.index > $i ? (Ds = ji, ji = null) : Ds = ji.sibling;
          var Pc = je(dt, ji, ht[$i], tn);
          if (Pc === null) {
            ji === null && (ji = Ds);
            break;
          }
          a && ji && Pc.alternate === null && s(dt, ji), il = N(Pc, il, $i), ga === null ? Pr = Pc : ga.sibling = Pc, ga = Pc, ji = Ds;
        }
        if ($i === ht.length) {
          if (v(dt, ji), Ma()) {
            var nc = $i;
            og(dt, nc);
          }
          return Pr;
        }
        if (ji === null) {
          for (; $i < ht.length; $i++) {
            var ph = Ke(dt, ht[$i], tn);
            ph !== null && (il = N(ph, il, $i), ga === null ? Pr = ph : ga.sibling = ph, ga = ph);
          }
          if (Ma()) {
            var Af = $i;
            og(dt, Af);
          }
          return Pr;
        }
        for (var Df = _(dt, ji); $i < ht.length; $i++) {
          var Uc = Et(Df, dt, $i, ht[$i], tn);
          Uc !== null && (a && Uc.alternate !== null && Df.delete(Uc.key === null ? $i : Uc.key), il = N(Uc, il, $i), ga === null ? Pr = Uc : ga.sibling = Uc, ga = Uc);
        }
        if (a && Df.forEach(function(a1) {
          return s(dt, a1);
        }), Ma()) {
          var Rg = $i;
          og(dt, Rg);
        }
        return Pr;
      }
      function Dn(dt, Bt, ht, tn) {
        var Ln = Hr(ht);
        if (typeof Ln != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          ht[Symbol.toStringTag] === "Generator" && (N_ || l("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), N_ = !0), ht.entries === Ln && (db || l("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), db = !0);
          var Mn = Ln.call(ht);
          if (Mn)
            for (var br = null, Pr = Mn.next(); !Pr.done; Pr = Mn.next()) {
              var ga = Pr.value;
              br = wt(ga, br, dt);
            }
        }
        var ji = Ln.call(ht);
        if (ji == null)
          throw new Error("An iterable object provided no iterator.");
        for (var il = null, $i = null, Ds = Bt, Pc = 0, nc = 0, ph = null, Af = ji.next(); Ds !== null && !Af.done; nc++, Af = ji.next()) {
          Ds.index > nc ? (ph = Ds, Ds = null) : ph = Ds.sibling;
          var Df = je(dt, Ds, Af.value, tn);
          if (Df === null) {
            Ds === null && (Ds = ph);
            break;
          }
          a && Ds && Df.alternate === null && s(dt, Ds), Pc = N(Df, Pc, nc), $i === null ? il = Df : $i.sibling = Df, $i = Df, Ds = ph;
        }
        if (Af.done) {
          if (v(dt, Ds), Ma()) {
            var Uc = nc;
            og(dt, Uc);
          }
          return il;
        }
        if (Ds === null) {
          for (; !Af.done; nc++, Af = ji.next()) {
            var Rg = Ke(dt, Af.value, tn);
            Rg !== null && (Pc = N(Rg, Pc, nc), $i === null ? il = Rg : $i.sibling = Rg, $i = Rg);
          }
          if (Ma()) {
            var a1 = nc;
            og(dt, a1);
          }
          return il;
        }
        for (var eT = _(dt, Ds); !Af.done; nc++, Af = ji.next()) {
          var yv = Et(eT, dt, nc, Af.value, tn);
          yv !== null && (a && yv.alternate !== null && eT.delete(yv.key === null ? nc : yv.key), Pc = N(yv, Pc, nc), $i === null ? il = yv : $i.sibling = yv, $i = yv);
        }
        if (a && eT.forEach(function(z8) {
          return s(dt, z8);
        }), Ma()) {
          var k8 = nc;
          og(dt, k8);
        }
        return il;
      }
      function fr(dt, Bt, ht, tn) {
        if (Bt !== null && Bt.tag === R) {
          v(dt, Bt.sibling);
          var Ln = M(Bt, ht);
          return Ln.return = dt, Ln;
        }
        v(dt, Bt);
        var Mn = gD(ht, dt.mode, tn);
        return Mn.return = dt, Mn;
      }
      function Jn(dt, Bt, ht, tn) {
        for (var Ln = ht.key, Mn = Bt; Mn !== null; ) {
          if (Mn.key === Ln) {
            var br = ht.type;
            if (br === Ri) {
              if (Mn.tag === U) {
                v(dt, Mn.sibling);
                var Pr = M(Mn, ht.props.children);
                return Pr.return = dt, Pr._debugSource = ht._source, Pr._debugOwner = ht._owner, Pr;
              }
            } else if (Mn.elementType === br || // Keep this check inline so it only runs on the false path:
            WU(Mn, ht) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof br == "object" && br !== null && br.$$typeof === Ve && DM(br) === Mn.type) {
              v(dt, Mn.sibling);
              var ga = M(Mn, ht.props);
              return ga.ref = ts(dt, Mn, ht), ga.return = dt, ga._debugSource = ht._source, ga._debugOwner = ht._owner, ga;
            }
            v(dt, Mn);
            break;
          } else
            s(dt, Mn);
          Mn = Mn.sibling;
        }
        if (ht.type === Ri) {
          var ji = o0(ht.props.children, dt.mode, tn, ht.key);
          return ji.return = dt, ji;
        } else {
          var il = vD(ht, dt.mode, tn);
          return il.ref = ts(dt, Bt, ht), il.return = dt, il;
        }
      }
      function Ci(dt, Bt, ht, tn) {
        for (var Ln = ht.key, Mn = Bt; Mn !== null; ) {
          if (Mn.key === Ln)
            if (Mn.tag === b && Mn.stateNode.containerInfo === ht.containerInfo && Mn.stateNode.implementation === ht.implementation) {
              v(dt, Mn.sibling);
              var br = M(Mn, ht.children || []);
              return br.return = dt, br;
            } else {
              v(dt, Mn);
              break;
            }
          else
            s(dt, Mn);
          Mn = Mn.sibling;
        }
        var Pr = yD(ht, dt.mode, tn);
        return Pr.return = dt, Pr;
      }
      function vi(dt, Bt, ht, tn) {
        var Ln = typeof ht == "object" && ht !== null && ht.type === Ri && ht.key === null;
        if (Ln && (ht = ht.props.children), typeof ht == "object" && ht !== null) {
          switch (ht.$$typeof) {
            case Br:
              return G(Jn(dt, Bt, ht, tn));
            case Mr:
              return G(Ci(dt, Bt, ht, tn));
            case Ve:
              var Mn = ht._payload, br = ht._init;
              return vi(dt, Bt, br(Mn), tn);
          }
          if (oo(ht))
            return It(dt, Bt, ht, tn);
          if (Hr(ht))
            return Dn(dt, Bt, ht, tn);
          F_(dt, ht);
        }
        return typeof ht == "string" && ht !== "" || typeof ht == "number" ? G(fr(dt, Bt, "" + ht, tn)) : (typeof ht == "function" && bS(dt), v(dt, Bt));
      }
      return vi;
    }
    var Vy = LM(!0), OM = LM(!1);
    function mA(a, s) {
      if (a !== null && s.child !== a.child)
        throw new Error("Resuming work not yet implemented.");
      if (s.child !== null) {
        var v = s.child, _ = VS(v, v.pendingProps);
        for (s.child = _, _.return = s; v.sibling !== null; )
          v = v.sibling, _ = _.sibling = VS(v, v.pendingProps), _.return = s;
        _.sibling = null;
      }
    }
    function PM(a, s) {
      for (var v = a.child; v !== null; )
        t8(v, s), v = v.sibling;
    }
    var fv = {}, dh = Yp(fv), Gy = Yp(fv), Wy = Yp(fv);
    function k_(a) {
      if (a === fv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return a;
    }
    function gb() {
      var a = k_(Wy.current);
      return a;
    }
    function TS(a, s) {
      Tu(Wy, s, a), Tu(Gy, a, a), Tu(dh, fv, a);
      var v = k2(s);
      bu(dh, a), Tu(dh, v, a);
    }
    function jy(a) {
      bu(dh, a), bu(Gy, a), bu(Wy, a);
    }
    function gg() {
      var a = k_(dh.current);
      return a;
    }
    function z_(a) {
      k_(Wy.current);
      var s = k_(dh.current), v = zw(s, a.type);
      s !== v && (Tu(Gy, a, a), Tu(dh, v, a));
    }
    function $y(a) {
      Gy.current === a && (bu(dh, a), bu(Gy, a));
    }
    var UM = 0, yb = 1, NM = 1, wS = 2, Ho = Yp(UM);
    function dv(a, s) {
      return (a & s) !== 0;
    }
    function Yy(a) {
      return a & yb;
    }
    function hv(a, s) {
      return a & yb | s;
    }
    function Sb(a, s) {
      return a | s;
    }
    function ep(a, s) {
      Tu(Ho, s, a);
    }
    function yg(a) {
      bu(Ho, a);
    }
    function FM(a, s) {
      var v = a.memoizedState;
      return v !== null ? v.dehydrated !== null : (a.memoizedProps, !0);
    }
    function I_(a) {
      for (var s = a; s !== null; ) {
        if (s.tag === B) {
          var v = s.memoizedState;
          if (v !== null) {
            var _ = v.dehydrated;
            if (_ === null || IE(_) || BE(_))
              return s;
          }
        } else if (s.tag === le && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        s.memoizedProps.revealOrder !== void 0) {
          var M = (s.flags & hr) !== Xn;
          if (M)
            return s;
        } else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === a)
          return null;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === a)
            return null;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return null;
    }
    var Ac = (
      /*   */
      0
    ), ns = (
      /* */
      1
    ), tp = (
      /*  */
      2
    ), rs = (
      /*    */
      4
    ), Yl = (
      /*   */
      8
    ), xb = [];
    function MS() {
      for (var a = 0; a < xb.length; a++) {
        var s = xb[a];
        s._workInProgressVersionPrimary = null;
      }
      xb.length = 0;
    }
    function kM(a, s) {
      var v = s._getVersion, _ = v(s._source);
      a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [s, _] : a.mutableSourceEagerHydrationData.push(s, _);
    }
    var wn = t.ReactCurrentDispatcher, Xl = t.ReactCurrentBatchConfig, CS, Xy;
    CS = /* @__PURE__ */ new Set();
    var Sg = Nt, _i = null, nl = null, rl = null, qy = !1, xg = !1, md = 0, vA = 0, gA = 25, jt = null, Tf = null, np = -1, _b = !1;
    function Wi() {
      {
        var a = jt;
        Tf === null ? Tf = [a] : Tf.push(a);
      }
    }
    function fn() {
      {
        var a = jt;
        Tf !== null && (np++, Tf[np] !== a && yA(a));
      }
    }
    function _g(a) {
      a != null && !oo(a) && l("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", jt, typeof a);
    }
    function yA(a) {
      {
        var s = nr(_i);
        if (!CS.has(s) && (CS.add(s), Tf !== null)) {
          for (var v = "", _ = 30, M = 0; M <= np; M++) {
            for (var N = Tf[M], G = M === np ? a : N, q = M + 1 + ". " + N; q.length < _; )
              q += " ";
            q += G + `
`, v += q;
          }
          l(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, s, v);
        }
      }
    }
    function ql() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function Eb(a, s) {
      if (_b)
        return !1;
      if (s === null)
        return l("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", jt), !1;
      a.length !== s.length && l(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, jt, "[" + s.join(", ") + "]", "[" + a.join(", ") + "]");
      for (var v = 0; v < s.length && v < a.length; v++)
        if (!Un(a[v], s[v]))
          return !1;
      return !0;
    }
    function Ky(a, s, v, _, M, N) {
      Sg = N, _i = s, Tf = a !== null ? a._debugHookTypes : null, np = -1, _b = a !== null && a.type !== s.type, s.memoizedState = null, s.updateQueue = null, s.lanes = Nt, a !== null && a.memoizedState !== null ? wn.current = sn : Tf !== null ? wn.current = yt : wn.current = Gt;
      var G = v(_, M);
      if (xg) {
        var q = 0;
        do {
          if (xg = !1, md = 0, q >= gA)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          q += 1, _b = !1, nl = null, rl = null, s.updateQueue = null, np = -1, wn.current = jn, G = v(_, M);
        } while (xg);
      }
      wn.current = xt, s._debugHookTypes = Tf;
      var te = nl !== null && nl.next !== null;
      if (Sg = Nt, _i = null, nl = null, rl = null, jt = null, Tf = null, np = -1, a !== null && (a.flags & nn) !== (s.flags & nn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (a.mode & Cr) !== qn && l("Internal React error: Expected static flag was missing. Please notify the React team."), qy = !1, te)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return G;
    }
    function pv() {
      var a = md !== 0;
      return md = 0, a;
    }
    function B_(a, s, v) {
      s.updateQueue = a.updateQueue, (s.mode & bo) !== qn ? s.flags &= ~(hu | ci | ta | In) : s.flags &= ~(ta | In), a.lanes = An(a.lanes, v);
    }
    function bb() {
      if (wn.current = xt, qy) {
        for (var a = _i.memoizedState; a !== null; ) {
          var s = a.queue;
          s !== null && (s.pending = null), a = a.next;
        }
        qy = !1;
      }
      Sg = Nt, _i = null, nl = null, rl = null, Tf = null, np = -1, jt = null, ft = !1, xg = !1, md = 0;
    }
    function rp() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return rl === null ? _i.memoizedState = rl = a : rl = rl.next = a, rl;
    }
    function vd() {
      var a;
      if (nl === null) {
        var s = _i.alternate;
        s !== null ? a = s.memoizedState : a = null;
      } else
        a = nl.next;
      var v;
      if (rl === null ? v = _i.memoizedState : v = rl.next, v !== null)
        rl = v, v = rl.next, nl = a;
      else {
        if (a === null)
          throw new Error("Rendered more hooks than during the previous render.");
        nl = a;
        var _ = {
          memoizedState: nl.memoizedState,
          baseState: nl.baseState,
          baseQueue: nl.baseQueue,
          queue: nl.queue,
          next: null
        };
        rl === null ? _i.memoizedState = rl = _ : rl = rl.next = _;
      }
      return rl;
    }
    function zM() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Tb(a, s) {
      return typeof s == "function" ? s(a) : s;
    }
    function H_(a, s, v) {
      var _ = rp(), M;
      v !== void 0 ? M = v(s) : M = s, _.memoizedState = _.baseState = M;
      var N = {
        pending: null,
        interleaved: null,
        lanes: Nt,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: M
      };
      _.queue = N;
      var G = N.dispatch = rn.bind(null, _i, N);
      return [_.memoizedState, G];
    }
    function wb(a, s, v) {
      var _ = vd(), M = _.queue;
      if (M === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      M.lastRenderedReducer = a;
      var N = nl, G = N.baseQueue, q = M.pending;
      if (q !== null) {
        if (G !== null) {
          var te = G.next, ge = q.next;
          G.next = ge, q.next = te;
        }
        N.baseQueue !== G && l("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), N.baseQueue = G = q, M.pending = null;
      }
      if (G !== null) {
        var Ee = G.next, Ke = N.baseState, je = null, Et = null, wt = null, It = Ee;
        do {
          var Dn = It.lane;
          if (Mt(Sg, Dn)) {
            if (wt !== null) {
              var Jn = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Qr,
                action: It.action,
                hasEagerState: It.hasEagerState,
                eagerState: It.eagerState,
                next: null
              };
              wt = wt.next = Jn;
            }
            if (It.hasEagerState)
              Ke = It.eagerState;
            else {
              var Ci = It.action;
              Ke = a(Ke, Ci);
            }
          } else {
            var fr = {
              lane: Dn,
              action: It.action,
              hasEagerState: It.hasEagerState,
              eagerState: It.eagerState,
              next: null
            };
            wt === null ? (Et = wt = fr, je = Ke) : wt = wt.next = fr, _i.lanes = Vt(_i.lanes, Dn), qb(Dn);
          }
          It = It.next;
        } while (It !== null && It !== Ee);
        wt === null ? je = Ke : wt.next = Et, Un(Ke, _.memoizedState) || kb(), _.memoizedState = Ke, _.baseState = je, _.baseQueue = wt, M.lastRenderedState = Ke;
      }
      var vi = M.interleaved;
      if (vi !== null) {
        var dt = vi;
        do {
          var Bt = dt.lane;
          _i.lanes = Vt(_i.lanes, Bt), qb(Bt), dt = dt.next;
        } while (dt !== vi);
      } else
        G === null && (M.lanes = Nt);
      var ht = M.dispatch;
      return [_.memoizedState, ht];
    }
    function Mb(a, s, v) {
      var _ = vd(), M = _.queue;
      if (M === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      M.lastRenderedReducer = a;
      var N = M.dispatch, G = M.pending, q = _.memoizedState;
      if (G !== null) {
        M.pending = null;
        var te = G.next, ge = te;
        do {
          var Ee = ge.action;
          q = a(q, Ee), ge = ge.next;
        } while (ge !== te);
        Un(q, _.memoizedState) || kb(), _.memoizedState = q, _.baseQueue === null && (_.baseState = q), M.lastRenderedState = q;
      }
      return [q, N];
    }
    function SA(a, s, v) {
    }
    function IM(a, s, v) {
    }
    function Cb(a, s, v) {
      var _ = _i, M = rp(), N, G = Ma();
      if (G) {
        if (v === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        N = v(), Xy || N !== v() && (l("The result of getServerSnapshot should be cached to avoid an infinite loop"), Xy = !0);
      } else {
        if (N = s(), !Xy) {
          var q = s();
          Un(N, q) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Xy = !0);
        }
        var te = JM();
        if (te === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Jt(te, Sg) || BM(_, s, N);
      }
      M.memoizedState = N;
      var ge = {
        value: N,
        getSnapshot: s
      };
      return M.queue = ge, LS(Ab.bind(null, _, ge, a), [a]), _.flags |= ta, Qy(ns | Yl, Rb.bind(null, _, ge, N, s), void 0, null), N;
    }
    function V_(a, s, v) {
      var _ = _i, M = vd(), N = s();
      if (!Xy) {
        var G = s();
        Un(N, G) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Xy = !0);
      }
      var q = M.memoizedState, te = !Un(q, N);
      te && (M.memoizedState = N, kb());
      var ge = M.queue;
      if (Jy(Ab.bind(null, _, ge, a), [a]), ge.getSnapshot !== s || te || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      rl !== null && rl.memoizedState.tag & ns) {
        _.flags |= ta, Qy(ns | Yl, Rb.bind(null, _, ge, N, s), void 0, null);
        var Ee = JM();
        if (Ee === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Jt(Ee, Sg) || BM(_, s, N);
      }
      return N;
    }
    function BM(a, s, v) {
      a.flags |= Kf;
      var _ = {
        getSnapshot: s,
        value: v
      }, M = _i.updateQueue;
      if (M === null)
        M = zM(), _i.updateQueue = M, M.stores = [_];
      else {
        var N = M.stores;
        N === null ? M.stores = [_] : N.push(_);
      }
    }
    function Rb(a, s, v, _) {
      s.value = v, s.getSnapshot = _, Db(s) && Lb(a);
    }
    function Ab(a, s, v) {
      var _ = function() {
        Db(s) && Lb(a);
      };
      return v(_);
    }
    function Db(a) {
      var s = a.getSnapshot, v = a.value;
      try {
        var _ = s();
        return !Un(v, _);
      } catch {
        return !0;
      }
    }
    function Lb(a) {
      var s = jl(a, Hn);
      s !== null && Jl(s, a, Hn, $r);
    }
    function RS(a) {
      var s = rp();
      typeof a == "function" && (a = a()), s.memoizedState = s.baseState = a;
      var v = {
        pending: null,
        interleaved: null,
        lanes: Nt,
        dispatch: null,
        lastRenderedReducer: Tb,
        lastRenderedState: a
      };
      s.queue = v;
      var _ = v.dispatch = sr.bind(null, _i, v);
      return [s.memoizedState, _];
    }
    function G_(a) {
      return wb(Tb);
    }
    function W_(a) {
      return Mb(Tb);
    }
    function Qy(a, s, v, _) {
      var M = {
        tag: a,
        create: s,
        destroy: v,
        deps: _,
        // Circular
        next: null
      }, N = _i.updateQueue;
      if (N === null)
        N = zM(), _i.updateQueue = N, N.lastEffect = M.next = M;
      else {
        var G = N.lastEffect;
        if (G === null)
          N.lastEffect = M.next = M;
        else {
          var q = G.next;
          G.next = M, M.next = q, N.lastEffect = M;
        }
      }
      return M;
    }
    function j_(a) {
      var s = rp();
      {
        var v = {
          current: a
        };
        return s.memoizedState = v, v;
      }
    }
    function AS(a) {
      var s = vd();
      return s.memoizedState;
    }
    function Zy(a, s, v, _) {
      var M = rp(), N = _ === void 0 ? null : _;
      _i.flags |= a, M.memoizedState = Qy(ns | s, v, void 0, N);
    }
    function DS(a, s, v, _) {
      var M = vd(), N = _ === void 0 ? null : _, G = void 0;
      if (nl !== null) {
        var q = nl.memoizedState;
        if (G = q.destroy, N !== null) {
          var te = q.deps;
          if (Eb(N, te)) {
            M.memoizedState = Qy(s, v, G, N);
            return;
          }
        }
      }
      _i.flags |= a, M.memoizedState = Qy(ns | s, v, G, N);
    }
    function LS(a, s) {
      return (_i.mode & bo) !== qn ? Zy(hu | ta | zu, Yl, a, s) : Zy(ta | zu, Yl, a, s);
    }
    function Jy(a, s) {
      return DS(ta, Yl, a, s);
    }
    function $_(a, s) {
      return Zy(In, tp, a, s);
    }
    function OS(a, s) {
      return DS(In, tp, a, s);
    }
    function Y_(a, s) {
      var v = In;
      return v |= Ua, (_i.mode & bo) !== qn && (v |= ci), Zy(v, rs, a, s);
    }
    function PS(a, s) {
      return DS(In, rs, a, s);
    }
    function Ob(a, s) {
      if (typeof s == "function") {
        var v = s, _ = a();
        return v(_), function() {
          v(null);
        };
      } else if (s != null) {
        var M = s;
        M.hasOwnProperty("current") || l("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(M).join(", ") + "}");
        var N = a();
        return M.current = N, function() {
          M.current = null;
        };
      }
    }
    function US(a, s, v) {
      typeof s != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var _ = v != null ? v.concat([a]) : null, M = In;
      return M |= Ua, (_i.mode & bo) !== qn && (M |= ci), Zy(M, rs, Ob.bind(null, s, a), _);
    }
    function X_(a, s, v) {
      typeof s != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var _ = v != null ? v.concat([a]) : null;
      return DS(In, rs, Ob.bind(null, s, a), _);
    }
    function xA(a, s) {
    }
    var q_ = xA;
    function Pb(a, s) {
      var v = rp(), _ = s === void 0 ? null : s;
      return v.memoizedState = [a, _], a;
    }
    function u(a, s) {
      var v = vd(), _ = s === void 0 ? null : s, M = v.memoizedState;
      if (M !== null && _ !== null) {
        var N = M[1];
        if (Eb(_, N))
          return M[0];
      }
      return v.memoizedState = [a, _], a;
    }
    function d(a, s) {
      var v = rp(), _ = s === void 0 ? null : s, M = a();
      return v.memoizedState = [M, _], M;
    }
    function T(a, s) {
      var v = vd(), _ = s === void 0 ? null : s, M = v.memoizedState;
      if (M !== null && _ !== null) {
        var N = M[1];
        if (Eb(_, N))
          return M[0];
      }
      var G = a();
      return v.memoizedState = [G, _], G;
    }
    function C(a) {
      var s = rp();
      return s.memoizedState = a, a;
    }
    function P(a) {
      var s = vd(), v = nl, _ = v.memoizedState;
      return Q(s, _, a);
    }
    function V(a) {
      var s = vd();
      if (nl === null)
        return s.memoizedState = a, a;
      var v = nl.memoizedState;
      return Q(s, v, a);
    }
    function Q(a, s, v) {
      var _ = !Qe(Sg);
      if (_) {
        if (!Un(v, s)) {
          var M = Qn();
          _i.lanes = Vt(_i.lanes, M), qb(M), a.baseState = !0;
        }
        return s;
      } else
        return a.baseState && (a.baseState = !1, kb()), a.memoizedState = v, v;
    }
    function se(a, s, v) {
      var _ = Wu();
      po(Ts(_, Qo)), a(!0);
      var M = Xl.transition;
      Xl.transition = {};
      var N = Xl.transition;
      Xl.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a(!1), s();
      } finally {
        if (po(_), Xl.transition = M, M === null && N._updatedFibers) {
          var G = N._updatedFibers.size;
          G > 10 && o("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), N._updatedFibers.clear();
        }
      }
    }
    function me() {
      var a = RS(!1), s = a[0], v = a[1], _ = se.bind(null, v), M = rp();
      return M.memoizedState = _, [s, _];
    }
    function Ce() {
      var a = G_(), s = a[0], v = vd(), _ = v.memoizedState;
      return [s, _];
    }
    function ze() {
      var a = W_(), s = a[0], v = vd(), _ = v.memoizedState;
      return [s, _];
    }
    var ft = !1;
    function Lt() {
      return ft;
    }
    function zt() {
      var a = rp(), s = JM(), v = s.identifierPrefix, _;
      if (Ma()) {
        var M = lA();
        _ = ":" + v + "R" + M;
        var N = md++;
        N > 0 && (_ += "H" + N.toString(32)), _ += ":";
      } else {
        var G = vA++;
        _ = ":" + v + "r" + G.toString(32) + ":";
      }
      return a.memoizedState = _, _;
    }
    function Qt() {
      var a = vd(), s = a.memoizedState;
      return s;
    }
    function rn(a, s, v) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var _ = i0(a), M = {
        lane: _,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (zr(a))
        pr(s, M);
      else {
        var N = _M(a, s, M, _);
        if (N !== null) {
          var G = Rf();
          Jl(N, a, _, G), Ga(N, s, _);
        }
      }
      Wa(a, _);
    }
    function sr(a, s, v) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var _ = i0(a), M = {
        lane: _,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (zr(a))
        pr(s, M);
      else {
        var N = a.alternate;
        if (a.lanes === Nt && (N === null || N.lanes === Nt)) {
          var G = s.lastRenderedReducer;
          if (G !== null) {
            var q;
            q = wn.current, wn.current = Ar;
            try {
              var te = s.lastRenderedState, ge = G(te, v);
              if (M.hasEagerState = !0, M.eagerState = ge, Un(ge, te)) {
                T_(a, s, M, _);
                return;
              }
            } catch {
            } finally {
              wn.current = q;
            }
          }
        }
        var Ee = _M(a, s, M, _);
        if (Ee !== null) {
          var Ke = Rf();
          Jl(Ee, a, _, Ke), Ga(Ee, s, _);
        }
      }
      Wa(a, _);
    }
    function zr(a) {
      var s = a.alternate;
      return a === _i || s !== null && s === _i;
    }
    function pr(a, s) {
      xg = qy = !0;
      var v = a.pending;
      v === null ? s.next = s : (s.next = v.next, v.next = s), a.pending = s;
    }
    function Ga(a, s, v) {
      if (cr(v)) {
        var _ = s.lanes;
        _ = Rr(_, a.pendingLanes);
        var M = Vt(_, v);
        s.lanes = M, Ap(a, M);
      }
    }
    function Wa(a, s, v) {
      gu(a, s);
    }
    var xt = {
      readContext: Io,
      useCallback: ql,
      useContext: ql,
      useEffect: ql,
      useImperativeHandle: ql,
      useInsertionEffect: ql,
      useLayoutEffect: ql,
      useMemo: ql,
      useReducer: ql,
      useRef: ql,
      useState: ql,
      useDebugValue: ql,
      useDeferredValue: ql,
      useTransition: ql,
      useMutableSource: ql,
      useSyncExternalStore: ql,
      useId: ql,
      unstable_isNewReconciler: ce
    }, Gt = null, yt = null, sn = null, jn = null, pn = null, Ar = null, Pi = null;
    {
      var la = function() {
        l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, vn = function() {
        l("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Gt = {
        readContext: function(a) {
          return Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", Wi(), _g(s), Pb(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", Wi(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", Wi(), _g(s), LS(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", Wi(), _g(v), US(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", Wi(), _g(s), $_(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", Wi(), _g(s), Y_(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", Wi(), _g(s);
          var v = wn.current;
          wn.current = pn;
          try {
            return d(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", Wi();
          var _ = wn.current;
          wn.current = pn;
          try {
            return H_(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", Wi(), j_(a);
        },
        useState: function(a) {
          jt = "useState", Wi();
          var s = wn.current;
          wn.current = pn;
          try {
            return RS(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", Wi(), void 0;
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", Wi(), C(a);
        },
        useTransition: function() {
          return jt = "useTransition", Wi(), me();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", Wi(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", Wi(), Cb(a, s, v);
        },
        useId: function() {
          return jt = "useId", Wi(), zt();
        },
        unstable_isNewReconciler: ce
      }, yt = {
        readContext: function(a) {
          return Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", fn(), Pb(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", fn(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", fn(), LS(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", fn(), US(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", fn(), $_(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", fn(), Y_(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", fn();
          var v = wn.current;
          wn.current = pn;
          try {
            return d(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", fn();
          var _ = wn.current;
          wn.current = pn;
          try {
            return H_(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", fn(), j_(a);
        },
        useState: function(a) {
          jt = "useState", fn();
          var s = wn.current;
          wn.current = pn;
          try {
            return RS(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", fn(), void 0;
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", fn(), C(a);
        },
        useTransition: function() {
          return jt = "useTransition", fn(), me();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", fn(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", fn(), Cb(a, s, v);
        },
        useId: function() {
          return jt = "useId", fn(), zt();
        },
        unstable_isNewReconciler: ce
      }, sn = {
        readContext: function(a) {
          return Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", fn(), u(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", fn(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", fn(), Jy(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", fn(), X_(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", fn(), OS(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", fn(), PS(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", fn();
          var v = wn.current;
          wn.current = Ar;
          try {
            return T(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", fn();
          var _ = wn.current;
          wn.current = Ar;
          try {
            return wb(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", fn(), AS();
        },
        useState: function(a) {
          jt = "useState", fn();
          var s = wn.current;
          wn.current = Ar;
          try {
            return G_(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", fn(), q_();
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", fn(), P(a);
        },
        useTransition: function() {
          return jt = "useTransition", fn(), Ce();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", fn(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", fn(), V_(a, s);
        },
        useId: function() {
          return jt = "useId", fn(), Qt();
        },
        unstable_isNewReconciler: ce
      }, jn = {
        readContext: function(a) {
          return Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", fn(), u(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", fn(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", fn(), Jy(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", fn(), X_(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", fn(), OS(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", fn(), PS(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", fn();
          var v = wn.current;
          wn.current = Pi;
          try {
            return T(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", fn();
          var _ = wn.current;
          wn.current = Pi;
          try {
            return Mb(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", fn(), AS();
        },
        useState: function(a) {
          jt = "useState", fn();
          var s = wn.current;
          wn.current = Pi;
          try {
            return W_(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", fn(), q_();
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", fn(), V(a);
        },
        useTransition: function() {
          return jt = "useTransition", fn(), ze();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", fn(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", fn(), V_(a, s);
        },
        useId: function() {
          return jt = "useId", fn(), Qt();
        },
        unstable_isNewReconciler: ce
      }, pn = {
        readContext: function(a) {
          return la(), Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", vn(), Wi(), Pb(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", vn(), Wi(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", vn(), Wi(), LS(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", vn(), Wi(), US(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", vn(), Wi(), $_(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", vn(), Wi(), Y_(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", vn(), Wi();
          var v = wn.current;
          wn.current = pn;
          try {
            return d(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", vn(), Wi();
          var _ = wn.current;
          wn.current = pn;
          try {
            return H_(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", vn(), Wi(), j_(a);
        },
        useState: function(a) {
          jt = "useState", vn(), Wi();
          var s = wn.current;
          wn.current = pn;
          try {
            return RS(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", vn(), Wi(), void 0;
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", vn(), Wi(), C(a);
        },
        useTransition: function() {
          return jt = "useTransition", vn(), Wi(), me();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", vn(), Wi(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", vn(), Wi(), Cb(a, s, v);
        },
        useId: function() {
          return jt = "useId", vn(), Wi(), zt();
        },
        unstable_isNewReconciler: ce
      }, Ar = {
        readContext: function(a) {
          return la(), Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", vn(), fn(), u(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", vn(), fn(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", vn(), fn(), Jy(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", vn(), fn(), X_(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", vn(), fn(), OS(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", vn(), fn(), PS(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", vn(), fn();
          var v = wn.current;
          wn.current = Ar;
          try {
            return T(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", vn(), fn();
          var _ = wn.current;
          wn.current = Ar;
          try {
            return wb(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", vn(), fn(), AS();
        },
        useState: function(a) {
          jt = "useState", vn(), fn();
          var s = wn.current;
          wn.current = Ar;
          try {
            return G_(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", vn(), fn(), q_();
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", vn(), fn(), P(a);
        },
        useTransition: function() {
          return jt = "useTransition", vn(), fn(), Ce();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", vn(), fn(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", vn(), fn(), V_(a, s);
        },
        useId: function() {
          return jt = "useId", vn(), fn(), Qt();
        },
        unstable_isNewReconciler: ce
      }, Pi = {
        readContext: function(a) {
          return la(), Io(a);
        },
        useCallback: function(a, s) {
          return jt = "useCallback", vn(), fn(), u(a, s);
        },
        useContext: function(a) {
          return jt = "useContext", vn(), fn(), Io(a);
        },
        useEffect: function(a, s) {
          return jt = "useEffect", vn(), fn(), Jy(a, s);
        },
        useImperativeHandle: function(a, s, v) {
          return jt = "useImperativeHandle", vn(), fn(), X_(a, s, v);
        },
        useInsertionEffect: function(a, s) {
          return jt = "useInsertionEffect", vn(), fn(), OS(a, s);
        },
        useLayoutEffect: function(a, s) {
          return jt = "useLayoutEffect", vn(), fn(), PS(a, s);
        },
        useMemo: function(a, s) {
          jt = "useMemo", vn(), fn();
          var v = wn.current;
          wn.current = Ar;
          try {
            return T(a, s);
          } finally {
            wn.current = v;
          }
        },
        useReducer: function(a, s, v) {
          jt = "useReducer", vn(), fn();
          var _ = wn.current;
          wn.current = Ar;
          try {
            return Mb(a, s, v);
          } finally {
            wn.current = _;
          }
        },
        useRef: function(a) {
          return jt = "useRef", vn(), fn(), AS();
        },
        useState: function(a) {
          jt = "useState", vn(), fn();
          var s = wn.current;
          wn.current = Ar;
          try {
            return W_(a);
          } finally {
            wn.current = s;
          }
        },
        useDebugValue: function(a, s) {
          return jt = "useDebugValue", vn(), fn(), q_();
        },
        useDeferredValue: function(a) {
          return jt = "useDeferredValue", vn(), fn(), V(a);
        },
        useTransition: function() {
          return jt = "useTransition", vn(), fn(), ze();
        },
        useMutableSource: function(a, s, v) {
          return jt = "useMutableSource", vn(), fn(), void 0;
        },
        useSyncExternalStore: function(a, s, v) {
          return jt = "useSyncExternalStore", vn(), fn(), V_(a, s);
        },
        useId: function() {
          return jt = "useId", vn(), fn(), Qt();
        },
        unstable_isNewReconciler: ce
      };
    }
    var ia = e.unstable_now, Ui = 0, Yr = -1, no = -1, ja = -1, Dc = !1, As = !1;
    function Lc() {
      return Dc;
    }
    function wf() {
      As = !0;
    }
    function ip() {
      Dc = !1, As = !1;
    }
    function e0() {
      Dc = As, As = !1;
    }
    function Eg() {
      return Ui;
    }
    function Oc() {
      Ui = ia();
    }
    function em(a) {
      no = ia(), a.actualStartTime < 0 && (a.actualStartTime = ia());
    }
    function K_(a) {
      no = -1;
    }
    function NS(a, s) {
      if (no >= 0) {
        var v = ia() - no;
        a.actualDuration += v, s && (a.selfBaseDuration = v), no = -1;
      }
    }
    function ap(a) {
      if (Yr >= 0) {
        var s = ia() - Yr;
        Yr = -1;
        for (var v = a.return; v !== null; ) {
          switch (v.tag) {
            case x:
              var _ = v.stateNode;
              _.effectDuration += s;
              return;
            case H:
              var M = v.stateNode;
              M.effectDuration += s;
              return;
          }
          v = v.return;
        }
      }
    }
    function Ub(a) {
      if (ja >= 0) {
        var s = ia() - ja;
        ja = -1;
        for (var v = a.return; v !== null; ) {
          switch (v.tag) {
            case x:
              var _ = v.stateNode;
              _ !== null && (_.passiveEffectDuration += s);
              return;
            case H:
              var M = v.stateNode;
              M !== null && (M.passiveEffectDuration += s);
              return;
          }
          v = v.return;
        }
      }
    }
    function mv() {
      Yr = ia();
    }
    function _A() {
      ja = ia();
    }
    function EA(a) {
      for (var s = a.child; s; )
        a.actualDuration += s.actualDuration, s = s.sibling;
    }
    function FS(a, s) {
      return {
        value: a,
        source: s,
        stack: ll(s),
        digest: null
      };
    }
    function bA(a, s, v) {
      return {
        value: a,
        source: null,
        stack: v ?? null,
        digest: s ?? null
      };
    }
    function VH(a, s) {
      return !0;
    }
    function TA(a, s) {
      try {
        var v = VH(a, s);
        if (v === !1)
          return;
        var _ = s.value, M = s.source, N = s.stack, G = N !== null ? N : "";
        if (_ != null && _._suppressLogging) {
          if (a.tag === p)
            return;
          console.error(_);
        }
        var q = M ? nr(M) : null, te = q ? "The above error occurred in the <" + q + "> component:" : "The above error occurred in one of your React components:", ge;
        if (a.tag === x)
          ge = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ee = nr(a) || "Anonymous";
          ge = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ee + ".");
        }
        var Ke = te + `
` + G + `

` + ("" + ge);
        console.error(Ke);
      } catch (je) {
        setTimeout(function() {
          throw je;
        });
      }
    }
    var GH = typeof WeakMap == "function" ? WeakMap : Map;
    function U3(a, s, v) {
      var _ = Qh($r, v);
      _.tag = ab, _.payload = {
        element: null
      };
      var M = s.value;
      return _.callback = function() {
        N6(M), TA(a, s);
      }, _;
    }
    function wA(a, s, v) {
      var _ = Qh($r, v);
      _.tag = ab;
      var M = a.type.getDerivedStateFromError;
      if (typeof M == "function") {
        var N = s.value;
        _.payload = function() {
          return M(N);
        }, _.callback = function() {
          jU(a), TA(a, s);
        };
      }
      var G = a.stateNode;
      return G !== null && typeof G.componentDidCatch == "function" && (_.callback = function() {
        jU(a), TA(a, s), typeof M != "function" && P6(this);
        var te = s.value, ge = s.stack;
        this.componentDidCatch(te, {
          componentStack: ge !== null ? ge : ""
        }), typeof M != "function" && (We(a.lanes, Hn) || l("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", nr(a) || "Unknown"));
      }), _;
    }
    function N3(a, s, v) {
      var _ = a.pingCache, M;
      if (_ === null ? (_ = a.pingCache = new GH(), M = /* @__PURE__ */ new Set(), _.set(s, M)) : (M = _.get(s), M === void 0 && (M = /* @__PURE__ */ new Set(), _.set(s, M))), !M.has(v)) {
        M.add(v);
        var N = F6.bind(null, a, s, v);
        Na && Kb(a, v), s.then(N, N);
      }
    }
    function WH(a, s, v, _) {
      var M = a.updateQueue;
      if (M === null) {
        var N = /* @__PURE__ */ new Set();
        N.add(v), a.updateQueue = N;
      } else
        M.add(v);
    }
    function jH(a, s) {
      var v = a.tag;
      if ((a.mode & Cr) === qn && (v === h || v === k || v === Y)) {
        var _ = a.alternate;
        _ ? (a.updateQueue = _.updateQueue, a.memoizedState = _.memoizedState, a.lanes = _.lanes) : (a.updateQueue = null, a.memoizedState = null);
      }
    }
    function F3(a) {
      var s = a;
      do {
        if (s.tag === B && FM(s))
          return s;
        s = s.return;
      } while (s !== null);
      return null;
    }
    function k3(a, s, v, _, M) {
      if ((a.mode & Cr) === qn) {
        if (a === s)
          a.flags |= xo;
        else {
          if (a.flags |= hr, v.flags |= Ch, v.flags &= ~(vc | ys), v.tag === p) {
            var N = v.alternate;
            if (N === null)
              v.tag = K;
            else {
              var G = Qh($r, Hn);
              G.tag = Bo, uv(v, G, Hn);
            }
          }
          v.lanes = Vt(v.lanes, Hn);
        }
        return a;
      }
      return a.flags |= xo, a.lanes = M, a;
    }
    function $H(a, s, v, _, M) {
      if (v.flags |= ys, Na && Kb(a, M), _ !== null && typeof _ == "object" && typeof _.then == "function") {
        var N = _;
        jH(v), Ma() && v.mode & Cr && S_();
        var G = F3(s);
        if (G !== null) {
          G.flags &= ~ba, k3(G, s, v, a, M), G.mode & Cr && N3(a, N, M), WH(G, a, N);
          return;
        } else {
          if (!W(M)) {
            N3(a, N, M), iD();
            return;
          }
          var q = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          _ = q;
        }
      } else if (Ma() && v.mode & Cr) {
        S_();
        var te = F3(s);
        if (te !== null) {
          (te.flags & xo) === Xn && (te.flags |= ba), k3(te, s, v, a, M), fh(FS(_, v));
          return;
        }
      }
      _ = FS(_, v), w6(_);
      var ge = s;
      do {
        switch (ge.tag) {
          case x: {
            var Ee = _;
            ge.flags |= xo;
            var Ke = ri(M);
            ge.lanes = Vt(ge.lanes, Ke);
            var je = U3(ge, Ee, Ke);
            Zh(ge, je);
            return;
          }
          case p:
            var Et = _, wt = ge.type, It = ge.stateNode;
            if ((ge.flags & hr) === Xn && (typeof wt.getDerivedStateFromError == "function" || It !== null && typeof It.componentDidCatch == "function" && !FU(It))) {
              ge.flags |= xo;
              var Dn = ri(M);
              ge.lanes = Vt(ge.lanes, Dn);
              var fr = wA(ge, Et, Dn);
              Zh(ge, fr);
              return;
            }
            break;
        }
        ge = ge.return;
      } while (ge !== null);
    }
    function YH() {
      return null;
    }
    var Nb = t.ReactCurrentOwner, tm = !1, MA, Fb, CA, RA, AA, kS, DA, HM;
    MA = {}, Fb = {}, CA = {}, RA = {}, AA = {}, kS = !1, DA = {}, HM = {};
    function Mf(a, s, v, _) {
      a === null ? s.child = OM(s, null, v, _) : s.child = Vy(s, a.child, v, _);
    }
    function XH(a, s, v, _) {
      s.child = Vy(s, a.child, null, _), s.child = Vy(s, null, v, _);
    }
    function z3(a, s, v, _, M) {
      if (s.type !== s.elementType) {
        var N = v.propTypes;
        N && ih(
          N,
          _,
          // Resolved props
          "prop",
          ei(v)
        );
      }
      var G = v.render, q = s.ref, te, ge;
      Kh(s, M), qi(s);
      {
        if (Nb.current = s, qr(!0), te = Ky(a, s, G, _, q, M), ge = pv(), s.mode & jr) {
          Gi(!0);
          try {
            te = Ky(a, s, G, _, q, M), ge = pv();
          } finally {
            Gi(!1);
          }
        }
        qr(!1);
      }
      return na(), a !== null && !tm ? (B_(a, s, M), bg(a, s, M)) : (Ma() && ge && qE(s), s.flags |= pi, Mf(a, s, te, M), s.child);
    }
    function I3(a, s, v, _, M) {
      if (a === null) {
        var N = v.type;
        if (J6(N) && v.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        v.defaultProps === void 0) {
          var G = N;
          return G = i1(N), s.tag = Y, s.type = G, PA(s, N), B3(a, s, G, _, M);
        }
        {
          var q = N.propTypes;
          q && ih(
            q,
            _,
            // Resolved props
            "prop",
            ei(N)
          );
        }
        var te = mD(v.type, null, _, s, s.mode, M);
        return te.ref = s.ref, te.return = s, s.child = te, te;
      }
      {
        var ge = v.type, Ee = ge.propTypes;
        Ee && ih(
          Ee,
          _,
          // Resolved props
          "prop",
          ei(ge)
        );
      }
      var Ke = a.child, je = IA(a, M);
      if (!je) {
        var Et = Ke.memoizedProps, wt = v.compare;
        if (wt = wt !== null ? wt : Zn, wt(Et, _) && a.ref === s.ref)
          return bg(a, s, M);
      }
      s.flags |= pi;
      var It = VS(Ke, _);
      return It.ref = s.ref, It.return = s, s.child = It, It;
    }
    function B3(a, s, v, _, M) {
      if (s.type !== s.elementType) {
        var N = s.elementType;
        if (N.$$typeof === Ve) {
          var G = N, q = G._payload, te = G._init;
          try {
            N = te(q);
          } catch {
            N = null;
          }
          var ge = N && N.propTypes;
          ge && ih(
            ge,
            _,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            ei(N)
          );
        }
      }
      if (a !== null) {
        var Ee = a.memoizedProps;
        if (Zn(Ee, _) && a.ref === s.ref && // Prevent bailout if the implementation changed due to hot reload.
        s.type === a.type)
          if (tm = !1, s.pendingProps = _ = Ee, IA(a, M))
            (a.flags & Ch) !== Xn && (tm = !0);
          else
            return s.lanes = a.lanes, bg(a, s, M);
      }
      return LA(a, s, v, _, M);
    }
    function H3(a, s, v) {
      var _ = s.pendingProps, M = _.children, N = a !== null ? a.memoizedState : null;
      if (_.mode === "hidden" || re)
        if ((s.mode & Cr) === qn) {
          var G = {
            baseLanes: Nt,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = G, eC(s, v);
        } else if (We(v, _l)) {
          var Ke = {
            baseLanes: Nt,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = Ke;
          var je = N !== null ? N.baseLanes : v;
          eC(s, je);
        } else {
          var q = null, te;
          if (N !== null) {
            var ge = N.baseLanes;
            te = Vt(ge, v);
          } else
            te = v;
          s.lanes = s.childLanes = _l;
          var Ee = {
            baseLanes: te,
            cachePool: q,
            transitions: null
          };
          return s.memoizedState = Ee, s.updateQueue = null, eC(s, te), null;
        }
      else {
        var Et;
        N !== null ? (Et = Vt(N.baseLanes, v), s.memoizedState = null) : Et = v, eC(s, Et);
      }
      return Mf(a, s, M, v), s.child;
    }
    function qH(a, s, v) {
      var _ = s.pendingProps;
      return Mf(a, s, _, v), s.child;
    }
    function KH(a, s, v) {
      var _ = s.pendingProps.children;
      return Mf(a, s, _, v), s.child;
    }
    function QH(a, s, v) {
      {
        s.flags |= In;
        {
          var _ = s.stateNode;
          _.effectDuration = 0, _.passiveEffectDuration = 0;
        }
      }
      var M = s.pendingProps, N = M.children;
      return Mf(a, s, N, v), s.child;
    }
    function V3(a, s) {
      var v = s.ref;
      (a === null && v !== null || a !== null && a.ref !== v) && (s.flags |= gs, s.flags |= Qf);
    }
    function LA(a, s, v, _, M) {
      if (s.type !== s.elementType) {
        var N = v.propTypes;
        N && ih(
          N,
          _,
          // Resolved props
          "prop",
          ei(v)
        );
      }
      var G;
      {
        var q = tv(s, v, !0);
        G = Oy(s, q);
      }
      var te, ge;
      Kh(s, M), qi(s);
      {
        if (Nb.current = s, qr(!0), te = Ky(a, s, v, _, G, M), ge = pv(), s.mode & jr) {
          Gi(!0);
          try {
            te = Ky(a, s, v, _, G, M), ge = pv();
          } finally {
            Gi(!1);
          }
        }
        qr(!1);
      }
      return na(), a !== null && !tm ? (B_(a, s, M), bg(a, s, M)) : (Ma() && ge && qE(s), s.flags |= pi, Mf(a, s, te, M), s.child);
    }
    function G3(a, s, v, _, M) {
      {
        switch (p8(s)) {
          case !1: {
            var N = s.stateNode, G = s.type, q = new G(s.memoizedProps, N.context), te = q.state;
            N.updater.enqueueSetState(N, te, null);
            break;
          }
          case !0: {
            s.flags |= hr, s.flags |= xo;
            var ge = new Error("Simulated error coming from DevTools"), Ee = ri(M);
            s.lanes = Vt(s.lanes, Ee);
            var Ke = wA(s, FS(ge, s), Ee);
            Zh(s, Ke);
            break;
          }
        }
        if (s.type !== s.elementType) {
          var je = v.propTypes;
          je && ih(
            je,
            _,
            // Resolved props
            "prop",
            ei(v)
          );
        }
      }
      var Et;
      oh(v) ? (Et = !0, d_(s)) : Et = !1, Kh(s, M);
      var wt = s.stateNode, It;
      wt === null ? (GM(a, s), cb(s, v, _), fb(s, v, _, M), It = !0) : a === null ? It = Jh(s, v, _, M) : It = pA(a, s, v, _, M);
      var Dn = OA(a, s, v, It, Et, M);
      {
        var fr = s.stateNode;
        It && fr.props !== _ && (kS || l("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", nr(s) || "a component"), kS = !0);
      }
      return Dn;
    }
    function OA(a, s, v, _, M, N) {
      V3(a, s);
      var G = (s.flags & hr) !== Xn;
      if (!_ && !G)
        return M && cM(s, v, !1), bg(a, s, N);
      var q = s.stateNode;
      Nb.current = s;
      var te;
      if (G && typeof v.getDerivedStateFromError != "function")
        te = null, K_();
      else {
        qi(s);
        {
          if (qr(!0), te = q.render(), s.mode & jr) {
            Gi(!0);
            try {
              q.render();
            } finally {
              Gi(!1);
            }
          }
          qr(!1);
        }
        na();
      }
      return s.flags |= pi, a !== null && G ? XH(a, s, te, N) : Mf(a, s, te, N), s.memoizedState = q.state, M && cM(s, v, !0), s.child;
    }
    function W3(a) {
      var s = a.stateNode;
      s.pendingContext ? lM(a, s.pendingContext, s.pendingContext !== s.context) : s.context && lM(a, s.context, !1), TS(a, s.containerInfo);
    }
    function ZH(a, s, v) {
      if (W3(s), a === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var _ = s.pendingProps, M = s.memoizedState, N = M.element;
      R_(a, s), D_(s, _, null, v);
      var G = s.memoizedState;
      s.stateNode;
      var q = G.element;
      if (M.isDehydrated) {
        var te = {
          element: q,
          isDehydrated: !1,
          cache: G.cache,
          pendingSuspenseBoundaries: G.pendingSuspenseBoundaries,
          transitions: G.transitions
        }, ge = s.updateQueue;
        if (ge.baseState = te, s.memoizedState = te, s.flags & ba) {
          var Ee = FS(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), s);
          return j3(a, s, q, v, Ee);
        } else if (q !== N) {
          var Ke = FS(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), s);
          return j3(a, s, q, v, Ke);
        } else {
          vM(s);
          var je = OM(s, null, q, v);
          s.child = je;
          for (var Et = je; Et; )
            Et.flags = Et.flags & ~Nr | Ys, Et = Et.sibling;
        }
      } else {
        if (av(), q === N)
          return bg(a, s, v);
        Mf(a, s, q, v);
      }
      return s.child;
    }
    function j3(a, s, v, _, M) {
      return av(), fh(M), s.flags |= ba, Mf(a, s, v, _), s.child;
    }
    function JH(a, s, v) {
      z_(s), a === null && tb(s);
      var _ = s.type, M = s.pendingProps, N = a !== null ? a.memoizedProps : null, G = M.children, q = PE(_, M);
      return q ? G = null : N !== null && PE(_, N) && (s.flags |= ui), V3(a, s), Mf(a, s, G, v), s.child;
    }
    function eV(a, s) {
      return a === null && tb(s), null;
    }
    function tV(a, s, v, _) {
      GM(a, s);
      var M = s.pendingProps, N = v, G = N._payload, q = N._init, te = q(G);
      s.type = te;
      var ge = s.tag = e8(te), Ee = Ku(te, M), Ke;
      switch (ge) {
        case h:
          return PA(s, te), s.type = te = i1(te), Ke = LA(null, s, te, Ee, _), Ke;
        case p:
          return s.type = te = uD(te), Ke = G3(null, s, te, Ee, _), Ke;
        case k:
          return s.type = te = cD(te), Ke = z3(null, s, te, Ee, _), Ke;
        case $: {
          if (s.type !== s.elementType) {
            var je = te.propTypes;
            je && ih(
              je,
              Ee,
              // Resolved for outer only
              "prop",
              ei(te)
            );
          }
          return Ke = I3(
            null,
            s,
            te,
            Ku(te.type, Ee),
            // The inner type can have defaults too
            _
          ), Ke;
        }
      }
      var Et = "";
      throw te !== null && typeof te == "object" && te.$$typeof === Ve && (Et = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + te + ". " + ("Lazy element type must resolve to a class or function." + Et));
    }
    function nV(a, s, v, _, M) {
      GM(a, s), s.tag = p;
      var N;
      return oh(v) ? (N = !0, d_(s)) : N = !1, Kh(s, M), cb(s, v, _), fb(s, v, _, M), OA(null, s, v, !0, N, M);
    }
    function rV(a, s, v, _) {
      GM(a, s);
      var M = s.pendingProps, N;
      {
        var G = tv(s, v, !1);
        N = Oy(s, G);
      }
      Kh(s, _);
      var q, te;
      qi(s);
      {
        if (v.prototype && typeof v.prototype.render == "function") {
          var ge = ei(v) || "Unknown";
          MA[ge] || (l("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ge, ge), MA[ge] = !0);
        }
        s.mode & jr && qu.recordLegacyContextWarning(s, null), qr(!0), Nb.current = s, q = Ky(null, s, v, M, N, _), te = pv(), qr(!1);
      }
      if (na(), s.flags |= pi, typeof q == "object" && q !== null && typeof q.render == "function" && q.$$typeof === void 0) {
        var Ee = ei(v) || "Unknown";
        Fb[Ee] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ee, Ee, Ee), Fb[Ee] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof q == "object" && q !== null && typeof q.render == "function" && q.$$typeof === void 0
      ) {
        {
          var Ke = ei(v) || "Unknown";
          Fb[Ke] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ke, Ke, Ke), Fb[Ke] = !0);
        }
        s.tag = p, s.memoizedState = null, s.updateQueue = null;
        var je = !1;
        return oh(v) ? (je = !0, d_(s)) : je = !1, s.memoizedState = q.state !== null && q.state !== void 0 ? q.state : null, C_(s), RM(s, q), fb(s, v, M, _), OA(null, s, v, !0, je, _);
      } else {
        if (s.tag = h, s.mode & jr) {
          Gi(!0);
          try {
            q = Ky(null, s, v, M, N, _), te = pv();
          } finally {
            Gi(!1);
          }
        }
        return Ma() && te && qE(s), Mf(null, s, q, _), PA(s, v), s.child;
      }
    }
    function PA(a, s) {
      {
        if (s && s.childContextTypes && l("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), a.ref !== null) {
          var v = "", _ = hs();
          _ && (v += `

Check the render method of \`` + _ + "`.");
          var M = _ || "", N = a._debugSource;
          N && (M = N.fileName + ":" + N.lineNumber), AA[M] || (AA[M] = !0, l("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", v));
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var G = ei(s) || "Unknown";
          RA[G] || (l("%s: Function components do not support getDerivedStateFromProps.", G), RA[G] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var q = ei(s) || "Unknown";
          CA[q] || (l("%s: Function components do not support contextType.", q), CA[q] = !0);
        }
      }
    }
    var UA = {
      dehydrated: null,
      treeContext: null,
      retryLane: Qr
    };
    function NA(a) {
      return {
        baseLanes: a,
        cachePool: YH(),
        transitions: null
      };
    }
    function iV(a, s) {
      var v = null;
      return {
        baseLanes: Vt(a.baseLanes, s),
        cachePool: v,
        transitions: a.transitions
      };
    }
    function aV(a, s, v, _) {
      if (s !== null) {
        var M = s.memoizedState;
        if (M === null)
          return !1;
      }
      return dv(a, wS);
    }
    function oV(a, s) {
      return An(a.childLanes, s);
    }
    function $3(a, s, v) {
      var _ = s.pendingProps;
      m8(s) && (s.flags |= hr);
      var M = Ho.current, N = !1, G = (s.flags & hr) !== Xn;
      if (G || aV(M, a) ? (N = !0, s.flags &= ~hr) : (a === null || a.memoizedState !== null) && (M = Sb(M, NM)), M = Yy(M), ep(s, M), a === null) {
        tb(s);
        var q = s.memoizedState;
        if (q !== null) {
          var te = q.dehydrated;
          if (te !== null)
            return fV(s, te);
        }
        var ge = _.children, Ee = _.fallback;
        if (N) {
          var Ke = sV(s, ge, Ee, v), je = s.child;
          return je.memoizedState = NA(v), s.memoizedState = UA, Ke;
        } else
          return FA(s, ge);
      } else {
        var Et = a.memoizedState;
        if (Et !== null) {
          var wt = Et.dehydrated;
          if (wt !== null)
            return dV(a, s, G, _, wt, Et, v);
        }
        if (N) {
          var It = _.fallback, Dn = _.children, fr = uV(a, s, Dn, It, v), Jn = s.child, Ci = a.child.memoizedState;
          return Jn.memoizedState = Ci === null ? NA(v) : iV(Ci, v), Jn.childLanes = oV(a, v), s.memoizedState = UA, fr;
        } else {
          var vi = _.children, dt = lV(a, s, vi, v);
          return s.memoizedState = null, dt;
        }
      }
    }
    function FA(a, s, v) {
      var _ = a.mode, M = {
        mode: "visible",
        children: s
      }, N = kA(M, _);
      return N.return = a, a.child = N, N;
    }
    function sV(a, s, v, _) {
      var M = a.mode, N = a.child, G = {
        mode: "hidden",
        children: s
      }, q, te;
      return (M & Cr) === qn && N !== null ? (q = N, q.childLanes = Nt, q.pendingProps = G, a.mode & Kn && (q.actualDuration = 0, q.actualStartTime = -1, q.selfBaseDuration = 0, q.treeBaseDuration = 0), te = o0(v, M, _, null)) : (q = kA(G, M), te = o0(v, M, _, null)), q.return = a, te.return = a, q.sibling = te, a.child = q, te;
    }
    function kA(a, s, v) {
      return YU(a, s, Nt, null);
    }
    function Y3(a, s) {
      return VS(a, s);
    }
    function lV(a, s, v, _) {
      var M = a.child, N = M.sibling, G = Y3(M, {
        mode: "visible",
        children: v
      });
      if ((s.mode & Cr) === qn && (G.lanes = _), G.return = s, G.sibling = null, N !== null) {
        var q = s.deletions;
        q === null ? (s.deletions = [N], s.flags |= Zr) : q.push(N);
      }
      return s.child = G, G;
    }
    function uV(a, s, v, _, M) {
      var N = s.mode, G = a.child, q = G.sibling, te = {
        mode: "hidden",
        children: v
      }, ge;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (N & Cr) === qn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        s.child !== G
      ) {
        var Ee = s.child;
        ge = Ee, ge.childLanes = Nt, ge.pendingProps = te, s.mode & Kn && (ge.actualDuration = 0, ge.actualStartTime = -1, ge.selfBaseDuration = G.selfBaseDuration, ge.treeBaseDuration = G.treeBaseDuration), s.deletions = null;
      } else
        ge = Y3(G, te), ge.subtreeFlags = G.subtreeFlags & nn;
      var Ke;
      return q !== null ? Ke = VS(q, _) : (Ke = o0(_, N, M, null), Ke.flags |= Nr), Ke.return = s, ge.return = s, ge.sibling = Ke, s.child = ge, Ke;
    }
    function VM(a, s, v, _) {
      _ !== null && fh(_), Vy(s, a.child, null, v);
      var M = s.pendingProps, N = M.children, G = FA(s, N);
      return G.flags |= Nr, s.memoizedState = null, G;
    }
    function cV(a, s, v, _, M) {
      var N = s.mode, G = {
        mode: "visible",
        children: v
      }, q = kA(G, N), te = o0(_, N, M, null);
      return te.flags |= Nr, q.return = s, te.return = s, q.sibling = te, s.child = q, (s.mode & Cr) !== qn && Vy(s, a.child, null, M), te;
    }
    function fV(a, s, v) {
      return (a.mode & Cr) === qn ? (l("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), a.lanes = Hn) : BE(s) ? a.lanes = No : a.lanes = _l, null;
    }
    function dV(a, s, v, _, M, N, G) {
      if (v)
        if (s.flags & ba) {
          s.flags &= ~ba;
          var dt = bA(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return VM(a, s, G, dt);
        } else {
          if (s.memoizedState !== null)
            return s.child = a.child, s.flags |= hr, null;
          var Bt = _.children, ht = _.fallback, tn = cV(a, s, Bt, ht, G), Ln = s.child;
          return Ln.memoizedState = NA(G), s.memoizedState = UA, tn;
        }
      else {
        if (KE(), (s.mode & Cr) === qn)
          return VM(
            a,
            s,
            G,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (BE(M)) {
          var q, te, ge;
          {
            var Ee = Qw(M);
            q = Ee.digest, te = Ee.message, ge = Ee.stack;
          }
          var Ke;
          te ? Ke = new Error(te) : Ke = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var je = bA(Ke, q, ge);
          return VM(a, s, G, je);
        }
        var Et = We(G, a.childLanes);
        if (tm || Et) {
          var wt = JM();
          if (wt !== null) {
            var It = ny(wt, G);
            if (It !== Qr && It !== N.retryLane) {
              N.retryLane = It;
              var Dn = $r;
              jl(a, It), Jl(wt, a, It, Dn);
            }
          }
          iD();
          var fr = bA(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return VM(a, s, G, fr);
        } else if (IE(M)) {
          s.flags |= hr, s.child = a.child;
          var Jn = k6.bind(null, a);
          return Q2(M, Jn), null;
        } else {
          uA(s, M, N.treeContext);
          var Ci = _.children, vi = FA(s, Ci);
          return vi.flags |= Ys, vi;
        }
      }
    }
    function X3(a, s, v) {
      a.lanes = Vt(a.lanes, s);
      var _ = a.alternate;
      _ !== null && (_.lanes = Vt(_.lanes, s)), lv(a.return, s, v);
    }
    function hV(a, s, v) {
      for (var _ = s; _ !== null; ) {
        if (_.tag === B) {
          var M = _.memoizedState;
          M !== null && X3(_, v, a);
        } else if (_.tag === le)
          X3(_, v, a);
        else if (_.child !== null) {
          _.child.return = _, _ = _.child;
          continue;
        }
        if (_ === a)
          return;
        for (; _.sibling === null; ) {
          if (_.return === null || _.return === a)
            return;
          _ = _.return;
        }
        _.sibling.return = _.return, _ = _.sibling;
      }
    }
    function pV(a) {
      for (var s = a, v = null; s !== null; ) {
        var _ = s.alternate;
        _ !== null && I_(_) === null && (v = s), s = s.sibling;
      }
      return v;
    }
    function mV(a) {
      if (a !== void 0 && a !== "forwards" && a !== "backwards" && a !== "together" && !DA[a])
        if (DA[a] = !0, typeof a == "string")
          switch (a.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', a, a.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', a, a.toLowerCase());
              break;
            }
            default:
              l('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
              break;
          }
        else
          l('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
    }
    function vV(a, s) {
      a !== void 0 && !HM[a] && (a !== "collapsed" && a !== "hidden" ? (HM[a] = !0, l('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a)) : s !== "forwards" && s !== "backwards" && (HM[a] = !0, l('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a)));
    }
    function q3(a, s) {
      {
        var v = oo(a), _ = !v && typeof Hr(a) == "function";
        if (v || _) {
          var M = v ? "array" : "iterable";
          return l("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", M, s, M), !1;
        }
      }
      return !0;
    }
    function gV(a, s) {
      if ((s === "forwards" || s === "backwards") && a !== void 0 && a !== null && a !== !1)
        if (oo(a)) {
          for (var v = 0; v < a.length; v++)
            if (!q3(a[v], v))
              return;
        } else {
          var _ = Hr(a);
          if (typeof _ == "function") {
            var M = _.call(a);
            if (M)
              for (var N = M.next(), G = 0; !N.done; N = M.next()) {
                if (!q3(N.value, G))
                  return;
                G++;
              }
          } else
            l('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', s);
        }
    }
    function zA(a, s, v, _, M) {
      var N = a.memoizedState;
      N === null ? a.memoizedState = {
        isBackwards: s,
        rendering: null,
        renderingStartTime: 0,
        last: _,
        tail: v,
        tailMode: M
      } : (N.isBackwards = s, N.rendering = null, N.renderingStartTime = 0, N.last = _, N.tail = v, N.tailMode = M);
    }
    function K3(a, s, v) {
      var _ = s.pendingProps, M = _.revealOrder, N = _.tail, G = _.children;
      mV(M), vV(N, M), gV(G, M), Mf(a, s, G, v);
      var q = Ho.current, te = dv(q, wS);
      if (te)
        q = hv(q, wS), s.flags |= hr;
      else {
        var ge = a !== null && (a.flags & hr) !== Xn;
        ge && hV(s, s.child, v), q = Yy(q);
      }
      if (ep(s, q), (s.mode & Cr) === qn)
        s.memoizedState = null;
      else
        switch (M) {
          case "forwards": {
            var Ee = pV(s.child), Ke;
            Ee === null ? (Ke = s.child, s.child = null) : (Ke = Ee.sibling, Ee.sibling = null), zA(
              s,
              !1,
              // isBackwards
              Ke,
              Ee,
              N
            );
            break;
          }
          case "backwards": {
            var je = null, Et = s.child;
            for (s.child = null; Et !== null; ) {
              var wt = Et.alternate;
              if (wt !== null && I_(wt) === null) {
                s.child = Et;
                break;
              }
              var It = Et.sibling;
              Et.sibling = je, je = Et, Et = It;
            }
            zA(
              s,
              !0,
              // isBackwards
              je,
              null,
              // last
              N
            );
            break;
          }
          case "together": {
            zA(
              s,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            s.memoizedState = null;
        }
      return s.child;
    }
    function yV(a, s, v) {
      TS(s, s.stateNode.containerInfo);
      var _ = s.pendingProps;
      return a === null ? s.child = Vy(s, null, _, v) : Mf(a, s, _, v), s.child;
    }
    var Q3 = !1;
    function SV(a, s, v) {
      var _ = s.type, M = _._context, N = s.pendingProps, G = s.memoizedProps, q = N.value;
      {
        "value" in N || Q3 || (Q3 = !0, l("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var te = s.type.propTypes;
        te && ih(te, N, "prop", "Context.Provider");
      }
      if (gS(s, M, q), G !== null) {
        var ge = G.value;
        if (Un(ge, q)) {
          if (G.children === N.children && !Py())
            return bg(a, s, v);
        } else
          hg(s, M, v);
      }
      var Ee = N.children;
      return Mf(a, s, Ee, v), s.child;
    }
    var Z3 = !1;
    function xV(a, s, v) {
      var _ = s.type;
      _._context === void 0 ? _ !== _.Consumer && (Z3 || (Z3 = !0, l("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : _ = _._context;
      var M = s.pendingProps, N = M.children;
      typeof N != "function" && l("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Kh(s, v);
      var G = Io(_);
      qi(s);
      var q;
      return Nb.current = s, qr(!0), q = N(G), qr(!1), na(), s.flags |= pi, Mf(a, s, q, v), s.child;
    }
    function kb() {
      tm = !0;
    }
    function GM(a, s) {
      (s.mode & Cr) === qn && a !== null && (a.alternate = null, s.alternate = null, s.flags |= Nr);
    }
    function bg(a, s, v) {
      return a !== null && (s.dependencies = a.dependencies), K_(), qb(s.lanes), We(v, s.childLanes) ? (mA(a, s), s.child) : null;
    }
    function _V(a, s, v) {
      {
        var _ = s.return;
        if (_ === null)
          throw new Error("Cannot swap the root fiber.");
        if (a.alternate = null, s.alternate = null, v.index = s.index, v.sibling = s.sibling, v.return = s.return, v.ref = s.ref, s === _.child)
          _.child = v;
        else {
          var M = _.child;
          if (M === null)
            throw new Error("Expected parent to have a child.");
          for (; M.sibling !== s; )
            if (M = M.sibling, M === null)
              throw new Error("Expected to find the previous sibling.");
          M.sibling = v;
        }
        var N = _.deletions;
        return N === null ? (_.deletions = [a], _.flags |= Zr) : N.push(a), v.flags |= Nr, v;
      }
    }
    function IA(a, s) {
      var v = a.lanes;
      return !!We(v, s);
    }
    function EV(a, s, v) {
      switch (s.tag) {
        case x:
          W3(s), s.stateNode, av();
          break;
        case w:
          z_(s);
          break;
        case p: {
          var _ = s.type;
          oh(_) && d_(s);
          break;
        }
        case b:
          TS(s, s.stateNode.containerInfo);
          break;
        case F: {
          var M = s.memoizedProps.value, N = s.type._context;
          gS(s, N, M);
          break;
        }
        case H:
          {
            var G = We(v, s.childLanes);
            G && (s.flags |= In);
            {
              var q = s.stateNode;
              q.effectDuration = 0, q.passiveEffectDuration = 0;
            }
          }
          break;
        case B: {
          var te = s.memoizedState;
          if (te !== null) {
            if (te.dehydrated !== null)
              return ep(s, Yy(Ho.current)), s.flags |= hr, null;
            var ge = s.child, Ee = ge.childLanes;
            if (We(v, Ee))
              return $3(a, s, v);
            ep(s, Yy(Ho.current));
            var Ke = bg(a, s, v);
            return Ke !== null ? Ke.sibling : null;
          } else
            ep(s, Yy(Ho.current));
          break;
        }
        case le: {
          var je = (a.flags & hr) !== Xn, Et = We(v, s.childLanes);
          if (je) {
            if (Et)
              return K3(a, s, v);
            s.flags |= hr;
          }
          var wt = s.memoizedState;
          if (wt !== null && (wt.rendering = null, wt.tail = null, wt.lastEffect = null), ep(s, Ho.current), Et)
            break;
          return null;
        }
        case fe:
        case de:
          return s.lanes = Nt, H3(a, s, v);
      }
      return bg(a, s, v);
    }
    function J3(a, s, v) {
      if (s._debugNeedsRemount && a !== null)
        return _V(a, s, mD(s.type, s.key, s.pendingProps, s._debugOwner || null, s.mode, s.lanes));
      if (a !== null) {
        var _ = a.memoizedProps, M = s.pendingProps;
        if (_ !== M || Py() || // Force a re-render if the implementation changed due to hot reload:
        s.type !== a.type)
          tm = !0;
        else {
          var N = IA(a, v);
          if (!N && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (s.flags & hr) === Xn)
            return tm = !1, EV(a, s, v);
          (a.flags & Ch) !== Xn ? tm = !0 : tm = !1;
        }
      } else if (tm = !1, Ma() && pM(s)) {
        var G = s.index, q = hd();
        mM(s, q, G);
      }
      switch (s.lanes = Nt, s.tag) {
        case y:
          return rV(a, s, s.type, v);
        case J: {
          var te = s.elementType;
          return tV(a, s, te, v);
        }
        case h: {
          var ge = s.type, Ee = s.pendingProps, Ke = s.elementType === ge ? Ee : Ku(ge, Ee);
          return LA(a, s, ge, Ke, v);
        }
        case p: {
          var je = s.type, Et = s.pendingProps, wt = s.elementType === je ? Et : Ku(je, Et);
          return G3(a, s, je, wt, v);
        }
        case x:
          return ZH(a, s, v);
        case w:
          return JH(a, s, v);
        case R:
          return eV(a, s);
        case B:
          return $3(a, s, v);
        case b:
          return yV(a, s, v);
        case k: {
          var It = s.type, Dn = s.pendingProps, fr = s.elementType === It ? Dn : Ku(It, Dn);
          return z3(a, s, It, fr, v);
        }
        case U:
          return qH(a, s, v);
        case L:
          return KH(a, s, v);
        case H:
          return QH(a, s, v);
        case F:
          return SV(a, s, v);
        case A:
          return xV(a, s, v);
        case $: {
          var Jn = s.type, Ci = s.pendingProps, vi = Ku(Jn, Ci);
          if (s.type !== s.elementType) {
            var dt = Jn.propTypes;
            dt && ih(
              dt,
              vi,
              // Resolved for outer only
              "prop",
              ei(Jn)
            );
          }
          return vi = Ku(Jn.type, vi), I3(a, s, Jn, vi, v);
        }
        case Y:
          return B3(a, s, s.type, s.pendingProps, v);
        case K: {
          var Bt = s.type, ht = s.pendingProps, tn = s.elementType === Bt ? ht : Ku(Bt, ht);
          return nV(a, s, Bt, tn, v);
        }
        case le:
          return K3(a, s, v);
        case oe:
          break;
        case fe:
          return H3(a, s, v);
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Q_(a) {
      a.flags |= In;
    }
    function eU(a) {
      a.flags |= gs, a.flags |= Qf;
    }
    var tU, BA, nU, rU;
    tU = function(a, s, v, _) {
      for (var M = s.child; M !== null; ) {
        if (M.tag === w || M.tag === R)
          z2(a, M.stateNode);
        else if (M.tag !== b) {
          if (M.child !== null) {
            M.child.return = M, M = M.child;
            continue;
          }
        }
        if (M === s)
          return;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === s)
            return;
          M = M.return;
        }
        M.sibling.return = M.return, M = M.sibling;
      }
    }, BA = function(a, s) {
    }, nU = function(a, s, v, _, M) {
      var N = a.memoizedProps;
      if (N !== _) {
        var G = s.stateNode, q = gg(), te = I2(G, v, N, _, M, q);
        s.updateQueue = te, te && Q_(s);
      }
    }, rU = function(a, s, v, _) {
      v !== _ && Q_(s);
    };
    function zb(a, s) {
      if (!Ma())
        switch (a.tailMode) {
          case "hidden": {
            for (var v = a.tail, _ = null; v !== null; )
              v.alternate !== null && (_ = v), v = v.sibling;
            _ === null ? a.tail = null : _.sibling = null;
            break;
          }
          case "collapsed": {
            for (var M = a.tail, N = null; M !== null; )
              M.alternate !== null && (N = M), M = M.sibling;
            N === null ? !s && a.tail !== null ? a.tail.sibling = null : a.tail = null : N.sibling = null;
            break;
          }
        }
    }
    function Qu(a) {
      var s = a.alternate !== null && a.alternate.child === a.child, v = Nt, _ = Xn;
      if (s) {
        if ((a.mode & Kn) !== qn) {
          for (var te = a.selfBaseDuration, ge = a.child; ge !== null; )
            v = Vt(v, Vt(ge.lanes, ge.childLanes)), _ |= ge.subtreeFlags & nn, _ |= ge.flags & nn, te += ge.treeBaseDuration, ge = ge.sibling;
          a.treeBaseDuration = te;
        } else
          for (var Ee = a.child; Ee !== null; )
            v = Vt(v, Vt(Ee.lanes, Ee.childLanes)), _ |= Ee.subtreeFlags & nn, _ |= Ee.flags & nn, Ee.return = a, Ee = Ee.sibling;
        a.subtreeFlags |= _;
      } else {
        if ((a.mode & Kn) !== qn) {
          for (var M = a.actualDuration, N = a.selfBaseDuration, G = a.child; G !== null; )
            v = Vt(v, Vt(G.lanes, G.childLanes)), _ |= G.subtreeFlags, _ |= G.flags, M += G.actualDuration, N += G.treeBaseDuration, G = G.sibling;
          a.actualDuration = M, a.treeBaseDuration = N;
        } else
          for (var q = a.child; q !== null; )
            v = Vt(v, Vt(q.lanes, q.childLanes)), _ |= q.subtreeFlags, _ |= q.flags, q.return = a, q = q.sibling;
        a.subtreeFlags |= _;
      }
      return a.childLanes = v, s;
    }
    function bV(a, s, v) {
      if (ch() && (s.mode & Cr) !== qn && (s.flags & hr) === Xn)
        return es(s), av(), s.flags |= ba | ys | xo, !1;
      var _ = Va(s);
      if (v !== null && v.dehydrated !== null)
        if (a === null) {
          if (!_)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (fA(s), Qu(s), (s.mode & Kn) !== qn) {
            var M = v !== null;
            if (M) {
              var N = s.child;
              N !== null && (s.treeBaseDuration -= N.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (av(), (s.flags & hr) === Xn && (s.memoizedState = null), s.flags |= In, Qu(s), (s.mode & Kn) !== qn) {
            var G = v !== null;
            if (G) {
              var q = s.child;
              q !== null && (s.treeBaseDuration -= q.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return Gl(), !0;
    }
    function iU(a, s, v) {
      var _ = s.pendingProps;
      switch (ky(s), s.tag) {
        case y:
        case J:
        case Y:
        case h:
        case k:
        case U:
        case L:
        case H:
        case A:
        case $:
          return Qu(s), null;
        case p: {
          var M = s.type;
          return oh(M) && f_(s), Qu(s), null;
        }
        case x: {
          var N = s.stateNode;
          if (jy(s), Uy(s), MS(), N.pendingContext && (N.context = N.pendingContext, N.pendingContext = null), a === null || a.child === null) {
            var G = Va(s);
            if (G)
              Q_(s);
            else if (a !== null) {
              var q = a.memoizedState;
              // Check if this is a client root
              (!q.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (s.flags & ba) !== Xn) && (s.flags |= $s, Gl());
            }
          }
          return BA(a, s), Qu(s), null;
        }
        case w: {
          $y(s);
          var te = gb(), ge = s.type;
          if (a !== null && s.stateNode != null)
            nU(a, s, ge, _, te), a.ref !== s.ref && eU(s);
          else {
            if (!_) {
              if (s.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Qu(s), null;
            }
            var Ee = gg(), Ke = Va(s);
            if (Ke)
              cA(s, te, Ee) && Q_(s);
            else {
              var je = Hw(ge, _, te, Ee, s);
              tU(je, s, !1, !1), s.stateNode = je, Vw(je, ge, _, te) && Q_(s);
            }
            s.ref !== null && eU(s);
          }
          return Qu(s), null;
        }
        case R: {
          var Et = _;
          if (a && s.stateNode != null) {
            var wt = a.memoizedProps;
            rU(a, s, wt, Et);
          } else {
            if (typeof Et != "string" && s.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var It = gb(), Dn = gg(), fr = Va(s);
            fr ? SM(s) && Q_(s) : s.stateNode = B2(Et, It, Dn, s);
          }
          return Qu(s), null;
        }
        case B: {
          yg(s);
          var Jn = s.memoizedState;
          if (a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            var Ci = bV(a, s, Jn);
            if (!Ci)
              return s.flags & xo ? s : null;
          }
          if ((s.flags & hr) !== Xn)
            return s.lanes = v, (s.mode & Kn) !== qn && EA(s), s;
          var vi = Jn !== null, dt = a !== null && a.memoizedState !== null;
          if (vi !== dt && vi) {
            var Bt = s.child;
            if (Bt.flags |= mc, (s.mode & Cr) !== qn) {
              var ht = a === null && (s.memoizedProps.unstable_avoidThisFallback !== !0 || !ee);
              ht || dv(Ho.current, NM) ? T6() : iD();
            }
          }
          var tn = s.updateQueue;
          if (tn !== null && (s.flags |= In), Qu(s), (s.mode & Kn) !== qn && vi) {
            var Ln = s.child;
            Ln !== null && (s.treeBaseDuration -= Ln.treeBaseDuration);
          }
          return null;
        }
        case b:
          return jy(s), BA(a, s), a === null && Dy(s.stateNode.containerInfo), Qu(s), null;
        case F:
          var Mn = s.type._context;
          return yS(Mn, s), Qu(s), null;
        case K: {
          var br = s.type;
          return oh(br) && f_(s), Qu(s), null;
        }
        case le: {
          yg(s);
          var Pr = s.memoizedState;
          if (Pr === null)
            return Qu(s), null;
          var ga = (s.flags & hr) !== Xn, ji = Pr.rendering;
          if (ji === null)
            if (ga)
              zb(Pr, !1);
            else {
              var il = M6() && (a === null || (a.flags & hr) === Xn);
              if (!il)
                for (var $i = s.child; $i !== null; ) {
                  var Ds = I_($i);
                  if (Ds !== null) {
                    ga = !0, s.flags |= hr, zb(Pr, !1);
                    var Pc = Ds.updateQueue;
                    return Pc !== null && (s.updateQueue = Pc, s.flags |= In), s.subtreeFlags = Xn, PM(s, v), ep(s, hv(Ho.current, wS)), s.child;
                  }
                  $i = $i.sibling;
                }
              Pr.tail !== null && sa() > wU() && (s.flags |= hr, ga = !0, zb(Pr, !1), s.lanes = mf);
            }
          else {
            if (!ga) {
              var nc = I_(ji);
              if (nc !== null) {
                s.flags |= hr, ga = !0;
                var ph = nc.updateQueue;
                if (ph !== null && (s.updateQueue = ph, s.flags |= In), zb(Pr, !0), Pr.tail === null && Pr.tailMode === "hidden" && !ji.alternate && !Ma())
                  return Qu(s), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                sa() * 2 - Pr.renderingStartTime > wU() && v !== _l && (s.flags |= hr, ga = !0, zb(Pr, !1), s.lanes = mf);
            }
            if (Pr.isBackwards)
              ji.sibling = s.child, s.child = ji;
            else {
              var Af = Pr.last;
              Af !== null ? Af.sibling = ji : s.child = ji, Pr.last = ji;
            }
          }
          if (Pr.tail !== null) {
            var Df = Pr.tail;
            Pr.rendering = Df, Pr.tail = Df.sibling, Pr.renderingStartTime = sa(), Df.sibling = null;
            var Uc = Ho.current;
            return ga ? Uc = hv(Uc, wS) : Uc = Yy(Uc), ep(s, Uc), Df;
          }
          return Qu(s), null;
        }
        case oe:
          break;
        case fe:
        case de: {
          rD(s);
          var Rg = s.memoizedState, a1 = Rg !== null;
          if (a !== null) {
            var eT = a.memoizedState, yv = eT !== null;
            yv !== a1 && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !re && (s.flags |= mc);
          }
          return !a1 || (s.mode & Cr) === qn ? Qu(s) : We(gv, _l) && (Qu(s), s.subtreeFlags & (Nr | In) && (s.flags |= mc)), null;
        }
        case xe:
          return null;
        case _e:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function TV(a, s, v) {
      switch (ky(s), s.tag) {
        case p: {
          var _ = s.type;
          oh(_) && f_(s);
          var M = s.flags;
          return M & xo ? (s.flags = M & ~xo | hr, (s.mode & Kn) !== qn && EA(s), s) : null;
        }
        case x: {
          s.stateNode, jy(s), Uy(s), MS();
          var N = s.flags;
          return (N & xo) !== Xn && (N & hr) === Xn ? (s.flags = N & ~xo | hr, s) : null;
        }
        case w:
          return $y(s), null;
        case B: {
          yg(s);
          var G = s.memoizedState;
          if (G !== null && G.dehydrated !== null) {
            if (s.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            av();
          }
          var q = s.flags;
          return q & xo ? (s.flags = q & ~xo | hr, (s.mode & Kn) !== qn && EA(s), s) : null;
        }
        case le:
          return yg(s), null;
        case b:
          return jy(s), null;
        case F:
          var te = s.type._context;
          return yS(te, s), null;
        case fe:
        case de:
          return rD(s), null;
        case xe:
          return null;
        default:
          return null;
      }
    }
    function aU(a, s, v) {
      switch (ky(s), s.tag) {
        case p: {
          var _ = s.type.childContextTypes;
          _ != null && f_(s);
          break;
        }
        case x: {
          s.stateNode, jy(s), Uy(s), MS();
          break;
        }
        case w: {
          $y(s);
          break;
        }
        case b:
          jy(s);
          break;
        case B:
          yg(s);
          break;
        case le:
          yg(s);
          break;
        case F:
          var M = s.type._context;
          yS(M, s);
          break;
        case fe:
        case de:
          rD(s);
          break;
      }
    }
    var oU = null;
    oU = /* @__PURE__ */ new Set();
    var WM = !1, Zu = !1, wV = typeof WeakSet == "function" ? WeakSet : Set, Bn = null, Z_ = null, J_ = null;
    function MV(a) {
      pc(null, function() {
        throw a;
      }), Vd();
    }
    var CV = function(a, s) {
      if (s.props = a.memoizedProps, s.state = a.memoizedState, a.mode & Kn)
        try {
          mv(), s.componentWillUnmount();
        } finally {
          ap(a);
        }
      else
        s.componentWillUnmount();
    };
    function sU(a, s) {
      try {
        t0(rs, a);
      } catch (v) {
        ro(a, s, v);
      }
    }
    function HA(a, s, v) {
      try {
        CV(a, v);
      } catch (_) {
        ro(a, s, _);
      }
    }
    function RV(a, s, v) {
      try {
        v.componentDidMount();
      } catch (_) {
        ro(a, s, _);
      }
    }
    function lU(a, s) {
      try {
        cU(a);
      } catch (v) {
        ro(a, s, v);
      }
    }
    function e1(a, s) {
      var v = a.ref;
      if (v !== null)
        if (typeof v == "function") {
          var _;
          try {
            if (Ue && Ne && a.mode & Kn)
              try {
                mv(), _ = v(null);
              } finally {
                ap(a);
              }
            else
              _ = v(null);
          } catch (M) {
            ro(a, s, M);
          }
          typeof _ == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", nr(a));
        } else
          v.current = null;
    }
    function jM(a, s, v) {
      try {
        v();
      } catch (_) {
        ro(a, s, _);
      }
    }
    var uU = !1;
    function AV(a, s) {
      Bw(a.containerInfo), Bn = s, DV();
      var v = uU;
      return uU = !1, v;
    }
    function DV() {
      for (; Bn !== null; ) {
        var a = Bn, s = a.child;
        (a.subtreeFlags & gr) !== Xn && s !== null ? (s.return = a, Bn = s) : LV();
      }
    }
    function LV() {
      for (; Bn !== null; ) {
        var a = Bn;
        gi(a);
        try {
          OV(a);
        } catch (v) {
          ro(a, a.return, v);
        }
        fa();
        var s = a.sibling;
        if (s !== null) {
          s.return = a.return, Bn = s;
          return;
        }
        Bn = a.return;
      }
    }
    function OV(a) {
      var s = a.alternate, v = a.flags;
      if ((v & $s) !== Xn) {
        switch (gi(a), a.tag) {
          case h:
          case k:
          case Y:
            break;
          case p: {
            if (s !== null) {
              var _ = s.memoizedProps, M = s.memoizedState, N = a.stateNode;
              a.type === a.elementType && !kS && (N.props !== a.memoizedProps && l("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", nr(a) || "instance"), N.state !== a.memoizedState && l("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", nr(a) || "instance"));
              var G = N.getSnapshotBeforeUpdate(a.elementType === a.type ? _ : Ku(a.type, _), M);
              {
                var q = oU;
                G === void 0 && !q.has(a.type) && (q.add(a.type), l("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", nr(a)));
              }
              N.__reactInternalSnapshotBeforeUpdate = G;
            }
            break;
          }
          case x: {
            {
              var te = a.stateNode;
              q2(te.containerInfo);
            }
            break;
          }
          case w:
          case R:
          case b:
          case K:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        fa();
      }
    }
    function nm(a, s, v) {
      var _ = s.updateQueue, M = _ !== null ? _.lastEffect : null;
      if (M !== null) {
        var N = M.next, G = N;
        do {
          if ((G.tag & a) === a) {
            var q = G.destroy;
            G.destroy = void 0, q !== void 0 && ((a & Yl) !== Ac ? lf(s) : (a & rs) !== Ac && mu(s), (a & tp) !== Ac && Qb(!0), jM(s, v, q), (a & tp) !== Ac && Qb(!1), (a & Yl) !== Ac ? fo() : (a & rs) !== Ac && Jf());
          }
          G = G.next;
        } while (G !== N);
      }
    }
    function t0(a, s) {
      var v = s.updateQueue, _ = v !== null ? v.lastEffect : null;
      if (_ !== null) {
        var M = _.next, N = M;
        do {
          if ((N.tag & a) === a) {
            (a & Yl) !== Ac ? ti(s) : (a & rs) !== Ac && jd(s);
            var G = N.create;
            (a & tp) !== Ac && Qb(!0), N.destroy = G(), (a & tp) !== Ac && Qb(!1), (a & Yl) !== Ac ? Xs() : (a & rs) !== Ac && Bu();
            {
              var q = N.destroy;
              if (q !== void 0 && typeof q != "function") {
                var te = void 0;
                (N.tag & rs) !== Xn ? te = "useLayoutEffect" : (N.tag & tp) !== Xn ? te = "useInsertionEffect" : te = "useEffect";
                var ge = void 0;
                q === null ? ge = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof q.then == "function" ? ge = `

It looks like you wrote ` + te + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + te + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : ge = " You returned: " + q, l("%s must not return anything besides a function, which is used for clean-up.%s", te, ge);
              }
            }
          }
          N = N.next;
        } while (N !== M);
      }
    }
    function PV(a, s) {
      if ((s.flags & In) !== Xn)
        switch (s.tag) {
          case H: {
            var v = s.stateNode.passiveEffectDuration, _ = s.memoizedProps, M = _.id, N = _.onPostCommit, G = Eg(), q = s.alternate === null ? "mount" : "update";
            Lc() && (q = "nested-update"), typeof N == "function" && N(M, q, v, G);
            var te = s.return;
            e:
              for (; te !== null; ) {
                switch (te.tag) {
                  case x:
                    var ge = te.stateNode;
                    ge.passiveEffectDuration += v;
                    break e;
                  case H:
                    var Ee = te.stateNode;
                    Ee.passiveEffectDuration += v;
                    break e;
                }
                te = te.return;
              }
            break;
          }
        }
    }
    function UV(a, s, v, _) {
      if ((v.flags & Ta) !== Xn)
        switch (v.tag) {
          case h:
          case k:
          case Y: {
            if (!Zu)
              if (v.mode & Kn)
                try {
                  mv(), t0(rs | ns, v);
                } finally {
                  ap(v);
                }
              else
                t0(rs | ns, v);
            break;
          }
          case p: {
            var M = v.stateNode;
            if (v.flags & In && !Zu)
              if (s === null)
                if (v.type === v.elementType && !kS && (M.props !== v.memoizedProps && l("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", nr(v) || "instance"), M.state !== v.memoizedState && l("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", nr(v) || "instance")), v.mode & Kn)
                  try {
                    mv(), M.componentDidMount();
                  } finally {
                    ap(v);
                  }
                else
                  M.componentDidMount();
              else {
                var N = v.elementType === v.type ? s.memoizedProps : Ku(v.type, s.memoizedProps), G = s.memoizedState;
                if (v.type === v.elementType && !kS && (M.props !== v.memoizedProps && l("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", nr(v) || "instance"), M.state !== v.memoizedState && l("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", nr(v) || "instance")), v.mode & Kn)
                  try {
                    mv(), M.componentDidUpdate(N, G, M.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ap(v);
                  }
                else
                  M.componentDidUpdate(N, G, M.__reactInternalSnapshotBeforeUpdate);
              }
            var q = v.updateQueue;
            q !== null && (v.type === v.elementType && !kS && (M.props !== v.memoizedProps && l("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", nr(v) || "instance"), M.state !== v.memoizedState && l("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", nr(v) || "instance")), xS(v, q, M));
            break;
          }
          case x: {
            var te = v.updateQueue;
            if (te !== null) {
              var ge = null;
              if (v.child !== null)
                switch (v.child.tag) {
                  case w:
                    ge = v.child.stateNode;
                    break;
                  case p:
                    ge = v.child.stateNode;
                    break;
                }
              xS(v, te, ge);
            }
            break;
          }
          case w: {
            var Ee = v.stateNode;
            if (s === null && v.flags & In) {
              var Ke = v.type, je = v.memoizedProps;
              Ww(Ee, Ke, je);
            }
            break;
          }
          case R:
            break;
          case b:
            break;
          case H: {
            {
              var Et = v.memoizedProps, wt = Et.onCommit, It = Et.onRender, Dn = v.stateNode.effectDuration, fr = Eg(), Jn = s === null ? "mount" : "update";
              Lc() && (Jn = "nested-update"), typeof It == "function" && It(v.memoizedProps.id, Jn, v.actualDuration, v.treeBaseDuration, v.actualStartTime, fr);
              {
                typeof wt == "function" && wt(v.memoizedProps.id, Jn, Dn, fr), L6(v);
                var Ci = v.return;
                e:
                  for (; Ci !== null; ) {
                    switch (Ci.tag) {
                      case x:
                        var vi = Ci.stateNode;
                        vi.effectDuration += Dn;
                        break e;
                      case H:
                        var dt = Ci.stateNode;
                        dt.effectDuration += Dn;
                        break e;
                    }
                    Ci = Ci.return;
                  }
              }
            }
            break;
          }
          case B: {
            VV(a, v);
            break;
          }
          case le:
          case K:
          case oe:
          case fe:
          case de:
          case _e:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Zu || v.flags & gs && cU(v);
    }
    function NV(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          if (a.mode & Kn)
            try {
              mv(), sU(a, a.return);
            } finally {
              ap(a);
            }
          else
            sU(a, a.return);
          break;
        }
        case p: {
          var s = a.stateNode;
          typeof s.componentDidMount == "function" && RV(a, a.return, s), lU(a, a.return);
          break;
        }
        case w: {
          lU(a, a.return);
          break;
        }
      }
    }
    function FV(a, s) {
      for (var v = null, _ = a; ; ) {
        if (_.tag === w) {
          if (v === null) {
            v = _;
            try {
              var M = _.stateNode;
              s ? qw(M) : Y2(_.stateNode, _.memoizedProps);
            } catch (G) {
              ro(a, a.return, G);
            }
          }
        } else if (_.tag === R) {
          if (v === null)
            try {
              var N = _.stateNode;
              s ? $2(N) : X2(N, _.memoizedProps);
            } catch (G) {
              ro(a, a.return, G);
            }
        } else if (!((_.tag === fe || _.tag === de) && _.memoizedState !== null && _ !== a)) {
          if (_.child !== null) {
            _.child.return = _, _ = _.child;
            continue;
          }
        }
        if (_ === a)
          return;
        for (; _.sibling === null; ) {
          if (_.return === null || _.return === a)
            return;
          v === _ && (v = null), _ = _.return;
        }
        v === _ && (v = null), _.sibling.return = _.return, _ = _.sibling;
      }
    }
    function cU(a) {
      var s = a.ref;
      if (s !== null) {
        var v = a.stateNode, _;
        switch (a.tag) {
          case w:
            _ = v;
            break;
          default:
            _ = v;
        }
        if (typeof s == "function") {
          var M;
          if (a.mode & Kn)
            try {
              mv(), M = s(_);
            } finally {
              ap(a);
            }
          else
            M = s(_);
          typeof M == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", nr(a));
        } else
          s.hasOwnProperty("current") || l("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", nr(a)), s.current = _;
      }
    }
    function kV(a) {
      var s = a.alternate;
      s !== null && (s.return = null), a.return = null;
    }
    function fU(a) {
      var s = a.alternate;
      s !== null && (a.alternate = null, fU(s));
      {
        if (a.child = null, a.deletions = null, a.sibling = null, a.tag === w) {
          var v = a.stateNode;
          v !== null && u_(v);
        }
        a.stateNode = null, a._debugOwner = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
    }
    function zV(a) {
      for (var s = a.return; s !== null; ) {
        if (dU(s))
          return s;
        s = s.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function dU(a) {
      return a.tag === w || a.tag === x || a.tag === b;
    }
    function hU(a) {
      var s = a;
      e:
        for (; ; ) {
          for (; s.sibling === null; ) {
            if (s.return === null || dU(s.return))
              return null;
            s = s.return;
          }
          for (s.sibling.return = s.return, s = s.sibling; s.tag !== w && s.tag !== R && s.tag !== X; ) {
            if (s.flags & Nr || s.child === null || s.tag === b)
              continue e;
            s.child.return = s, s = s.child;
          }
          if (!(s.flags & Nr))
            return s.stateNode;
        }
    }
    function IV(a) {
      var s = zV(a);
      switch (s.tag) {
        case w: {
          var v = s.stateNode;
          s.flags & ui && (i_(v), s.flags &= ~ui);
          var _ = hU(a);
          GA(a, _, v);
          break;
        }
        case x:
        case b: {
          var M = s.stateNode.containerInfo, N = hU(a);
          VA(a, N, M);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function VA(a, s, v) {
      var _ = a.tag, M = _ === w || _ === R;
      if (M) {
        var N = a.stateNode;
        s ? Xw(v, N, s) : $w(v, N);
      } else if (_ !== b) {
        var G = a.child;
        if (G !== null) {
          VA(G, s, v);
          for (var q = G.sibling; q !== null; )
            VA(q, s, v), q = q.sibling;
        }
      }
    }
    function GA(a, s, v) {
      var _ = a.tag, M = _ === w || _ === R;
      if (M) {
        var N = a.stateNode;
        s ? Yw(v, N, s) : FE(v, N);
      } else if (_ !== b) {
        var G = a.child;
        if (G !== null) {
          GA(G, s, v);
          for (var q = G.sibling; q !== null; )
            GA(q, s, v), q = q.sibling;
        }
      }
    }
    var Ju = null, rm = !1;
    function BV(a, s, v) {
      {
        var _ = s;
        e:
          for (; _ !== null; ) {
            switch (_.tag) {
              case w: {
                Ju = _.stateNode, rm = !1;
                break e;
              }
              case x: {
                Ju = _.stateNode.containerInfo, rm = !0;
                break e;
              }
              case b: {
                Ju = _.stateNode.containerInfo, rm = !0;
                break e;
              }
            }
            _ = _.return;
          }
        if (Ju === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        pU(a, s, v), Ju = null, rm = !1;
      }
      kV(v);
    }
    function n0(a, s, v) {
      for (var _ = v.child; _ !== null; )
        pU(a, s, _), _ = _.sibling;
    }
    function pU(a, s, v) {
      switch (dn(v), v.tag) {
        case w:
          Zu || e1(v, s);
        case R: {
          {
            var _ = Ju, M = rm;
            Ju = null, n0(a, s, v), Ju = _, rm = M, Ju !== null && (rm ? W2(Ju, v.stateNode) : a_(Ju, v.stateNode));
          }
          return;
        }
        case X: {
          Ju !== null && (rm ? j2(Ju, v.stateNode) : kE(Ju, v.stateNode));
          return;
        }
        case b: {
          {
            var N = Ju, G = rm;
            Ju = v.stateNode.containerInfo, rm = !0, n0(a, s, v), Ju = N, rm = G;
          }
          return;
        }
        case h:
        case k:
        case $:
        case Y: {
          if (!Zu) {
            var q = v.updateQueue;
            if (q !== null) {
              var te = q.lastEffect;
              if (te !== null) {
                var ge = te.next, Ee = ge;
                do {
                  var Ke = Ee, je = Ke.destroy, Et = Ke.tag;
                  je !== void 0 && ((Et & tp) !== Ac ? jM(v, s, je) : (Et & rs) !== Ac && (mu(v), v.mode & Kn ? (mv(), jM(v, s, je), ap(v)) : jM(v, s, je), Jf())), Ee = Ee.next;
                } while (Ee !== ge);
              }
            }
          }
          n0(a, s, v);
          return;
        }
        case p: {
          if (!Zu) {
            e1(v, s);
            var wt = v.stateNode;
            typeof wt.componentWillUnmount == "function" && HA(v, s, wt);
          }
          n0(a, s, v);
          return;
        }
        case oe: {
          n0(a, s, v);
          return;
        }
        case fe: {
          if (
            // TODO: Remove this dead flag
            v.mode & Cr
          ) {
            var It = Zu;
            Zu = It || v.memoizedState !== null, n0(a, s, v), Zu = It;
          } else
            n0(a, s, v);
          break;
        }
        default: {
          n0(a, s, v);
          return;
        }
      }
    }
    function HV(a) {
      a.memoizedState;
    }
    function VV(a, s) {
      var v = s.memoizedState;
      if (v === null) {
        var _ = s.alternate;
        if (_ !== null) {
          var M = _.memoizedState;
          if (M !== null) {
            var N = M.dehydrated;
            N !== null && eM(N);
          }
        }
      }
    }
    function mU(a) {
      var s = a.updateQueue;
      if (s !== null) {
        a.updateQueue = null;
        var v = a.stateNode;
        v === null && (v = a.stateNode = new wV()), s.forEach(function(_) {
          var M = z6.bind(null, a, _);
          if (!v.has(_)) {
            if (v.add(_), Na)
              if (Z_ !== null && J_ !== null)
                Kb(J_, Z_);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            _.then(M, M);
          }
        });
      }
    }
    function GV(a, s, v) {
      Z_ = v, J_ = a, gi(s), vU(s, a), gi(s), Z_ = null, J_ = null;
    }
    function im(a, s, v) {
      var _ = s.deletions;
      if (_ !== null)
        for (var M = 0; M < _.length; M++) {
          var N = _[M];
          try {
            BV(a, s, N);
          } catch (te) {
            ro(N, s, te);
          }
        }
      var G = Sm();
      if (s.subtreeFlags & uo)
        for (var q = s.child; q !== null; )
          gi(q), vU(q, a), q = q.sibling;
      gi(G);
    }
    function vU(a, s, v) {
      var _ = a.alternate, M = a.flags;
      switch (a.tag) {
        case h:
        case k:
        case $:
        case Y: {
          if (im(s, a), vv(a), M & In) {
            try {
              nm(tp | ns, a, a.return), t0(tp | ns, a);
            } catch (br) {
              ro(a, a.return, br);
            }
            if (a.mode & Kn) {
              try {
                mv(), nm(rs | ns, a, a.return);
              } catch (br) {
                ro(a, a.return, br);
              }
              ap(a);
            } else
              try {
                nm(rs | ns, a, a.return);
              } catch (br) {
                ro(a, a.return, br);
              }
          }
          return;
        }
        case p: {
          im(s, a), vv(a), M & gs && _ !== null && e1(_, _.return);
          return;
        }
        case w: {
          im(s, a), vv(a), M & gs && _ !== null && e1(_, _.return);
          {
            if (a.flags & ui) {
              var N = a.stateNode;
              try {
                i_(N);
              } catch (br) {
                ro(a, a.return, br);
              }
            }
            if (M & In) {
              var G = a.stateNode;
              if (G != null) {
                var q = a.memoizedProps, te = _ !== null ? _.memoizedProps : q, ge = a.type, Ee = a.updateQueue;
                if (a.updateQueue = null, Ee !== null)
                  try {
                    jw(G, Ee, ge, te, q, a);
                  } catch (br) {
                    ro(a, a.return, br);
                  }
              }
            }
          }
          return;
        }
        case R: {
          if (im(s, a), vv(a), M & In) {
            if (a.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Ke = a.stateNode, je = a.memoizedProps, Et = _ !== null ? _.memoizedProps : je;
            try {
              G2(Ke, Et, je);
            } catch (br) {
              ro(a, a.return, br);
            }
          }
          return;
        }
        case x: {
          if (im(s, a), vv(a), M & In && _ !== null) {
            var wt = _.memoizedState;
            if (wt.isDehydrated)
              try {
                Jw(s.containerInfo);
              } catch (br) {
                ro(a, a.return, br);
              }
          }
          return;
        }
        case b: {
          im(s, a), vv(a);
          return;
        }
        case B: {
          im(s, a), vv(a);
          var It = a.child;
          if (It.flags & mc) {
            var Dn = It.stateNode, fr = It.memoizedState, Jn = fr !== null;
            if (Dn.isHidden = Jn, Jn) {
              var Ci = It.alternate !== null && It.alternate.memoizedState !== null;
              Ci || b6();
            }
          }
          if (M & In) {
            try {
              HV(a);
            } catch (br) {
              ro(a, a.return, br);
            }
            mU(a);
          }
          return;
        }
        case fe: {
          var vi = _ !== null && _.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            a.mode & Cr
          ) {
            var dt = Zu;
            Zu = dt || vi, im(s, a), Zu = dt;
          } else
            im(s, a);
          if (vv(a), M & mc) {
            var Bt = a.stateNode, ht = a.memoizedState, tn = ht !== null, Ln = a;
            if (Bt.isHidden = tn, tn && !vi && (Ln.mode & Cr) !== qn) {
              Bn = Ln;
              for (var Mn = Ln.child; Mn !== null; )
                Bn = Mn, jV(Mn), Mn = Mn.sibling;
            }
            FV(Ln, tn);
          }
          return;
        }
        case le: {
          im(s, a), vv(a), M & In && mU(a);
          return;
        }
        case oe:
          return;
        default: {
          im(s, a), vv(a);
          return;
        }
      }
    }
    function vv(a) {
      var s = a.flags;
      if (s & Nr) {
        try {
          IV(a);
        } catch (v) {
          ro(a, a.return, v);
        }
        a.flags &= ~Nr;
      }
      s & Ys && (a.flags &= ~Ys);
    }
    function WV(a, s, v) {
      Z_ = v, J_ = s, Bn = a, gU(a, s, v), Z_ = null, J_ = null;
    }
    function gU(a, s, v) {
      for (var _ = (a.mode & Cr) !== qn; Bn !== null; ) {
        var M = Bn, N = M.child;
        if (M.tag === fe && _) {
          var G = M.memoizedState !== null, q = G || WM;
          if (q) {
            WA(a, s, v);
            continue;
          } else {
            var te = M.alternate, ge = te !== null && te.memoizedState !== null, Ee = ge || Zu, Ke = WM, je = Zu;
            WM = q, Zu = Ee, Zu && !je && (Bn = M, $V(M));
            for (var Et = N; Et !== null; )
              Bn = Et, gU(
                Et,
                // New root; bubble back up to here and stop.
                s,
                v
              ), Et = Et.sibling;
            Bn = M, WM = Ke, Zu = je, WA(a, s, v);
            continue;
          }
        }
        (M.subtreeFlags & Ta) !== Xn && N !== null ? (N.return = M, Bn = N) : WA(a, s, v);
      }
    }
    function WA(a, s, v) {
      for (; Bn !== null; ) {
        var _ = Bn;
        if ((_.flags & Ta) !== Xn) {
          var M = _.alternate;
          gi(_);
          try {
            UV(s, M, _, v);
          } catch (G) {
            ro(_, _.return, G);
          }
          fa();
        }
        if (_ === a) {
          Bn = null;
          return;
        }
        var N = _.sibling;
        if (N !== null) {
          N.return = _.return, Bn = N;
          return;
        }
        Bn = _.return;
      }
    }
    function jV(a) {
      for (; Bn !== null; ) {
        var s = Bn, v = s.child;
        switch (s.tag) {
          case h:
          case k:
          case $:
          case Y: {
            if (s.mode & Kn)
              try {
                mv(), nm(rs, s, s.return);
              } finally {
                ap(s);
              }
            else
              nm(rs, s, s.return);
            break;
          }
          case p: {
            e1(s, s.return);
            var _ = s.stateNode;
            typeof _.componentWillUnmount == "function" && HA(s, s.return, _);
            break;
          }
          case w: {
            e1(s, s.return);
            break;
          }
          case fe: {
            var M = s.memoizedState !== null;
            if (M) {
              yU(a);
              continue;
            }
            break;
          }
        }
        v !== null ? (v.return = s, Bn = v) : yU(a);
      }
    }
    function yU(a) {
      for (; Bn !== null; ) {
        var s = Bn;
        if (s === a) {
          Bn = null;
          return;
        }
        var v = s.sibling;
        if (v !== null) {
          v.return = s.return, Bn = v;
          return;
        }
        Bn = s.return;
      }
    }
    function $V(a) {
      for (; Bn !== null; ) {
        var s = Bn, v = s.child;
        if (s.tag === fe) {
          var _ = s.memoizedState !== null;
          if (_) {
            SU(a);
            continue;
          }
        }
        v !== null ? (v.return = s, Bn = v) : SU(a);
      }
    }
    function SU(a) {
      for (; Bn !== null; ) {
        var s = Bn;
        gi(s);
        try {
          NV(s);
        } catch (_) {
          ro(s, s.return, _);
        }
        if (fa(), s === a) {
          Bn = null;
          return;
        }
        var v = s.sibling;
        if (v !== null) {
          v.return = s.return, Bn = v;
          return;
        }
        Bn = s.return;
      }
    }
    function YV(a, s, v, _) {
      Bn = s, XV(s, a, v, _);
    }
    function XV(a, s, v, _) {
      for (; Bn !== null; ) {
        var M = Bn, N = M.child;
        (M.subtreeFlags & Iu) !== Xn && N !== null ? (N.return = M, Bn = N) : qV(a, s, v, _);
      }
    }
    function qV(a, s, v, _) {
      for (; Bn !== null; ) {
        var M = Bn;
        if ((M.flags & ta) !== Xn) {
          gi(M);
          try {
            KV(s, M, v, _);
          } catch (G) {
            ro(M, M.return, G);
          }
          fa();
        }
        if (M === a) {
          Bn = null;
          return;
        }
        var N = M.sibling;
        if (N !== null) {
          N.return = M.return, Bn = N;
          return;
        }
        Bn = M.return;
      }
    }
    function KV(a, s, v, _) {
      switch (s.tag) {
        case h:
        case k:
        case Y: {
          if (s.mode & Kn) {
            _A();
            try {
              t0(Yl | ns, s);
            } finally {
              Ub(s);
            }
          } else
            t0(Yl | ns, s);
          break;
        }
      }
    }
    function QV(a) {
      Bn = a, ZV();
    }
    function ZV() {
      for (; Bn !== null; ) {
        var a = Bn, s = a.child;
        if ((Bn.flags & Zr) !== Xn) {
          var v = a.deletions;
          if (v !== null) {
            for (var _ = 0; _ < v.length; _++) {
              var M = v[_];
              Bn = M, t6(M, a);
            }
            {
              var N = a.alternate;
              if (N !== null) {
                var G = N.child;
                if (G !== null) {
                  N.child = null;
                  do {
                    var q = G.sibling;
                    G.sibling = null, G = q;
                  } while (G !== null);
                }
              }
            }
            Bn = a;
          }
        }
        (a.subtreeFlags & Iu) !== Xn && s !== null ? (s.return = a, Bn = s) : JV();
      }
    }
    function JV() {
      for (; Bn !== null; ) {
        var a = Bn;
        (a.flags & ta) !== Xn && (gi(a), e6(a), fa());
        var s = a.sibling;
        if (s !== null) {
          s.return = a.return, Bn = s;
          return;
        }
        Bn = a.return;
      }
    }
    function e6(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          a.mode & Kn ? (_A(), nm(Yl | ns, a, a.return), Ub(a)) : nm(Yl | ns, a, a.return);
          break;
        }
      }
    }
    function t6(a, s) {
      for (; Bn !== null; ) {
        var v = Bn;
        gi(v), r6(v, s), fa();
        var _ = v.child;
        _ !== null ? (_.return = v, Bn = _) : n6(a);
      }
    }
    function n6(a) {
      for (; Bn !== null; ) {
        var s = Bn, v = s.sibling, _ = s.return;
        if (fU(s), s === a) {
          Bn = null;
          return;
        }
        if (v !== null) {
          v.return = _, Bn = v;
          return;
        }
        Bn = _;
      }
    }
    function r6(a, s) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          a.mode & Kn ? (_A(), nm(Yl, a, s), Ub(a)) : nm(Yl, a, s);
          break;
        }
      }
    }
    function i6(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          try {
            t0(rs | ns, a);
          } catch (v) {
            ro(a, a.return, v);
          }
          break;
        }
        case p: {
          var s = a.stateNode;
          try {
            s.componentDidMount();
          } catch (v) {
            ro(a, a.return, v);
          }
          break;
        }
      }
    }
    function a6(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          try {
            t0(Yl | ns, a);
          } catch (s) {
            ro(a, a.return, s);
          }
          break;
        }
      }
    }
    function o6(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y: {
          try {
            nm(rs | ns, a, a.return);
          } catch (v) {
            ro(a, a.return, v);
          }
          break;
        }
        case p: {
          var s = a.stateNode;
          typeof s.componentWillUnmount == "function" && HA(a, a.return, s);
          break;
        }
      }
    }
    function s6(a) {
      switch (a.tag) {
        case h:
        case k:
        case Y:
          try {
            nm(Yl | ns, a, a.return);
          } catch (s) {
            ro(a, a.return, s);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Ib = Symbol.for;
      Ib("selector.component"), Ib("selector.has_pseudo_class"), Ib("selector.role"), Ib("selector.test_id"), Ib("selector.text");
    }
    var l6 = [];
    function u6() {
      l6.forEach(function(a) {
        return a();
      });
    }
    var c6 = t.ReactCurrentActQueue;
    function f6(a) {
      {
        var s = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), v = typeof jest < "u";
        return v && s !== !1;
      }
    }
    function xU() {
      {
        var a = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !a && c6.current !== null && l("The current testing environment is not configured to support act(...)"), a;
      }
    }
    var d6 = Math.ceil, jA = t.ReactCurrentDispatcher, $A = t.ReactCurrentOwner, ec = t.ReactCurrentBatchConfig, am = t.ReactCurrentActQueue, Kl = (
      /*             */
      0
    ), _U = (
      /*               */
      1
    ), tc = (
      /*                */
      2
    ), op = (
      /*                */
      4
    ), Tg = 0, Bb = 1, zS = 2, $M = 3, Hb = 4, EU = 5, YA = 6, Mi = Kl, Cf = null, is = null, Ql = Nt, gv = Nt, XA = Yp(Nt), Zl = Tg, Vb = null, YM = Nt, Gb = Nt, XM = Nt, Wb = null, gd = null, qA = 0, bU = 500, TU = 1 / 0, h6 = 500, wg = null;
    function jb() {
      TU = sa() + h6;
    }
    function wU() {
      return TU;
    }
    var qM = !1, KA = null, t1 = null, IS = !1, r0 = null, $b = Nt, QA = [], ZA = null, p6 = 50, Yb = 0, JA = null, eD = !1, KM = !1, m6 = 50, n1 = 0, QM = null, Xb = $r, ZM = Nt, MU = !1;
    function JM() {
      return Cf;
    }
    function Rf() {
      return (Mi & (tc | op)) !== Kl ? sa() : (Xb !== $r || (Xb = sa()), Xb);
    }
    function i0(a) {
      var s = a.mode;
      if ((s & Cr) === qn)
        return Hn;
      if ((Mi & tc) !== Kl && Ql !== Nt)
        return ri(Ql);
      var v = __() !== ug;
      if (v) {
        if (ec.transition !== null) {
          var _ = ec.transition;
          _._updatedFibers || (_._updatedFibers = /* @__PURE__ */ new Set()), _._updatedFibers.add(a);
        }
        return ZM === Qr && (ZM = Qn()), ZM;
      }
      var M = Wu();
      if (M !== Qr)
        return M;
      var N = H2();
      return N;
    }
    function v6(a) {
      var s = a.mode;
      return (s & Cr) === qn ? Hn : Ki();
    }
    function Jl(a, s, v, _) {
      B6(), MU && l("useInsertionEffect must not schedule updates."), eD && (KM = !0), kr(a, v, _), (Mi & tc) !== Nt && a === Cf ? G6(s) : (Na && ry(a, s, v), W6(s), a === Cf && ((Mi & tc) === Kl && (Gb = Vt(Gb, v)), Zl === Hb && a0(a, Ql)), yd(a, _), v === Hn && Mi === Kl && (s.mode & Cr) === qn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !am.isBatchingLegacy && (jb(), hM()));
    }
    function g6(a, s, v) {
      var _ = a.current;
      _.lanes = s, kr(a, s, v), yd(a, v);
    }
    function y6(a) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Mi & tc) !== Kl
      );
    }
    function yd(a, s) {
      var v = a.callbackNode;
      S(a, s);
      var _ = Sc(a, a === Cf ? Ql : Nt);
      if (_ === Nt) {
        v !== null && VU(v), a.callbackNode = null, a.callbackPriority = Qr;
        return;
      }
      var M = hn(_), N = a.callbackPriority;
      if (N === M && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(am.current !== null && v !== sD)) {
        v == null && N !== Hn && l("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      v != null && VU(v);
      var G;
      if (M === Hn)
        a.tag === nv ? (am.isBatchingLegacy !== null && (am.didScheduleLegacyUpdate = !0), dM(AU.bind(null, a))) : fM(AU.bind(null, a)), am.current !== null ? am.current.push(rv) : Gw(function() {
          (Mi & (tc | op)) === Kl && rv();
        }), G = null;
      else {
        var q;
        switch (Op(_)) {
          case bs:
            q = Um;
            break;
          case Qo:
            q = vl;
            break;
          case yf:
            q = pu;
            break;
          case Dp:
            q = sf;
            break;
          default:
            q = pu;
            break;
        }
        G = lD(q, CU.bind(null, a));
      }
      a.callbackPriority = M, a.callbackNode = G;
    }
    function CU(a, s) {
      if (ip(), Xb = $r, ZM = Nt, (Mi & (tc | op)) !== Kl)
        throw new Error("Should not already be working.");
      var v = a.callbackNode, _ = Cg();
      if (_ && a.callbackNode !== v)
        return null;
      var M = Sc(a, a === Cf ? Ql : Nt);
      if (M === Nt)
        return null;
      var N = !Jt(a, M) && !ln(a, M) && !s, G = N ? R6(a, M) : tC(a, M);
      if (G !== Tg) {
        if (G === zS) {
          var q = z(a);
          q !== Nt && (M = q, G = tD(a, q));
        }
        if (G === Bb) {
          var te = Vb;
          throw BS(a, Nt), a0(a, M), yd(a, sa()), te;
        }
        if (G === YA)
          a0(a, M);
        else {
          var ge = !Jt(a, M), Ee = a.current.alternate;
          if (ge && !x6(Ee)) {
            if (G = tC(a, M), G === zS) {
              var Ke = z(a);
              Ke !== Nt && (M = Ke, G = tD(a, Ke));
            }
            if (G === Bb) {
              var je = Vb;
              throw BS(a, Nt), a0(a, M), yd(a, sa()), je;
            }
          }
          a.finishedWork = Ee, a.finishedLanes = M, S6(a, G, M);
        }
      }
      return yd(a, sa()), a.callbackNode === v ? CU.bind(null, a) : null;
    }
    function tD(a, s) {
      var v = Wb;
      if (Mo(a)) {
        var _ = BS(a, s);
        _.flags |= ba, _n(a.containerInfo);
      }
      var M = tC(a, s);
      if (M !== zS) {
        var N = gd;
        gd = v, N !== null && RU(N);
      }
      return M;
    }
    function RU(a) {
      gd === null ? gd = a : gd.push.apply(gd, a);
    }
    function S6(a, s, v) {
      switch (s) {
        case Tg:
        case Bb:
          throw new Error("Root did not complete. This is a bug in React.");
        case zS: {
          HS(a, gd, wg);
          break;
        }
        case $M: {
          if (a0(a, v), we(v) && // do not delay if we're inside an act() scope
          !GU()) {
            var _ = qA + bU - sa();
            if (_ > 10) {
              var M = Sc(a, Nt);
              if (M !== Nt)
                break;
              var N = a.suspendedLanes;
              if (!Mt(N, v)) {
                Rf(), Oh(a, N);
                break;
              }
              a.timeoutHandle = UE(HS.bind(null, a, gd, wg), _);
              break;
            }
          }
          HS(a, gd, wg);
          break;
        }
        case Hb: {
          if (a0(a, v), Ot(v))
            break;
          if (!GU()) {
            var G = Bm(a, v), q = G, te = sa() - q, ge = I6(te) - te;
            if (ge > 10) {
              a.timeoutHandle = UE(HS.bind(null, a, gd, wg), ge);
              break;
            }
          }
          HS(a, gd, wg);
          break;
        }
        case EU: {
          HS(a, gd, wg);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function x6(a) {
      for (var s = a; ; ) {
        if (s.flags & Kf) {
          var v = s.updateQueue;
          if (v !== null) {
            var _ = v.stores;
            if (_ !== null)
              for (var M = 0; M < _.length; M++) {
                var N = _[M], G = N.getSnapshot, q = N.value;
                try {
                  if (!Un(G(), q))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var te = s.child;
        if (s.subtreeFlags & Kf && te !== null) {
          te.return = s, s = te;
          continue;
        }
        if (s === a)
          return !0;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === a)
            return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return !0;
    }
    function a0(a, s) {
      s = An(s, XM), s = An(s, Gb), xc(a, s);
    }
    function AU(a) {
      if (e0(), (Mi & (tc | op)) !== Kl)
        throw new Error("Should not already be working.");
      Cg();
      var s = Sc(a, Nt);
      if (!We(s, Hn))
        return yd(a, sa()), null;
      var v = tC(a, s);
      if (a.tag !== nv && v === zS) {
        var _ = z(a);
        _ !== Nt && (s = _, v = tD(a, _));
      }
      if (v === Bb) {
        var M = Vb;
        throw BS(a, Nt), a0(a, s), yd(a, sa()), M;
      }
      if (v === YA)
        throw new Error("Root did not complete. This is a bug in React.");
      var N = a.current.alternate;
      return a.finishedWork = N, a.finishedLanes = s, HS(a, gd, wg), yd(a, sa()), null;
    }
    function _6(a, s) {
      s !== Nt && (Ap(a, Vt(s, Hn)), yd(a, sa()), (Mi & (tc | op)) === Kl && (jb(), rv()));
    }
    function nD(a, s) {
      var v = Mi;
      Mi |= _U;
      try {
        return a(s);
      } finally {
        Mi = v, Mi === Kl && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !am.isBatchingLegacy && (jb(), hM());
      }
    }
    function E6(a, s, v, _, M) {
      var N = Wu(), G = ec.transition;
      try {
        return ec.transition = null, po(bs), a(s, v, _, M);
      } finally {
        po(N), ec.transition = G, Mi === Kl && jb();
      }
    }
    function Mg(a) {
      r0 !== null && r0.tag === nv && (Mi & (tc | op)) === Kl && Cg();
      var s = Mi;
      Mi |= _U;
      var v = ec.transition, _ = Wu();
      try {
        return ec.transition = null, po(bs), a ? a() : void 0;
      } finally {
        po(_), ec.transition = v, Mi = s, (Mi & (tc | op)) === Kl && rv();
      }
    }
    function DU() {
      return (Mi & (tc | op)) !== Kl;
    }
    function eC(a, s) {
      Tu(XA, gv, a), gv = Vt(gv, s);
    }
    function rD(a) {
      gv = XA.current, bu(XA, a);
    }
    function BS(a, s) {
      a.finishedWork = null, a.finishedLanes = Nt;
      var v = a.timeoutHandle;
      if (v !== Ay && (a.timeoutHandle = Ay, NE(v)), is !== null)
        for (var _ = is.return; _ !== null; ) {
          var M = _.alternate;
          aU(M, _), _ = _.return;
        }
      Cf = a;
      var N = VS(a.current, null);
      return is = N, Ql = gv = s, Zl = Tg, Vb = null, YM = Nt, Gb = Nt, XM = Nt, Wb = null, gd = null, ib(), qu.discardPendingWarnings(), N;
    }
    function LU(a, s) {
      do {
        var v = is;
        try {
          if (b_(), bb(), fa(), $A.current = null, v === null || v.return === null) {
            Zl = Bb, Vb = s, is = null;
            return;
          }
          if (Ue && v.mode & Kn && NS(v, !0), Ae)
            if (na(), s !== null && typeof s == "object" && typeof s.then == "function") {
              var _ = s;
              qs(v, _, Ql);
            } else
              ed(v, s, Ql);
          $H(a, v.return, v, s, Ql), NU(v);
        } catch (M) {
          s = M, is === v && v !== null ? (v = v.return, is = v) : v = is;
          continue;
        }
        return;
      } while (!0);
    }
    function OU() {
      var a = jA.current;
      return jA.current = xt, a === null ? xt : a;
    }
    function PU(a) {
      jA.current = a;
    }
    function b6() {
      qA = sa();
    }
    function qb(a) {
      YM = Vt(a, YM);
    }
    function T6() {
      Zl === Tg && (Zl = $M);
    }
    function iD() {
      (Zl === Tg || Zl === $M || Zl === zS) && (Zl = Hb), Cf !== null && (Z(YM) || Z(Gb)) && a0(Cf, Ql);
    }
    function w6(a) {
      Zl !== Hb && (Zl = zS), Wb === null ? Wb = [a] : Wb.push(a);
    }
    function M6() {
      return Zl === Tg;
    }
    function tC(a, s) {
      var v = Mi;
      Mi |= tc;
      var _ = OU();
      if (Cf !== a || Ql !== s) {
        if (Na) {
          var M = a.memoizedUpdaters;
          M.size > 0 && (Kb(a, Ql), M.clear()), Hm(a, s);
        }
        wg = iy(), BS(a, s);
      }
      gl(s);
      do
        try {
          C6();
          break;
        } catch (N) {
          LU(a, N);
        }
      while (!0);
      if (b_(), Mi = v, PU(_), is !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return cf(), Cf = null, Ql = Nt, Zl;
    }
    function C6() {
      for (; is !== null; )
        UU(is);
    }
    function R6(a, s) {
      var v = Mi;
      Mi |= tc;
      var _ = OU();
      if (Cf !== a || Ql !== s) {
        if (Na) {
          var M = a.memoizedUpdaters;
          M.size > 0 && (Kb(a, Ql), M.clear()), Hm(a, s);
        }
        wg = iy(), jb(), BS(a, s);
      }
      gl(s);
      do
        try {
          A6();
          break;
        } catch (N) {
          LU(a, N);
        }
      while (!0);
      return b_(), PU(_), Mi = v, is !== null ? (vu(), Tg) : (cf(), Cf = null, Ql = Nt, Zl);
    }
    function A6() {
      for (; is !== null && !xs(); )
        UU(is);
    }
    function UU(a) {
      var s = a.alternate;
      gi(a);
      var v;
      (a.mode & Kn) !== qn ? (em(a), v = aD(s, a, gv), NS(a, !0)) : v = aD(s, a, gv), fa(), a.memoizedProps = a.pendingProps, v === null ? NU(a) : is = v, $A.current = null;
    }
    function NU(a) {
      var s = a;
      do {
        var v = s.alternate, _ = s.return;
        if ((s.flags & ys) === Xn) {
          gi(s);
          var M = void 0;
          if ((s.mode & Kn) === qn ? M = iU(v, s, gv) : (em(s), M = iU(v, s, gv), NS(s, !1)), fa(), M !== null) {
            is = M;
            return;
          }
        } else {
          var N = TV(v, s);
          if (N !== null) {
            N.flags &= Uv, is = N;
            return;
          }
          if ((s.mode & Kn) !== qn) {
            NS(s, !1);
            for (var G = s.actualDuration, q = s.child; q !== null; )
              G += q.actualDuration, q = q.sibling;
            s.actualDuration = G;
          }
          if (_ !== null)
            _.flags |= ys, _.subtreeFlags = Xn, _.deletions = null;
          else {
            Zl = YA, is = null;
            return;
          }
        }
        var te = s.sibling;
        if (te !== null) {
          is = te;
          return;
        }
        s = _, is = s;
      } while (s !== null);
      Zl === Tg && (Zl = EU);
    }
    function HS(a, s, v) {
      var _ = Wu(), M = ec.transition;
      try {
        ec.transition = null, po(bs), D6(a, s, v, _);
      } finally {
        ec.transition = M, po(_);
      }
      return null;
    }
    function D6(a, s, v, _) {
      do
        Cg();
      while (r0 !== null);
      if (H6(), (Mi & (tc | op)) !== Kl)
        throw new Error("Should not already be working.");
      var M = a.finishedWork, N = a.finishedLanes;
      if (ma(N), M === null)
        return Lr(), null;
      if (N === Nt && l("root.finishedLanes should not be empty during a commit. This is a bug in React."), a.finishedWork = null, a.finishedLanes = Nt, M === a.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      a.callbackNode = null, a.callbackPriority = Qr;
      var G = Vt(M.lanes, M.childLanes);
      L0(a, G), a === Cf && (Cf = null, is = null, Ql = Nt), ((M.subtreeFlags & Iu) !== Xn || (M.flags & Iu) !== Xn) && (IS || (IS = !0, ZA = v, lD(pu, function() {
        return Cg(), null;
      })));
      var q = (M.subtreeFlags & (gr | uo | Ta | Iu)) !== Xn, te = (M.flags & (gr | uo | Ta | Iu)) !== Xn;
      if (q || te) {
        var ge = ec.transition;
        ec.transition = null;
        var Ee = Wu();
        po(bs);
        var Ke = Mi;
        Mi |= op, $A.current = null, AV(a, M), Oc(), GV(a, M, N), OE(a.containerInfo), a.current = M, km(N), WV(M, a, N), td(), co(), Mi = Ke, po(Ee), ec.transition = ge;
      } else
        a.current = M, Oc();
      var je = IS;
      if (IS ? (IS = !1, r0 = a, $b = N) : (n1 = 0, QM = null), G = a.pendingLanes, G === Nt && (t1 = null), je || IU(a.current, !1), _s(M.stateNode, _), Na && a.memoizedUpdaters.clear(), u6(), yd(a, sa()), s !== null)
        for (var Et = a.onRecoverableError, wt = 0; wt < s.length; wt++) {
          var It = s[wt], Dn = It.stack, fr = It.digest;
          Et(It.value, {
            componentStack: Dn,
            digest: fr
          });
        }
      if (qM) {
        qM = !1;
        var Jn = KA;
        throw KA = null, Jn;
      }
      return We($b, Hn) && a.tag !== nv && Cg(), G = a.pendingLanes, We(G, Hn) ? (wf(), a === JA ? Yb++ : (Yb = 0, JA = a)) : Yb = 0, rv(), Lr(), null;
    }
    function Cg() {
      if (r0 !== null) {
        var a = Op($b), s = O0(yf, a), v = ec.transition, _ = Wu();
        try {
          return ec.transition = null, po(s), O6();
        } finally {
          po(_), ec.transition = v;
        }
      }
      return !1;
    }
    function L6(a) {
      QA.push(a), IS || (IS = !0, lD(pu, function() {
        return Cg(), null;
      }));
    }
    function O6() {
      if (r0 === null)
        return !1;
      var a = ZA;
      ZA = null;
      var s = r0, v = $b;
      if (r0 = null, $b = Nt, (Mi & (tc | op)) !== Kl)
        throw new Error("Cannot flush passive effects while already rendering.");
      eD = !0, KM = !1, $d(v);
      var _ = Mi;
      Mi |= op, QV(s.current), YV(s, s.current, v, a);
      {
        var M = QA;
        QA = [];
        for (var N = 0; N < M.length; N++) {
          var G = M[N];
          PV(s, G);
        }
      }
      uf(), IU(s.current, !0), Mi = _, rv(), KM ? s === QM ? n1++ : (n1 = 0, QM = s) : n1 = 0, eD = !1, KM = !1, pa(s);
      {
        var q = s.current.stateNode;
        q.effectDuration = 0, q.passiveEffectDuration = 0;
      }
      return !0;
    }
    function FU(a) {
      return t1 !== null && t1.has(a);
    }
    function P6(a) {
      t1 === null ? t1 = /* @__PURE__ */ new Set([a]) : t1.add(a);
    }
    function U6(a) {
      qM || (qM = !0, KA = a);
    }
    var N6 = U6;
    function kU(a, s, v) {
      var _ = FS(v, s), M = U3(a, _, Hn), N = uv(a, M, Hn), G = Rf();
      N !== null && (kr(N, Hn, G), yd(N, G));
    }
    function ro(a, s, v) {
      if (MV(v), Qb(!1), a.tag === x) {
        kU(a, a, v);
        return;
      }
      var _ = null;
      for (_ = s; _ !== null; ) {
        if (_.tag === x) {
          kU(_, a, v);
          return;
        } else if (_.tag === p) {
          var M = _.type, N = _.stateNode;
          if (typeof M.getDerivedStateFromError == "function" || typeof N.componentDidCatch == "function" && !FU(N)) {
            var G = FS(v, a), q = wA(_, G, Hn), te = uv(_, q, Hn), ge = Rf();
            te !== null && (kr(te, Hn, ge), yd(te, ge));
            return;
          }
        }
        _ = _.return;
      }
      l(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, v);
    }
    function F6(a, s, v) {
      var _ = a.pingCache;
      _ !== null && _.delete(s);
      var M = Rf();
      Oh(a, v), j6(a), Cf === a && Mt(Ql, v) && (Zl === Hb || Zl === $M && we(Ql) && sa() - qA < bU ? BS(a, Nt) : XM = Vt(XM, v)), yd(a, M);
    }
    function zU(a, s) {
      s === Qr && (s = v6(a));
      var v = Rf(), _ = jl(a, s);
      _ !== null && (kr(_, s, v), yd(_, v));
    }
    function k6(a) {
      var s = a.memoizedState, v = Qr;
      s !== null && (v = s.retryLane), zU(a, v);
    }
    function z6(a, s) {
      var v = Qr, _;
      switch (a.tag) {
        case B:
          _ = a.stateNode;
          var M = a.memoizedState;
          M !== null && (v = M.retryLane);
          break;
        case le:
          _ = a.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      _ !== null && _.delete(s), zU(a, v);
    }
    function I6(a) {
      return a < 120 ? 120 : a < 480 ? 480 : a < 1080 ? 1080 : a < 1920 ? 1920 : a < 3e3 ? 3e3 : a < 4320 ? 4320 : d6(a / 1960) * 1960;
    }
    function B6() {
      if (Yb > p6)
        throw Yb = 0, JA = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      n1 > m6 && (n1 = 0, QM = null, l("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function H6() {
      qu.flushLegacyContextWarning(), qu.flushPendingUnsafeLifecycleWarnings();
    }
    function IU(a, s) {
      gi(a), nC(a, ci, o6), s && nC(a, hu, s6), nC(a, ci, i6), s && nC(a, hu, a6), fa();
    }
    function nC(a, s, v) {
      for (var _ = a, M = null; _ !== null; ) {
        var N = _.subtreeFlags & s;
        _ !== M && _.child !== null && N !== Xn ? _ = _.child : ((_.flags & s) !== Xn && v(_), _.sibling !== null ? _ = _.sibling : _ = M = _.return);
      }
    }
    var rC = null;
    function BU(a) {
      {
        if ((Mi & tc) !== Kl || !(a.mode & Cr))
          return;
        var s = a.tag;
        if (s !== y && s !== x && s !== p && s !== h && s !== k && s !== $ && s !== Y)
          return;
        var v = nr(a) || "ReactComponent";
        if (rC !== null) {
          if (rC.has(v))
            return;
          rC.add(v);
        } else
          rC = /* @__PURE__ */ new Set([v]);
        var _ = Fi;
        try {
          gi(a), l("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          _ ? gi(a) : fa();
        }
      }
    }
    var aD;
    {
      var V6 = null;
      aD = function(a, s, v) {
        var _ = XU(V6, s);
        try {
          return J3(a, s, v);
        } catch (N) {
          if (QE() || N !== null && typeof N == "object" && typeof N.then == "function")
            throw N;
          if (b_(), bb(), aU(a, s), XU(s, _), s.mode & Kn && em(s), pc(null, J3, null, a, s, v), qf()) {
            var M = Vd();
            typeof M == "object" && M !== null && M._suppressLogging && typeof N == "object" && N !== null && !N._suppressLogging && (N._suppressLogging = !0);
          }
          throw N;
        }
      };
    }
    var HU = !1, oD;
    oD = /* @__PURE__ */ new Set();
    function G6(a) {
      if (dr && !Lt())
        switch (a.tag) {
          case h:
          case k:
          case Y: {
            var s = is && nr(is) || "Unknown", v = s;
            if (!oD.has(v)) {
              oD.add(v);
              var _ = nr(a) || "Unknown";
              l("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", _, s, s);
            }
            break;
          }
          case p: {
            HU || (l("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), HU = !0);
            break;
          }
        }
    }
    function Kb(a, s) {
      if (Na) {
        var v = a.memoizedUpdaters;
        v.forEach(function(_) {
          ry(a, _, s);
        });
      }
    }
    var sD = {};
    function lD(a, s) {
      {
        var v = am.current;
        return v !== null ? (v.push(s), sD) : Wd(a, s);
      }
    }
    function VU(a) {
      if (a !== sD)
        return Zf(a);
    }
    function GU() {
      return am.current !== null;
    }
    function W6(a) {
      {
        if (a.mode & Cr) {
          if (!xU())
            return;
        } else if (!f6() || Mi !== Kl || a.tag !== h && a.tag !== k && a.tag !== Y)
          return;
        if (am.current === null) {
          var s = Fi;
          try {
            gi(a), l(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, nr(a));
          } finally {
            s ? gi(a) : fa();
          }
        }
      }
    }
    function j6(a) {
      a.tag !== nv && xU() && am.current === null && l(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function Qb(a) {
      MU = a;
    }
    var sp = null, r1 = null, $6 = function(a) {
      sp = a;
    };
    function i1(a) {
      {
        if (sp === null)
          return a;
        var s = sp(a);
        return s === void 0 ? a : s.current;
      }
    }
    function uD(a) {
      return i1(a);
    }
    function cD(a) {
      {
        if (sp === null)
          return a;
        var s = sp(a);
        if (s === void 0) {
          if (a != null && typeof a.render == "function") {
            var v = i1(a.render);
            if (a.render !== v) {
              var _ = {
                $$typeof: En,
                render: v
              };
              return a.displayName !== void 0 && (_.displayName = a.displayName), _;
            }
          }
          return a;
        }
        return s.current;
      }
    }
    function WU(a, s) {
      {
        if (sp === null)
          return !1;
        var v = a.elementType, _ = s.type, M = !1, N = typeof _ == "object" && _ !== null ? _.$$typeof : null;
        switch (a.tag) {
          case p: {
            typeof _ == "function" && (M = !0);
            break;
          }
          case h: {
            (typeof _ == "function" || N === Ve) && (M = !0);
            break;
          }
          case k: {
            (N === En || N === Ve) && (M = !0);
            break;
          }
          case $:
          case Y: {
            (N === tt || N === Ve) && (M = !0);
            break;
          }
          default:
            return !1;
        }
        if (M) {
          var G = sp(v);
          if (G !== void 0 && G === sp(_))
            return !0;
        }
        return !1;
      }
    }
    function jU(a) {
      {
        if (sp === null || typeof WeakSet != "function")
          return;
        r1 === null && (r1 = /* @__PURE__ */ new WeakSet()), r1.add(a);
      }
    }
    var Y6 = function(a, s) {
      {
        if (sp === null)
          return;
        var v = s.staleFamilies, _ = s.updatedFamilies;
        Cg(), Mg(function() {
          fD(a.current, _, v);
        });
      }
    }, X6 = function(a, s) {
      {
        if (a.context !== Cc)
          return;
        Cg(), Mg(function() {
          Zb(s, a, null, null);
        });
      }
    };
    function fD(a, s, v) {
      {
        var _ = a.alternate, M = a.child, N = a.sibling, G = a.tag, q = a.type, te = null;
        switch (G) {
          case h:
          case Y:
          case p:
            te = q;
            break;
          case k:
            te = q.render;
            break;
        }
        if (sp === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var ge = !1, Ee = !1;
        if (te !== null) {
          var Ke = sp(te);
          Ke !== void 0 && (v.has(Ke) ? Ee = !0 : s.has(Ke) && (G === p ? Ee = !0 : ge = !0));
        }
        if (r1 !== null && (r1.has(a) || _ !== null && r1.has(_)) && (Ee = !0), Ee && (a._debugNeedsRemount = !0), Ee || ge) {
          var je = jl(a, Hn);
          je !== null && Jl(je, a, Hn, $r);
        }
        M !== null && !Ee && fD(M, s, v), N !== null && fD(N, s, v);
      }
    }
    var q6 = function(a, s) {
      {
        var v = /* @__PURE__ */ new Set(), _ = new Set(s.map(function(M) {
          return M.current;
        }));
        return dD(a.current, _, v), v;
      }
    };
    function dD(a, s, v) {
      {
        var _ = a.child, M = a.sibling, N = a.tag, G = a.type, q = null;
        switch (N) {
          case h:
          case Y:
          case p:
            q = G;
            break;
          case k:
            q = G.render;
            break;
        }
        var te = !1;
        q !== null && s.has(q) && (te = !0), te ? K6(a, v) : _ !== null && dD(_, s, v), M !== null && dD(M, s, v);
      }
    }
    function K6(a, s) {
      {
        var v = Q6(a, s);
        if (v)
          return;
        for (var _ = a; ; ) {
          switch (_.tag) {
            case w:
              s.add(_.stateNode);
              return;
            case b:
              s.add(_.stateNode.containerInfo);
              return;
            case x:
              s.add(_.stateNode.containerInfo);
              return;
          }
          if (_.return === null)
            throw new Error("Expected to reach root first.");
          _ = _.return;
        }
      }
    }
    function Q6(a, s) {
      for (var v = a, _ = !1; ; ) {
        if (v.tag === w)
          _ = !0, s.add(v.stateNode);
        else if (v.child !== null) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === a)
          return _;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === a)
            return _;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
      return !1;
    }
    var hD;
    {
      hD = !1;
      try {
        var $U = Object.preventExtensions({});
      } catch {
        hD = !0;
      }
    }
    function Z6(a, s, v, _) {
      this.tag = a, this.key = v, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = s, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = _, this.flags = Xn, this.subtreeFlags = Xn, this.deletions = null, this.lanes = Nt, this.childLanes = Nt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hD && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var hh = function(a, s, v, _) {
      return new Z6(a, s, v, _);
    };
    function pD(a) {
      var s = a.prototype;
      return !!(s && s.isReactComponent);
    }
    function J6(a) {
      return typeof a == "function" && !pD(a) && a.defaultProps === void 0;
    }
    function e8(a) {
      if (typeof a == "function")
        return pD(a) ? p : h;
      if (a != null) {
        var s = a.$$typeof;
        if (s === En)
          return k;
        if (s === tt)
          return $;
      }
      return y;
    }
    function VS(a, s) {
      var v = a.alternate;
      v === null ? (v = hh(a.tag, s, a.key, a.mode), v.elementType = a.elementType, v.type = a.type, v.stateNode = a.stateNode, v._debugSource = a._debugSource, v._debugOwner = a._debugOwner, v._debugHookTypes = a._debugHookTypes, v.alternate = a, a.alternate = v) : (v.pendingProps = s, v.type = a.type, v.flags = Xn, v.subtreeFlags = Xn, v.deletions = null, v.actualDuration = 0, v.actualStartTime = -1), v.flags = a.flags & nn, v.childLanes = a.childLanes, v.lanes = a.lanes, v.child = a.child, v.memoizedProps = a.memoizedProps, v.memoizedState = a.memoizedState, v.updateQueue = a.updateQueue;
      var _ = a.dependencies;
      switch (v.dependencies = _ === null ? null : {
        lanes: _.lanes,
        firstContext: _.firstContext
      }, v.sibling = a.sibling, v.index = a.index, v.ref = a.ref, v.selfBaseDuration = a.selfBaseDuration, v.treeBaseDuration = a.treeBaseDuration, v._debugNeedsRemount = a._debugNeedsRemount, v.tag) {
        case y:
        case h:
        case Y:
          v.type = i1(a.type);
          break;
        case p:
          v.type = uD(a.type);
          break;
        case k:
          v.type = cD(a.type);
          break;
      }
      return v;
    }
    function t8(a, s) {
      a.flags &= nn | Nr;
      var v = a.alternate;
      if (v === null)
        a.childLanes = Nt, a.lanes = s, a.child = null, a.subtreeFlags = Xn, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null, a.selfBaseDuration = 0, a.treeBaseDuration = 0;
      else {
        a.childLanes = v.childLanes, a.lanes = v.lanes, a.child = v.child, a.subtreeFlags = Xn, a.deletions = null, a.memoizedProps = v.memoizedProps, a.memoizedState = v.memoizedState, a.updateQueue = v.updateQueue, a.type = v.type;
        var _ = v.dependencies;
        a.dependencies = _ === null ? null : {
          lanes: _.lanes,
          firstContext: _.firstContext
        }, a.selfBaseDuration = v.selfBaseDuration, a.treeBaseDuration = v.treeBaseDuration;
      }
      return a;
    }
    function n8(a, s, v) {
      var _;
      return a === fS ? (_ = Cr, s === !0 && (_ |= jr, _ |= bo)) : _ = qn, Na && (_ |= Kn), hh(x, null, null, _);
    }
    function mD(a, s, v, _, M, N) {
      var G = y, q = a;
      if (typeof a == "function")
        pD(a) ? (G = p, q = uD(q)) : q = i1(q);
      else if (typeof a == "string")
        G = w;
      else
        e:
          switch (a) {
            case Ri:
              return o0(v.children, M, N, s);
            case si:
              G = L, M |= jr, (M & Cr) !== qn && (M |= bo);
              break;
            case De:
              return r8(v, M, N, s);
            case ye:
              return i8(v, M, N, s);
            case qe:
              return a8(v, M, N, s);
            case cn:
              return YU(v, M, N, s);
            case xn:
            case pt:
            case Nn:
            case lr:
            case en:
            default: {
              if (typeof a == "object" && a !== null)
                switch (a.$$typeof) {
                  case Ft:
                    G = F;
                    break e;
                  case qt:
                    G = A;
                    break e;
                  case En:
                    G = k, q = cD(q);
                    break e;
                  case tt:
                    G = $;
                    break e;
                  case Ve:
                    G = J, q = null;
                    break e;
                }
              var te = "";
              {
                (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var ge = _ ? nr(_) : null;
                ge && (te += `

Check the render method of \`` + ge + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (a == null ? a : typeof a) + "." + te));
            }
          }
      var Ee = hh(G, v, s, M);
      return Ee.elementType = a, Ee.type = q, Ee.lanes = N, Ee._debugOwner = _, Ee;
    }
    function vD(a, s, v) {
      var _ = null;
      _ = a._owner;
      var M = a.type, N = a.key, G = a.props, q = mD(M, N, G, _, s, v);
      return q._debugSource = a._source, q._debugOwner = a._owner, q;
    }
    function o0(a, s, v, _) {
      var M = hh(U, a, _, s);
      return M.lanes = v, M;
    }
    function r8(a, s, v, _) {
      typeof a.id != "string" && l('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof a.id);
      var M = hh(H, a, _, s | Kn);
      return M.elementType = De, M.lanes = v, M.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, M;
    }
    function i8(a, s, v, _) {
      var M = hh(B, a, _, s);
      return M.elementType = ye, M.lanes = v, M;
    }
    function a8(a, s, v, _) {
      var M = hh(le, a, _, s);
      return M.elementType = qe, M.lanes = v, M;
    }
    function YU(a, s, v, _) {
      var M = hh(fe, a, _, s);
      M.elementType = cn, M.lanes = v;
      var N = {
        isHidden: !1
      };
      return M.stateNode = N, M;
    }
    function gD(a, s, v) {
      var _ = hh(R, a, null, s);
      return _.lanes = v, _;
    }
    function o8() {
      var a = hh(w, null, null, qn);
      return a.elementType = "DELETED", a;
    }
    function s8(a) {
      var s = hh(X, null, null, qn);
      return s.stateNode = a, s;
    }
    function yD(a, s, v) {
      var _ = a.children !== null ? a.children : [], M = hh(b, _, a.key, s);
      return M.lanes = v, M.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: a.implementation
      }, M;
    }
    function XU(a, s) {
      return a === null && (a = hh(y, null, null, qn)), a.tag = s.tag, a.key = s.key, a.elementType = s.elementType, a.type = s.type, a.stateNode = s.stateNode, a.return = s.return, a.child = s.child, a.sibling = s.sibling, a.index = s.index, a.ref = s.ref, a.pendingProps = s.pendingProps, a.memoizedProps = s.memoizedProps, a.updateQueue = s.updateQueue, a.memoizedState = s.memoizedState, a.dependencies = s.dependencies, a.mode = s.mode, a.flags = s.flags, a.subtreeFlags = s.subtreeFlags, a.deletions = s.deletions, a.lanes = s.lanes, a.childLanes = s.childLanes, a.alternate = s.alternate, a.actualDuration = s.actualDuration, a.actualStartTime = s.actualStartTime, a.selfBaseDuration = s.selfBaseDuration, a.treeBaseDuration = s.treeBaseDuration, a._debugSource = s._debugSource, a._debugOwner = s._debugOwner, a._debugNeedsRemount = s._debugNeedsRemount, a._debugHookTypes = s._debugHookTypes, a;
    }
    function l8(a, s, v, _, M) {
      this.tag = s, this.containerInfo = a, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Ay, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Qr, this.eventTimes = va(Nt), this.expirationTimes = va($r), this.pendingLanes = Nt, this.suspendedLanes = Nt, this.pingedLanes = Nt, this.expiredLanes = Nt, this.mutableReadLanes = Nt, this.finishedLanes = Nt, this.entangledLanes = Nt, this.entanglements = va(Nt), this.identifierPrefix = _, this.onRecoverableError = M, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var N = this.pendingUpdatersLaneMap = [], G = 0; G < ni; G++)
          N.push(/* @__PURE__ */ new Set());
      }
      switch (s) {
        case fS:
          this._debugRootType = v ? "hydrateRoot()" : "createRoot()";
          break;
        case nv:
          this._debugRootType = v ? "hydrate()" : "render()";
          break;
      }
    }
    function qU(a, s, v, _, M, N, G, q, te, ge) {
      var Ee = new l8(a, s, v, q, te), Ke = n8(s, N);
      Ee.current = Ke, Ke.stateNode = Ee;
      {
        var je = {
          element: _,
          isDehydrated: v,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Ke.memoizedState = je;
      }
      return C_(Ke), Ee;
    }
    var SD = "18.2.0";
    function u8(a, s, v) {
      var _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Ct(_), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Mr,
        key: _ == null ? null : "" + _,
        children: a,
        containerInfo: s,
        implementation: v
      };
    }
    var xD, _D;
    xD = !1, _D = {};
    function KU(a) {
      if (!a)
        return Cc;
      var s = Xo(a), v = sA(s);
      if (s.tag === p) {
        var _ = s.type;
        if (oh(_))
          return uM(s, _, v);
      }
      return v;
    }
    function c8(a, s) {
      {
        var v = Xo(a);
        if (v === void 0) {
          if (typeof a.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var _ = Object.keys(a).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + _);
        }
        var M = ml(v);
        if (M === null)
          return null;
        if (M.mode & jr) {
          var N = nr(v) || "Component";
          if (!_D[N]) {
            _D[N] = !0;
            var G = Fi;
            try {
              gi(M), v.mode & jr ? l("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, N) : l("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, N);
            } finally {
              G ? gi(G) : fa();
            }
          }
        }
        return M.stateNode;
      }
    }
    function QU(a, s, v, _, M, N, G, q) {
      var te = !1, ge = null;
      return qU(a, s, te, ge, v, _, M, N, G);
    }
    function ZU(a, s, v, _, M, N, G, q, te, ge) {
      var Ee = !0, Ke = qU(v, _, Ee, a, M, N, G, q, te);
      Ke.context = KU(null);
      var je = Ke.current, Et = Rf(), wt = i0(je), It = Qh(Et, wt);
      return It.callback = s ?? null, uv(je, It, wt), g6(Ke, wt, Et), Ke;
    }
    function Zb(a, s, v, _) {
      Fm(s, a);
      var M = s.current, N = Rf(), G = i0(M);
      yl(G);
      var q = KU(v);
      s.context === null ? s.context = q : s.pendingContext = q, dr && Fi !== null && !xD && (xD = !0, l(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, nr(Fi) || "Unknown"));
      var te = Qh(N, G);
      te.payload = {
        element: a
      }, _ = _ === void 0 ? null : _, _ !== null && (typeof _ != "function" && l("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", _), te.callback = _);
      var ge = uv(M, te, G);
      return ge !== null && (Jl(ge, M, G, N), A_(ge, M, G)), G;
    }
    function iC(a) {
      var s = a.current;
      if (!s.child)
        return null;
      switch (s.child.tag) {
        case w:
          return s.child.stateNode;
        default:
          return s.child.stateNode;
      }
    }
    function f8(a) {
      switch (a.tag) {
        case x: {
          var s = a.stateNode;
          if (Mo(s)) {
            var v = D(s);
            _6(s, v);
          }
          break;
        }
        case B: {
          Mg(function() {
            var M = jl(a, Hn);
            if (M !== null) {
              var N = Rf();
              Jl(M, a, Hn, N);
            }
          });
          var _ = Hn;
          ED(a, _);
          break;
        }
      }
    }
    function JU(a, s) {
      var v = a.memoizedState;
      v !== null && v.dehydrated !== null && (v.retryLane = Fr(v.retryLane, s));
    }
    function ED(a, s) {
      JU(a, s);
      var v = a.alternate;
      v && JU(v, s);
    }
    function d8(a) {
      if (a.tag === B) {
        var s = Il, v = jl(a, s);
        if (v !== null) {
          var _ = Rf();
          Jl(v, a, s, _);
        }
        ED(a, s);
      }
    }
    function h8(a) {
      if (a.tag === B) {
        var s = i0(a), v = jl(a, s);
        if (v !== null) {
          var _ = Rf();
          Jl(v, a, s, _);
        }
        ED(a, s);
      }
    }
    function eN(a) {
      var s = Gd(a);
      return s === null ? null : s.stateNode;
    }
    var tN = function(a) {
      return null;
    };
    function p8(a) {
      return tN(a);
    }
    var nN = function(a) {
      return !1;
    };
    function m8(a) {
      return nN(a);
    }
    var rN = null, iN = null, aN = null, oN = null, sN = null, lN = null, uN = null, cN = null, fN = null;
    {
      var dN = function(a, s, v) {
        var _ = s[v], M = oo(a) ? a.slice() : Tn({}, a);
        return v + 1 === s.length ? (oo(M) ? M.splice(_, 1) : delete M[_], M) : (M[_] = dN(a[_], s, v + 1), M);
      }, hN = function(a, s) {
        return dN(a, s, 0);
      }, pN = function(a, s, v, _) {
        var M = s[_], N = oo(a) ? a.slice() : Tn({}, a);
        if (_ + 1 === s.length) {
          var G = v[_];
          N[G] = N[M], oo(N) ? N.splice(M, 1) : delete N[M];
        } else
          N[M] = pN(
            // $FlowFixMe number or string is fine here
            a[M],
            s,
            v,
            _ + 1
          );
        return N;
      }, mN = function(a, s, v) {
        if (s.length !== v.length) {
          o("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var _ = 0; _ < v.length - 1; _++)
            if (s[_] !== v[_]) {
              o("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return pN(a, s, v, 0);
      }, vN = function(a, s, v, _) {
        if (v >= s.length)
          return _;
        var M = s[v], N = oo(a) ? a.slice() : Tn({}, a);
        return N[M] = vN(a[M], s, v + 1, _), N;
      }, gN = function(a, s, v) {
        return vN(a, s, 0, v);
      }, bD = function(a, s) {
        for (var v = a.memoizedState; v !== null && s > 0; )
          v = v.next, s--;
        return v;
      };
      rN = function(a, s, v, _) {
        var M = bD(a, s);
        if (M !== null) {
          var N = gN(M.memoizedState, v, _);
          M.memoizedState = N, M.baseState = N, a.memoizedProps = Tn({}, a.memoizedProps);
          var G = jl(a, Hn);
          G !== null && Jl(G, a, Hn, $r);
        }
      }, iN = function(a, s, v) {
        var _ = bD(a, s);
        if (_ !== null) {
          var M = hN(_.memoizedState, v);
          _.memoizedState = M, _.baseState = M, a.memoizedProps = Tn({}, a.memoizedProps);
          var N = jl(a, Hn);
          N !== null && Jl(N, a, Hn, $r);
        }
      }, aN = function(a, s, v, _) {
        var M = bD(a, s);
        if (M !== null) {
          var N = mN(M.memoizedState, v, _);
          M.memoizedState = N, M.baseState = N, a.memoizedProps = Tn({}, a.memoizedProps);
          var G = jl(a, Hn);
          G !== null && Jl(G, a, Hn, $r);
        }
      }, oN = function(a, s, v) {
        a.pendingProps = gN(a.memoizedProps, s, v), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var _ = jl(a, Hn);
        _ !== null && Jl(_, a, Hn, $r);
      }, sN = function(a, s) {
        a.pendingProps = hN(a.memoizedProps, s), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var v = jl(a, Hn);
        v !== null && Jl(v, a, Hn, $r);
      }, lN = function(a, s, v) {
        a.pendingProps = mN(a.memoizedProps, s, v), a.alternate && (a.alternate.pendingProps = a.pendingProps);
        var _ = jl(a, Hn);
        _ !== null && Jl(_, a, Hn, $r);
      }, uN = function(a) {
        var s = jl(a, Hn);
        s !== null && Jl(s, a, Hn, $r);
      }, cN = function(a) {
        tN = a;
      }, fN = function(a) {
        nN = a;
      };
    }
    function v8(a) {
      var s = ml(a);
      return s === null ? null : s.stateNode;
    }
    function g8(a) {
      return null;
    }
    function y8() {
      return Fi;
    }
    function S8(a) {
      var s = a.findFiberByHostInstance, v = t.ReactCurrentDispatcher;
      return Rp({
        bundleType: a.bundleType,
        version: a.version,
        rendererPackageName: a.rendererPackageName,
        rendererConfig: a.rendererConfig,
        overrideHookState: rN,
        overrideHookStateDeletePath: iN,
        overrideHookStateRenamePath: aN,
        overrideProps: oN,
        overridePropsDeletePath: sN,
        overridePropsRenamePath: lN,
        setErrorHandler: cN,
        setSuspenseHandler: fN,
        scheduleUpdate: uN,
        currentDispatcherRef: v,
        findHostInstanceByFiber: v8,
        findFiberByHostInstance: s || g8,
        // React Refresh
        findHostInstancesForRefresh: q6,
        scheduleRefresh: Y6,
        scheduleRoot: X6,
        setRefreshHandler: $6,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: y8,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: SD
      });
    }
    var yN = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(a) {
      console.error(a);
    };
    function TD(a) {
      this._internalRoot = a;
    }
    aC.prototype.render = TD.prototype.render = function(a) {
      var s = this._internalRoot;
      if (s === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? l("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : oC(arguments[1]) ? l("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && l("You passed a second argument to root.render(...) but it only accepts one argument.");
        var v = s.containerInfo;
        if (v.nodeType !== Oa) {
          var _ = eN(s.current);
          _ && _.parentNode !== v && l("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Zb(a, s, null, null);
    }, aC.prototype.unmount = TD.prototype.unmount = function() {
      typeof arguments[0] == "function" && l("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var s = a.containerInfo;
        DU() && l("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Mg(function() {
          Zb(null, a, null, null);
        }), aM(s);
      }
    };
    function x8(a, s) {
      if (!oC(a))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      SN(a);
      var v = !1, _ = !1, M = "", N = yN;
      s != null && (s.hydrate ? o("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof s == "object" && s !== null && s.$$typeof === Br && l(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), s.unstable_strictMode === !0 && (v = !0), s.identifierPrefix !== void 0 && (M = s.identifierPrefix), s.onRecoverableError !== void 0 && (N = s.onRecoverableError), s.transitionCallbacks !== void 0 && s.transitionCallbacks);
      var G = QU(a, fS, null, v, _, M, N);
      oS(G.current, a);
      var q = a.nodeType === Oa ? a.parentNode : a;
      return Yu(q), new TD(G);
    }
    function aC(a) {
      this._internalRoot = a;
    }
    function _8(a) {
      a && oy(a);
    }
    aC.prototype.unstable_scheduleHydration = _8;
    function E8(a, s, v) {
      if (!oC(a))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      SN(a), s === void 0 && l("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var _ = v ?? null, M = v != null && v.hydratedSources || null, N = !1, G = !1, q = "", te = yN;
      v != null && (v.unstable_strictMode === !0 && (N = !0), v.identifierPrefix !== void 0 && (q = v.identifierPrefix), v.onRecoverableError !== void 0 && (te = v.onRecoverableError));
      var ge = ZU(s, null, a, fS, _, N, G, q, te);
      if (oS(ge.current, a), Yu(a), M)
        for (var Ee = 0; Ee < M.length; Ee++) {
          var Ke = M[Ee];
          kM(ge, Ke);
        }
      return new aC(ge);
    }
    function oC(a) {
      return !!(a && (a.nodeType === Bs || a.nodeType === _a || a.nodeType === Ea || !he));
    }
    function Jb(a) {
      return !!(a && (a.nodeType === Bs || a.nodeType === _a || a.nodeType === Ea || a.nodeType === Oa && a.nodeValue === " react-mount-point-unstable "));
    }
    function SN(a) {
      a.nodeType === Bs && a.tagName && a.tagName.toUpperCase() === "BODY" && l("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), sS(a) && (a._reactRootContainer ? l("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : l("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var b8 = t.ReactCurrentOwner, xN;
    xN = function(a) {
      if (a._reactRootContainer && a.nodeType !== Oa) {
        var s = eN(a._reactRootContainer.current);
        s && s.parentNode !== a && l("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var v = !!a._reactRootContainer, _ = wD(a), M = !!(_ && ev(_));
      M && !v && l("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), a.nodeType === Bs && a.tagName && a.tagName.toUpperCase() === "BODY" && l("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function wD(a) {
      return a ? a.nodeType === _a ? a.documentElement : a.firstChild : null;
    }
    function _N() {
    }
    function T8(a, s, v, _, M) {
      if (M) {
        if (typeof _ == "function") {
          var N = _;
          _ = function() {
            var je = iC(G);
            N.call(je);
          };
        }
        var G = ZU(
          s,
          _,
          a,
          nv,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          _N
        );
        a._reactRootContainer = G, oS(G.current, a);
        var q = a.nodeType === Oa ? a.parentNode : a;
        return Yu(q), Mg(), G;
      } else {
        for (var te; te = a.lastChild; )
          a.removeChild(te);
        if (typeof _ == "function") {
          var ge = _;
          _ = function() {
            var je = iC(Ee);
            ge.call(je);
          };
        }
        var Ee = QU(
          a,
          nv,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          _N
        );
        a._reactRootContainer = Ee, oS(Ee.current, a);
        var Ke = a.nodeType === Oa ? a.parentNode : a;
        return Yu(Ke), Mg(function() {
          Zb(s, Ee, v, _);
        }), Ee;
      }
    }
    function w8(a, s) {
      a !== null && typeof a != "function" && l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, a);
    }
    function sC(a, s, v, _, M) {
      xN(v), w8(M === void 0 ? null : M, "render");
      var N = v._reactRootContainer, G;
      if (!N)
        G = T8(v, s, a, M, _);
      else {
        if (G = N, typeof M == "function") {
          var q = M;
          M = function() {
            var te = iC(G);
            q.call(te);
          };
        }
        Zb(s, G, a, M);
      }
      return iC(G);
    }
    function M8(a) {
      {
        var s = b8.current;
        if (s !== null && s.stateNode !== null) {
          var v = s.stateNode._warnedAboutRefsInRender;
          v || l("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ei(s.type) || "A component"), s.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return a == null ? null : a.nodeType === Bs ? a : c8(a, "findDOMNode");
    }
    function C8(a, s, v) {
      if (l("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Jb(s))
        throw new Error("Target container is not a DOM element.");
      {
        var _ = sS(s) && s._reactRootContainer === void 0;
        _ && l("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return sC(null, a, s, !0, v);
    }
    function R8(a, s, v) {
      if (l("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Jb(s))
        throw new Error("Target container is not a DOM element.");
      {
        var _ = sS(s) && s._reactRootContainer === void 0;
        _ && l("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return sC(null, a, s, !1, v);
    }
    function A8(a, s, v, _) {
      if (l("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Jb(v))
        throw new Error("Target container is not a DOM element.");
      if (a == null || !js(a))
        throw new Error("parentComponent must be a valid React Component");
      return sC(a, s, v, !1, _);
    }
    function D8(a) {
      if (!Jb(a))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var s = sS(a) && a._reactRootContainer === void 0;
        s && l("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (a._reactRootContainer) {
        {
          var v = wD(a), _ = v && !ev(v);
          _ && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Mg(function() {
          sC(null, null, a, !1, function() {
            a._reactRootContainer = null, aM(a);
          });
        }), !0;
      } else {
        {
          var M = wD(a), N = !!(M && ev(M)), G = a.nodeType === Bs && Jb(a.parentNode) && !!a.parentNode._reactRootContainer;
          N && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", G ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    On(f8), Dx(d8), Up(h8), N0(Wu), Np(Lp), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && l("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), fc(Fw), zd(nD, E6, Mg);
    function L8(a, s) {
      var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!oC(s))
        throw new Error("Target container is not a DOM element.");
      return u8(a, s, null, v);
    }
    function O8(a, s, v, _) {
      return A8(a, s, v, _);
    }
    var MD = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [ev, tl, cd, Ul, hc, nD]
    };
    function P8(a, s) {
      return MD.usingClientEntryPoint || l('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), x8(a, s);
    }
    function U8(a, s, v) {
      return MD.usingClientEntryPoint || l('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), E8(a, s, v);
    }
    function N8(a) {
      return DU() && l("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Mg(a);
    }
    var F8 = S8({
      findFiberByHostInstance: ig,
      bundleType: 1,
      version: SD,
      rendererPackageName: "react-dom"
    });
    if (!F8 && et && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var EN = window.location.protocol;
      /^(https?|file):$/.test(EN) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (EN === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    xd.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = MD, xd.createPortal = L8, xd.createRoot = P8, xd.findDOMNode = M8, xd.flushSync = N8, xd.hydrate = C8, xd.hydrateRoot = U8, xd.render = R8, xd.unmountComponentAtNode = D8, xd.unstable_batchedUpdates = nD, xd.unstable_renderSubtreeIntoContainer = O8, xd.version = SD, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), xd;
}
function VB() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(VB);
    } catch (n) {
      console.error(n);
    }
  }
}
process.env.NODE_ENV === "production" ? (VB(), FO.exports = Nq()) : FO.exports = Fq();
var b2 = FO.exports;
const GB = /* @__PURE__ */ rw(b2);
function kq(n, e, t) {
  return Math.max(e, Math.min(n, t));
}
const zc = {
  toVector(n, e) {
    return n === void 0 && (n = e), Array.isArray(n) ? n : [n, n];
  },
  add(n, e) {
    return [n[0] + e[0], n[1] + e[1]];
  },
  sub(n, e) {
    return [n[0] - e[0], n[1] - e[1]];
  },
  addTo(n, e) {
    n[0] += e[0], n[1] += e[1];
  },
  subTo(n, e) {
    n[0] -= e[0], n[1] -= e[1];
  }
};
function _k(n, e, t) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(n, t * 5) : n * e * t / (e + t * n);
}
function Ek(n, e, t, r = 0.15) {
  return r === 0 ? kq(n, e, t) : n < e ? -_k(e - n, t - e, r) + e : n > t ? +_k(n - t, t - e, r) + t : n;
}
function zq(n, [e, t], [r, i]) {
  const [[o, l], [c, h]] = n;
  return [Ek(e, o, l, r), Ek(t, c, h, i)];
}
function Iq(n, e) {
  if (typeof n != "object" || n === null)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function Bq(n) {
  var e = Iq(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ed(n, e, t) {
  return e = Bq(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function bk(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function us(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bk(Object(t), !0).forEach(function(r) {
      Ed(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : bk(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
const WB = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Tk(n) {
  return n ? n[0].toUpperCase() + n.slice(1) : "";
}
const Hq = ["enter", "leave"];
function Vq(n = !1, e) {
  return n && !Hq.includes(e);
}
function Gq(n, e = "", t = !1) {
  const r = WB[n], i = r && r[e] || e;
  return "on" + Tk(n) + Tk(i) + (Vq(t, i) ? "Capture" : "");
}
const Wq = ["gotpointercapture", "lostpointercapture"];
function jq(n) {
  let e = n.substring(2).toLowerCase();
  const t = !!~e.indexOf("passive");
  t && (e = e.replace("passive", ""));
  const r = Wq.includes(e) ? "capturecapture" : "capture", i = !!~e.indexOf(r);
  return i && (e = e.replace("capture", "")), {
    device: e,
    capture: i,
    passive: t
  };
}
function $q(n, e = "") {
  const t = WB[n], r = t && t[e] || e;
  return n + r;
}
function T2(n) {
  return "touches" in n;
}
function jB(n) {
  return T2(n) ? "touch" : "pointerType" in n ? n.pointerType : "mouse";
}
function Yq(n) {
  return Array.from(n.touches).filter((e) => {
    var t, r;
    return e.target === n.currentTarget || ((t = n.currentTarget) === null || t === void 0 || (r = t.contains) === null || r === void 0 ? void 0 : r.call(t, e.target));
  });
}
function Xq(n) {
  return n.type === "touchend" || n.type === "touchcancel" ? n.changedTouches : n.targetTouches;
}
function $B(n) {
  return T2(n) ? Xq(n)[0] : n;
}
function qq(n) {
  return Yq(n).map((e) => e.identifier);
}
function xL(n) {
  const e = $B(n);
  return T2(n) ? e.identifier : e.pointerId;
}
function wk(n) {
  const e = $B(n);
  return [e.clientX, e.clientY];
}
function Kq(n) {
  const e = {};
  if ("buttons" in n && (e.buttons = n.buttons), "shiftKey" in n) {
    const {
      shiftKey: t,
      altKey: r,
      metaKey: i,
      ctrlKey: o
    } = n;
    Object.assign(e, {
      shiftKey: t,
      altKey: r,
      metaKey: i,
      ctrlKey: o
    });
  }
  return e;
}
function DR(n, ...e) {
  return typeof n == "function" ? n(...e) : n;
}
function Qq() {
}
function Zq(...n) {
  return n.length === 0 ? Qq : n.length === 1 ? n[0] : function() {
    let e;
    for (const t of n)
      e = t.apply(this, arguments) || e;
    return e;
  };
}
function Mk(n, e) {
  return Object.assign({}, e, n || {});
}
const Jq = 32;
class eK {
  constructor(e, t, r) {
    this.ctrl = e, this.args = t, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: t,
      ingKey: r,
      args: i
    } = this;
    t[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = i, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const t = this.state, r = this.config;
    t._active || (this.reset(), this.computeInitial(), t._active = !0, t.target = e.target, t.currentTarget = e.currentTarget, t.lastOffset = r.from ? DR(r.from, t) : t.offset, t.offset = t.lastOffset, t.startTime = t.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const t = this.state;
    t._values = e, t.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: t,
      config: r,
      shared: i
    } = this;
    t.args = this.args;
    let o = 0;
    if (e && (t.event = e, r.preventDefault && e.cancelable && t.event.preventDefault(), t.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, Kq(e)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, o = e.timeStamp - t.timeStamp, t.timeStamp = e.timeStamp, t.elapsedTime = t.timeStamp - t.startTime), t._active) {
      const $ = t._delta.map(Math.abs);
      zc.addTo(t._distance, $);
    }
    this.axisIntent && this.axisIntent(e);
    const [l, c] = t._movement, [h, p] = r.threshold, {
      _step: y,
      values: x
    } = t;
    if (r.hasCustomTransform ? (y[0] === !1 && (y[0] = Math.abs(l) >= h && x[0]), y[1] === !1 && (y[1] = Math.abs(c) >= p && x[1])) : (y[0] === !1 && (y[0] = Math.abs(l) >= h && Math.sign(l) * h), y[1] === !1 && (y[1] = Math.abs(c) >= p && Math.sign(c) * p)), t.intentional = y[0] !== !1 || y[1] !== !1, !t.intentional)
      return;
    const b = [0, 0];
    if (r.hasCustomTransform) {
      const [$, Y] = x;
      b[0] = y[0] !== !1 ? $ - y[0] : 0, b[1] = y[1] !== !1 ? Y - y[1] : 0;
    } else
      b[0] = y[0] !== !1 ? l - y[0] : 0, b[1] = y[1] !== !1 ? c - y[1] : 0;
    this.restrictToAxis && !t._blocked && this.restrictToAxis(b);
    const w = t.offset, R = t._active && !t._blocked || t.active;
    R && (t.first = t._active && !t.active, t.last = !t._active && t.active, t.active = i[this.ingKey] = t._active, e && (t.first && ("bounds" in r && (t._bounds = DR(r.bounds, t)), this.setup && this.setup()), t.movement = b, this.computeOffset()));
    const [U, L] = t.offset, [[A, F], [k, H]] = t._bounds;
    t.overflow = [U < A ? -1 : U > F ? 1 : 0, L < k ? -1 : L > H ? 1 : 0], t._movementBound[0] = t.overflow[0] ? t._movementBound[0] === !1 ? t._movement[0] : t._movementBound[0] : !1, t._movementBound[1] = t.overflow[1] ? t._movementBound[1] === !1 ? t._movement[1] : t._movementBound[1] : !1;
    const B = t._active ? r.rubberband || [0, 0] : [0, 0];
    if (t.offset = zq(t._bounds, t.offset, B), t.delta = zc.sub(t.offset, w), this.computeMovement(), R && (!t.last || o > Jq)) {
      t.delta = zc.sub(t.offset, w);
      const $ = t.delta.map(Math.abs);
      zc.addTo(t.distance, $), t.direction = t.delta.map(Math.sign), t._direction = t._delta.map(Math.sign), !t.first && o > 0 && (t.velocity = [$[0] / o, $[1] / o], t.timeDelta = o);
    }
  }
  emit() {
    const e = this.state, t = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents)
      return;
    const i = this.handler(us(us(us({}, t), e), {}, {
      [this.aliasKey]: e.values
    }));
    i !== void 0 && (e.memo = i);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function tK([n, e], t) {
  const r = Math.abs(n), i = Math.abs(e);
  if (r > i && r > t)
    return "x";
  if (i > r && i > t)
    return "y";
}
class nK extends eK {
  constructor(...e) {
    super(...e), Ed(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = zc.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = zc.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const t = this.state, r = this.config;
    if (!t.axis && e) {
      const i = typeof r.axisThreshold == "object" ? r.axisThreshold[jB(e)] : r.axisThreshold;
      t.axis = tK(t._movement, i);
    }
    t._blocked = (r.lockDirection || !!r.axis) && !t.axis || !!r.axis && r.axis !== t.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const Ck = (n) => n, Rk = 0.15, s3 = {
  enabled(n = !0) {
    return n;
  },
  eventOptions(n, e, t) {
    return us(us({}, t.shared.eventOptions), n);
  },
  preventDefault(n = !1) {
    return n;
  },
  triggerAllEvents(n = !1) {
    return n;
  },
  rubberband(n = 0) {
    switch (n) {
      case !0:
        return [Rk, Rk];
      case !1:
        return [0, 0];
      default:
        return zc.toVector(n);
    }
  },
  from(n) {
    if (typeof n == "function")
      return n;
    if (n != null)
      return zc.toVector(n);
  },
  transform(n, e, t) {
    const r = n || t.shared.transform;
    if (this.hasCustomTransform = !!r, process.env.NODE_ENV === "development") {
      const i = r || Ck;
      return (o) => {
        const l = i(o);
        return (!isFinite(l[0]) || !isFinite(l[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${l[0]},${[1]}]`), l;
      };
    }
    return r || Ck;
  },
  threshold(n) {
    return zc.toVector(n, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(s3, {
  domTarget(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const rK = 0, pw = us(us({}, s3), {}, {
  axis(n, e, {
    axis: t
  }) {
    if (this.lockDirection = t === "lock", !this.lockDirection)
      return t;
  },
  axisThreshold(n = rK) {
    return n;
  },
  bounds(n = {}) {
    if (typeof n == "function")
      return (o) => pw.bounds(n(o));
    if ("current" in n)
      return () => n.current;
    if (typeof HTMLElement == "function" && n instanceof HTMLElement)
      return n;
    const {
      left: e = -1 / 0,
      right: t = 1 / 0,
      top: r = -1 / 0,
      bottom: i = 1 / 0
    } = n;
    return [[e, t], [r, i]];
  }
}), Ak = {
  ArrowRight: (n, e = 1) => [n * e, 0],
  ArrowLeft: (n, e = 1) => [-1 * n * e, 0],
  ArrowUp: (n, e = 1) => [0, -1 * n * e],
  ArrowDown: (n, e = 1) => [0, n * e]
};
class iK extends nK {
  constructor(...e) {
    super(...e), Ed(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const t = e._bounds.getBoundingClientRect(), r = e.currentTarget.getBoundingClientRect(), i = {
        left: t.left - r.left + e.offset[0],
        right: t.right - r.right + e.offset[0],
        top: t.top - r.top + e.offset[1],
        bottom: t.bottom - r.bottom + e.offset[1]
      };
      e._bounds = pw.bounds(i);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(e) {
    const t = this.config, r = this.state;
    if (e.buttons != null && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : t.pointerButtons !== -1 && t.pointerButtons !== e.buttons))
      return;
    const i = this.ctrl.setEventIds(e);
    t.pointerCapture && e.target.setPointerCapture(e.pointerId), !(i && i.size > 1 && r._pointerActive) && (this.start(e), this.setupPointer(e), r._pointerId = xL(e), r._pointerActive = !0, this.computeValues(wk(e)), this.computeInitial(), t.preventScrollAxis && jB(e) !== "mouse" ? (r._active = !1, this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e), t.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const t = this.state;
    t._active = !0, t._preventScroll = !0, t._delayed = !1, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const t = this.state, r = this.config;
    if (!t._pointerActive)
      return;
    const i = xL(e);
    if (t._pointerId !== void 0 && i !== t._pointerId)
      return;
    const o = wk(e);
    if (document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = zc.sub(o, t._values), this.computeValues(o)), zc.addTo(t._movement, t._delta), this.compute(e), t._delayed && t.intentional) {
      this.timeoutStore.remove("dragDelay"), t.active = !1, this.startPointerDrag(e);
      return;
    }
    if (r.preventScrollAxis && !t._preventScroll)
      if (t.axis)
        if (t.axis === r.preventScrollAxis || r.preventScrollAxis === "xy") {
          t._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const t = this.state, r = this.config;
    if (!t._active || !t._pointerActive)
      return;
    const i = xL(e);
    if (t._pointerId !== void 0 && i !== t._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [o, l] = t._distance;
    if (t.tap = o <= r.tapsThreshold && l <= r.tapsThreshold, t.tap && r.filterTaps)
      t._force = !0;
    else {
      const [c, h] = t._delta, [p, y] = t._movement, [x, b] = r.swipe.velocity, [w, R] = r.swipe.distance, U = r.swipe.duration;
      if (t.elapsedTime < U) {
        const L = Math.abs(c / t.timeDelta), A = Math.abs(h / t.timeDelta);
        L > x && Math.abs(p) > w && (t.swipe[0] = Math.sign(c)), A > b && Math.abs(y) > R && (t.swipe[1] = Math.sign(h));
      }
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const t = this.config, r = t.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (r === "pointer" && t.preventScrollDelay === void 0) {
          const i = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(i).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", i);
        }
      } catch {
      }
    t.pointerLock && e.currentTarget.requestPointerLock(), t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, r, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, aK(e);
    const t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", t), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const t = Ak[e.key];
    if (t) {
      const r = this.state, i = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), r._delta = t(this.config.keyboardDisplacement, i), r._keyboardActive = !0, zc.addTo(r._movement, r._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in Ak && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const t = this.config.device;
    e(t, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)), e(t, "end", this.pointerUp.bind(this)), e(t, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function aK(n) {
  "persist" in n && typeof n.persist == "function" && n.persist();
}
const mw = typeof window < "u" && window.document && window.document.createElement;
function YB() {
  return mw && "ontouchstart" in window;
}
function oK() {
  return YB() || mw && window.navigator.maxTouchPoints > 1;
}
function sK() {
  return mw && "onpointerdown" in window;
}
function lK() {
  return mw && "exitPointerLock" in window.document;
}
function uK() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const fp = {
  isBrowser: mw,
  gesture: uK(),
  touch: YB(),
  touchscreen: oK(),
  pointer: sK(),
  pointerLock: lK()
}, cK = 250, fK = 180, dK = 0.5, hK = 50, pK = 250, mK = 10, Dk = {
  mouse: 0,
  touch: 0,
  pen: 8
}, XB = us(us({}, pw), {}, {
  device(n, e, {
    pointer: {
      touch: t = !1,
      lock: r = !1,
      mouse: i = !1
    } = {}
  }) {
    return this.pointerLock = r && fp.pointerLock, fp.touch && t ? "touch" : this.pointerLock ? "mouse" : fp.pointer && !i ? "pointer" : fp.touch ? "touch" : "mouse";
  },
  preventScrollAxis(n, e, {
    preventScroll: t
  }) {
    if (this.preventScrollDelay = typeof t == "number" ? t : t || t === void 0 && n ? cK : void 0, !(!fp.touchscreen || t === !1))
      return n || (t !== void 0 ? "y" : void 0);
  },
  pointerCapture(n, e, {
    pointer: {
      capture: t = !0,
      buttons: r = 1,
      keys: i = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = i, !this.pointerLock && this.device === "pointer" && t;
  },
  threshold(n, e, {
    filterTaps: t = !1,
    tapsThreshold: r = 3,
    axis: i = void 0
  }) {
    const o = zc.toVector(n, t ? r : i ? 1 : 0);
    return this.filterTaps = t, this.tapsThreshold = r, o;
  },
  swipe({
    velocity: n = dK,
    distance: e = hK,
    duration: t = pK
  } = {}) {
    return {
      velocity: this.transform(zc.toVector(n)),
      distance: this.transform(zc.toVector(e)),
      duration: t
    };
  },
  delay(n = 0) {
    switch (n) {
      case !0:
        return fK;
      case !1:
        return 0;
      default:
        return n;
    }
  },
  axisThreshold(n) {
    return n ? us(us({}, Dk), n) : Dk;
  },
  keyboardDisplacement(n = mK) {
    return n;
  }
});
process.env.NODE_ENV === "development" && Object.assign(XB, {
  useTouch(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
us(us({}, s3), {}, {
  device(n, e, {
    shared: t,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (t.target && !fp.touch && fp.gesture)
      return "gesture";
    if (fp.touch && r)
      return "touch";
    if (fp.touchscreen) {
      if (fp.pointer)
        return "pointer";
      if (fp.touch)
        return "touch";
    }
  },
  bounds(n, e, {
    scaleBounds: t = {},
    angleBounds: r = {}
  }) {
    const i = (l) => {
      const c = Mk(DR(t, l), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    }, o = (l) => {
      const c = Mk(DR(r, l), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    };
    return typeof t != "function" && typeof r != "function" ? [i(), o()] : (l) => [i(l), o(l)];
  },
  threshold(n, e, t) {
    return this.lockDirection = t.axis === "lock", zc.toVector(n, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(n) {
    return n === void 0 ? "ctrlKey" : n;
  },
  pinchOnWheel(n = !0) {
    return n;
  }
});
us(us({}, pw), {}, {
  mouseOnly: (n = !0) => n
});
us(us({}, pw), {}, {
  mouseOnly: (n = !0) => n
});
const qB = /* @__PURE__ */ new Map(), kO = /* @__PURE__ */ new Map();
function vK(n) {
  qB.set(n.key, n.engine), kO.set(n.key, n.resolver);
}
const gK = {
  key: "drag",
  engine: iK,
  resolver: XB
};
function yK(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function SK(n, e) {
  if (n == null)
    return {};
  var t = yK(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
const xK = {
  target(n) {
    if (n)
      return () => "current" in n ? n.current : n;
  },
  enabled(n = !0) {
    return n;
  },
  window(n = fp.isBrowser ? window : void 0) {
    return n;
  },
  eventOptions({
    passive: n = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: n,
      capture: e
    };
  },
  transform(n) {
    return n;
  }
}, _K = ["target", "eventOptions", "window", "enabled", "transform"];
function yR(n = {}, e) {
  const t = {};
  for (const [r, i] of Object.entries(e))
    switch (typeof i) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const o = i.call(t, n[r], r, n);
          Number.isNaN(o) || (t[r] = o);
        } else
          t[r] = i.call(t, n[r], r, n);
        break;
      case "object":
        t[r] = yR(n[r], i);
        break;
      case "boolean":
        i && (t[r] = n[r]);
        break;
    }
  return t;
}
function EK(n, e, t = {}) {
  const r = n, {
    target: i,
    eventOptions: o,
    window: l,
    enabled: c,
    transform: h
  } = r, p = SK(r, _K);
  if (t.shared = yR({
    target: i,
    eventOptions: o,
    window: l,
    enabled: c,
    transform: h
  }, xK), e) {
    const y = kO.get(e);
    t[e] = yR(us({
      shared: t.shared
    }, p), y);
  } else
    for (const y in p) {
      const x = kO.get(y);
      if (x)
        t[y] = yR(us({
          shared: t.shared
        }, p[y]), x);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(y)) {
        if (y === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${y}\` was used. Please read the documentation for further information.`);
      }
    }
  return t;
}
class KB {
  constructor(e, t) {
    Ed(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = t;
  }
  add(e, t, r, i, o) {
    const l = this._listeners, c = $q(t, r), h = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, p = us(us({}, h), o);
    e.addEventListener(c, i, p);
    const y = () => {
      e.removeEventListener(c, i, p), l.delete(y);
    };
    return l.add(y), y;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class bK {
  constructor() {
    Ed(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, t, r = 140, ...i) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(t, r, ...i));
  }
  remove(e) {
    const t = this._timeouts.get(e);
    t && window.clearTimeout(t);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class TK {
  constructor(e) {
    Ed(this, "gestures", /* @__PURE__ */ new Set()), Ed(this, "_targetEventStore", new KB(this)), Ed(this, "gestureEventStores", {}), Ed(this, "gestureTimeoutStores", {}), Ed(this, "handlers", {}), Ed(this, "config", {}), Ed(this, "pointerIds", /* @__PURE__ */ new Set()), Ed(this, "touchIds", /* @__PURE__ */ new Set()), Ed(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), wK(this, e);
  }
  setEventIds(e) {
    if (T2(e))
      return this.touchIds = new Set(qq(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, t) {
    this.handlers = e, this.nativeHandlers = t;
  }
  applyConfig(e, t) {
    this.config = EK(e, t, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const t = this.config.shared, r = {};
    let i;
    if (!(t.target && (i = t.target(), !i))) {
      if (t.enabled) {
        for (const l of this.gestures) {
          const c = this.config[l], h = Lk(r, c.eventOptions, !!i);
          if (c.enabled) {
            const p = qB.get(l);
            new p(this, e, l).bind(h);
          }
        }
        const o = Lk(r, t.eventOptions, !!i);
        for (const l in this.nativeHandlers)
          o(l, "", (c) => this.nativeHandlers[l](us(us({}, this.state.shared), {}, {
            event: c,
            args: e
          })), void 0, !0);
      }
      for (const o in r)
        r[o] = Zq(...r[o]);
      if (!i)
        return r;
      for (const o in r) {
        const {
          device: l,
          capture: c,
          passive: h
        } = jq(o);
        this._targetEventStore.add(i, l, "", r[o], {
          capture: c,
          passive: h
        });
      }
    }
  }
}
function D1(n, e) {
  n.gestures.add(e), n.gestureEventStores[e] = new KB(n, e), n.gestureTimeoutStores[e] = new bK();
}
function wK(n, e) {
  e.drag && D1(n, "drag"), e.wheel && D1(n, "wheel"), e.scroll && D1(n, "scroll"), e.move && D1(n, "move"), e.pinch && D1(n, "pinch"), e.hover && D1(n, "hover");
}
const Lk = (n, e, t) => (r, i, o, l = {}, c = !1) => {
  var h, p;
  const y = (h = l.capture) !== null && h !== void 0 ? h : e.capture, x = (p = l.passive) !== null && p !== void 0 ? p : e.passive;
  let b = c ? r : Gq(r, i, y);
  t && x && (b += "Passive"), n[b] = n[b] || [], n[b].push(o);
};
function MK(n, e = {}, t, r) {
  const i = Fe.useMemo(() => new TK(n), []);
  if (i.applyHandlers(n, r), i.applyConfig(e, t), Fe.useEffect(i.effect.bind(i)), Fe.useEffect(() => i.clean.bind(i), []), e.target === void 0)
    return i.bind.bind(i);
}
function CK(n, e) {
  return vK(gK), MK({
    drag: n
  }, e || {}, "drag");
}
const RK = (n) => (e, t, r) => {
  const i = r.subscribe;
  return r.subscribe = (l, c, h) => {
    let p = l;
    if (c) {
      const y = (h == null ? void 0 : h.equalityFn) || Object.is;
      let x = l(r.getState());
      p = (b) => {
        const w = l(b);
        if (!y(x, w)) {
          const R = x;
          c(x = w, R);
        }
      }, h != null && h.fireImmediately && c(x, x);
    }
    return i(p);
  }, n(e, t, r);
};
var AK = Object.defineProperty, DK = (n, e, t) => e in n ? AK(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Ur = (n, e, t) => (DK(n, typeof e != "symbol" ? e + "" : e, t), t);
const JC = new wx(), Ok = new kg(), LK = Math.cos(70 * (Math.PI / 180)), Pk = (n, e) => (n % e + e) % e;
let OK = class extends Av {
  constructor(e, t) {
    super(), Ur(this, "object"), Ur(this, "domElement"), Ur(this, "enabled", !0), Ur(this, "target", new Te()), Ur(this, "minDistance", 0), Ur(this, "maxDistance", 1 / 0), Ur(this, "minZoom", 0), Ur(this, "maxZoom", 1 / 0), Ur(this, "minPolarAngle", 0), Ur(this, "maxPolarAngle", Math.PI), Ur(this, "minAzimuthAngle", -1 / 0), Ur(this, "maxAzimuthAngle", 1 / 0), Ur(this, "enableDamping", !1), Ur(this, "dampingFactor", 0.05), Ur(this, "enableZoom", !0), Ur(this, "zoomSpeed", 1), Ur(this, "enableRotate", !0), Ur(this, "rotateSpeed", 1), Ur(this, "enablePan", !0), Ur(this, "panSpeed", 1), Ur(this, "screenSpacePanning", !0), Ur(this, "keyPanSpeed", 7), Ur(this, "zoomToCursor", !1), Ur(this, "autoRotate", !1), Ur(this, "autoRotateSpeed", 2), Ur(this, "reverseOrbit", !1), Ur(this, "reverseHorizontalOrbit", !1), Ur(this, "reverseVerticalOrbit", !1), Ur(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Ur(this, "mouseButtons", {
      LEFT: JS.ROTATE,
      MIDDLE: JS.DOLLY,
      RIGHT: JS.PAN
    }), Ur(this, "touches", { ONE: ex.ROTATE, TWO: ex.DOLLY_PAN }), Ur(this, "target0"), Ur(this, "position0"), Ur(this, "zoom0"), Ur(this, "_domElementKeyEvents", null), Ur(this, "getPolarAngle"), Ur(this, "getAzimuthalAngle"), Ur(this, "setPolarAngle"), Ur(this, "setAzimuthalAngle"), Ur(this, "getDistance"), Ur(this, "listenToKeyEvents"), Ur(this, "stopListenToKeyEvents"), Ur(this, "saveState"), Ur(this, "reset"), Ur(this, "update"), Ur(this, "connect"), Ur(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => y.phi, this.getAzimuthalAngle = () => y.theta, this.setPolarAngle = (be) => {
      let Ze = Pk(be, 2 * Math.PI), ct = y.phi;
      ct < 0 && (ct += 2 * Math.PI), Ze < 0 && (Ze += 2 * Math.PI);
      let pe = Math.abs(Ze - ct);
      2 * Math.PI - pe < pe && (Ze < ct ? Ze += 2 * Math.PI : ct += 2 * Math.PI), x.phi = Ze - ct, r.update();
    }, this.setAzimuthalAngle = (be) => {
      let Ze = Pk(be, 2 * Math.PI), ct = y.theta;
      ct < 0 && (ct += 2 * Math.PI), Ze < 0 && (Ze += 2 * Math.PI);
      let pe = Math.abs(Ze - ct);
      2 * Math.PI - pe < pe && (Ze < ct ? Ze += 2 * Math.PI : ct += 2 * Math.PI), x.theta = Ze - ct, r.update();
    }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = (be) => {
      be.addEventListener("keydown", at), this._domElementKeyEvents = be;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", at), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom;
    }, this.reset = () => {
      r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(i), r.update(), h = c.NONE;
    }, this.update = (() => {
      const be = new Te(), Ze = new Te(0, 1, 0), ct = new Bc().setFromUnitVectors(e.up, Ze), pe = ct.clone().invert(), Rt = new Te(), Be = new Bc(), ut = 2 * Math.PI;
      return function() {
        const zn = r.object.position;
        ct.setFromUnitVectors(e.up, Ze), pe.copy(ct).invert(), be.copy(zn).sub(r.target), be.applyQuaternion(ct), y.setFromVector3(be), r.autoRotate && h === c.NONE && de(oe()), r.enableDamping ? (y.theta += x.theta * r.dampingFactor, y.phi += x.phi * r.dampingFactor) : (y.theta += x.theta, y.phi += x.phi);
        let Gn = r.minAzimuthAngle, rr = r.maxAzimuthAngle;
        isFinite(Gn) && isFinite(rr) && (Gn < -Math.PI ? Gn += ut : Gn > Math.PI && (Gn -= ut), rr < -Math.PI ? rr += ut : rr > Math.PI && (rr -= ut), Gn <= rr ? y.theta = Math.max(Gn, Math.min(rr, y.theta)) : y.theta = y.theta > (Gn + rr) / 2 ? Math.max(Gn, y.theta) : Math.min(rr, y.theta)), y.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, y.phi)), y.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(w, r.dampingFactor) : r.target.add(w), r.zoomToCursor && K || r.object.isOrthographicCamera ? y.radius = he(y.radius) : y.radius = he(y.radius * b), be.setFromSpherical(y), be.applyQuaternion(pe), zn.copy(r.target).add(be), r.object.lookAt(r.target), r.enableDamping === !0 ? (x.theta *= 1 - r.dampingFactor, x.phi *= 1 - r.dampingFactor, w.multiplyScalar(1 - r.dampingFactor)) : (x.set(0, 0, 0), w.set(0, 0, 0));
        let mn = !1;
        if (r.zoomToCursor && K) {
          let er = null;
          if (r.object instanceof Ps && r.object.isPerspectiveCamera) {
            const ir = be.length();
            er = he(ir * b);
            const Wn = ir - er;
            r.object.position.addScaledVector(Y, Wn), r.object.updateMatrixWorld();
          } else if (r.object.isOrthographicCamera) {
            const ir = new Te(J.x, J.y, 0);
            ir.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / b)), r.object.updateProjectionMatrix(), mn = !0;
            const Wn = new Te(J.x, J.y, 0);
            Wn.unproject(r.object), r.object.position.sub(Wn).add(ir), r.object.updateMatrixWorld(), er = be.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1;
          er !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar(er).add(r.object.position) : (JC.origin.copy(r.object.position), JC.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(JC.direction)) < LK ? e.lookAt(r.target) : (Ok.setFromNormalAndCoplanarPoint(r.object.up, r.target), JC.intersectPlane(Ok, r.target))));
        } else
          r.object instanceof Vg && r.object.isOrthographicCamera && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / b)), r.object.updateProjectionMatrix(), mn = !0);
        return b = 1, K = !1, mn || Rt.distanceToSquared(r.object.position) > p || 8 * (1 - Be.dot(r.object.quaternion)) > p ? (r.dispatchEvent(i), Rt.copy(r.object.position), Be.copy(r.object.quaternion), mn = !1, !0) : !1;
      };
    })(), this.connect = (be) => {
      be === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), r.domElement = be, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Se), r.domElement.addEventListener("pointerdown", vt), r.domElement.addEventListener("pointercancel", ne), r.domElement.addEventListener("wheel", ot);
    }, this.dispose = () => {
      var be, Ze, ct, pe, Rt, Be;
      (be = r.domElement) == null || be.removeEventListener("contextmenu", Se), (Ze = r.domElement) == null || Ze.removeEventListener("pointerdown", vt), (ct = r.domElement) == null || ct.removeEventListener("pointercancel", ne), (pe = r.domElement) == null || pe.removeEventListener("wheel", ot), (Rt = r.domElement) == null || Rt.ownerDocument.removeEventListener("pointermove", Zt), (Be = r.domElement) == null || Be.ownerDocument.removeEventListener("pointerup", ie), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", at);
    };
    const r = this, i = { type: "change" }, o = { type: "start" }, l = { type: "end" }, c = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let h = c.NONE;
    const p = 1e-6, y = new AO(), x = new AO();
    let b = 1;
    const w = new Te(), R = new Ht(), U = new Ht(), L = new Ht(), A = new Ht(), F = new Ht(), k = new Ht(), H = new Ht(), B = new Ht(), $ = new Ht(), Y = new Te(), J = new Ht();
    let K = !1;
    const X = [], le = {};
    function oe() {
      return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed;
    }
    function fe() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function de(be) {
      r.reverseOrbit || r.reverseHorizontalOrbit ? x.theta += be : x.theta -= be;
    }
    function xe(be) {
      r.reverseOrbit || r.reverseVerticalOrbit ? x.phi += be : x.phi -= be;
    }
    const _e = (() => {
      const be = new Te();
      return function(ct, pe) {
        be.setFromMatrixColumn(pe, 0), be.multiplyScalar(-ct), w.add(be);
      };
    })(), Pe = (() => {
      const be = new Te();
      return function(ct, pe) {
        r.screenSpacePanning === !0 ? be.setFromMatrixColumn(pe, 1) : (be.setFromMatrixColumn(pe, 0), be.crossVectors(r.object.up, be)), be.multiplyScalar(ct), w.add(be);
      };
    })(), ce = (() => {
      const be = new Te();
      return function(ct, pe) {
        const Rt = r.domElement;
        if (Rt && r.object instanceof Ps && r.object.isPerspectiveCamera) {
          const Be = r.object.position;
          be.copy(Be).sub(r.target);
          let ut = be.length();
          ut *= Math.tan(r.object.fov / 2 * Math.PI / 180), _e(2 * ct * ut / Rt.clientHeight, r.object.matrix), Pe(2 * pe * ut / Rt.clientHeight, r.object.matrix);
        } else
          Rt && r.object instanceof Vg && r.object.isOrthographicCamera ? (_e(
            ct * (r.object.right - r.object.left) / r.object.zoom / Rt.clientWidth,
            r.object.matrix
          ), Pe(
            pe * (r.object.top - r.object.bottom) / r.object.zoom / Rt.clientHeight,
            r.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1);
      };
    })();
    function ve(be) {
      r.object instanceof Ps && r.object.isPerspectiveCamera || r.object instanceof Vg && r.object.isOrthographicCamera ? b /= be : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function re(be) {
      r.object instanceof Ps && r.object.isPerspectiveCamera || r.object instanceof Vg && r.object.isOrthographicCamera ? b *= be : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function ee(be) {
      if (!r.zoomToCursor || !r.domElement)
        return;
      K = !0;
      const Ze = r.domElement.getBoundingClientRect(), ct = be.clientX - Ze.left, pe = be.clientY - Ze.top, Rt = Ze.width, Be = Ze.height;
      J.x = ct / Rt * 2 - 1, J.y = -(pe / Be) * 2 + 1, Y.set(J.x, J.y, 1).unproject(r.object).sub(r.object.position).normalize();
    }
    function he(be) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, be));
    }
    function Me(be) {
      R.set(be.clientX, be.clientY);
    }
    function Le(be) {
      ee(be), H.set(be.clientX, be.clientY);
    }
    function Ae(be) {
      A.set(be.clientX, be.clientY);
    }
    function Ue(be) {
      U.set(be.clientX, be.clientY), L.subVectors(U, R).multiplyScalar(r.rotateSpeed);
      const Ze = r.domElement;
      Ze && (de(2 * Math.PI * L.x / Ze.clientHeight), xe(2 * Math.PI * L.y / Ze.clientHeight)), R.copy(U), r.update();
    }
    function Ne(be) {
      B.set(be.clientX, be.clientY), $.subVectors(B, H), $.y > 0 ? ve(fe()) : $.y < 0 && re(fe()), H.copy(B), r.update();
    }
    function ke(be) {
      F.set(be.clientX, be.clientY), k.subVectors(F, A).multiplyScalar(r.panSpeed), ce(k.x, k.y), A.copy(F), r.update();
    }
    function it(be) {
      ee(be), be.deltaY < 0 ? re(fe()) : be.deltaY > 0 && ve(fe()), r.update();
    }
    function At(be) {
      let Ze = !1;
      switch (be.code) {
        case r.keys.UP:
          ce(0, r.keyPanSpeed), Ze = !0;
          break;
        case r.keys.BOTTOM:
          ce(0, -r.keyPanSpeed), Ze = !0;
          break;
        case r.keys.LEFT:
          ce(r.keyPanSpeed, 0), Ze = !0;
          break;
        case r.keys.RIGHT:
          ce(-r.keyPanSpeed, 0), Ze = !0;
          break;
      }
      Ze && (be.preventDefault(), r.update());
    }
    function rt() {
      if (X.length == 1)
        R.set(X[0].pageX, X[0].pageY);
      else {
        const be = 0.5 * (X[0].pageX + X[1].pageX), Ze = 0.5 * (X[0].pageY + X[1].pageY);
        R.set(be, Ze);
      }
    }
    function ae() {
      if (X.length == 1)
        A.set(X[0].pageX, X[0].pageY);
      else {
        const be = 0.5 * (X[0].pageX + X[1].pageX), Ze = 0.5 * (X[0].pageY + X[1].pageY);
        A.set(be, Ze);
      }
    }
    function et() {
      const be = X[0].pageX - X[1].pageX, Ze = X[0].pageY - X[1].pageY, ct = Math.sqrt(be * be + Ze * Ze);
      H.set(0, ct);
    }
    function Ye() {
      r.enableZoom && et(), r.enablePan && ae();
    }
    function Ge() {
      r.enableZoom && et(), r.enableRotate && rt();
    }
    function $e(be) {
      if (X.length == 1)
        U.set(be.pageX, be.pageY);
      else {
        const ct = Je(be), pe = 0.5 * (be.pageX + ct.x), Rt = 0.5 * (be.pageY + ct.y);
        U.set(pe, Rt);
      }
      L.subVectors(U, R).multiplyScalar(r.rotateSpeed);
      const Ze = r.domElement;
      Ze && (de(2 * Math.PI * L.x / Ze.clientHeight), xe(2 * Math.PI * L.y / Ze.clientHeight)), R.copy(U);
    }
    function Ut(be) {
      if (X.length == 1)
        F.set(be.pageX, be.pageY);
      else {
        const Ze = Je(be), ct = 0.5 * (be.pageX + Ze.x), pe = 0.5 * (be.pageY + Ze.y);
        F.set(ct, pe);
      }
      k.subVectors(F, A).multiplyScalar(r.panSpeed), ce(k.x, k.y), A.copy(F);
    }
    function nt(be) {
      const Ze = Je(be), ct = be.pageX - Ze.x, pe = be.pageY - Ze.y, Rt = Math.sqrt(ct * ct + pe * pe);
      B.set(0, Rt), $.set(0, Math.pow(B.y / H.y, r.zoomSpeed)), ve($.y), H.copy(B);
    }
    function Ct(be) {
      r.enableZoom && nt(be), r.enablePan && Ut(be);
    }
    function Pt(be) {
      r.enableZoom && nt(be), r.enableRotate && $e(be);
    }
    function vt(be) {
      var Ze, ct;
      r.enabled !== !1 && (X.length === 0 && ((Ze = r.domElement) == null || Ze.ownerDocument.addEventListener("pointermove", Zt), (ct = r.domElement) == null || ct.ownerDocument.addEventListener("pointerup", ie)), He(be), be.pointerType === "touch" ? Wt(be) : Oe(be));
    }
    function Zt(be) {
      r.enabled !== !1 && (be.pointerType === "touch" ? Dt(be) : _t(be));
    }
    function ie(be) {
      var Ze, ct, pe;
      lt(be), X.length === 0 && ((Ze = r.domElement) == null || Ze.releasePointerCapture(be.pointerId), (ct = r.domElement) == null || ct.ownerDocument.removeEventListener("pointermove", Zt), (pe = r.domElement) == null || pe.ownerDocument.removeEventListener("pointerup", ie)), r.dispatchEvent(l), h = c.NONE;
    }
    function ne(be) {
      lt(be);
    }
    function Oe(be) {
      let Ze;
      switch (be.button) {
        case 0:
          Ze = r.mouseButtons.LEFT;
          break;
        case 1:
          Ze = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Ze = r.mouseButtons.RIGHT;
          break;
        default:
          Ze = -1;
      }
      switch (Ze) {
        case JS.DOLLY:
          if (r.enableZoom === !1)
            return;
          Le(be), h = c.DOLLY;
          break;
        case JS.ROTATE:
          if (be.ctrlKey || be.metaKey || be.shiftKey) {
            if (r.enablePan === !1)
              return;
            Ae(be), h = c.PAN;
          } else {
            if (r.enableRotate === !1)
              return;
            Me(be), h = c.ROTATE;
          }
          break;
        case JS.PAN:
          if (be.ctrlKey || be.metaKey || be.shiftKey) {
            if (r.enableRotate === !1)
              return;
            Me(be), h = c.ROTATE;
          } else {
            if (r.enablePan === !1)
              return;
            Ae(be), h = c.PAN;
          }
          break;
        default:
          h = c.NONE;
      }
      h !== c.NONE && r.dispatchEvent(o);
    }
    function _t(be) {
      if (r.enabled !== !1)
        switch (h) {
          case c.ROTATE:
            if (r.enableRotate === !1)
              return;
            Ue(be);
            break;
          case c.DOLLY:
            if (r.enableZoom === !1)
              return;
            Ne(be);
            break;
          case c.PAN:
            if (r.enablePan === !1)
              return;
            ke(be);
            break;
        }
    }
    function ot(be) {
      r.enabled === !1 || r.enableZoom === !1 || h !== c.NONE && h !== c.ROTATE || (be.preventDefault(), r.dispatchEvent(o), it(be), r.dispatchEvent(l));
    }
    function at(be) {
      r.enabled === !1 || r.enablePan === !1 || At(be);
    }
    function Wt(be) {
      switch (St(be), X.length) {
        case 1:
          switch (r.touches.ONE) {
            case ex.ROTATE:
              if (r.enableRotate === !1)
                return;
              rt(), h = c.TOUCH_ROTATE;
              break;
            case ex.PAN:
              if (r.enablePan === !1)
                return;
              ae(), h = c.TOUCH_PAN;
              break;
            default:
              h = c.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case ex.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1)
                return;
              Ye(), h = c.TOUCH_DOLLY_PAN;
              break;
            case ex.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1)
                return;
              Ge(), h = c.TOUCH_DOLLY_ROTATE;
              break;
            default:
              h = c.NONE;
          }
          break;
        default:
          h = c.NONE;
      }
      h !== c.NONE && r.dispatchEvent(o);
    }
    function Dt(be) {
      switch (St(be), h) {
        case c.TOUCH_ROTATE:
          if (r.enableRotate === !1)
            return;
          $e(be), r.update();
          break;
        case c.TOUCH_PAN:
          if (r.enablePan === !1)
            return;
          Ut(be), r.update();
          break;
        case c.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1)
            return;
          Ct(be), r.update();
          break;
        case c.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1)
            return;
          Pt(be), r.update();
          break;
        default:
          h = c.NONE;
      }
    }
    function Se(be) {
      r.enabled !== !1 && be.preventDefault();
    }
    function He(be) {
      X.push(be);
    }
    function lt(be) {
      delete le[be.pointerId];
      for (let Ze = 0; Ze < X.length; Ze++)
        if (X[Ze].pointerId == be.pointerId) {
          X.splice(Ze, 1);
          return;
        }
    }
    function St(be) {
      let Ze = le[be.pointerId];
      Ze === void 0 && (Ze = new Ht(), le[be.pointerId] = Ze), Ze.set(be.pageX, be.pageY);
    }
    function Je(be) {
      const Ze = be.pointerId === X[0].pointerId ? X[1] : X[0];
      return le[Ze.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
function vw(n, e) {
  if (Object.is(n, e))
    return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(n);
  if (t.length !== Object.keys(e).length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!Object.prototype.hasOwnProperty.call(e, t[r]) || !Object.is(n[t[r]], e[t[r]]))
      return !1;
  return !0;
}
function PK() {
  var n = /* @__PURE__ */ Object.create(null);
  function e(i, o) {
    var l = i.id, c = i.name, h = i.dependencies;
    h === void 0 && (h = []);
    var p = i.init;
    p === void 0 && (p = function() {
    });
    var y = i.getTransferables;
    if (y === void 0 && (y = null), !n[l])
      try {
        h = h.map(function(b) {
          return b && b.isWorkerModule && (e(b, function(w) {
            if (w instanceof Error)
              throw w;
          }), b = n[b.id].value), b;
        }), p = r("<" + c + ">.init", p), y && (y = r("<" + c + ">.getTransferables", y));
        var x = null;
        typeof p == "function" ? x = p.apply(void 0, h) : console.error("worker module init function failed to rehydrate"), n[l] = {
          id: l,
          value: x,
          getTransferables: y
        }, o(x);
      } catch (b) {
        b && b.noLog || console.error(b), o(b);
      }
  }
  function t(i, o) {
    var l, c = i.id, h = i.args;
    (!n[c] || typeof n[c].value != "function") && o(new Error("Worker module " + c + ": not found or its 'init' did not return a function"));
    try {
      var p = (l = n[c]).value.apply(l, h);
      p && typeof p.then == "function" ? p.then(y, function(x) {
        return o(x instanceof Error ? x : new Error("" + x));
      }) : y(p);
    } catch (x) {
      o(x);
    }
    function y(x) {
      try {
        var b = n[c].getTransferables && n[c].getTransferables(x);
        (!b || !Array.isArray(b) || !b.length) && (b = void 0), o(x, b);
      } catch (w) {
        console.error(w), o(w);
      }
    }
  }
  function r(i, o) {
    var l = void 0;
    self.troikaDefine = function(h) {
      return l = h;
    };
    var c = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(c);
    } catch (h) {
      console.error(h);
    }
    return URL.revokeObjectURL(c), delete self.troikaDefine, l;
  }
  self.addEventListener("message", function(i) {
    var o = i.data, l = o.messageId, c = o.action, h = o.data;
    try {
      c === "registerModule" && e(h, function(p) {
        p instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: p.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: { isCallable: typeof p == "function" }
        });
      }), c === "callModule" && t(h, function(p, y) {
        p instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: p.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: p
        }, y || void 0);
      });
    } catch (p) {
      postMessage({
        messageId: l,
        success: !1,
        error: p.stack
      });
    }
  });
}
function UK(n) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = n.dependencies, r = n.init;
    t = Array.isArray(t) ? t.map(
      function(o) {
        return o && o._getInitResult ? o._getInitResult() : o;
      }
    ) : [];
    var i = Promise.all(t).then(function(o) {
      return r.apply(null, o);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var QB = function() {
  var n = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), n = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return QB = function() {
    return n;
  }, n;
}, NK = 0, FK = 0, _L = !1, AT = /* @__PURE__ */ Object.create(null), DT = /* @__PURE__ */ Object.create(null), zO = /* @__PURE__ */ Object.create(null);
function gw(n) {
  if ((!n || typeof n.init != "function") && !_L)
    throw new Error("requires `options.init` function");
  var e = n.dependencies, t = n.init, r = n.getTransferables, i = n.workerId;
  if (!QB())
    return UK(n);
  i == null && (i = "#default");
  var o = "workerModule" + ++NK, l = n.name || o, c = null;
  e = e && e.map(function(p) {
    return typeof p == "function" && !p.workerModuleData && (_L = !0, p = gw({
      workerId: i,
      name: "<" + l + "> function dependency: " + p.name,
      init: `function(){return (
` + SR(p) + `
)}`
    }), _L = !1), p && p.workerModuleData && (p = p.workerModuleData), p;
  });
  function h() {
    for (var p = [], y = arguments.length; y--; )
      p[y] = arguments[y];
    if (!c) {
      c = Uk(i, "registerModule", h.workerModuleData);
      var x = function() {
        c = null, DT[i].delete(x);
      };
      (DT[i] || (DT[i] = /* @__PURE__ */ new Set())).add(x);
    }
    return c.then(function(b) {
      var w = b.isCallable;
      if (w)
        return Uk(i, "callModule", { id: o, args: p });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return h.workerModuleData = {
    isWorkerModule: !0,
    id: o,
    name: l,
    dependencies: e,
    init: SR(t),
    getTransferables: r && SR(r)
  }, h;
}
function kK(n) {
  DT[n] && DT[n].forEach(function(e) {
    e();
  }), AT[n] && (AT[n].terminate(), delete AT[n]);
}
function SR(n) {
  var e = n.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function zK(n) {
  var e = AT[n];
  if (!e) {
    var t = SR(PK);
    e = AT[n] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + n.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var i = r.data, o = i.messageId, l = zO[o];
      if (!l)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete zO[o], l(i);
    };
  }
  return e;
}
function Uk(n, e, t) {
  return new Promise(function(r, i) {
    var o = ++FK;
    zO[o] = function(l) {
      l.success ? r(l.result) : i(new Error("Error in worker " + e + " call: " + l.error));
    }, zK(n).postMessage({
      messageId: o,
      action: e,
      data: t
    });
  });
}
function ZB() {
  var n = function(e) {
    function t(ve, re, ee, he, Me, Le, Ae, Ue) {
      var Ne = 1 - Ae;
      Ue.x = Ne * Ne * ve + 2 * Ne * Ae * ee + Ae * Ae * Me, Ue.y = Ne * Ne * re + 2 * Ne * Ae * he + Ae * Ae * Le;
    }
    function r(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke) {
      var it = 1 - Ne;
      ke.x = it * it * it * ve + 3 * it * it * Ne * ee + 3 * it * Ne * Ne * Me + Ne * Ne * Ne * Ae, ke.y = it * it * it * re + 3 * it * it * Ne * he + 3 * it * Ne * Ne * Le + Ne * Ne * Ne * Ue;
    }
    function i(ve, re) {
      for (var ee = /([MLQCZ])([^MLQCZ]*)/g, he, Me, Le, Ae, Ue; he = ee.exec(ve); ) {
        var Ne = he[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(ke) {
          return parseFloat(ke);
        });
        switch (he[1]) {
          case "M":
            Ae = Me = Ne[0], Ue = Le = Ne[1];
            break;
          case "L":
            (Ne[0] !== Ae || Ne[1] !== Ue) && re("L", Ae, Ue, Ae = Ne[0], Ue = Ne[1]);
            break;
          case "Q": {
            re("Q", Ae, Ue, Ae = Ne[2], Ue = Ne[3], Ne[0], Ne[1]);
            break;
          }
          case "C": {
            re("C", Ae, Ue, Ae = Ne[4], Ue = Ne[5], Ne[0], Ne[1], Ne[2], Ne[3]);
            break;
          }
          case "Z":
            (Ae !== Me || Ue !== Le) && re("L", Ae, Ue, Me, Le);
            break;
        }
      }
    }
    function o(ve, re, ee) {
      ee === void 0 && (ee = 16);
      var he = { x: 0, y: 0 };
      i(ve, function(Me, Le, Ae, Ue, Ne, ke, it, At, rt) {
        switch (Me) {
          case "L":
            re(Le, Ae, Ue, Ne);
            break;
          case "Q": {
            for (var ae = Le, et = Ae, Ye = 1; Ye < ee; Ye++)
              t(
                Le,
                Ae,
                ke,
                it,
                Ue,
                Ne,
                Ye / (ee - 1),
                he
              ), re(ae, et, he.x, he.y), ae = he.x, et = he.y;
            break;
          }
          case "C": {
            for (var Ge = Le, $e = Ae, Ut = 1; Ut < ee; Ut++)
              r(
                Le,
                Ae,
                ke,
                it,
                At,
                rt,
                Ue,
                Ne,
                Ut / (ee - 1),
                he
              ), re(Ge, $e, he.x, he.y), Ge = he.x, $e = he.y;
            break;
          }
        }
      });
    }
    var l = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", c = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", h = /* @__PURE__ */ new WeakMap(), p = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function y(ve, re) {
      var ee = ve.getContext ? ve.getContext("webgl", p) : ve, he = h.get(ee);
      if (!he) {
        let it = function(Ge) {
          var $e = Le[Ge];
          if (!$e && ($e = Le[Ge] = ee.getExtension(Ge), !$e))
            throw new Error(Ge + " not supported");
          return $e;
        }, At = function(Ge, $e) {
          var Ut = ee.createShader($e);
          return ee.shaderSource(Ut, Ge), ee.compileShader(Ut), Ut;
        }, rt = function(Ge, $e, Ut, nt) {
          if (!Ae[Ge]) {
            var Ct = {}, Pt = {}, vt = ee.createProgram();
            ee.attachShader(vt, At($e, ee.VERTEX_SHADER)), ee.attachShader(vt, At(Ut, ee.FRAGMENT_SHADER)), ee.linkProgram(vt), Ae[Ge] = {
              program: vt,
              transaction: function(ie) {
                ee.useProgram(vt), ie({
                  setUniform: function(Oe, _t) {
                    for (var ot = [], at = arguments.length - 2; at-- > 0; )
                      ot[at] = arguments[at + 2];
                    var Wt = Pt[_t] || (Pt[_t] = ee.getUniformLocation(vt, _t));
                    ee["uniform" + Oe].apply(ee, [Wt].concat(ot));
                  },
                  setAttribute: function(Oe, _t, ot, at, Wt) {
                    var Dt = Ct[Oe];
                    Dt || (Dt = Ct[Oe] = {
                      buf: ee.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: ee.getAttribLocation(vt, Oe),
                      data: null
                    }), ee.bindBuffer(ee.ARRAY_BUFFER, Dt.buf), ee.vertexAttribPointer(Dt.loc, _t, ee.FLOAT, !1, 0, 0), ee.enableVertexAttribArray(Dt.loc), Me ? ee.vertexAttribDivisor(Dt.loc, at) : it("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Dt.loc, at), Wt !== Dt.data && (ee.bufferData(ee.ARRAY_BUFFER, Wt, ot), Dt.data = Wt);
                  }
                });
              }
            };
          }
          Ae[Ge].transaction(nt);
        }, ae = function(Ge, $e) {
          Ne++;
          try {
            ee.activeTexture(ee.TEXTURE0 + Ne);
            var Ut = Ue[Ge];
            Ut || (Ut = Ue[Ge] = ee.createTexture(), ee.bindTexture(ee.TEXTURE_2D, Ut), ee.texParameteri(ee.TEXTURE_2D, ee.TEXTURE_MIN_FILTER, ee.NEAREST), ee.texParameteri(ee.TEXTURE_2D, ee.TEXTURE_MAG_FILTER, ee.NEAREST)), ee.bindTexture(ee.TEXTURE_2D, Ut), $e(Ut, Ne);
          } finally {
            Ne--;
          }
        }, et = function(Ge, $e, Ut) {
          var nt = ee.createFramebuffer();
          ke.push(nt), ee.bindFramebuffer(ee.FRAMEBUFFER, nt), ee.activeTexture(ee.TEXTURE0 + $e), ee.bindTexture(ee.TEXTURE_2D, Ge), ee.framebufferTexture2D(ee.FRAMEBUFFER, ee.COLOR_ATTACHMENT0, ee.TEXTURE_2D, Ge, 0);
          try {
            Ut(nt);
          } finally {
            ee.deleteFramebuffer(nt), ee.bindFramebuffer(ee.FRAMEBUFFER, ke[--ke.length - 1] || null);
          }
        }, Ye = function() {
          Le = {}, Ae = {}, Ue = {}, Ne = -1, ke.length = 0;
        };
        var Me = typeof WebGL2RenderingContext < "u" && ee instanceof WebGL2RenderingContext, Le = {}, Ae = {}, Ue = {}, Ne = -1, ke = [];
        ee.canvas.addEventListener("webglcontextlost", function(Ge) {
          Ye(), Ge.preventDefault();
        }, !1), h.set(ee, he = {
          gl: ee,
          isWebGL2: Me,
          getExtension: it,
          withProgram: rt,
          withTexture: ae,
          withTextureFramebuffer: et,
          handleContextLoss: Ye
        });
      }
      re(he);
    }
    function x(ve, re, ee, he, Me, Le, Ae, Ue) {
      Ae === void 0 && (Ae = 15), Ue === void 0 && (Ue = null), y(ve, function(Ne) {
        var ke = Ne.gl, it = Ne.withProgram, At = Ne.withTexture;
        At("copy", function(rt, ae) {
          ke.texImage2D(ke.TEXTURE_2D, 0, ke.RGBA, Me, Le, 0, ke.RGBA, ke.UNSIGNED_BYTE, re), it("copy", l, c, function(et) {
            var Ye = et.setUniform, Ge = et.setAttribute;
            Ge("aUV", 2, ke.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Ye("1i", "image", ae), ke.bindFramebuffer(ke.FRAMEBUFFER, Ue || null), ke.disable(ke.BLEND), ke.colorMask(Ae & 8, Ae & 4, Ae & 2, Ae & 1), ke.viewport(ee, he, Me, Le), ke.scissor(ee, he, Me, Le), ke.drawArrays(ke.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function b(ve, re, ee) {
      var he = ve.width, Me = ve.height;
      y(ve, function(Le) {
        var Ae = Le.gl, Ue = new Uint8Array(he * Me * 4);
        Ae.readPixels(0, 0, he, Me, Ae.RGBA, Ae.UNSIGNED_BYTE, Ue), ve.width = re, ve.height = ee, x(Ae, Ue, 0, 0, he, Me);
      });
    }
    var w = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: y,
      renderImageData: x,
      resizeWebGLCanvasWithoutClearing: b
    });
    function R(ve, re, ee, he, Me, Le) {
      Le === void 0 && (Le = 1);
      var Ae = new Uint8Array(ve * re), Ue = he[2] - he[0], Ne = he[3] - he[1], ke = [];
      o(ee, function(Ge, $e, Ut, nt) {
        ke.push({
          x1: Ge,
          y1: $e,
          x2: Ut,
          y2: nt,
          minX: Math.min(Ge, Ut),
          minY: Math.min($e, nt),
          maxX: Math.max(Ge, Ut),
          maxY: Math.max($e, nt)
        });
      }), ke.sort(function(Ge, $e) {
        return Ge.maxX - $e.maxX;
      });
      for (var it = 0; it < ve; it++)
        for (var At = 0; At < re; At++) {
          var rt = et(
            he[0] + Ue * (it + 0.5) / ve,
            he[1] + Ne * (At + 0.5) / re
          ), ae = Math.pow(1 - Math.abs(rt) / Me, Le) / 2;
          rt < 0 && (ae = 1 - ae), ae = Math.max(0, Math.min(255, Math.round(ae * 255))), Ae[At * ve + it] = ae;
        }
      return Ae;
      function et(Ge, $e) {
        for (var Ut = 1 / 0, nt = 1 / 0, Ct = ke.length; Ct--; ) {
          var Pt = ke[Ct];
          if (Pt.maxX + nt <= Ge)
            break;
          if (Ge + nt > Pt.minX && $e - nt < Pt.maxY && $e + nt > Pt.minY) {
            var vt = A(Ge, $e, Pt.x1, Pt.y1, Pt.x2, Pt.y2);
            vt < Ut && (Ut = vt, nt = Math.sqrt(Ut));
          }
        }
        return Ye(Ge, $e) && (nt = -nt), nt;
      }
      function Ye(Ge, $e) {
        for (var Ut = 0, nt = ke.length; nt--; ) {
          var Ct = ke[nt];
          if (Ct.maxX <= Ge)
            break;
          var Pt = Ct.y1 > $e != Ct.y2 > $e && Ge < (Ct.x2 - Ct.x1) * ($e - Ct.y1) / (Ct.y2 - Ct.y1) + Ct.x1;
          Pt && (Ut += Ct.y1 < Ct.y2 ? 1 : -1);
        }
        return Ut !== 0;
      }
    }
    function U(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke) {
      Le === void 0 && (Le = 1), Ue === void 0 && (Ue = 0), Ne === void 0 && (Ne = 0), ke === void 0 && (ke = 0), L(ve, re, ee, he, Me, Le, Ae, null, Ue, Ne, ke);
    }
    function L(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke, it) {
      Le === void 0 && (Le = 1), Ne === void 0 && (Ne = 0), ke === void 0 && (ke = 0), it === void 0 && (it = 0);
      for (var At = R(ve, re, ee, he, Me, Le), rt = new Uint8Array(At.length * 4), ae = 0; ae < At.length; ae++)
        rt[ae * 4 + it] = At[ae];
      x(Ae, rt, Ne, ke, ve, re, 1 << 3 - it, Ue);
    }
    function A(ve, re, ee, he, Me, Le) {
      var Ae = Me - ee, Ue = Le - he, Ne = Ae * Ae + Ue * Ue, ke = Ne ? Math.max(0, Math.min(1, ((ve - ee) * Ae + (re - he) * Ue) / Ne)) : 0, it = ve - (ee + ke * Ae), At = re - (he + ke * Ue);
      return it * it + At * At;
    }
    var F = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: R,
      generateIntoCanvas: U,
      generateIntoFramebuffer: L
    }), k = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", H = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", B = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", $ = new Float32Array([0, 0, 2, 0, 0, 2]), Y = null, J = !1, K = {}, X = /* @__PURE__ */ new WeakMap();
    function le(ve) {
      if (!J && !xe(ve))
        throw new Error("WebGL generation not supported");
    }
    function oe(ve, re, ee, he, Me, Le, Ae) {
      if (Le === void 0 && (Le = 1), Ae === void 0 && (Ae = null), !Ae && (Ae = Y, !Ae)) {
        var Ue = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Ue)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        Ae = Y = Ue.getContext("webgl", { depth: !1 });
      }
      le(Ae);
      var Ne = new Uint8Array(ve * re * 4);
      y(Ae, function(rt) {
        var ae = rt.gl, et = rt.withTexture, Ye = rt.withTextureFramebuffer;
        et("readable", function(Ge, $e) {
          ae.texImage2D(ae.TEXTURE_2D, 0, ae.RGBA, ve, re, 0, ae.RGBA, ae.UNSIGNED_BYTE, null), Ye(Ge, $e, function(Ut) {
            de(
              ve,
              re,
              ee,
              he,
              Me,
              Le,
              ae,
              Ut,
              0,
              0,
              0
              // red channel
            ), ae.readPixels(0, 0, ve, re, ae.RGBA, ae.UNSIGNED_BYTE, Ne);
          });
        });
      });
      for (var ke = new Uint8Array(ve * re), it = 0, At = 0; it < Ne.length; it += 4)
        ke[At++] = Ne[it];
      return ke;
    }
    function fe(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke) {
      Le === void 0 && (Le = 1), Ue === void 0 && (Ue = 0), Ne === void 0 && (Ne = 0), ke === void 0 && (ke = 0), de(ve, re, ee, he, Me, Le, Ae, null, Ue, Ne, ke);
    }
    function de(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke, it) {
      Le === void 0 && (Le = 1), Ne === void 0 && (Ne = 0), ke === void 0 && (ke = 0), it === void 0 && (it = 0), le(Ae);
      var At = [];
      o(ee, function(rt, ae, et, Ye) {
        At.push(rt, ae, et, Ye);
      }), At = new Float32Array(At), y(Ae, function(rt) {
        var ae = rt.gl, et = rt.isWebGL2, Ye = rt.getExtension, Ge = rt.withProgram, $e = rt.withTexture, Ut = rt.withTextureFramebuffer, nt = rt.handleContextLoss;
        if ($e("rawDistances", function(Ct, Pt) {
          (ve !== Ct._lastWidth || re !== Ct._lastHeight) && ae.texImage2D(
            ae.TEXTURE_2D,
            0,
            ae.RGBA,
            Ct._lastWidth = ve,
            Ct._lastHeight = re,
            0,
            ae.RGBA,
            ae.UNSIGNED_BYTE,
            null
          ), Ge("main", k, H, function(vt) {
            var Zt = vt.setAttribute, ie = vt.setUniform, ne = !et && Ye("ANGLE_instanced_arrays"), Oe = !et && Ye("EXT_blend_minmax");
            Zt("aUV", 2, ae.STATIC_DRAW, 0, $), Zt("aLineSegment", 4, ae.DYNAMIC_DRAW, 1, At), ie.apply(void 0, ["4f", "uGlyphBounds"].concat(he)), ie("1f", "uMaxDistance", Me), ie("1f", "uExponent", Le), Ut(Ct, Pt, function(_t) {
              ae.enable(ae.BLEND), ae.colorMask(!0, !0, !0, !0), ae.viewport(0, 0, ve, re), ae.scissor(0, 0, ve, re), ae.blendFunc(ae.ONE, ae.ONE), ae.blendEquationSeparate(ae.FUNC_ADD, et ? ae.MAX : Oe.MAX_EXT), ae.clear(ae.COLOR_BUFFER_BIT), et ? ae.drawArraysInstanced(ae.TRIANGLES, 0, 3, At.length / 4) : ne.drawArraysInstancedANGLE(ae.TRIANGLES, 0, 3, At.length / 4);
            });
          }), Ge("post", l, B, function(vt) {
            vt.setAttribute("aUV", 2, ae.STATIC_DRAW, 0, $), vt.setUniform("1i", "tex", Pt), ae.bindFramebuffer(ae.FRAMEBUFFER, Ue), ae.disable(ae.BLEND), ae.colorMask(it === 0, it === 1, it === 2, it === 3), ae.viewport(Ne, ke, ve, re), ae.scissor(Ne, ke, ve, re), ae.drawArrays(ae.TRIANGLES, 0, 3);
          });
        }), ae.isContextLost())
          throw nt(), new Error("webgl context lost");
      });
    }
    function xe(ve) {
      var re = !ve || ve === Y ? K : ve.canvas || ve, ee = X.get(re);
      if (ee === void 0) {
        J = !0;
        var he = null;
        try {
          var Me = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], Le = oe(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            ve
          );
          ee = Le && Me.length === Le.length && Le.every(function(Ae, Ue) {
            return Ae === Me[Ue];
          }), ee || (he = "bad trial run results", console.info(Me, Le));
        } catch (Ae) {
          ee = !1, he = Ae.message;
        }
        he && console.warn("WebGL SDF generation not supported:", he), J = !1, X.set(re, ee);
      }
      return ee;
    }
    var _e = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: oe,
      generateIntoCanvas: fe,
      generateIntoFramebuffer: de,
      isSupported: xe
    });
    function Pe(ve, re, ee, he, Me, Le) {
      Me === void 0 && (Me = Math.max(he[2] - he[0], he[3] - he[1]) / 2), Le === void 0 && (Le = 1);
      try {
        return oe.apply(_e, arguments);
      } catch (Ae) {
        return console.info("WebGL SDF generation failed, falling back to JS", Ae), R.apply(F, arguments);
      }
    }
    function ce(ve, re, ee, he, Me, Le, Ae, Ue, Ne, ke) {
      Me === void 0 && (Me = Math.max(he[2] - he[0], he[3] - he[1]) / 2), Le === void 0 && (Le = 1), Ue === void 0 && (Ue = 0), Ne === void 0 && (Ne = 0), ke === void 0 && (ke = 0);
      try {
        return fe.apply(_e, arguments);
      } catch (it) {
        return console.info("WebGL SDF generation failed, falling back to JS", it), U.apply(F, arguments);
      }
    }
    return e.forEachPathCommand = i, e.generate = Pe, e.generateIntoCanvas = ce, e.javascript = F, e.pathToLineSegments = o, e.webgl = _e, e.webglUtils = w, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return n;
}
function IK() {
  var n = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, i = {};
    r.L = 1, i[1] = "L", Object.keys(t).forEach(function(nt, Ct) {
      r[nt] = 1 << Ct + 1, i[r[nt]] = nt;
    }), Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI, l = r.L | r.R | r.AL, c = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, h = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, p = r.S | r.WS | r.B | o | r.PDI | h, y = null;
    function x() {
      if (!y) {
        y = /* @__PURE__ */ new Map();
        var nt = function(Pt) {
          if (t.hasOwnProperty(Pt)) {
            var vt = 0;
            t[Pt].split(",").forEach(function(Zt) {
              var ie = Zt.split("+"), ne = ie[0], Oe = ie[1];
              ne = parseInt(ne, 36), Oe = Oe ? parseInt(Oe, 36) : 0, y.set(vt += ne, r[Pt]);
              for (var _t = 0; _t < Oe; _t++)
                y.set(++vt, r[Pt]);
            });
          }
        };
        for (var Ct in t)
          nt(Ct);
      }
    }
    function b(nt) {
      return x(), y.get(nt.codePointAt(0)) || r.L;
    }
    function w(nt) {
      return i[b(nt)];
    }
    var R = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function U(nt, Ct) {
      var Pt = 36, vt = 0, Zt = /* @__PURE__ */ new Map(), ie = Ct && /* @__PURE__ */ new Map(), ne;
      return nt.split(",").forEach(function Oe(_t) {
        if (_t.indexOf("+") !== -1)
          for (var ot = +_t; ot--; )
            Oe(ne);
        else {
          ne = _t;
          var at = _t.split(">"), Wt = at[0], Dt = at[1];
          Wt = String.fromCodePoint(vt += parseInt(Wt, Pt)), Dt = String.fromCodePoint(vt += parseInt(Dt, Pt)), Zt.set(Wt, Dt), Ct && ie.set(Dt, Wt);
        }
      }), { map: Zt, reverseMap: ie };
    }
    var L, A, F;
    function k() {
      if (!L) {
        var nt = U(R.pairs, !0), Ct = nt.map, Pt = nt.reverseMap;
        L = Ct, A = Pt, F = U(R.canonical, !1).map;
      }
    }
    function H(nt) {
      return k(), L.get(nt) || null;
    }
    function B(nt) {
      return k(), A.get(nt) || null;
    }
    function $(nt) {
      return k(), F.get(nt) || null;
    }
    var Y = r.L, J = r.R, K = r.EN, X = r.ES, le = r.ET, oe = r.AN, fe = r.CS, de = r.B, xe = r.S, _e = r.ON, Pe = r.BN, ce = r.NSM, ve = r.AL, re = r.LRO, ee = r.RLO, he = r.LRE, Me = r.RLE, Le = r.PDF, Ae = r.LRI, Ue = r.RLI, Ne = r.FSI, ke = r.PDI;
    function it(nt, Ct) {
      for (var Pt = 125, vt = new Uint32Array(nt.length), Zt = 0; Zt < nt.length; Zt++)
        vt[Zt] = b(nt[Zt]);
      var ie = /* @__PURE__ */ new Map();
      function ne(Da, ao) {
        var La = vt[Da];
        vt[Da] = ao, ie.set(La, ie.get(La) - 1), La & c && ie.set(c, ie.get(c) - 1), ie.set(ao, (ie.get(ao) || 0) + 1), ao & c && ie.set(c, (ie.get(c) || 0) + 1);
      }
      for (var Oe = new Uint8Array(nt.length), _t = /* @__PURE__ */ new Map(), ot = [], at = null, Wt = 0; Wt < nt.length; Wt++)
        at || ot.push(at = {
          start: Wt,
          end: nt.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: Ct === "rtl" ? 1 : Ct === "ltr" ? 0 : Po(Wt, !1)
        }), vt[Wt] & de && (at.end = Wt, at = null);
      for (var Dt = Me | he | ee | re | o | ke | Le | de, Se = function(Da) {
        return Da + (Da & 1 ? 1 : 2);
      }, He = function(Da) {
        return Da + (Da & 1 ? 2 : 1);
      }, lt = 0; lt < ot.length; lt++) {
        at = ot[lt];
        var St = [{
          _level: at.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Je = void 0, be = 0, Ze = 0, ct = 0;
        ie.clear();
        for (var pe = at.start; pe <= at.end; pe++) {
          var Rt = vt[pe];
          if (Je = St[St.length - 1], ie.set(Rt, (ie.get(Rt) || 0) + 1), Rt & c && ie.set(c, (ie.get(c) || 0) + 1), Rt & Dt)
            if (Rt & (Me | he)) {
              Oe[pe] = Je._level;
              var Be = (Rt === Me ? He : Se)(Je._level);
              Be <= Pt && !be && !Ze ? St.push({
                _level: Be,
                _override: 0,
                _isolate: 0
              }) : be || Ze++;
            } else if (Rt & (ee | re)) {
              Oe[pe] = Je._level;
              var ut = (Rt === ee ? He : Se)(Je._level);
              ut <= Pt && !be && !Ze ? St.push({
                _level: ut,
                _override: Rt & ee ? J : Y,
                _isolate: 0
              }) : be || Ze++;
            } else if (Rt & o) {
              Rt & Ne && (Rt = Po(pe + 1, !0) === 1 ? Ue : Ae), Oe[pe] = Je._level, Je._override && ne(pe, Je._override);
              var on = (Rt === Ue ? He : Se)(Je._level);
              on <= Pt && be === 0 && Ze === 0 ? (ct++, St.push({
                _level: on,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: pe
              })) : be++;
            } else if (Rt & ke) {
              if (be > 0)
                be--;
              else if (ct > 0) {
                for (Ze = 0; !St[St.length - 1]._isolate; )
                  St.pop();
                var zn = St[St.length - 1]._isolInitIndex;
                zn != null && (_t.set(zn, pe), _t.set(pe, zn)), St.pop(), ct--;
              }
              Je = St[St.length - 1], Oe[pe] = Je._level, Je._override && ne(pe, Je._override);
            } else
              Rt & Le ? (be === 0 && (Ze > 0 ? Ze-- : !Je._isolate && St.length > 1 && (St.pop(), Je = St[St.length - 1])), Oe[pe] = Je._level) : Rt & de && (Oe[pe] = at.level);
          else
            Oe[pe] = Je._level, Je._override && Rt !== Pe && ne(pe, Je._override);
        }
        for (var Gn = [], rr = null, mn = at.start; mn <= at.end; mn++) {
          var er = vt[mn];
          if (!(er & h)) {
            var ir = Oe[mn], Wn = er & o, Ei = er === ke;
            rr && ir === rr._level ? (rr._end = mn, rr._endsWithIsolInit = Wn) : Gn.push(rr = {
              _start: mn,
              _end: mn,
              _level: ir,
              _startsWithPDI: Ei,
              _endsWithIsolInit: Wn
            });
          }
        }
        for (var Wr = [], Br = 0; Br < Gn.length; Br++) {
          var Mr = Gn[Br];
          if (!Mr._startsWithPDI || Mr._startsWithPDI && !_t.has(Mr._start)) {
            for (var Ri = [rr = Mr], si = void 0; rr && rr._endsWithIsolInit && (si = _t.get(rr._end)) != null; )
              for (var De = Br + 1; De < Gn.length; De++)
                if (Gn[De]._start === si) {
                  Ri.push(rr = Gn[De]);
                  break;
                }
            for (var Ft = [], qt = 0; qt < Ri.length; qt++)
              for (var En = Ri[qt], ye = En._start; ye <= En._end; ye++)
                Ft.push(ye);
            for (var qe = Oe[Ft[0]], tt = at.level, Ve = Ft[0] - 1; Ve >= 0; Ve--)
              if (!(vt[Ve] & h)) {
                tt = Oe[Ve];
                break;
              }
            var pt = Ft[Ft.length - 1], en = Oe[pt], cn = at.level;
            if (!(vt[pt] & o)) {
              for (var xn = pt + 1; xn <= at.end; xn++)
                if (!(vt[xn] & h)) {
                  cn = Oe[xn];
                  break;
                }
            }
            Wr.push({
              _seqIndices: Ft,
              _sosType: Math.max(tt, qe) % 2 ? J : Y,
              _eosType: Math.max(cn, en) % 2 ? J : Y
            });
          }
        }
        for (var Nn = 0; Nn < Wr.length; Nn++) {
          var lr = Wr[Nn], bt = lr._seqIndices, ar = lr._sosType, Hr = lr._eosType, Tn = Oe[bt[0]] & 1 ? J : Y;
          if (ie.get(ce))
            for (var Ji = 0; Ji < bt.length; Ji++) {
              var Do = bt[Ji];
              if (vt[Do] & ce) {
                for (var li = ar, $n = Ji - 1; $n >= 0; $n--)
                  if (!(vt[bt[$n]] & h)) {
                    li = vt[bt[$n]];
                    break;
                  }
                ne(Do, li & (o | ke) ? _e : li);
              }
            }
          if (ie.get(K))
            for (var _r = 0; _r < bt.length; _r++) {
              var ur = bt[_r];
              if (vt[ur] & K)
                for (var di = _r - 1; di >= -1; di--) {
                  var xa = di === -1 ? ar : vt[bt[di]];
                  if (xa & l) {
                    xa === ve && ne(ur, oe);
                    break;
                  }
                }
            }
          if (ie.get(ve))
            for (var Xr = 0; Xr < bt.length; Xr++) {
              var ds = bt[Xr];
              vt[ds] & ve && ne(ds, J);
            }
          if (ie.get(X) || ie.get(fe))
            for (var bi = 1; bi < bt.length - 1; bi++) {
              var Ti = bt[bi];
              if (vt[Ti] & (X | fe)) {
                for (var Xa = 0, Ai = 0, ru = bi - 1; ru >= 0 && (Xa = vt[bt[ru]], !!(Xa & h)); ru--)
                  ;
                for (var Ns = bi + 1; Ns < bt.length && (Ai = vt[bt[Ns]], !!(Ai & h)); Ns++)
                  ;
                Xa === Ai && (vt[Ti] === X ? Xa === K : Xa & (K | oe)) && ne(Ti, Xa);
              }
            }
          if (ie.get(K))
            for (var yo = 0; yo < bt.length; yo++) {
              var Wo = bt[yo];
              if (vt[Wo] & K) {
                for (var ac = yo - 1; ac >= 0 && vt[bt[ac]] & (le | h); ac--)
                  ne(bt[ac], K);
                for (yo++; yo < bt.length && vt[bt[yo]] & (le | h | K); yo++)
                  vt[bt[yo]] !== K && ne(bt[yo], K);
              }
            }
          if (ie.get(le) || ie.get(X) || ie.get(fe))
            for (var sl = 0; sl < bt.length; sl++) {
              var yp = bt[sl];
              if (vt[yp] & (le | X | fe)) {
                ne(yp, _e);
                for (var Dl = sl - 1; Dl >= 0 && vt[bt[Dl]] & h; Dl--)
                  ne(bt[Dl], _e);
                for (var Vr = sl + 1; Vr < bt.length && vt[bt[Vr]] & h; Vr++)
                  ne(bt[Vr], _e);
              }
            }
          if (ie.get(K))
            for (var ll = 0, kf = ar; ll < bt.length; ll++) {
              var jo = bt[ll], ei = vt[jo];
              ei & K ? kf === Y && ne(jo, Y) : ei & l && (kf = ei);
            }
          if (ie.get(c)) {
            var Ra = J | K | oe, zf = Ra | Y, nr = [];
            {
              for (var iu = [], Fi = 0; Fi < bt.length; Fi++)
                if (vt[bt[Fi]] & c) {
                  var dr = nt[bt[Fi]], hs = void 0;
                  if (H(dr) !== null)
                    if (iu.length < 63)
                      iu.push({ char: dr, seqIndex: Fi });
                    else
                      break;
                  else if ((hs = B(dr)) !== null)
                    for (var Lo = iu.length - 1; Lo >= 0; Lo--) {
                      var fa = iu[Lo].char;
                      if (fa === hs || fa === B($(dr)) || H($(fa)) === dr) {
                        nr.push([iu[Lo].seqIndex, Fi]), iu.length = Lo;
                        break;
                      }
                    }
                }
              nr.sort(function(Da, ao) {
                return Da[0] - ao[0];
              });
            }
            for (var gi = 0; gi < nr.length; gi++) {
              for (var Sm = nr[gi], qr = Sm[0], Aa = Sm[1], Ru = !1, ps = 0, oc = qr + 1; oc < Aa; oc++) {
                var Vc = bt[oc];
                if (vt[Vc] & zf) {
                  Ru = !0;
                  var ul = vt[Vc] & Ra ? J : Y;
                  if (ul === Tn) {
                    ps = ul;
                    break;
                  }
                }
              }
              if (Ru && !ps) {
                ps = ar;
                for (var Gc = qr - 1; Gc >= 0; Gc--) {
                  var If = bt[Gc];
                  if (vt[If] & zf) {
                    var Oo = vt[If] & Ra ? J : Y;
                    Oo !== Tn ? ps = Oo : ps = Tn;
                    break;
                  }
                }
              }
              if (ps) {
                if (vt[bt[qr]] = vt[bt[Aa]] = ps, ps !== Tn) {
                  for (var qa = qr + 1; qa < bt.length; qa++)
                    if (!(vt[bt[qa]] & h)) {
                      b(nt[bt[qa]]) & ce && (vt[bt[qa]] = ps);
                      break;
                    }
                }
                if (ps !== Tn) {
                  for (var Au = Aa + 1; Au < bt.length; Au++)
                    if (!(vt[bt[Au]] & h)) {
                      b(nt[bt[Au]]) & ce && (vt[bt[Au]] = ps);
                      break;
                    }
                }
              }
            }
            for (var Fs = 0; Fs < bt.length; Fs++)
              if (vt[bt[Fs]] & c) {
                for (var Wc = Fs, jc = Fs, $o = ar, $c = Fs - 1; $c >= 0; $c--)
                  if (vt[bt[$c]] & h)
                    Wc = $c;
                  else {
                    $o = vt[bt[$c]] & Ra ? J : Y;
                    break;
                  }
                for (var ks = Hr, Du = Fs + 1; Du < bt.length; Du++)
                  if (vt[bt[Du]] & (c | h))
                    jc = Du;
                  else {
                    ks = vt[bt[Du]] & Ra ? J : Y;
                    break;
                  }
                for (var So = Wc; So <= jc; So++)
                  vt[bt[So]] = $o === ks ? $o : Tn;
                Fs = jc;
              }
          }
        }
        for (var Ka = at.start; Ka <= at.end; Ka++) {
          var au = Oe[Ka], zs = vt[Ka];
          if (au & 1 ? zs & (Y | K | oe) && Oe[Ka]++ : zs & J ? Oe[Ka]++ : zs & (oe | K) && (Oe[Ka] += 2), zs & h && (Oe[Ka] = Ka === 0 ? at.level : Oe[Ka - 1]), Ka === at.end || b(nt[Ka]) & (xe | de))
            for (var sc = Ka; sc >= 0 && b(nt[sc]) & p; sc--)
              Oe[sc] = at.level;
        }
      }
      return {
        levels: Oe,
        paragraphs: ot
      };
      function Po(Da, ao) {
        for (var La = Da; La < nt.length; La++) {
          var da = vt[La];
          if (da & (J | ve))
            return 1;
          if (da & (de | Y) || ao && da === ke)
            return 0;
          if (da & o) {
            var ms = ou(La);
            La = ms === -1 ? nt.length : ms;
          }
        }
        return 0;
      }
      function ou(Da) {
        for (var ao = 1, La = Da + 1; La < nt.length; La++) {
          var da = vt[La];
          if (da & de)
            break;
          if (da & ke) {
            if (--ao === 0)
              return La;
          } else
            da & o && ao++;
        }
        return -1;
      }
    }
    var At = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", rt;
    function ae() {
      if (!rt) {
        var nt = U(At, !0), Ct = nt.map, Pt = nt.reverseMap;
        Pt.forEach(function(vt, Zt) {
          Ct.set(Zt, vt);
        }), rt = Ct;
      }
    }
    function et(nt) {
      return ae(), rt.get(nt) || null;
    }
    function Ye(nt, Ct, Pt, vt) {
      var Zt = nt.length;
      Pt = Math.max(0, Pt == null ? 0 : +Pt), vt = Math.min(Zt - 1, vt == null ? Zt - 1 : +vt);
      for (var ie = /* @__PURE__ */ new Map(), ne = Pt; ne <= vt; ne++)
        if (Ct[ne] & 1) {
          var Oe = et(nt[ne]);
          Oe !== null && ie.set(ne, Oe);
        }
      return ie;
    }
    function Ge(nt, Ct, Pt, vt) {
      var Zt = nt.length;
      Pt = Math.max(0, Pt == null ? 0 : +Pt), vt = Math.min(Zt - 1, vt == null ? Zt - 1 : +vt);
      var ie = [];
      return Ct.paragraphs.forEach(function(ne) {
        var Oe = Math.max(Pt, ne.start), _t = Math.min(vt, ne.end);
        if (Oe < _t) {
          for (var ot = Ct.levels.slice(Oe, _t + 1), at = _t; at >= Oe && b(nt[at]) & p; at--)
            ot[at] = ne.level;
          for (var Wt = ne.level, Dt = 1 / 0, Se = 0; Se < ot.length; Se++) {
            var He = ot[Se];
            He > Wt && (Wt = He), He < Dt && (Dt = He | 1);
          }
          for (var lt = Wt; lt >= Dt; lt--)
            for (var St = 0; St < ot.length; St++)
              if (ot[St] >= lt) {
                for (var Je = St; St + 1 < ot.length && ot[St + 1] >= lt; )
                  St++;
                St > Je && ie.push([Je + Oe, St + Oe]);
              }
        }
      }), ie;
    }
    function $e(nt, Ct, Pt, vt) {
      var Zt = Ut(nt, Ct, Pt, vt), ie = [].concat(nt);
      return Zt.forEach(function(ne, Oe) {
        ie[Oe] = (Ct.levels[ne] & 1 ? et(nt[ne]) : null) || nt[ne];
      }), ie.join("");
    }
    function Ut(nt, Ct, Pt, vt) {
      for (var Zt = Ge(nt, Ct, Pt, vt), ie = [], ne = 0; ne < nt.length; ne++)
        ie[ne] = ne;
      return Zt.forEach(function(Oe) {
        for (var _t = Oe[0], ot = Oe[1], at = ie.slice(_t, ot + 1), Wt = at.length; Wt--; )
          ie[ot - Wt] = at[Wt];
      }), ie;
    }
    return e.closingToOpeningBracket = B, e.getBidiCharType = b, e.getBidiCharTypeName = w, e.getCanonicalBracket = $, e.getEmbeddingLevels = it, e.getMirroredCharacter = et, e.getMirroredCharactersMap = Ye, e.getReorderSegments = Ge, e.getReorderedIndices = Ut, e.getReorderedString = $e, e.openingToClosingBracket = H, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return n;
}
const JB = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function IO(n) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let o = Jr[i];
    return o ? IO(o) : r;
  }
  return n.replace(e, t);
}
const rc = [];
for (let n = 0; n < 256; n++)
  rc[n] = (n < 16 ? "0" : "") + n.toString(16);
function BK() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (rc[n & 255] + rc[n >> 8 & 255] + rc[n >> 16 & 255] + rc[n >> 24 & 255] + "-" + rc[e & 255] + rc[e >> 8 & 255] + "-" + rc[e >> 16 & 15 | 64] + rc[e >> 24 & 255] + "-" + rc[t & 63 | 128] + rc[t >> 8 & 255] + "-" + rc[t >> 16 & 255] + rc[t >> 24 & 255] + rc[r & 255] + rc[r >> 8 & 255] + rc[r >> 16 & 255] + rc[r >> 24 & 255]).toUpperCase();
}
const ZS = Object.assign || function() {
  let n = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }
  return n;
}, HK = Date.now(), Nk = /* @__PURE__ */ new WeakMap(), Fk = /* @__PURE__ */ new Map();
let VK = 1e10;
function BO(n, e) {
  const t = $K(e);
  let r = Nk.get(n);
  if (r || Nk.set(n, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const i = `_onBeforeCompile${t}`, o = function(p, y) {
    n.onBeforeCompile.call(this, p, y);
    const x = this.customProgramCacheKey() + "|" + p.vertexShader + "|" + p.fragmentShader;
    let b = Fk[x];
    if (!b) {
      const w = GK(this, p, e, t);
      b = Fk[x] = w;
    }
    p.vertexShader = b.vertexShader, p.fragmentShader = b.fragmentShader, ZS(p.uniforms, this.uniforms), e.timeUniform && (p.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - HK;
      }
    }), this[i] && this[i](p);
  }, l = function() {
    return c(e.chained ? n : n.clone());
  }, c = function(p) {
    const y = Object.create(p, h);
    return Object.defineProperty(y, "baseMaterial", { value: n }), Object.defineProperty(y, "id", { value: VK++ }), y.uuid = BK(), y.uniforms = ZS({}, p.uniforms, e.uniforms), y.defines = ZS({}, p.defines, e.defines), y.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", y.extensions = ZS({}, p.extensions, e.extensions), y._listeners = void 0, y;
  }, h = {
    constructor: { value: l },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return n.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(p) {
        this[i] = p;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(p) {
        return n.copy.call(this, p), !n.isShaderMaterial && !n.isDerivedMaterial && (ZS(this.extensions, p.extensions), ZS(this.defines, p.defines), ZS(this.uniforms, PP.clone(p.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const p = new n.constructor();
        return c(p).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let p = this._depthMaterial;
        return p || (p = this._depthMaterial = BO(
          n.isDerivedMaterial ? n.getDepthMaterial() : new JR({ depthPacking: CP }),
          e
        ), p.defines.IS_DEPTH_MATERIAL = "", p.uniforms = this.uniforms), p;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let p = this._distanceMaterial;
        return p || (p = this._distanceMaterial = BO(
          n.isDerivedMaterial ? n.getDistanceMaterial() : new e2(),
          e
        ), p.defines.IS_DISTANCE_MATERIAL = "", p.uniforms = this.uniforms), p;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: p, _distanceMaterial: y } = this;
        p && p.dispose(), y && y.dispose(), n.dispose.call(this);
      }
    }
  };
  return r[t] = l, new l();
}
function GK(n, { vertexShader: e, fragmentShader: t }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: l,
    vertexMainOutro: c,
    vertexTransform: h,
    fragmentDefs: p,
    fragmentMainIntro: y,
    fragmentMainOutro: x,
    fragmentColorTransform: b,
    customRewriter: w,
    timeUniform: R
  } = r;
  if (o = o || "", l = l || "", c = c || "", p = p || "", y = y || "", x = x || "", (h || w) && (e = IO(e)), (b || w) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = IO(t)), w) {
    let U = w({ vertexShader: e, fragmentShader: t });
    e = U.vertexShader, t = U.fragmentShader;
  }
  if (b) {
    let U = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (L) => (U.push(L), "")
    ), x = `${b}
${U.join(`
`)}
${x}`;
  }
  if (R) {
    const U = `
uniform float ${R};
`;
    o = U + o, p = U + p;
  }
  return h && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${h}
}
`, l = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${l}
`, e = e.replace(/\b(position|normal|uv)\b/g, (U, L, A, F) => /\battribute\s+vec[23]\s+$/.test(F.substr(0, A)) ? L : `troika_${L}_${i}`), n.map && n.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = kk(e, i, o, l, c), t = kk(t, i, p, y, x), {
    vertexShader: e,
    fragmentShader: t
  };
}
function kk(n, e, t, r, i) {
  return (r || i || t) && (n = n.replace(
    JB,
    `
${t}
void troikaOrigMain${e}() {`
  ), n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`), n;
}
function WK(n, e) {
  return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let jK = 0;
const zk = /* @__PURE__ */ new Map();
function $K(n) {
  const e = JSON.stringify(n, WK);
  let t = zk.get(e);
  return t == null && zk.set(e, t = ++jK), t;
}
function YK(n, e, t) {
  const {
    defaultFontURL: r
  } = t, i = /* @__PURE__ */ Object.create(null), o = 1 / 0, l = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, c = "[^\\S\\u00A0]", h = new RegExp(`${c}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function p(F, k) {
    function H() {
      const B = ($) => {
        console.error(`Failure loading font ${F}${F === r ? "" : "; trying fallback"}`, $), F !== r && (F = r, H());
      };
      try {
        const $ = new XMLHttpRequest();
        $.open("get", F, !0), $.responseType = "arraybuffer", $.onload = function() {
          if ($.status >= 400)
            B(new Error($.statusText));
          else if ($.status > 0)
            try {
              const Y = n($.response);
              k(Y);
            } catch (Y) {
              B(Y);
            }
        }, $.onerror = B, $.send();
      } catch ($) {
        B($);
      }
    }
    H();
  }
  function y(F, k) {
    F || (F = r);
    let H = i[F];
    H ? H.pending ? H.pending.push(k) : k(H) : (i[F] = { pending: [k] }, p(F, (B) => {
      let $ = i[F].pending;
      i[F] = B, $.forEach((Y) => Y(B));
    }));
  }
  function x({
    text: F = "",
    font: k = r,
    sdfGlyphSize: H = 64,
    fontSize: B = 1,
    letterSpacing: $ = 0,
    lineHeight: Y = "normal",
    maxWidth: J = o,
    direction: K,
    textAlign: X = "left",
    textIndent: le = 0,
    whiteSpace: oe = "normal",
    overflowWrap: fe = "normal",
    anchorX: de = 0,
    anchorY: xe = 0,
    includeCaretPositions: _e = !1,
    chunkedBoundsSize: Pe = 8192,
    colorRanges: ce = null
  }, ve, re = !1) {
    const ee = U(), he = { fontLoad: 0, typesetting: 0 };
    F.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), F = F.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), B = +B, $ = +$, J = +J, Y = Y || "normal", le = +le, y(k, (Me) => {
      const Le = isFinite(J);
      let Ae = null, Ue = null, Ne = null, ke = null, it = null, At = null, rt = null, ae = 0, et = 0, Ye = oe !== "nowrap";
      const { ascender: Ge, descender: $e, unitsPerEm: Ut, lineGap: nt, capHeight: Ct, xHeight: Pt } = Me;
      he.fontLoad = U() - ee;
      const vt = U(), Zt = B / Ut;
      Y === "normal" && (Y = (Ge - $e + nt) / Ut), Y = Y * B;
      const ie = (Y - (Ge - $e) * Zt) / 2, ne = -(Ge * Zt + ie), Oe = Math.min(Y, (Ge - $e) * Zt), _t = (Ge + $e) / 2 * Zt - Oe / 2;
      let ot = le, at = new L();
      const Wt = [at];
      Me.forEachGlyph(F, B, $, (He, lt, St) => {
        const Je = F.charAt(St), be = He.advanceWidth * Zt, Ze = at.count;
        let ct;
        if ("isEmpty" in He || (He.isWhitespace = !!Je && new RegExp(c).test(Je), He.canBreakAfter = !!Je && h.test(Je), He.isEmpty = He.xMin === He.xMax || He.yMin === He.yMax || l.test(Je)), !He.isWhitespace && !He.isEmpty && et++, Ye && Le && !He.isWhitespace && lt + be + ot > J && Ze) {
          if (at.glyphAt(Ze - 1).glyphObj.canBreakAfter)
            ct = new L(), ot = -lt;
          else
            for (let Rt = Ze; Rt--; )
              if (Rt === 0 && fe === "break-word") {
                ct = new L(), ot = -lt;
                break;
              } else if (at.glyphAt(Rt).glyphObj.canBreakAfter) {
                ct = at.splitAt(Rt + 1);
                const Be = ct.glyphAt(0).x;
                ot -= Be;
                for (let ut = ct.count; ut--; )
                  ct.glyphAt(ut).x -= Be;
                break;
              }
          ct && (at.isSoftWrapped = !0, at = ct, Wt.push(at), ae = J);
        }
        let pe = at.glyphAt(at.count);
        pe.glyphObj = He, pe.x = lt + ot, pe.width = be, pe.charIndex = St, Je === `
` && (at = new L(), Wt.push(at), ot = -(lt + be + $ * B) + le);
      }), Wt.forEach((He) => {
        for (let lt = He.count; lt--; ) {
          let { glyphObj: St, x: Je, width: be } = He.glyphAt(lt);
          if (!St.isWhitespace) {
            He.width = Je + be, He.width > ae && (ae = He.width);
            return;
          }
        }
      });
      let Dt = 0, Se = 0;
      if (de && (typeof de == "number" ? Dt = -de : typeof de == "string" && (Dt = -ae * (de === "left" ? 0 : de === "center" ? 0.5 : de === "right" ? 1 : w(de)))), xe) {
        if (typeof xe == "number")
          Se = -xe;
        else if (typeof xe == "string") {
          let He = Wt.length * Y;
          Se = xe === "top" ? 0 : xe === "top-baseline" ? -ne : xe === "top-cap" ? -ne - Ct * Zt : xe === "top-ex" ? -ne - Pt * Zt : xe === "middle" ? He / 2 : xe === "bottom" ? He : xe === "bottom-baseline" ? He - ie + $e * Zt : w(xe) * He;
        }
      }
      if (!re) {
        const He = e.getEmbeddingLevels(F, K);
        Ae = new Uint16Array(et), Ue = new Float32Array(et * 2), Ne = {}, At = [o, o, -o, -o], rt = [];
        let lt = ne;
        _e && (it = new Float32Array(F.length * 3)), ce && (ke = new Uint8Array(et * 3));
        let St = 0, Je = -1, be = -1, Ze, ct;
        if (Wt.forEach((pe, Rt) => {
          let { count: Be, width: ut } = pe;
          if (Be > 0) {
            let on = 0;
            for (let ir = Be; ir-- && pe.glyphAt(ir).glyphObj.isWhitespace; )
              on++;
            let zn = 0, Gn = 0;
            if (X === "center")
              zn = (ae - ut) / 2;
            else if (X === "right")
              zn = ae - ut;
            else if (X === "justify" && pe.isSoftWrapped) {
              let ir = 0;
              for (let Wn = Be - on; Wn--; )
                pe.glyphAt(Wn).glyphObj.isWhitespace && ir++;
              Gn = (ae - ut) / ir;
            }
            if (Gn || zn) {
              let ir = 0;
              for (let Wn = 0; Wn < Be; Wn++) {
                let Ei = pe.glyphAt(Wn);
                const Wr = Ei.glyphObj;
                Ei.x += zn + ir, Gn !== 0 && Wr.isWhitespace && Wn < Be - on && (ir += Gn, Ei.width += Gn);
              }
            }
            const rr = e.getReorderSegments(
              F,
              He,
              pe.glyphAt(0).charIndex,
              pe.glyphAt(pe.count - 1).charIndex
            );
            for (let ir = 0; ir < rr.length; ir++) {
              const [Wn, Ei] = rr[ir];
              let Wr = 1 / 0, Br = -1 / 0;
              for (let Mr = 0; Mr < Be; Mr++)
                if (pe.glyphAt(Mr).charIndex >= Wn) {
                  let Ri = Mr, si = Mr;
                  for (; si < Be; si++) {
                    let De = pe.glyphAt(si);
                    if (De.charIndex > Ei)
                      break;
                    si < Be - on && (Wr = Math.min(Wr, De.x), Br = Math.max(Br, De.x + De.width));
                  }
                  for (let De = Ri; De < si; De++) {
                    const Ft = pe.glyphAt(De);
                    Ft.x = Br - (Ft.x + Ft.width - Wr);
                  }
                  break;
                }
            }
            let mn;
            const er = (ir) => mn = ir;
            for (let ir = 0; ir < Be; ir++) {
              let Wn = pe.glyphAt(ir);
              mn = Wn.glyphObj;
              const Ei = mn.index, Wr = He.levels[Wn.charIndex] & 1;
              if (Wr) {
                const Br = e.getMirroredCharacter(F[Wn.charIndex]);
                Br && Me.forEachGlyph(Br, 0, 0, er);
              }
              if (_e) {
                const { charIndex: Br } = Wn, Mr = Wn.x + Dt, Ri = Wn.x + Wn.width + Dt;
                it[Br * 3] = Wr ? Ri : Mr, it[Br * 3 + 1] = Wr ? Mr : Ri, it[Br * 3 + 2] = lt + _t + Se;
                const si = Br - Je;
                si > 1 && R(it, Je, si), Je = Br;
              }
              if (ce) {
                const { charIndex: Br } = Wn;
                for (; Br > be; )
                  be++, ce.hasOwnProperty(be) && (ct = ce[be]);
              }
              if (!mn.isWhitespace && !mn.isEmpty) {
                const Br = St++;
                Ne[Ei] || (Ne[Ei] = {
                  path: mn.path,
                  pathBounds: [mn.xMin, mn.yMin, mn.xMax, mn.yMax]
                });
                const Mr = Wn.x + Dt, Ri = lt + Se;
                Ue[Br * 2] = Mr, Ue[Br * 2 + 1] = Ri;
                const si = Mr + mn.xMin * Zt, De = Ri + mn.yMin * Zt, Ft = Mr + mn.xMax * Zt, qt = Ri + mn.yMax * Zt;
                si < At[0] && (At[0] = si), De < At[1] && (At[1] = De), Ft > At[2] && (At[2] = Ft), qt > At[3] && (At[3] = qt), Br % Pe === 0 && (Ze = { start: Br, end: Br, rect: [o, o, -o, -o] }, rt.push(Ze)), Ze.end++;
                const En = Ze.rect;
                if (si < En[0] && (En[0] = si), De < En[1] && (En[1] = De), Ft > En[2] && (En[2] = Ft), qt > En[3] && (En[3] = qt), Ae[Br] = Ei, ce) {
                  const ye = Br * 3;
                  ke[ye] = ct >> 16 & 255, ke[ye + 1] = ct >> 8 & 255, ke[ye + 2] = ct & 255;
                }
              }
            }
          }
          lt -= Y;
        }), it) {
          const pe = F.length - Je;
          pe > 1 && R(it, Je, pe);
        }
      }
      he.typesetting = U() - vt, ve({
        glyphIds: Ae,
        //font indices for each glyph
        glyphPositions: Ue,
        //x,y of each glyph's origin in layout
        glyphData: Ne,
        //dict holding data about each glyph appearing in the text
        caretPositions: it,
        //startX,endX,bottomY caret positions for each char
        caretHeight: Oe,
        //height of cursor from bottom to top
        glyphColors: ke,
        //color for each glyph, if color ranges supplied
        chunkedBounds: rt,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: B,
        //calculated em height
        unitsPerEm: Ut,
        //font units per em
        ascender: Ge * Zt,
        //font ascender
        descender: $e * Zt,
        //font descender
        capHeight: Ct * Zt,
        //font cap-height
        xHeight: Pt * Zt,
        //font x-height
        lineHeight: Y,
        //computed line height
        topBaseline: ne,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          Dt,
          Se - Wt.length * Y,
          Dt + ae,
          Se
        ],
        visibleBounds: At,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: he
      });
    });
  }
  function b(F, k) {
    x(F, (H) => {
      const [B, $, Y, J] = H.blockBounds;
      k({
        width: Y - B,
        height: J - $
      });
    }, { metricsOnly: !0 });
  }
  function w(F) {
    let k = F.match(/^([\d.]+)%$/), H = k ? parseFloat(k[1]) : NaN;
    return isNaN(H) ? 0 : H / 100;
  }
  function R(F, k, H) {
    const B = F[k * 3], $ = F[k * 3 + 1], Y = F[k * 3 + 2], J = ($ - B) / H;
    for (let K = 0; K < H; K++) {
      const X = (k + K) * 3;
      F[X] = B + J * K, F[X + 1] = B + J * (K + 1), F[X + 2] = Y;
    }
  }
  function U() {
    return (self.performance || Date).now();
  }
  function L() {
    this.data = [];
  }
  const A = ["glyphObj", "x", "width", "charIndex"];
  return L.prototype = {
    width: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / A.length);
    },
    glyphAt(F) {
      let k = L.flyweight;
      return k.data = this.data, k.index = F, k;
    },
    splitAt(F) {
      let k = new L();
      return k.data = this.data.splice(F * A.length), k;
    }
  }, L.flyweight = A.reduce((F, k, H, B) => (Object.defineProperty(F, k, {
    get() {
      return this.data[this.index * A.length + H];
    },
    set($) {
      this.data[this.index * A.length + H] = $;
    }
  }), F), { data: null, index: 0 }), {
    typeset: x,
    measure: b,
    loadFont: y
  };
}
const hx = () => (self.performance || Date).now(), w2 = /* @__PURE__ */ ZB();
let Ik;
function XK(n, e, t, r, i, o, l, c, h, p, y = !0) {
  return y ? KK(n, e, t, r, i, o, l, c, h, p).then(
    null,
    (x) => (Ik || (console.warn("WebGL SDF generation failed, falling back to JS", x), Ik = !0), Hk(n, e, t, r, i, o, l, c, h, p))
  ) : Hk(n, e, t, r, i, o, l, c, h, p);
}
const xR = [], qK = 5;
let HO = 0;
function e5() {
  const n = hx();
  for (; xR.length && hx() - n < qK; )
    xR.shift()();
  HO = xR.length ? setTimeout(e5, 0) : 0;
}
const KK = (...n) => new Promise((e, t) => {
  xR.push(() => {
    const r = hx();
    try {
      w2.webgl.generateIntoCanvas(...n), e({ timing: hx() - r });
    } catch (i) {
      t(i);
    }
  }), HO || (HO = setTimeout(e5, 0));
}), QK = 4, ZK = 2e3, Bk = {};
let JK = 0;
function Hk(n, e, t, r, i, o, l, c, h, p) {
  const y = "TroikaTextSDFGenerator_JS_" + JK++ % QK;
  let x = Bk[y];
  return x || (x = Bk[y] = {
    workerModule: gw({
      name: y,
      workerId: y,
      dependencies: [
        ZB,
        hx
      ],
      init(b, w) {
        const R = b().javascript.generate;
        return function(...U) {
          const L = w();
          return {
            textureData: R(...U),
            timing: w() - L
          };
        };
      },
      getTransferables(b) {
        return [b.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), x.requests++, clearTimeout(x.idleTimer), x.workerModule(n, e, t, r, i, o).then(({ textureData: b, timing: w }) => {
    const R = hx(), U = new Uint8Array(b.length * 4);
    for (let L = 0; L < b.length; L++)
      U[L * 4 + p] = b[L];
    return w2.webglUtils.renderImageData(l, U, c, h, n, e, 1 << 3 - p), w += hx() - R, --x.requests === 0 && (x.idleTimer = setTimeout(() => {
      kK(y);
    }, ZK)), { timing: w };
  });
}
function eQ(n) {
  n._warm || (w2.webgl.isSupported(n), n._warm = !0);
}
const tQ = w2.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function nQ() {
  return typeof window > "u" && (self.window = self), function(n) {
    var e = { parse: function(i) {
      var o = e._bin, l = new Uint8Array(i);
      if (o.readASCII(l, 0, 4) == "ttcf") {
        var c = 4;
        o.readUshort(l, c), c += 2, o.readUshort(l, c), c += 2;
        var h = o.readUint(l, c);
        c += 4;
        for (var p = [], y = 0; y < h; y++) {
          var x = o.readUint(l, c);
          c += 4, p.push(e._readFont(l, x));
        }
        return p;
      }
      return [e._readFont(l, 0)];
    }, _readFont: function(i, o) {
      var l = e._bin, c = o;
      l.readFixed(i, o), o += 4;
      var h = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2;
      for (var p = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], y = { _data: i, _offset: c }, x = {}, b = 0; b < h; b++) {
        var w = l.readASCII(i, o, 4);
        o += 4, l.readUint(i, o), o += 4;
        var R = l.readUint(i, o);
        o += 4;
        var U = l.readUint(i, o);
        o += 4, x[w] = { offset: R, length: U };
      }
      for (b = 0; b < p.length; b++) {
        var L = p[b];
        x[L] && (y[L.trim()] = e[L.trim()].parse(i, x[L].offset, x[L].length, y));
      }
      return y;
    }, _tabOffset: function(i, o, l) {
      for (var c = e._bin, h = c.readUshort(i, l + 4), p = l + 12, y = 0; y < h; y++) {
        var x = c.readASCII(i, p, 4);
        p += 4, c.readUint(i, p), p += 4;
        var b = c.readUint(i, p);
        if (p += 4, c.readUint(i, p), p += 4, x == o)
          return b;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, o) {
      return (i[o] << 8 | i[o + 1]) + (i[o + 2] << 8 | i[o + 3]) / 65540;
    }, readF2dot14: function(i, o) {
      return e._bin.readShort(i, o) / 16384;
    }, readInt: function(i, o) {
      return e._bin._view(i).getInt32(o);
    }, readInt8: function(i, o) {
      return e._bin._view(i).getInt8(o);
    }, readShort: function(i, o) {
      return e._bin._view(i).getInt16(o);
    }, readUshort: function(i, o) {
      return e._bin._view(i).getUint16(o);
    }, readUshorts: function(i, o, l) {
      for (var c = [], h = 0; h < l; h++)
        c.push(e._bin.readUshort(i, o + 2 * h));
      return c;
    }, readUint: function(i, o) {
      return e._bin._view(i).getUint32(o);
    }, readUint64: function(i, o) {
      return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
    }, readASCII: function(i, o, l) {
      for (var c = "", h = 0; h < l; h++)
        c += String.fromCharCode(i[o + h]);
      return c;
    }, readUnicode: function(i, o, l) {
      for (var c = "", h = 0; h < l; h++) {
        var p = i[o++] << 8 | i[o++];
        c += String.fromCharCode(p);
      }
      return c;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, o, l) {
      var c = e._bin._tdec;
      return c && o == 0 && l == i.length ? c.decode(i) : e._bin.readASCII(i, o, l);
    }, readBytes: function(i, o, l) {
      for (var c = [], h = 0; h < l; h++)
        c.push(i[o + h]);
      return c;
    }, readASCIIArray: function(i, o, l) {
      for (var c = [], h = 0; h < l; h++)
        c.push(String.fromCharCode(i[o + h]));
      return c;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, o, l, c, h) {
      var p = e._bin, y = {}, x = o;
      p.readFixed(i, o), o += 4;
      var b = p.readUshort(i, o);
      o += 2;
      var w = p.readUshort(i, o);
      o += 2;
      var R = p.readUshort(i, o);
      return o += 2, y.scriptList = e._lctf.readScriptList(i, x + b), y.featureList = e._lctf.readFeatureList(i, x + w), y.lookupList = e._lctf.readLookupList(i, x + R, h), y;
    }, e._lctf.readLookupList = function(i, o, l) {
      var c = e._bin, h = o, p = [], y = c.readUshort(i, o);
      o += 2;
      for (var x = 0; x < y; x++) {
        var b = c.readUshort(i, o);
        o += 2;
        var w = e._lctf.readLookupTable(i, h + b, l);
        p.push(w);
      }
      return p;
    }, e._lctf.readLookupTable = function(i, o, l) {
      var c = e._bin, h = o, p = { tabs: [] };
      p.ltype = c.readUshort(i, o), o += 2, p.flag = c.readUshort(i, o), o += 2;
      var y = c.readUshort(i, o);
      o += 2;
      for (var x = p.ltype, b = 0; b < y; b++) {
        var w = c.readUshort(i, o);
        o += 2;
        var R = l(i, x, h + w, p);
        p.tabs.push(R);
      }
      return p;
    }, e._lctf.numOfOnes = function(i) {
      for (var o = 0, l = 0; l < 32; l++)
        i >>> l & 1 && o++;
      return o;
    }, e._lctf.readClassDef = function(i, o) {
      var l = e._bin, c = [], h = l.readUshort(i, o);
      if (o += 2, h == 1) {
        var p = l.readUshort(i, o);
        o += 2;
        var y = l.readUshort(i, o);
        o += 2;
        for (var x = 0; x < y; x++)
          c.push(p + x), c.push(p + x), c.push(l.readUshort(i, o)), o += 2;
      }
      if (h == 2) {
        var b = l.readUshort(i, o);
        for (o += 2, x = 0; x < b; x++)
          c.push(l.readUshort(i, o)), o += 2, c.push(l.readUshort(i, o)), o += 2, c.push(l.readUshort(i, o)), o += 2;
      }
      return c;
    }, e._lctf.getInterval = function(i, o) {
      for (var l = 0; l < i.length; l += 3) {
        var c = i[l], h = i[l + 1];
        if (i[l + 2], c <= o && o <= h)
          return l;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, o) {
      var l = e._bin, c = {};
      c.fmt = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      return o += 2, c.fmt == 1 && (c.tab = l.readUshorts(i, o, h)), c.fmt == 2 && (c.tab = l.readUshorts(i, o, 3 * h)), c;
    }, e._lctf.coverageIndex = function(i, o) {
      var l = i.tab;
      if (i.fmt == 1)
        return l.indexOf(o);
      if (i.fmt == 2) {
        var c = e._lctf.getInterval(l, o);
        if (c != -1)
          return l[c + 2] + (o - l[c]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, o) {
      var l = e._bin, c = o, h = [], p = l.readUshort(i, o);
      o += 2;
      for (var y = 0; y < p; y++) {
        var x = l.readASCII(i, o, 4);
        o += 4;
        var b = l.readUshort(i, o);
        o += 2;
        var w = e._lctf.readFeatureTable(i, c + b);
        w.tag = x.trim(), h.push(w);
      }
      return h;
    }, e._lctf.readFeatureTable = function(i, o) {
      var l = e._bin, c = o, h = {}, p = l.readUshort(i, o);
      o += 2, p > 0 && (h.featureParams = c + p);
      var y = l.readUshort(i, o);
      o += 2, h.tab = [];
      for (var x = 0; x < y; x++)
        h.tab.push(l.readUshort(i, o + 2 * x));
      return h;
    }, e._lctf.readScriptList = function(i, o) {
      var l = e._bin, c = o, h = {}, p = l.readUshort(i, o);
      o += 2;
      for (var y = 0; y < p; y++) {
        var x = l.readASCII(i, o, 4);
        o += 4;
        var b = l.readUshort(i, o);
        o += 2, h[x.trim()] = e._lctf.readScriptTable(i, c + b);
      }
      return h;
    }, e._lctf.readScriptTable = function(i, o) {
      var l = e._bin, c = o, h = {}, p = l.readUshort(i, o);
      o += 2, h.default = e._lctf.readLangSysTable(i, c + p);
      var y = l.readUshort(i, o);
      o += 2;
      for (var x = 0; x < y; x++) {
        var b = l.readASCII(i, o, 4);
        o += 4;
        var w = l.readUshort(i, o);
        o += 2, h[b.trim()] = e._lctf.readLangSysTable(i, c + w);
      }
      return h;
    }, e._lctf.readLangSysTable = function(i, o) {
      var l = e._bin, c = {};
      l.readUshort(i, o), o += 2, c.reqFeature = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      return o += 2, c.features = l.readUshorts(i, o, h), c;
    }, e.CFF = {}, e.CFF.parse = function(i, o, l) {
      var c = e._bin;
      (i = new Uint8Array(i.buffer, o, l))[o = 0], i[++o], i[++o], i[++o], o++;
      var h = [];
      o = e.CFF.readIndex(i, o, h);
      for (var p = [], y = 0; y < h.length - 1; y++)
        p.push(c.readASCII(i, o + h[y], h[y + 1] - h[y]));
      o += h[h.length - 1];
      var x = [];
      o = e.CFF.readIndex(i, o, x);
      var b = [];
      for (y = 0; y < x.length - 1; y++)
        b.push(e.CFF.readDict(i, o + x[y], o + x[y + 1]));
      o += x[x.length - 1];
      var w = b[0], R = [];
      o = e.CFF.readIndex(i, o, R);
      var U = [];
      for (y = 0; y < R.length - 1; y++)
        U.push(c.readASCII(i, o + R[y], R[y + 1] - R[y]));
      if (o += R[R.length - 1], e.CFF.readSubrs(i, o, w), w.CharStrings) {
        o = w.CharStrings, R = [], o = e.CFF.readIndex(i, o, R);
        var L = [];
        for (y = 0; y < R.length - 1; y++)
          L.push(c.readBytes(i, o + R[y], R[y + 1] - R[y]));
        w.CharStrings = L;
      }
      if (w.ROS) {
        o = w.FDArray;
        var A = [];
        for (o = e.CFF.readIndex(i, o, A), w.FDArray = [], y = 0; y < A.length - 1; y++) {
          var F = e.CFF.readDict(i, o + A[y], o + A[y + 1]);
          e.CFF._readFDict(i, F, U), w.FDArray.push(F);
        }
        o += A[A.length - 1], o = w.FDSelect, w.FDSelect = [];
        var k = i[o];
        if (o++, k != 3)
          throw k;
        var H = c.readUshort(i, o);
        for (o += 2, y = 0; y < H + 1; y++)
          w.FDSelect.push(c.readUshort(i, o), i[o + 2]), o += 3;
      }
      return w.Encoding && (w.Encoding = e.CFF.readEncoding(i, w.Encoding, w.CharStrings.length)), w.charset && (w.charset = e.CFF.readCharset(i, w.charset, w.CharStrings.length)), e.CFF._readFDict(i, w, U), w;
    }, e.CFF._readFDict = function(i, o, l) {
      var c;
      for (var h in o.Private && (c = o.Private[1], o.Private = e.CFF.readDict(i, c, c + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(i, c + o.Private.Subrs, o.Private)), o)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(h) != -1 && (o[h] = l[o[h] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, o, l) {
      var c = e._bin, h = [];
      o = e.CFF.readIndex(i, o, h);
      var p, y = h.length;
      p = y < 1240 ? 107 : y < 33900 ? 1131 : 32768, l.Bias = p, l.Subrs = [];
      for (var x = 0; x < h.length - 1; x++)
        l.Subrs.push(c.readBytes(i, o + h[x], h[x + 1] - h[x]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, o) {
      for (var l = 0; l < i.charset.length; l++)
        if (i.charset[l] == o)
          return l;
      return -1;
    }, e.CFF.glyphBySE = function(i, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(i, o, l) {
      e._bin;
      var c = [".notdef"], h = i[o];
      if (o++, h != 0)
        throw "error: unknown encoding format: " + h;
      var p = i[o];
      o++;
      for (var y = 0; y < p; y++)
        c.push(i[o + y]);
      return c;
    }, e.CFF.readCharset = function(i, o, l) {
      var c = e._bin, h = [".notdef"], p = i[o];
      if (o++, p == 0)
        for (var y = 0; y < l; y++) {
          var x = c.readUshort(i, o);
          o += 2, h.push(x);
        }
      else {
        if (p != 1 && p != 2)
          throw "error: format: " + p;
        for (; h.length < l; ) {
          x = c.readUshort(i, o), o += 2;
          var b = 0;
          for (p == 1 ? (b = i[o], o++) : (b = c.readUshort(i, o), o += 2), y = 0; y <= b; y++)
            h.push(x), x++;
        }
      }
      return h;
    }, e.CFF.readIndex = function(i, o, l) {
      var c = e._bin, h = c.readUshort(i, o) + 1, p = i[o += 2];
      if (o++, p == 1)
        for (var y = 0; y < h; y++)
          l.push(i[o + y]);
      else if (p == 2)
        for (y = 0; y < h; y++)
          l.push(c.readUshort(i, o + 2 * y));
      else if (p == 3)
        for (y = 0; y < h; y++)
          l.push(16777215 & c.readUint(i, o + 3 * y - 1));
      else if (h != 1)
        throw "unsupported offset size: " + p + ", count: " + h;
      return (o += h * p) - 1;
    }, e.CFF.getCharString = function(i, o, l) {
      var c = e._bin, h = i[o], p = i[o + 1];
      i[o + 2], i[o + 3], i[o + 4];
      var y = 1, x = null, b = null;
      h <= 20 && (x = h, y = 1), h == 12 && (x = 100 * h + p, y = 2), 21 <= h && h <= 27 && (x = h, y = 1), h == 28 && (b = c.readShort(i, o + 1), y = 3), 29 <= h && h <= 31 && (x = h, y = 1), 32 <= h && h <= 246 && (b = h - 139, y = 1), 247 <= h && h <= 250 && (b = 256 * (h - 247) + p + 108, y = 2), 251 <= h && h <= 254 && (b = 256 * -(h - 251) - p - 108, y = 2), h == 255 && (b = c.readInt(i, o + 1) / 65535, y = 5), l.val = b ?? "o" + x, l.size = y;
    }, e.CFF.readCharString = function(i, o, l) {
      for (var c = o + l, h = e._bin, p = []; o < c; ) {
        var y = i[o], x = i[o + 1];
        i[o + 2], i[o + 3], i[o + 4];
        var b = 1, w = null, R = null;
        y <= 20 && (w = y, b = 1), y == 12 && (w = 100 * y + x, b = 2), y != 19 && y != 20 || (w = y, b = 2), 21 <= y && y <= 27 && (w = y, b = 1), y == 28 && (R = h.readShort(i, o + 1), b = 3), 29 <= y && y <= 31 && (w = y, b = 1), 32 <= y && y <= 246 && (R = y - 139, b = 1), 247 <= y && y <= 250 && (R = 256 * (y - 247) + x + 108, b = 2), 251 <= y && y <= 254 && (R = 256 * -(y - 251) - x - 108, b = 2), y == 255 && (R = h.readInt(i, o + 1) / 65535, b = 5), p.push(R ?? "o" + w), o += b;
      }
      return p;
    }, e.CFF.readDict = function(i, o, l) {
      for (var c = e._bin, h = {}, p = []; o < l; ) {
        var y = i[o], x = i[o + 1];
        i[o + 2], i[o + 3], i[o + 4];
        var b = 1, w = null, R = null;
        if (y == 28 && (R = c.readShort(i, o + 1), b = 3), y == 29 && (R = c.readInt(i, o + 1), b = 5), 32 <= y && y <= 246 && (R = y - 139, b = 1), 247 <= y && y <= 250 && (R = 256 * (y - 247) + x + 108, b = 2), 251 <= y && y <= 254 && (R = 256 * -(y - 251) - x - 108, b = 2), y == 255)
          throw R = c.readInt(i, o + 1) / 65535, b = 5, "unknown number";
        if (y == 30) {
          var U = [];
          for (b = 1; ; ) {
            var L = i[o + b];
            b++;
            var A = L >> 4, F = 15 & L;
            if (A != 15 && U.push(A), F != 15 && U.push(F), F == 15)
              break;
          }
          for (var k = "", H = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], B = 0; B < U.length; B++)
            k += H[U[B]];
          R = parseFloat(k);
        }
        y <= 21 && (w = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][y], b = 1, y == 12 && (w = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][x], b = 2)), w != null ? (h[w] = p.length == 1 ? p[0] : p, p = []) : p.push(R), o += b;
      }
      return h;
    }, e.cmap = {}, e.cmap.parse = function(i, o, l) {
      i = new Uint8Array(i.buffer, o, l), o = 0;
      var c = e._bin, h = {};
      c.readUshort(i, o), o += 2;
      var p = c.readUshort(i, o);
      o += 2;
      var y = [];
      h.tables = [];
      for (var x = 0; x < p; x++) {
        var b = c.readUshort(i, o);
        o += 2;
        var w = c.readUshort(i, o);
        o += 2;
        var R = c.readUint(i, o);
        o += 4;
        var U = "p" + b + "e" + w, L = y.indexOf(R);
        if (L == -1) {
          var A;
          L = h.tables.length, y.push(R);
          var F = c.readUshort(i, R);
          F == 0 ? A = e.cmap.parse0(i, R) : F == 4 ? A = e.cmap.parse4(i, R) : F == 6 ? A = e.cmap.parse6(i, R) : F == 12 ? A = e.cmap.parse12(i, R) : console.debug("unknown format: " + F, b, w, R), h.tables.push(A);
        }
        if (h[U] != null)
          throw "multiple tables for one platform+encoding";
        h[U] = L;
      }
      return h;
    }, e.cmap.parse0 = function(i, o) {
      var l = e._bin, c = {};
      c.format = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2, c.map = [];
      for (var p = 0; p < h - 6; p++)
        c.map.push(i[o + p]);
      return c;
    }, e.cmap.parse4 = function(i, o) {
      var l = e._bin, c = o, h = {};
      h.format = l.readUshort(i, o), o += 2;
      var p = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2;
      var y = l.readUshort(i, o);
      o += 2;
      var x = y / 2;
      h.searchRange = l.readUshort(i, o), o += 2, h.entrySelector = l.readUshort(i, o), o += 2, h.rangeShift = l.readUshort(i, o), o += 2, h.endCount = l.readUshorts(i, o, x), o += 2 * x, o += 2, h.startCount = l.readUshorts(i, o, x), o += 2 * x, h.idDelta = [];
      for (var b = 0; b < x; b++)
        h.idDelta.push(l.readShort(i, o)), o += 2;
      for (h.idRangeOffset = l.readUshorts(i, o, x), o += 2 * x, h.glyphIdArray = []; o < c + p; )
        h.glyphIdArray.push(l.readUshort(i, o)), o += 2;
      return h;
    }, e.cmap.parse6 = function(i, o) {
      var l = e._bin, c = {};
      c.format = l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, c.firstCode = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2, c.glyphIdArray = [];
      for (var p = 0; p < h; p++)
        c.glyphIdArray.push(l.readUshort(i, o)), o += 2;
      return c;
    }, e.cmap.parse12 = function(i, o) {
      var l = e._bin, c = {};
      c.format = l.readUshort(i, o), o += 2, o += 2, l.readUint(i, o), o += 4, l.readUint(i, o), o += 4;
      var h = l.readUint(i, o);
      o += 4, c.groups = [];
      for (var p = 0; p < h; p++) {
        var y = o + 12 * p, x = l.readUint(i, y + 0), b = l.readUint(i, y + 4), w = l.readUint(i, y + 8);
        c.groups.push([x, b, w]);
      }
      return c;
    }, e.glyf = {}, e.glyf.parse = function(i, o, l, c) {
      for (var h = [], p = 0; p < c.maxp.numGlyphs; p++)
        h.push(null);
      return h;
    }, e.glyf._parseGlyf = function(i, o) {
      var l = e._bin, c = i._data, h = e._tabOffset(c, "glyf", i._offset) + i.loca[o];
      if (i.loca[o] == i.loca[o + 1])
        return null;
      var p = {};
      if (p.noc = l.readShort(c, h), h += 2, p.xMin = l.readShort(c, h), h += 2, p.yMin = l.readShort(c, h), h += 2, p.xMax = l.readShort(c, h), h += 2, p.yMax = l.readShort(c, h), h += 2, p.xMin >= p.xMax || p.yMin >= p.yMax)
        return null;
      if (p.noc > 0) {
        p.endPts = [];
        for (var y = 0; y < p.noc; y++)
          p.endPts.push(l.readUshort(c, h)), h += 2;
        var x = l.readUshort(c, h);
        if (h += 2, c.length - h < x)
          return null;
        p.instructions = l.readBytes(c, h, x), h += x;
        var b = p.endPts[p.noc - 1] + 1;
        for (p.flags = [], y = 0; y < b; y++) {
          var w = c[h];
          if (h++, p.flags.push(w), (8 & w) != 0) {
            var R = c[h];
            h++;
            for (var U = 0; U < R; U++)
              p.flags.push(w), y++;
          }
        }
        for (p.xs = [], y = 0; y < b; y++) {
          var L = (2 & p.flags[y]) != 0, A = (16 & p.flags[y]) != 0;
          L ? (p.xs.push(A ? c[h] : -c[h]), h++) : A ? p.xs.push(0) : (p.xs.push(l.readShort(c, h)), h += 2);
        }
        for (p.ys = [], y = 0; y < b; y++)
          L = (4 & p.flags[y]) != 0, A = (32 & p.flags[y]) != 0, L ? (p.ys.push(A ? c[h] : -c[h]), h++) : A ? p.ys.push(0) : (p.ys.push(l.readShort(c, h)), h += 2);
        var F = 0, k = 0;
        for (y = 0; y < b; y++)
          F += p.xs[y], k += p.ys[y], p.xs[y] = F, p.ys[y] = k;
      } else {
        var H;
        p.parts = [];
        do {
          H = l.readUshort(c, h), h += 2;
          var B = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (p.parts.push(B), B.glyphIndex = l.readUshort(c, h), h += 2, 1 & H) {
            var $ = l.readShort(c, h);
            h += 2;
            var Y = l.readShort(c, h);
            h += 2;
          } else
            $ = l.readInt8(c, h), h++, Y = l.readInt8(c, h), h++;
          2 & H ? (B.m.tx = $, B.m.ty = Y) : (B.p1 = $, B.p2 = Y), 8 & H ? (B.m.a = B.m.d = l.readF2dot14(c, h), h += 2) : 64 & H ? (B.m.a = l.readF2dot14(c, h), h += 2, B.m.d = l.readF2dot14(c, h), h += 2) : 128 & H && (B.m.a = l.readF2dot14(c, h), h += 2, B.m.b = l.readF2dot14(c, h), h += 2, B.m.c = l.readF2dot14(c, h), h += 2, B.m.d = l.readF2dot14(c, h), h += 2);
        } while (32 & H);
        if (256 & H) {
          var J = l.readUshort(c, h);
          for (h += 2, p.instr = [], y = 0; y < J; y++)
            p.instr.push(c[h]), h++;
        }
      }
      return p;
    }, e.GPOS = {}, e.GPOS.parse = function(i, o, l, c) {
      return e._lctf.parse(i, o, l, c, e.GPOS.subt);
    }, e.GPOS.subt = function(i, o, l, c) {
      var h = e._bin, p = l, y = {};
      if (y.fmt = h.readUshort(i, l), l += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && y.fmt <= 2) {
        var x = h.readUshort(i, l);
        l += 2, y.coverage = e._lctf.readCoverage(i, x + p);
      }
      if (o == 1 && y.fmt == 1) {
        var b = h.readUshort(i, l);
        l += 2;
        var w = e._lctf.numOfOnes(b);
        b != 0 && (y.pos = e.GPOS.readValueRecord(i, l, b));
      } else if (o == 2 && y.fmt >= 1 && y.fmt <= 2) {
        b = h.readUshort(i, l), l += 2;
        var R = h.readUshort(i, l);
        l += 2, w = e._lctf.numOfOnes(b);
        var U = e._lctf.numOfOnes(R);
        if (y.fmt == 1) {
          y.pairsets = [];
          var L = h.readUshort(i, l);
          l += 2;
          for (var A = 0; A < L; A++) {
            var F = p + h.readUshort(i, l);
            l += 2;
            var k = h.readUshort(i, F);
            F += 2;
            for (var H = [], B = 0; B < k; B++) {
              var $ = h.readUshort(i, F);
              F += 2, b != 0 && (oe = e.GPOS.readValueRecord(i, F, b), F += 2 * w), R != 0 && (fe = e.GPOS.readValueRecord(i, F, R), F += 2 * U), H.push({ gid2: $, val1: oe, val2: fe });
            }
            y.pairsets.push(H);
          }
        }
        if (y.fmt == 2) {
          var Y = h.readUshort(i, l);
          l += 2;
          var J = h.readUshort(i, l);
          l += 2;
          var K = h.readUshort(i, l);
          l += 2;
          var X = h.readUshort(i, l);
          for (l += 2, y.classDef1 = e._lctf.readClassDef(i, p + Y), y.classDef2 = e._lctf.readClassDef(i, p + J), y.matrix = [], A = 0; A < K; A++) {
            var le = [];
            for (B = 0; B < X; B++) {
              var oe = null, fe = null;
              b != 0 && (oe = e.GPOS.readValueRecord(i, l, b), l += 2 * w), R != 0 && (fe = e.GPOS.readValueRecord(i, l, R), l += 2 * U), le.push({ val1: oe, val2: fe });
            }
            y.matrix.push(le);
          }
        }
      } else {
        if (o == 9 && y.fmt == 1) {
          var de = h.readUshort(i, l);
          l += 2;
          var xe = h.readUint(i, l);
          if (l += 4, c.ltype == 9)
            c.ltype = de;
          else if (c.ltype != de)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, c.ltype, p + xe);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", y.fmt);
      }
      return y;
    }, e.GPOS.readValueRecord = function(i, o, l) {
      var c = e._bin, h = [];
      return h.push(1 & l ? c.readShort(i, o) : 0), o += 1 & l ? 2 : 0, h.push(2 & l ? c.readShort(i, o) : 0), o += 2 & l ? 2 : 0, h.push(4 & l ? c.readShort(i, o) : 0), o += 4 & l ? 2 : 0, h.push(8 & l ? c.readShort(i, o) : 0), o += 8 & l ? 2 : 0, h;
    }, e.GSUB = {}, e.GSUB.parse = function(i, o, l, c) {
      return e._lctf.parse(i, o, l, c, e.GSUB.subt);
    }, e.GSUB.subt = function(i, o, l, c) {
      var h = e._bin, p = l, y = {};
      if (y.fmt = h.readUshort(i, l), l += 2, o != 1 && o != 4 && o != 5 && o != 6)
        return null;
      if (o == 1 || o == 4 || o == 5 && y.fmt <= 2 || o == 6 && y.fmt <= 2) {
        var x = h.readUshort(i, l);
        l += 2, y.coverage = e._lctf.readCoverage(i, p + x);
      }
      if (o == 1 && y.fmt >= 1 && y.fmt <= 2) {
        if (y.fmt == 1)
          y.delta = h.readShort(i, l), l += 2;
        else if (y.fmt == 2) {
          var b = h.readUshort(i, l);
          l += 2, y.newg = h.readUshorts(i, l, b), l += 2 * y.newg.length;
        }
      } else if (o == 4) {
        y.vals = [], b = h.readUshort(i, l), l += 2;
        for (var w = 0; w < b; w++) {
          var R = h.readUshort(i, l);
          l += 2, y.vals.push(e.GSUB.readLigatureSet(i, p + R));
        }
      } else if (o == 5 && y.fmt == 2) {
        if (y.fmt == 2) {
          var U = h.readUshort(i, l);
          l += 2, y.cDef = e._lctf.readClassDef(i, p + U), y.scset = [];
          var L = h.readUshort(i, l);
          for (l += 2, w = 0; w < L; w++) {
            var A = h.readUshort(i, l);
            l += 2, y.scset.push(A == 0 ? null : e.GSUB.readSubClassSet(i, p + A));
          }
        }
      } else if (o == 6 && y.fmt == 3) {
        if (y.fmt == 3) {
          for (w = 0; w < 3; w++) {
            b = h.readUshort(i, l), l += 2;
            for (var F = [], k = 0; k < b; k++)
              F.push(e._lctf.readCoverage(i, p + h.readUshort(i, l + 2 * k)));
            l += 2 * b, w == 0 && (y.backCvg = F), w == 1 && (y.inptCvg = F), w == 2 && (y.ahedCvg = F);
          }
          b = h.readUshort(i, l), l += 2, y.lookupRec = e.GSUB.readSubstLookupRecords(i, l, b);
        }
      } else {
        if (o == 7 && y.fmt == 1) {
          var H = h.readUshort(i, l);
          l += 2;
          var B = h.readUint(i, l);
          if (l += 4, c.ltype == 9)
            c.ltype = H;
          else if (c.ltype != H)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, c.ltype, p + B);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", y.fmt);
      }
      return y;
    }, e.GSUB.readSubClassSet = function(i, o) {
      var l = e._bin.readUshort, c = o, h = [], p = l(i, o);
      o += 2;
      for (var y = 0; y < p; y++) {
        var x = l(i, o);
        o += 2, h.push(e.GSUB.readSubClassRule(i, c + x));
      }
      return h;
    }, e.GSUB.readSubClassRule = function(i, o) {
      var l = e._bin.readUshort, c = {}, h = l(i, o), p = l(i, o += 2);
      o += 2, c.input = [];
      for (var y = 0; y < h - 1; y++)
        c.input.push(l(i, o)), o += 2;
      return c.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, p), c;
    }, e.GSUB.readSubstLookupRecords = function(i, o, l) {
      for (var c = e._bin.readUshort, h = [], p = 0; p < l; p++)
        h.push(c(i, o), c(i, o + 2)), o += 4;
      return h;
    }, e.GSUB.readChainSubClassSet = function(i, o) {
      var l = e._bin, c = o, h = [], p = l.readUshort(i, o);
      o += 2;
      for (var y = 0; y < p; y++) {
        var x = l.readUshort(i, o);
        o += 2, h.push(e.GSUB.readChainSubClassRule(i, c + x));
      }
      return h;
    }, e.GSUB.readChainSubClassRule = function(i, o) {
      for (var l = e._bin, c = {}, h = ["backtrack", "input", "lookahead"], p = 0; p < h.length; p++) {
        var y = l.readUshort(i, o);
        o += 2, p == 1 && y--, c[h[p]] = l.readUshorts(i, o, y), o += 2 * c[h[p]].length;
      }
      return y = l.readUshort(i, o), o += 2, c.subst = l.readUshorts(i, o, 2 * y), o += 2 * c.subst.length, c;
    }, e.GSUB.readLigatureSet = function(i, o) {
      var l = e._bin, c = o, h = [], p = l.readUshort(i, o);
      o += 2;
      for (var y = 0; y < p; y++) {
        var x = l.readUshort(i, o);
        o += 2, h.push(e.GSUB.readLigature(i, c + x));
      }
      return h;
    }, e.GSUB.readLigature = function(i, o) {
      var l = e._bin, c = { chain: [] };
      c.nglyph = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2;
      for (var p = 0; p < h - 1; p++)
        c.chain.push(l.readUshort(i, o)), o += 2;
      return c;
    }, e.head = {}, e.head.parse = function(i, o, l) {
      var c = e._bin, h = {};
      return c.readFixed(i, o), o += 4, h.fontRevision = c.readFixed(i, o), o += 4, c.readUint(i, o), o += 4, c.readUint(i, o), o += 4, h.flags = c.readUshort(i, o), o += 2, h.unitsPerEm = c.readUshort(i, o), o += 2, h.created = c.readUint64(i, o), o += 8, h.modified = c.readUint64(i, o), o += 8, h.xMin = c.readShort(i, o), o += 2, h.yMin = c.readShort(i, o), o += 2, h.xMax = c.readShort(i, o), o += 2, h.yMax = c.readShort(i, o), o += 2, h.macStyle = c.readUshort(i, o), o += 2, h.lowestRecPPEM = c.readUshort(i, o), o += 2, h.fontDirectionHint = c.readShort(i, o), o += 2, h.indexToLocFormat = c.readShort(i, o), o += 2, h.glyphDataFormat = c.readShort(i, o), o += 2, h;
    }, e.hhea = {}, e.hhea.parse = function(i, o, l) {
      var c = e._bin, h = {};
      return c.readFixed(i, o), o += 4, h.ascender = c.readShort(i, o), o += 2, h.descender = c.readShort(i, o), o += 2, h.lineGap = c.readShort(i, o), o += 2, h.advanceWidthMax = c.readUshort(i, o), o += 2, h.minLeftSideBearing = c.readShort(i, o), o += 2, h.minRightSideBearing = c.readShort(i, o), o += 2, h.xMaxExtent = c.readShort(i, o), o += 2, h.caretSlopeRise = c.readShort(i, o), o += 2, h.caretSlopeRun = c.readShort(i, o), o += 2, h.caretOffset = c.readShort(i, o), o += 2, o += 8, h.metricDataFormat = c.readShort(i, o), o += 2, h.numberOfHMetrics = c.readUshort(i, o), o += 2, h;
    }, e.hmtx = {}, e.hmtx.parse = function(i, o, l, c) {
      for (var h = e._bin, p = { aWidth: [], lsBearing: [] }, y = 0, x = 0, b = 0; b < c.maxp.numGlyphs; b++)
        b < c.hhea.numberOfHMetrics && (y = h.readUshort(i, o), o += 2, x = h.readShort(i, o), o += 2), p.aWidth.push(y), p.lsBearing.push(x);
      return p;
    }, e.kern = {}, e.kern.parse = function(i, o, l, c) {
      var h = e._bin, p = h.readUshort(i, o);
      if (o += 2, p == 1)
        return e.kern.parseV1(i, o - 2, l, c);
      var y = h.readUshort(i, o);
      o += 2;
      for (var x = { glyph1: [], rval: [] }, b = 0; b < y; b++) {
        o += 2, l = h.readUshort(i, o), o += 2;
        var w = h.readUshort(i, o);
        o += 2;
        var R = w >>> 8;
        if ((R &= 15) != 0)
          throw "unknown kern table format: " + R;
        o = e.kern.readFormat0(i, o, x);
      }
      return x;
    }, e.kern.parseV1 = function(i, o, l, c) {
      var h = e._bin;
      h.readFixed(i, o), o += 4;
      var p = h.readUint(i, o);
      o += 4;
      for (var y = { glyph1: [], rval: [] }, x = 0; x < p; x++) {
        h.readUint(i, o), o += 4;
        var b = h.readUshort(i, o);
        o += 2, h.readUshort(i, o), o += 2;
        var w = b >>> 8;
        if ((w &= 15) != 0)
          throw "unknown kern table format: " + w;
        o = e.kern.readFormat0(i, o, y);
      }
      return y;
    }, e.kern.readFormat0 = function(i, o, l) {
      var c = e._bin, h = -1, p = c.readUshort(i, o);
      o += 2, c.readUshort(i, o), o += 2, c.readUshort(i, o), o += 2, c.readUshort(i, o), o += 2;
      for (var y = 0; y < p; y++) {
        var x = c.readUshort(i, o);
        o += 2;
        var b = c.readUshort(i, o);
        o += 2;
        var w = c.readShort(i, o);
        o += 2, x != h && (l.glyph1.push(x), l.rval.push({ glyph2: [], vals: [] }));
        var R = l.rval[l.rval.length - 1];
        R.glyph2.push(b), R.vals.push(w), h = x;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(i, o, l, c) {
      var h = e._bin, p = [], y = c.head.indexToLocFormat, x = c.maxp.numGlyphs + 1;
      if (y == 0)
        for (var b = 0; b < x; b++)
          p.push(h.readUshort(i, o + (b << 1)) << 1);
      if (y == 1)
        for (b = 0; b < x; b++)
          p.push(h.readUint(i, o + (b << 2)));
      return p;
    }, e.maxp = {}, e.maxp.parse = function(i, o, l) {
      var c = e._bin, h = {}, p = c.readUint(i, o);
      return o += 4, h.numGlyphs = c.readUshort(i, o), o += 2, p == 65536 && (h.maxPoints = c.readUshort(i, o), o += 2, h.maxContours = c.readUshort(i, o), o += 2, h.maxCompositePoints = c.readUshort(i, o), o += 2, h.maxCompositeContours = c.readUshort(i, o), o += 2, h.maxZones = c.readUshort(i, o), o += 2, h.maxTwilightPoints = c.readUshort(i, o), o += 2, h.maxStorage = c.readUshort(i, o), o += 2, h.maxFunctionDefs = c.readUshort(i, o), o += 2, h.maxInstructionDefs = c.readUshort(i, o), o += 2, h.maxStackElements = c.readUshort(i, o), o += 2, h.maxSizeOfInstructions = c.readUshort(i, o), o += 2, h.maxComponentElements = c.readUshort(i, o), o += 2, h.maxComponentDepth = c.readUshort(i, o), o += 2), h;
    }, e.name = {}, e.name.parse = function(i, o, l) {
      var c = e._bin, h = {};
      c.readUshort(i, o), o += 2;
      var p = c.readUshort(i, o);
      o += 2, c.readUshort(i, o);
      for (var y, x = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], b = o += 2, w = 0; w < p; w++) {
        var R = c.readUshort(i, o);
        o += 2;
        var U = c.readUshort(i, o);
        o += 2;
        var L = c.readUshort(i, o);
        o += 2;
        var A = c.readUshort(i, o);
        o += 2;
        var F = c.readUshort(i, o);
        o += 2;
        var k = c.readUshort(i, o);
        o += 2;
        var H, B = x[A], $ = b + 12 * p + k;
        if (R == 0)
          H = c.readUnicode(i, $, F / 2);
        else if (R == 3 && U == 0)
          H = c.readUnicode(i, $, F / 2);
        else if (U == 0)
          H = c.readASCII(i, $, F);
        else if (U == 1)
          H = c.readUnicode(i, $, F / 2);
        else if (U == 3)
          H = c.readUnicode(i, $, F / 2);
        else {
          if (R != 1)
            throw "unknown encoding " + U + ", platformID: " + R;
          H = c.readASCII(i, $, F), console.debug("reading unknown MAC encoding " + U + " as ASCII");
        }
        var Y = "p" + R + "," + L.toString(16);
        h[Y] == null && (h[Y] = {}), h[Y][B !== void 0 ? B : A] = H, h[Y]._lang = L;
      }
      for (var J in h)
        if (h[J].postScriptName != null && h[J]._lang == 1033)
          return h[J];
      for (var J in h)
        if (h[J].postScriptName != null && h[J]._lang == 0)
          return h[J];
      for (var J in h)
        if (h[J].postScriptName != null && h[J]._lang == 3084)
          return h[J];
      for (var J in h)
        if (h[J].postScriptName != null)
          return h[J];
      for (var J in h) {
        y = J;
        break;
      }
      return console.debug("returning name table with languageID " + h[y]._lang), h[y];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, o, l) {
      var c = e._bin.readUshort(i, o);
      o += 2;
      var h = {};
      if (c == 0)
        e["OS/2"].version0(i, o, h);
      else if (c == 1)
        e["OS/2"].version1(i, o, h);
      else if (c == 2 || c == 3 || c == 4)
        e["OS/2"].version2(i, o, h);
      else {
        if (c != 5)
          throw "unknown OS/2 table version: " + c;
        e["OS/2"].version5(i, o, h);
      }
      return h;
    }, e["OS/2"].version0 = function(i, o, l) {
      var c = e._bin;
      return l.xAvgCharWidth = c.readShort(i, o), o += 2, l.usWeightClass = c.readUshort(i, o), o += 2, l.usWidthClass = c.readUshort(i, o), o += 2, l.fsType = c.readUshort(i, o), o += 2, l.ySubscriptXSize = c.readShort(i, o), o += 2, l.ySubscriptYSize = c.readShort(i, o), o += 2, l.ySubscriptXOffset = c.readShort(i, o), o += 2, l.ySubscriptYOffset = c.readShort(i, o), o += 2, l.ySuperscriptXSize = c.readShort(i, o), o += 2, l.ySuperscriptYSize = c.readShort(i, o), o += 2, l.ySuperscriptXOffset = c.readShort(i, o), o += 2, l.ySuperscriptYOffset = c.readShort(i, o), o += 2, l.yStrikeoutSize = c.readShort(i, o), o += 2, l.yStrikeoutPosition = c.readShort(i, o), o += 2, l.sFamilyClass = c.readShort(i, o), o += 2, l.panose = c.readBytes(i, o, 10), o += 10, l.ulUnicodeRange1 = c.readUint(i, o), o += 4, l.ulUnicodeRange2 = c.readUint(i, o), o += 4, l.ulUnicodeRange3 = c.readUint(i, o), o += 4, l.ulUnicodeRange4 = c.readUint(i, o), o += 4, l.achVendID = [c.readInt8(i, o), c.readInt8(i, o + 1), c.readInt8(i, o + 2), c.readInt8(i, o + 3)], o += 4, l.fsSelection = c.readUshort(i, o), o += 2, l.usFirstCharIndex = c.readUshort(i, o), o += 2, l.usLastCharIndex = c.readUshort(i, o), o += 2, l.sTypoAscender = c.readShort(i, o), o += 2, l.sTypoDescender = c.readShort(i, o), o += 2, l.sTypoLineGap = c.readShort(i, o), o += 2, l.usWinAscent = c.readUshort(i, o), o += 2, l.usWinDescent = c.readUshort(i, o), o += 2;
    }, e["OS/2"].version1 = function(i, o, l) {
      var c = e._bin;
      return o = e["OS/2"].version0(i, o, l), l.ulCodePageRange1 = c.readUint(i, o), o += 4, l.ulCodePageRange2 = c.readUint(i, o), o += 4;
    }, e["OS/2"].version2 = function(i, o, l) {
      var c = e._bin;
      return o = e["OS/2"].version1(i, o, l), l.sxHeight = c.readShort(i, o), o += 2, l.sCapHeight = c.readShort(i, o), o += 2, l.usDefault = c.readUshort(i, o), o += 2, l.usBreak = c.readUshort(i, o), o += 2, l.usMaxContext = c.readUshort(i, o), o += 2;
    }, e["OS/2"].version5 = function(i, o, l) {
      var c = e._bin;
      return o = e["OS/2"].version2(i, o, l), l.usLowerOpticalPointSize = c.readUshort(i, o), o += 2, l.usUpperOpticalPointSize = c.readUshort(i, o), o += 2;
    }, e.post = {}, e.post.parse = function(i, o, l) {
      var c = e._bin, h = {};
      return h.version = c.readFixed(i, o), o += 4, h.italicAngle = c.readFixed(i, o), o += 4, h.underlinePosition = c.readShort(i, o), o += 2, h.underlineThickness = c.readShort(i, o), o += 2, h;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, o) {
      var l = i.cmap, c = -1;
      if (l.p0e4 != null ? c = l.p0e4 : l.p3e1 != null ? c = l.p3e1 : l.p1e0 != null ? c = l.p1e0 : l.p0e3 != null && (c = l.p0e3), c == -1)
        throw "no familiar platform and encoding!";
      var h = l.tables[c];
      if (h.format == 0)
        return o >= h.map.length ? 0 : h.map[o];
      if (h.format == 4) {
        for (var p = -1, y = 0; y < h.endCount.length; y++)
          if (o <= h.endCount[y]) {
            p = y;
            break;
          }
        return p == -1 || h.startCount[p] > o ? 0 : 65535 & (h.idRangeOffset[p] != 0 ? h.glyphIdArray[o - h.startCount[p] + (h.idRangeOffset[p] >> 1) - (h.idRangeOffset.length - p)] : o + h.idDelta[p]);
      }
      if (h.format == 12) {
        if (o > h.groups[h.groups.length - 1][1])
          return 0;
        for (y = 0; y < h.groups.length; y++) {
          var x = h.groups[y];
          if (x[0] <= o && o <= x[1])
            return x[2] + (o - x[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + h.format;
    }, e.U.glyphToPath = function(i, o) {
      var l = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[o]) {
        var c = i.SVG.entries[o];
        return c == null ? l : (typeof c == "string" && (c = e.SVG.toPath(c), i.SVG.entries[o] = c), c);
      }
      if (i.CFF) {
        var h = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, p = i.CFF, y = i.CFF.Private;
        if (p.ROS) {
          for (var x = 0; p.FDSelect[x + 2] <= o; )
            x += 2;
          y = p.FDArray[p.FDSelect[x + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[o], h, p, y, l);
      } else
        i.glyf && e.U._drawGlyf(o, i, l);
      return l;
    }, e.U._drawGlyf = function(i, o, l) {
      var c = o.glyf[i];
      c == null && (c = o.glyf[i] = e.glyf._parseGlyf(o, i)), c != null && (c.noc > -1 ? e.U._simpleGlyph(c, l) : e.U._compoGlyph(c, o, l));
    }, e.U._simpleGlyph = function(i, o) {
      for (var l = 0; l < i.noc; l++) {
        for (var c = l == 0 ? 0 : i.endPts[l - 1] + 1, h = i.endPts[l], p = c; p <= h; p++) {
          var y = p == c ? h : p - 1, x = p == h ? c : p + 1, b = 1 & i.flags[p], w = 1 & i.flags[y], R = 1 & i.flags[x], U = i.xs[p], L = i.ys[p];
          if (p == c)
            if (b) {
              if (!w) {
                e.U.P.moveTo(o, U, L);
                continue;
              }
              e.U.P.moveTo(o, i.xs[y], i.ys[y]);
            } else
              w ? e.U.P.moveTo(o, i.xs[y], i.ys[y]) : e.U.P.moveTo(o, (i.xs[y] + U) / 2, (i.ys[y] + L) / 2);
          b ? w && e.U.P.lineTo(o, U, L) : R ? e.U.P.qcurveTo(o, U, L, i.xs[x], i.ys[x]) : e.U.P.qcurveTo(o, U, L, (U + i.xs[x]) / 2, (L + i.ys[x]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(i, o, l) {
      for (var c = 0; c < i.parts.length; c++) {
        var h = { cmds: [], crds: [] }, p = i.parts[c];
        e.U._drawGlyf(p.glyphIndex, o, h);
        for (var y = p.m, x = 0; x < h.crds.length; x += 2) {
          var b = h.crds[x], w = h.crds[x + 1];
          l.crds.push(b * y.a + w * y.b + y.tx), l.crds.push(b * y.c + w * y.d + y.ty);
        }
        for (x = 0; x < h.cmds.length; x++)
          l.cmds.push(h.cmds[x]);
      }
    }, e.U._getGlyphClass = function(i, o) {
      var l = e._lctf.getInterval(o, i);
      return l == -1 ? 0 : o[l + 2];
    }, e.U.getPairAdjustment = function(i, o, l) {
      var c = !1;
      if (i.GPOS)
        for (var h = i.GPOS, p = h.lookupList, y = h.featureList, x = [], b = 0; b < y.length; b++) {
          var w = y[b];
          if (w.tag == "kern") {
            c = !0;
            for (var R = 0; R < w.tab.length; R++)
              if (!x[w.tab[R]]) {
                x[w.tab[R]] = !0;
                for (var U = p[w.tab[R]], L = 0; L < U.tabs.length; L++)
                  if (U.tabs[L] != null) {
                    var A, F = U.tabs[L];
                    if ((!F.coverage || (A = e._lctf.coverageIndex(F.coverage, o)) != -1) && U.ltype != 1) {
                      if (U.ltype == 2) {
                        var k = null;
                        if (F.fmt == 1) {
                          var H = F.pairsets[A];
                          for (b = 0; b < H.length; b++)
                            H[b].gid2 == l && (k = H[b]);
                        } else if (F.fmt == 2) {
                          var B = e.U._getGlyphClass(o, F.classDef1), $ = e.U._getGlyphClass(l, F.classDef2);
                          k = F.matrix[B][$];
                        }
                        if (k) {
                          var Y = 0;
                          return k.val1 && k.val1[2] && (Y += k.val1[2]), k.val2 && k.val2[0] && (Y += k.val2[0]), Y;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (i.kern && !c) {
        var J = i.kern.glyph1.indexOf(o);
        if (J != -1) {
          var K = i.kern.rval[J].glyph2.indexOf(l);
          if (K != -1)
            return i.kern.rval[J].vals[K];
        }
      }
      return 0;
    }, e.U._applySubs = function(i, o, l, c) {
      for (var h = i.length - o - 1, p = 0; p < l.tabs.length; p++)
        if (l.tabs[p] != null) {
          var y, x = l.tabs[p];
          if (!x.coverage || (y = e._lctf.coverageIndex(x.coverage, i[o])) != -1) {
            if (l.ltype == 1)
              i[o], x.fmt == 1 ? i[o] = i[o] + x.delta : i[o] = x.newg[y];
            else if (l.ltype == 4)
              for (var b = x.vals[y], w = 0; w < b.length; w++) {
                var R = b[w], U = R.chain.length;
                if (!(U > h)) {
                  for (var L = !0, A = 0, F = 0; F < U; F++) {
                    for (; i[o + A + (1 + F)] == -1; )
                      A++;
                    R.chain[F] != i[o + A + (1 + F)] && (L = !1);
                  }
                  if (L) {
                    for (i[o] = R.nglyph, F = 0; F < U + A; F++)
                      i[o + F + 1] = -1;
                    break;
                  }
                }
              }
            else if (l.ltype == 5 && x.fmt == 2)
              for (var k = e._lctf.getInterval(x.cDef, i[o]), H = x.cDef[k + 2], B = x.scset[H], $ = 0; $ < B.length; $++) {
                var Y = B[$], J = Y.input;
                if (!(J.length > h)) {
                  for (L = !0, F = 0; F < J.length; F++) {
                    var K = e._lctf.getInterval(x.cDef, i[o + 1 + F]);
                    if (k == -1 && x.cDef[K + 2] != J[F]) {
                      L = !1;
                      break;
                    }
                  }
                  if (L) {
                    var X = Y.substLookupRecords;
                    for (w = 0; w < X.length; w += 2)
                      X[w], X[w + 1];
                  }
                }
              }
            else if (l.ltype == 6 && x.fmt == 3) {
              if (!e.U._glsCovered(i, x.backCvg, o - x.backCvg.length) || !e.U._glsCovered(i, x.inptCvg, o) || !e.U._glsCovered(i, x.ahedCvg, o + x.inptCvg.length))
                continue;
              var le = x.lookupRec;
              for ($ = 0; $ < le.length; $ += 2) {
                k = le[$];
                var oe = c[le[$ + 1]];
                e.U._applySubs(i, o + k, oe, c);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, o, l) {
      for (var c = 0; c < o.length; c++)
        if (e._lctf.coverageIndex(o[c], i[l + c]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, o, l) {
      for (var c = { cmds: [], crds: [] }, h = 0, p = 0; p < o.length; p++) {
        var y = o[p];
        if (y != -1) {
          for (var x = p < o.length - 1 && o[p + 1] != -1 ? o[p + 1] : 0, b = e.U.glyphToPath(i, y), w = 0; w < b.crds.length; w += 2)
            c.crds.push(b.crds[w] + h), c.crds.push(b.crds[w + 1]);
          for (l && c.cmds.push(l), w = 0; w < b.cmds.length; w++)
            c.cmds.push(b.cmds[w]);
          l && c.cmds.push("X"), h += i.hmtx.aWidth[y], p < o.length - 1 && (h += e.U.getPairAdjustment(i, y, x));
        }
      }
      return c;
    }, e.U.P = {}, e.U.P.moveTo = function(i, o, l) {
      i.cmds.push("M"), i.crds.push(o, l);
    }, e.U.P.lineTo = function(i, o, l) {
      i.cmds.push("L"), i.crds.push(o, l);
    }, e.U.P.curveTo = function(i, o, l, c, h, p, y) {
      i.cmds.push("C"), i.crds.push(o, l, c, h, p, y);
    }, e.U.P.qcurveTo = function(i, o, l, c, h) {
      i.cmds.push("Q"), i.crds.push(o, l, c, h);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, o, l, c, h) {
      for (var p = o.stack, y = o.nStems, x = o.haveWidth, b = o.width, w = o.open, R = 0, U = o.x, L = o.y, A = 0, F = 0, k = 0, H = 0, B = 0, $ = 0, Y = 0, J = 0, K = 0, X = 0, le = { val: 0, size: 0 }; R < i.length; ) {
        e.CFF.getCharString(i, R, le);
        var oe = le.val;
        if (R += le.size, oe == "o1" || oe == "o18")
          p.length % 2 != 0 && !x && (b = p.shift() + c.nominalWidthX), y += p.length >> 1, p.length = 0, x = !0;
        else if (oe == "o3" || oe == "o23")
          p.length % 2 != 0 && !x && (b = p.shift() + c.nominalWidthX), y += p.length >> 1, p.length = 0, x = !0;
        else if (oe == "o4")
          p.length > 1 && !x && (b = p.shift() + c.nominalWidthX, x = !0), w && e.U.P.closePath(h), L += p.pop(), e.U.P.moveTo(h, U, L), w = !0;
        else if (oe == "o5")
          for (; p.length > 0; )
            U += p.shift(), L += p.shift(), e.U.P.lineTo(h, U, L);
        else if (oe == "o6" || oe == "o7")
          for (var fe = p.length, de = oe == "o6", xe = 0; xe < fe; xe++) {
            var _e = p.shift();
            de ? U += _e : L += _e, de = !de, e.U.P.lineTo(h, U, L);
          }
        else if (oe == "o8" || oe == "o24") {
          fe = p.length;
          for (var Pe = 0; Pe + 6 <= fe; )
            A = U + p.shift(), F = L + p.shift(), k = A + p.shift(), H = F + p.shift(), U = k + p.shift(), L = H + p.shift(), e.U.P.curveTo(h, A, F, k, H, U, L), Pe += 6;
          oe == "o24" && (U += p.shift(), L += p.shift(), e.U.P.lineTo(h, U, L));
        } else {
          if (oe == "o11")
            break;
          if (oe == "o1234" || oe == "o1235" || oe == "o1236" || oe == "o1237")
            oe == "o1234" && (F = L, k = (A = U + p.shift()) + p.shift(), X = H = F + p.shift(), $ = H, J = L, U = (Y = (B = (K = k + p.shift()) + p.shift()) + p.shift()) + p.shift(), e.U.P.curveTo(h, A, F, k, H, K, X), e.U.P.curveTo(h, B, $, Y, J, U, L)), oe == "o1235" && (A = U + p.shift(), F = L + p.shift(), k = A + p.shift(), H = F + p.shift(), K = k + p.shift(), X = H + p.shift(), B = K + p.shift(), $ = X + p.shift(), Y = B + p.shift(), J = $ + p.shift(), U = Y + p.shift(), L = J + p.shift(), p.shift(), e.U.P.curveTo(h, A, F, k, H, K, X), e.U.P.curveTo(h, B, $, Y, J, U, L)), oe == "o1236" && (A = U + p.shift(), F = L + p.shift(), k = A + p.shift(), X = H = F + p.shift(), $ = H, Y = (B = (K = k + p.shift()) + p.shift()) + p.shift(), J = $ + p.shift(), U = Y + p.shift(), e.U.P.curveTo(h, A, F, k, H, K, X), e.U.P.curveTo(h, B, $, Y, J, U, L)), oe == "o1237" && (A = U + p.shift(), F = L + p.shift(), k = A + p.shift(), H = F + p.shift(), K = k + p.shift(), X = H + p.shift(), B = K + p.shift(), $ = X + p.shift(), Y = B + p.shift(), J = $ + p.shift(), Math.abs(Y - U) > Math.abs(J - L) ? U = Y + p.shift() : L = J + p.shift(), e.U.P.curveTo(h, A, F, k, H, K, X), e.U.P.curveTo(h, B, $, Y, J, U, L));
          else if (oe == "o14") {
            if (p.length > 0 && !x && (b = p.shift() + l.nominalWidthX, x = !0), p.length == 4) {
              var ce = p.shift(), ve = p.shift(), re = p.shift(), ee = p.shift(), he = e.CFF.glyphBySE(l, re), Me = e.CFF.glyphBySE(l, ee);
              e.U._drawCFF(l.CharStrings[he], o, l, c, h), o.x = ce, o.y = ve, e.U._drawCFF(l.CharStrings[Me], o, l, c, h);
            }
            w && (e.U.P.closePath(h), w = !1);
          } else if (oe == "o19" || oe == "o20")
            p.length % 2 != 0 && !x && (b = p.shift() + c.nominalWidthX), y += p.length >> 1, p.length = 0, x = !0, R += y + 7 >> 3;
          else if (oe == "o21")
            p.length > 2 && !x && (b = p.shift() + c.nominalWidthX, x = !0), L += p.pop(), U += p.pop(), w && e.U.P.closePath(h), e.U.P.moveTo(h, U, L), w = !0;
          else if (oe == "o22")
            p.length > 1 && !x && (b = p.shift() + c.nominalWidthX, x = !0), U += p.pop(), w && e.U.P.closePath(h), e.U.P.moveTo(h, U, L), w = !0;
          else if (oe == "o25") {
            for (; p.length > 6; )
              U += p.shift(), L += p.shift(), e.U.P.lineTo(h, U, L);
            A = U + p.shift(), F = L + p.shift(), k = A + p.shift(), H = F + p.shift(), U = k + p.shift(), L = H + p.shift(), e.U.P.curveTo(h, A, F, k, H, U, L);
          } else if (oe == "o26")
            for (p.length % 2 && (U += p.shift()); p.length > 0; )
              A = U, F = L + p.shift(), U = k = A + p.shift(), L = (H = F + p.shift()) + p.shift(), e.U.P.curveTo(h, A, F, k, H, U, L);
          else if (oe == "o27")
            for (p.length % 2 && (L += p.shift()); p.length > 0; )
              F = L, k = (A = U + p.shift()) + p.shift(), H = F + p.shift(), U = k + p.shift(), L = H, e.U.P.curveTo(h, A, F, k, H, U, L);
          else if (oe == "o10" || oe == "o29") {
            var Le = oe == "o10" ? c : l;
            if (p.length == 0)
              console.debug("error: empty stack");
            else {
              var Ae = p.pop(), Ue = Le.Subrs[Ae + Le.Bias];
              o.x = U, o.y = L, o.nStems = y, o.haveWidth = x, o.width = b, o.open = w, e.U._drawCFF(Ue, o, l, c, h), U = o.x, L = o.y, y = o.nStems, x = o.haveWidth, b = o.width, w = o.open;
            }
          } else if (oe == "o30" || oe == "o31") {
            var Ne = p.length, ke = (Pe = 0, oe == "o31");
            for (Pe += Ne - (fe = -3 & Ne); Pe < fe; )
              ke ? (F = L, k = (A = U + p.shift()) + p.shift(), L = (H = F + p.shift()) + p.shift(), fe - Pe == 5 ? (U = k + p.shift(), Pe++) : U = k, ke = !1) : (A = U, F = L + p.shift(), k = A + p.shift(), H = F + p.shift(), U = k + p.shift(), fe - Pe == 5 ? (L = H + p.shift(), Pe++) : L = H, ke = !0), e.U.P.curveTo(h, A, F, k, H, U, L), Pe += 4;
          } else {
            if ((oe + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + oe, i), oe;
            p.push(oe);
          }
        }
      }
      o.x = U, o.y = L, o.nStems = y, o.haveWidth = x, o.width = b, o.open = w;
    };
    var t = e, r = { Typr: t };
    return n.Typr = t, n.default = r, Object.defineProperty(n, "__esModule", { value: !0 }), n;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function rQ() {
  return function(n) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), l = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), c = function(oe, fe) {
      for (var de = new t(31), xe = 0; xe < 31; ++xe)
        de[xe] = fe += 1 << oe[xe - 1];
      var _e = new r(de[30]);
      for (xe = 1; xe < 30; ++xe)
        for (var Pe = de[xe]; Pe < de[xe + 1]; ++Pe)
          _e[Pe] = Pe - de[xe] << 5 | xe;
      return [de, _e];
    }, h = c(i, 2), p = h[0], y = h[1];
    p[28] = 258, y[258] = 28;
    for (var x = c(o, 0)[0], b = new t(32768), w = 0; w < 32768; ++w) {
      var R = (43690 & w) >>> 1 | (21845 & w) << 1;
      R = (61680 & (R = (52428 & R) >>> 2 | (13107 & R) << 2)) >>> 4 | (3855 & R) << 4, b[w] = ((65280 & R) >>> 8 | (255 & R) << 8) >>> 1;
    }
    var U = function(oe, fe, de) {
      for (var xe = oe.length, _e = 0, Pe = new t(fe); _e < xe; ++_e)
        ++Pe[oe[_e] - 1];
      var ce, ve = new t(fe);
      for (_e = 0; _e < fe; ++_e)
        ve[_e] = ve[_e - 1] + Pe[_e - 1] << 1;
      if (de) {
        ce = new t(1 << fe);
        var re = 15 - fe;
        for (_e = 0; _e < xe; ++_e)
          if (oe[_e])
            for (var ee = _e << 4 | oe[_e], he = fe - oe[_e], Me = ve[oe[_e] - 1]++ << he, Le = Me | (1 << he) - 1; Me <= Le; ++Me)
              ce[b[Me] >>> re] = ee;
      } else
        for (ce = new t(xe), _e = 0; _e < xe; ++_e)
          oe[_e] && (ce[_e] = b[ve[oe[_e] - 1]++] >>> 15 - oe[_e]);
      return ce;
    }, L = new e(288);
    for (w = 0; w < 144; ++w)
      L[w] = 8;
    for (w = 144; w < 256; ++w)
      L[w] = 9;
    for (w = 256; w < 280; ++w)
      L[w] = 7;
    for (w = 280; w < 288; ++w)
      L[w] = 8;
    var A = new e(32);
    for (w = 0; w < 32; ++w)
      A[w] = 5;
    var F = U(L, 9, 1), k = U(A, 5, 1), H = function(oe) {
      for (var fe = oe[0], de = 1; de < oe.length; ++de)
        oe[de] > fe && (fe = oe[de]);
      return fe;
    }, B = function(oe, fe, de) {
      var xe = fe / 8 | 0;
      return (oe[xe] | oe[xe + 1] << 8) >> (7 & fe) & de;
    }, $ = function(oe, fe) {
      var de = fe / 8 | 0;
      return (oe[de] | oe[de + 1] << 8 | oe[de + 2] << 16) >> (7 & fe);
    }, Y = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], J = function(oe, fe, de) {
      var xe = new Error(fe || Y[oe]);
      if (xe.code = oe, Error.captureStackTrace && Error.captureStackTrace(xe, J), !de)
        throw xe;
      return xe;
    }, K = function(oe, fe, de) {
      var xe = oe.length;
      if (!xe || de && !de.l && xe < 5)
        return fe || new e(0);
      var _e = !fe || de, Pe = !de || de.i;
      de || (de = {}), fe || (fe = new e(3 * xe));
      var ce, ve = function(Je) {
        var be = fe.length;
        if (Je > be) {
          var Ze = new e(Math.max(2 * be, Je));
          Ze.set(fe), fe = Ze;
        }
      }, re = de.f || 0, ee = de.p || 0, he = de.b || 0, Me = de.l, Le = de.d, Ae = de.m, Ue = de.n, Ne = 8 * xe;
      do {
        if (!Me) {
          de.f = re = B(oe, ee, 1);
          var ke = B(oe, ee + 1, 3);
          if (ee += 3, !ke) {
            var it = oe[(Pt = ((ce = ee) / 8 | 0) + (7 & ce && 1) + 4) - 4] | oe[Pt - 3] << 8, At = Pt + it;
            if (At > xe) {
              Pe && J(0);
              break;
            }
            _e && ve(he + it), fe.set(oe.subarray(Pt, At), he), de.b = he += it, de.p = ee = 8 * At;
            continue;
          }
          if (ke == 1)
            Me = F, Le = k, Ae = 9, Ue = 5;
          else if (ke == 2) {
            var rt = B(oe, ee, 31) + 257, ae = B(oe, ee + 10, 15) + 4, et = rt + B(oe, ee + 5, 31) + 1;
            ee += 14;
            for (var Ye = new e(et), Ge = new e(19), $e = 0; $e < ae; ++$e)
              Ge[l[$e]] = B(oe, ee + 3 * $e, 7);
            ee += 3 * ae;
            var Ut = H(Ge), nt = (1 << Ut) - 1, Ct = U(Ge, Ut, 1);
            for ($e = 0; $e < et; ) {
              var Pt, vt = Ct[B(oe, ee, nt)];
              if (ee += 15 & vt, (Pt = vt >>> 4) < 16)
                Ye[$e++] = Pt;
              else {
                var Zt = 0, ie = 0;
                for (Pt == 16 ? (ie = 3 + B(oe, ee, 3), ee += 2, Zt = Ye[$e - 1]) : Pt == 17 ? (ie = 3 + B(oe, ee, 7), ee += 3) : Pt == 18 && (ie = 11 + B(oe, ee, 127), ee += 7); ie--; )
                  Ye[$e++] = Zt;
              }
            }
            var ne = Ye.subarray(0, rt), Oe = Ye.subarray(rt);
            Ae = H(ne), Ue = H(Oe), Me = U(ne, Ae, 1), Le = U(Oe, Ue, 1);
          } else
            J(1);
          if (ee > Ne) {
            Pe && J(0);
            break;
          }
        }
        _e && ve(he + 131072);
        for (var _t = (1 << Ae) - 1, ot = (1 << Ue) - 1, at = ee; ; at = ee) {
          var Wt = (Zt = Me[$(oe, ee) & _t]) >>> 4;
          if ((ee += 15 & Zt) > Ne) {
            Pe && J(0);
            break;
          }
          if (Zt || J(2), Wt < 256)
            fe[he++] = Wt;
          else {
            if (Wt == 256) {
              at = ee, Me = null;
              break;
            }
            var Dt = Wt - 254;
            if (Wt > 264) {
              var Se = i[$e = Wt - 257];
              Dt = B(oe, ee, (1 << Se) - 1) + p[$e], ee += Se;
            }
            var He = Le[$(oe, ee) & ot], lt = He >>> 4;
            if (He || J(3), ee += 15 & He, Oe = x[lt], lt > 3 && (Se = o[lt], Oe += $(oe, ee) & (1 << Se) - 1, ee += Se), ee > Ne) {
              Pe && J(0);
              break;
            }
            _e && ve(he + 131072);
            for (var St = he + Dt; he < St; he += 4)
              fe[he] = fe[he - Oe], fe[he + 1] = fe[he + 1 - Oe], fe[he + 2] = fe[he + 2 - Oe], fe[he + 3] = fe[he + 3 - Oe];
            he = St;
          }
        }
        de.l = Me, de.p = at, de.b = he, Me && (re = 1, de.m = Ae, de.d = Le, de.n = Ue);
      } while (!re);
      return he == fe.length ? fe : function(Je, be, Ze) {
        (be == null || be < 0) && (be = 0), (Ze == null || Ze > Je.length) && (Ze = Je.length);
        var ct = new (Je instanceof t ? t : Je instanceof r ? r : e)(Ze - be);
        return ct.set(Je.subarray(be, Ze)), ct;
      }(fe, 0, he);
    }, X = new e(0), le = typeof TextDecoder < "u" && new TextDecoder();
    try {
      le.decode(X, { stream: !0 });
    } catch {
    }
    return n.convert_streams = function(oe) {
      var fe = new DataView(oe), de = 0;
      function xe() {
        var rt = fe.getUint16(de);
        return de += 2, rt;
      }
      function _e() {
        var rt = fe.getUint32(de);
        return de += 4, rt;
      }
      function Pe(rt) {
        it.setUint16(At, rt), At += 2;
      }
      function ce(rt) {
        it.setUint32(At, rt), At += 4;
      }
      for (var ve = { signature: _e(), flavor: _e(), length: _e(), numTables: xe(), reserved: xe(), totalSfntSize: _e(), majorVersion: xe(), minorVersion: xe(), metaOffset: _e(), metaLength: _e(), metaOrigLength: _e(), privOffset: _e(), privLength: _e() }, re = 0; Math.pow(2, re) <= ve.numTables; )
        re++;
      re--;
      for (var ee = 16 * Math.pow(2, re), he = 16 * ve.numTables - ee, Me = 12, Le = [], Ae = 0; Ae < ve.numTables; Ae++)
        Le.push({ tag: _e(), offset: _e(), compLength: _e(), origLength: _e(), origChecksum: _e() }), Me += 16;
      var Ue, Ne = new Uint8Array(12 + 16 * Le.length + Le.reduce(function(rt, ae) {
        return rt + ae.origLength + 4;
      }, 0)), ke = Ne.buffer, it = new DataView(ke), At = 0;
      return ce(ve.flavor), Pe(ve.numTables), Pe(ee), Pe(re), Pe(he), Le.forEach(function(rt) {
        ce(rt.tag), ce(rt.origChecksum), ce(Me), ce(rt.origLength), rt.outOffset = Me, (Me += rt.origLength) % 4 != 0 && (Me += 4 - Me % 4);
      }), Le.forEach(function(rt) {
        var ae, et = oe.slice(rt.offset, rt.offset + rt.compLength);
        if (rt.compLength != rt.origLength) {
          var Ye = new Uint8Array(rt.origLength);
          ae = new Uint8Array(et, 2), K(ae, Ye);
        } else
          Ye = new Uint8Array(et);
        Ne.set(Ye, rt.outOffset);
        var Ge = 0;
        (Me = rt.outOffset + rt.origLength) % 4 != 0 && (Ge = 4 - Me % 4), Ne.set(new Uint8Array(Ge).buffer, rt.outOffset + rt.origLength), Ue = Me + Ge;
      }), ke.slice(0, Ue);
    }, Object.defineProperty(n, "__esModule", { value: !0 }), n;
  }({}).convert_streams;
}
function iQ(n, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, o = 2, l = 4, c = 8, h = 16, p = 32;
  let y;
  function x(B) {
    if (!y) {
      const $ = {
        R: o,
        L: i,
        D: l,
        C: h,
        U: p,
        T: c
      };
      y = /* @__PURE__ */ new Map();
      for (let Y in r) {
        let J = 0;
        r[Y].split(",").forEach((K) => {
          let [X, le] = K.split("+");
          X = parseInt(X, 36), le = le ? parseInt(le, 36) : 0, y.set(J += X, $[Y]);
          for (let oe = le; oe--; )
            y.set(++J, $[Y]);
        });
      }
    }
    return y.get(B) || p;
  }
  const b = 1, w = 2, R = 3, U = 4, L = [null, "isol", "init", "fina", "medi"];
  function A(B) {
    const $ = new Uint8Array(B.length);
    let Y = p, J = b, K = -1;
    for (let X = 0; X < B.length; X++) {
      const le = B.codePointAt(X);
      let oe = x(le) | 0, fe = b;
      oe & c || (Y & (i | l | h) ? oe & (o | l | h) ? (fe = R, (J === b || J === R) && $[K]++) : oe & (i | p) && (J === w || J === U) && $[K]-- : Y & (o | p) && (J === w || J === U) && $[K]--, J = $[X] = fe, Y = oe, K = X, le > 65535 && X++);
    }
    return $;
  }
  function F(B, $) {
    const Y = [];
    for (let K = 0; K < $.length; K++) {
      const X = $.codePointAt(K);
      X > 65535 && K++, Y.push(n.U.codeToGlyph(B, X));
    }
    const J = B.GSUB;
    if (J) {
      const { lookupList: K, featureList: X } = J;
      let le;
      const oe = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, fe = [];
      X.forEach((de) => {
        if (oe.test(de.tag))
          for (let xe = 0; xe < de.tab.length; xe++) {
            if (fe[de.tab[xe]])
              continue;
            fe[de.tab[xe]] = !0;
            const _e = K[de.tab[xe]], Pe = /^(isol|init|fina|medi)$/.test(de.tag);
            Pe && !le && (le = A($));
            for (let ce = 0; ce < Y.length; ce++)
              (!le || !Pe || L[le[ce]] === de.tag) && n.U._applySubs(Y, ce, _e, K);
          }
      });
    }
    return Y;
  }
  function k(...B) {
    for (let $ = 0; $ < B.length; $++)
      if (typeof B[$] == "number")
        return B[$];
  }
  function H(B) {
    const $ = /* @__PURE__ */ Object.create(null), Y = B["OS/2"], J = B.hhea, K = B.head.unitsPerEm, X = k(Y && Y.sTypoAscender, J && J.ascender, K), le = {
      unitsPerEm: K,
      ascender: X,
      descender: k(Y && Y.sTypoDescender, J && J.descender, 0),
      capHeight: k(Y && Y.sCapHeight, X),
      xHeight: k(Y && Y.sxHeight, X),
      lineGap: k(Y && Y.sTypoLineGap, J && J.lineGap),
      forEachGlyph(oe, fe, de, xe) {
        let _e = 0;
        const Pe = 1 / le.unitsPerEm * fe, ce = F(B, oe);
        let ve = 0, re = -1;
        return ce.forEach((ee, he) => {
          if (ee !== -1) {
            let Me = $[ee];
            if (!Me) {
              const { cmds: Le, crds: Ae } = n.U.glyphToPath(B, ee);
              let Ue = "", Ne = 0;
              for (let ae = 0, et = Le.length; ae < et; ae++) {
                const Ye = t[Le[ae]];
                Ue += Le[ae];
                for (let Ge = 1; Ge <= Ye; Ge++)
                  Ue += (Ge > 1 ? "," : "") + Ae[Ne++];
              }
              let ke, it, At, rt;
              if (Ae.length) {
                ke = it = 1 / 0, At = rt = -1 / 0;
                for (let ae = 0, et = Ae.length; ae < et; ae += 2) {
                  let Ye = Ae[ae], Ge = Ae[ae + 1];
                  Ye < ke && (ke = Ye), Ge < it && (it = Ge), Ye > At && (At = Ye), Ge > rt && (rt = Ge);
                }
              } else
                ke = At = it = rt = 0;
              Me = $[ee] = {
                index: ee,
                advanceWidth: B.hmtx.aWidth[ee],
                xMin: ke,
                yMin: it,
                xMax: At,
                yMax: rt,
                path: Ue,
                pathCommandCount: Le.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            re !== -1 && (_e += n.U.getPairAdjustment(B, re, ee) * Pe), xe.call(null, Me, _e, ve), Me.advanceWidth && (_e += Me.advanceWidth * Pe), de && (_e += de * fe), re = ee;
          }
          ve += oe.codePointAt(ve) > 65535 ? 2 : 1;
        }), _e;
      }
    };
    return le;
  }
  return function($) {
    const Y = new Uint8Array($, 0, 4), J = n._bin.readASCII(Y, 0, 4);
    if (J === "wOFF")
      $ = e($);
    else if (J === "wOF2")
      throw new Error("woff2 fonts not supported");
    return H(n.parse($)[0]);
  };
}
const aQ = /* @__PURE__ */ gw({
  name: "Typr Font Parser",
  dependencies: [nQ, rQ, iQ],
  init(n, e, t) {
    const r = n(), i = e();
    return t(r, i);
  }
}), H1 = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, oQ = /* @__PURE__ */ new Rn();
function L1() {
  return (self.performance || Date).now();
}
const Vk = /* @__PURE__ */ Object.create(null);
function t5(n, e) {
  n = uQ({}, n);
  const t = L1();
  if (n.font = cQ(n.font || H1.defaultFontURL), n.text = "" + n.text, n.sdfGlyphSize = n.sdfGlyphSize || H1.sdfGlyphSize, n.colorRanges != null) {
    let x = {};
    for (let b in n.colorRanges)
      if (n.colorRanges.hasOwnProperty(b)) {
        let w = n.colorRanges[b];
        typeof w != "number" && (w = oQ.set(w).getHex()), x[b] = w;
      }
    n.colorRanges = x;
  }
  Object.freeze(n);
  const { textureWidth: r, sdfExponent: i } = H1, { sdfGlyphSize: o } = n, l = r / o * 4;
  let c = Vk[o];
  if (!c) {
    const x = document.createElement("canvas");
    x.width = r, x.height = o * 256 / l, c = Vk[o] = {
      glyphCount: 0,
      sdfGlyphSize: o,
      sdfCanvas: x,
      sdfTexture: new cs(
        x,
        void 0,
        void 0,
        void 0,
        ss,
        ss
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, sQ(c);
  }
  const { sdfTexture: h, sdfCanvas: p } = c;
  let y = c.glyphsByFont.get(n.font);
  y || c.glyphsByFont.set(n.font, y = /* @__PURE__ */ new Map()), dQ(n).then((x) => {
    const { glyphIds: b, glyphPositions: w, fontSize: R, unitsPerEm: U, timings: L } = x, A = [], F = new Float32Array(b.length * 4), k = R / U;
    let H = 0, B = 0;
    const $ = L1();
    b.forEach((le, oe) => {
      let fe = y.get(le);
      if (!fe) {
        const { path: Pe, pathBounds: ce } = x.glyphData[le], ve = Math.max(ce[2] - ce[0], ce[3] - ce[1]) / o * (H1.sdfMargin * o + 0.5), re = c.glyphCount++, ee = [
          ce[0] - ve,
          ce[1] - ve,
          ce[2] + ve,
          ce[3] + ve
        ];
        y.set(le, fe = { path: Pe, atlasIndex: re, sdfViewBox: ee }), A.push(fe);
      }
      const { sdfViewBox: de } = fe, xe = w[B++], _e = w[B++];
      F[H++] = xe + de[0] * k, F[H++] = _e + de[1] * k, F[H++] = xe + de[2] * k, F[H++] = _e + de[3] * k, b[oe] = fe.atlasIndex;
    }), L.quads = (L.quads || 0) + (L1() - $);
    const Y = L1();
    L.sdf = {};
    const J = p.height, K = Math.ceil(c.glyphCount / l), X = Math.pow(2, Math.ceil(Math.log2(K * o)));
    X > J && (console.info(`Increasing SDF texture size ${J}->${X}`), tQ(p, r, X), h.dispose()), Promise.all(A.map(
      (le) => n5(le, c, n.gpuAccelerateSDF).then(({ timing: oe }) => {
        L.sdf[le.atlasIndex] = oe;
      })
    )).then(() => {
      A.length && !c.contextLost && (r5(c), h.needsUpdate = !0), L.sdfTotal = L1() - Y, L.total = L1() - t, e(Object.freeze({
        parameters: n,
        sdfTexture: h,
        sdfGlyphSize: o,
        sdfExponent: i,
        glyphBounds: F,
        glyphAtlasIndices: b,
        glyphColors: x.glyphColors,
        caretPositions: x.caretPositions,
        caretHeight: x.caretHeight,
        chunkedBounds: x.chunkedBounds,
        ascender: x.ascender,
        descender: x.descender,
        lineHeight: x.lineHeight,
        capHeight: x.capHeight,
        xHeight: x.xHeight,
        topBaseline: x.topBaseline,
        blockBounds: x.blockBounds,
        visibleBounds: x.visibleBounds,
        timings: x.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || eQ(p);
  });
}
function n5({ path: n, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: i, contextLost: o }, l) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: c, sdfExponent: h } = H1, p = Math.max(t[2] - t[0], t[3] - t[1]), y = Math.floor(e / 4), x = y % (c / r) * r, b = Math.floor(y / (c / r)) * r, w = e % 4;
  return XK(r, r, n, t, p, h, i, x, b, w, l);
}
function sQ(n) {
  const e = n.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), n.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), n.contextLost = !1;
    const r = [];
    n.glyphsByFont.forEach((i) => {
      i.forEach((o) => {
        r.push(n5(o, n, !0));
      });
    }), Promise.all(r).then(() => {
      r5(n), n.sdfTexture.needsUpdate = !0;
    });
  });
}
function lQ({ font: n, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e) ? e.join(`
`) : "" + e;
  t5({ font: n, sdfGlyphSize: t, text: i }, r);
}
function uQ(n, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
let eR;
function cQ(n) {
  return eR || (eR = typeof document > "u" ? {} : document.createElement("a")), eR.href = n, eR.href;
}
function r5(n) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = n, { width: r, height: i } = e, o = n.sdfCanvas.getContext("webgl");
    let l = t.image.data;
    (!l || l.length !== r * i * 4) && (l = new Uint8Array(r * i * 4), t.image = { width: r, height: i, data: l }, t.flipY = !1, t.isDataTexture = !0), o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, l);
  }
}
const fQ = /* @__PURE__ */ gw({
  name: "Typesetter",
  dependencies: [
    H1,
    aQ,
    YK,
    IK
  ],
  init(n, e, t, r) {
    const { defaultFontURL: i } = n;
    return t(e, r(), { defaultFontURL: i });
  }
}), dQ = /* @__PURE__ */ gw({
  name: "Typesetter",
  dependencies: [
    fQ
  ],
  init(n) {
    return function(e) {
      return new Promise((t) => {
        n.typeset(e, t);
      });
    };
  },
  getTransferables(n) {
    const e = [
      n.glyphPositions.buffer,
      n.glyphIds.buffer
    ];
    return n.caretPositions && e.push(n.caretPositions.buffer), n.glyphColors && e.push(n.glyphColors.buffer), e;
  }
}), Gk = {};
function hQ(n) {
  let e = Gk[n];
  if (!e) {
    const t = new R0(1, 1, n, n), r = t.clone(), i = t.attributes, o = r.attributes, l = new oi(), c = i.uv.count;
    for (let h = 0; h < c; h++)
      o.position.array[h * 3] *= -1, o.normal.array[h * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((h) => {
      l.setAttribute(
        h,
        new Yn(
          [...i[h].array, ...o[h].array],
          i[h].itemSize
        )
      );
    }), l.setIndex([...t.index.array, ...r.index.array.map((h) => h + c)]), l.translate(0.5, 0.5, 0), e = Gk[n] = l;
  }
  return e;
}
const pQ = "aTroikaGlyphBounds", Wk = "aTroikaGlyphIndex", mQ = "aTroikaGlyphColor";
class vQ extends ZP {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new vp(), this.boundingBox = new mm();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Ic ? t / 2 : 0, e === dp ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = hQ(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, r, i, o) {
    EL(this, pQ, e, 4), EL(this, Wk, t, 1), EL(this, mQ, o, 3), this._blockBounds = r, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: o, min: l, max: c, sin: h, cos: p } = Math, y = i / 2, x = i * 2, b = Math.abs(t), w = e[0] / b, R = e[2] / b, U = o((w + y) / x) !== o((R + y) / x) ? -b : l(h(w) * b, h(R) * b), L = o((w - y) / x) !== o((R - y) / x) ? b : c(h(w) * b, h(R) * b), A = o((w + i) / x) !== o((R + i) / x) ? b * 2 : c(b - p(w) * b, b - p(R) * b);
        r.min.set(U, e[1], t < 0 ? -A : 0), r.max.set(L, e[3], t < 0 ? 0 : A);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(Wk).count, r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function EL(n, e, t, r) {
  const i = n.getAttribute(e);
  t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (n.setAttribute(e, new Sx(t, r)), delete n._maxInstanceCount, n.dispose()) : i && n.deleteAttribute(e);
}
const gQ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, yQ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, SQ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, xQ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function _Q(n) {
  const e = BO(n, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Ht() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new ua(0, 0, 0, 0) },
      uTroikaClipRect: { value: new ua(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Ht() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Rn() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new ii() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: gQ,
    vertexTransform: yQ,
    fragmentDefs: SQ,
    fragmentColorTransform: xQ,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(r) && (r = r.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        JB,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const l3 = /* @__PURE__ */ new Qg({
  color: 16777215,
  side: dp,
  transparent: !0
}), jk = 8421504, $k = /* @__PURE__ */ new Gr(), tR = /* @__PURE__ */ new Te(), bL = /* @__PURE__ */ new Te(), mT = [], EQ = /* @__PURE__ */ new Te(), TL = "+x+y";
function Yk(n) {
  return Array.isArray(n) ? n[0] : n;
}
let i5 = () => {
  const n = new Al(
    new R0(1, 1),
    l3
  );
  return i5 = () => n, n;
}, a5 = () => {
  const n = new Al(
    new R0(1, 1, 32, 1),
    l3
  );
  return a5 = () => n, n;
};
const bQ = { type: "syncstart" }, TQ = { type: "synccomplete" }, o5 = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], wQ = o5.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
let s5 = class extends Al {
  constructor() {
    const e = new vQ();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = jk, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = TL, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(bQ), t5({
      text: this.text,
      font: this.font,
      fontSize: this.fontSize || 0.1,
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((i) => i && i());
      })), this.dispatchEvent(TQ), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, r, i, o, l) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o), o._hadOwnSide = o.hasOwnProperty("side"), this.geometry.setSide(o._actualSide = o.side), o.side = wv;
  }
  onAfterRender(e, t, r, i, o, l) {
    o._hadOwnSide ? o.side = o._actualSide : delete o.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = l3.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = _Q(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function i() {
        e.removeEventListener("dispose", i), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Yk(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Yk(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: c, blockBounds: h } = i;
      r.uTroikaSDFTexture.value = c, r.uTroikaSDFTextureSize.value.set(c.image.width, c.image.height), r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, r.uTroikaSDFExponent.value = i.sdfExponent, r.uTroikaTotalBounds.value.fromArray(h), r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
      let p = 0, y = 0, x = 0, b, w, R, U = 0, L = 0;
      if (t) {
        let { outlineWidth: F, outlineOffsetX: k, outlineOffsetY: H, outlineBlur: B, outlineOpacity: $ } = this;
        p = this._parsePercent(F) || 0, y = Math.max(0, this._parsePercent(B) || 0), b = $, U = this._parsePercent(k) || 0, L = this._parsePercent(H) || 0;
      } else
        x = Math.max(0, this._parsePercent(this.strokeWidth) || 0), x && (R = this.strokeColor, r.uTroikaStrokeColor.value.set(R ?? jk), w = this.strokeOpacity, w == null && (w = 1)), b = this.fillOpacity;
      r.uTroikaDistanceOffset.value = p, r.uTroikaPositionOffset.value.set(U, L), r.uTroikaBlurRadius.value = y, r.uTroikaStrokeWidth.value = x, r.uTroikaStrokeOpacity.value = w, r.uTroikaFillOpacity.value = b ?? 1, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let A = this.clipRect;
      if (A && Array.isArray(A) && A.length === 4)
        r.uTroikaClipRect.value.fromArray(A);
      else {
        const F = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          h[0] - F,
          h[1] - F,
          h[2] + F,
          h[3] + F
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const o = t ? this.outlineColor || 0 : this.color;
    if (o == null)
      delete e.color;
    else {
      const c = e.hasOwnProperty("color") ? e.color : e.color = new Rn();
      (o !== c._input || typeof o == "object") && c.set(c._input = o);
    }
    let l = this.orientation || TL;
    if (l !== e._orientation) {
      let c = r.uTroikaOrient.value;
      l = l.replace(/[^-+xyz]/g, "");
      let h = l !== TL && l.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (h) {
        let [, p, y, x, b] = h;
        tR.set(0, 0, 0)[y] = p === "-" ? 1 : -1, bL.set(0, 0, 0)[b] = x === "-" ? -1 : 1, $k.lookAt(EQ, tR.cross(bL), bL), c.setFromMatrix4($k);
      } else
        c.identity();
      e._orientation = l;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new Ht()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new Ht()) {
    return tR.copy(e), this.localPositionToTextCoords(this.worldToLocal(tR), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds, l = i ? a5() : i5(), c = l.geometry, { position: h, uv: p } = c.attributes;
      for (let y = 0; y < p.count; y++) {
        let x = o[0] + p.getX(y) * (o[2] - o[0]);
        const b = o[1] + p.getY(y) * (o[3] - o[1]);
        let w = 0;
        i && (w = i - Math.cos(x / i) * i, x = Math.sin(x / i) * i), h.setXYZ(y, x, b, w);
      }
      c.boundingSphere = this.geometry.boundingSphere, c.boundingBox = this.geometry.boundingBox, l.matrixWorld = this.matrixWorld, l.material.side = this.material.side, mT.length = 0, l.raycast(e, mT);
      for (let y = 0; y < mT.length; y++)
        mT[y].object = this, t.push(mT[y]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, wQ.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
o5.forEach((n) => {
  const e = "_private_" + n;
  Object.defineProperty(s5.prototype, n, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const wL = /* @__PURE__ */ Cn.forwardRef(({
  sdfGlyphSize: n = 64,
  anchorX: e = "center",
  anchorY: t = "middle",
  font: r,
  fontSize: i = 1,
  children: o,
  characters: l,
  onSync: c,
  ...h
}, p) => {
  const y = cm(({
    invalidate: R
  }) => R), [x] = Cn.useState(() => new s5()), [b, w] = Cn.useMemo(() => {
    const R = [];
    let U = "";
    return Cn.Children.forEach(o, (L) => {
      typeof L == "string" || typeof L == "number" ? U += L : R.push(L);
    }), [R, U];
  }, [o]);
  return jX(() => new Promise((R) => lQ({
    font: r,
    characters: l
  }, R)), ["troika-text", r, l]), Cn.useLayoutEffect(() => void x.sync(() => {
    y(), c && c(x);
  })), Cn.useEffect(() => () => x.dispose(), [x]), /* @__PURE__ */ Cn.createElement("primitive", fs({
    object: x,
    ref: p,
    font: r,
    text: w,
    anchorX: e,
    anchorY: t,
    fontSize: i,
    sdfGlyphSize: n
  }, h), b);
}), MQ = /* @__PURE__ */ Cn.forwardRef(({
  makeDefault: n,
  camera: e,
  regress: t,
  domElement: r,
  enableDamping: i = !0,
  keyEvents: o = !1,
  onChange: l,
  onStart: c,
  onEnd: h,
  ...p
}, y) => {
  const x = cm(($) => $.invalidate), b = cm(($) => $.camera), w = cm(($) => $.gl), R = cm(($) => $.events), U = cm(($) => $.setEvents), L = cm(($) => $.set), A = cm(($) => $.get), F = cm(($) => $.performance), k = e || b, H = r || R.connected || w.domElement, B = Cn.useMemo(() => new OK(k), [k]);
  return a3(() => {
    B.enabled && B.update();
  }, -1), Cn.useEffect(() => (o && B.connect(o === !0 ? H : o), B.connect(H), () => void B.dispose()), [o, H, t, B, x]), Cn.useEffect(() => {
    const $ = (K) => {
      x(), t && F.regress(), l && l(K);
    }, Y = (K) => {
      c && c(K);
    }, J = (K) => {
      h && h(K);
    };
    return B.addEventListener("change", $), B.addEventListener("start", Y), B.addEventListener("end", J), () => {
      B.removeEventListener("start", Y), B.removeEventListener("end", J), B.removeEventListener("change", $);
    };
  }, [l, c, h, B, x, U]), Cn.useEffect(() => {
    if (n) {
      const $ = A().controls;
      return L({
        controls: B
      }), () => L({
        controls: $
      });
    }
  }, [n, B]), /* @__PURE__ */ Cn.createElement("primitive", fs({
    ref: y,
    object: B,
    enableDamping: i
  }, p));
});
var VO = { exports: {} }, nR = { exports: {} }, ya = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xk;
function CQ() {
  if (Xk)
    return ya;
  Xk = 1;
  var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110, h = n ? Symbol.for("react.async_mode") : 60111, p = n ? Symbol.for("react.concurrent_mode") : 60111, y = n ? Symbol.for("react.forward_ref") : 60112, x = n ? Symbol.for("react.suspense") : 60113, b = n ? Symbol.for("react.suspense_list") : 60120, w = n ? Symbol.for("react.memo") : 60115, R = n ? Symbol.for("react.lazy") : 60116, U = n ? Symbol.for("react.block") : 60121, L = n ? Symbol.for("react.fundamental") : 60117, A = n ? Symbol.for("react.responder") : 60118, F = n ? Symbol.for("react.scope") : 60119;
  function k(B) {
    if (typeof B == "object" && B !== null) {
      var $ = B.$$typeof;
      switch ($) {
        case e:
          switch (B = B.type, B) {
            case h:
            case p:
            case r:
            case o:
            case i:
            case x:
              return B;
            default:
              switch (B = B && B.$$typeof, B) {
                case c:
                case y:
                case R:
                case w:
                case l:
                  return B;
                default:
                  return $;
              }
          }
        case t:
          return $;
      }
    }
  }
  function H(B) {
    return k(B) === p;
  }
  return ya.AsyncMode = h, ya.ConcurrentMode = p, ya.ContextConsumer = c, ya.ContextProvider = l, ya.Element = e, ya.ForwardRef = y, ya.Fragment = r, ya.Lazy = R, ya.Memo = w, ya.Portal = t, ya.Profiler = o, ya.StrictMode = i, ya.Suspense = x, ya.isAsyncMode = function(B) {
    return H(B) || k(B) === h;
  }, ya.isConcurrentMode = H, ya.isContextConsumer = function(B) {
    return k(B) === c;
  }, ya.isContextProvider = function(B) {
    return k(B) === l;
  }, ya.isElement = function(B) {
    return typeof B == "object" && B !== null && B.$$typeof === e;
  }, ya.isForwardRef = function(B) {
    return k(B) === y;
  }, ya.isFragment = function(B) {
    return k(B) === r;
  }, ya.isLazy = function(B) {
    return k(B) === R;
  }, ya.isMemo = function(B) {
    return k(B) === w;
  }, ya.isPortal = function(B) {
    return k(B) === t;
  }, ya.isProfiler = function(B) {
    return k(B) === o;
  }, ya.isStrictMode = function(B) {
    return k(B) === i;
  }, ya.isSuspense = function(B) {
    return k(B) === x;
  }, ya.isValidElementType = function(B) {
    return typeof B == "string" || typeof B == "function" || B === r || B === p || B === o || B === i || B === x || B === b || typeof B == "object" && B !== null && (B.$$typeof === R || B.$$typeof === w || B.$$typeof === l || B.$$typeof === c || B.$$typeof === y || B.$$typeof === L || B.$$typeof === A || B.$$typeof === F || B.$$typeof === U);
  }, ya.typeOf = k, ya;
}
var Sa = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qk;
function RQ() {
  return qk || (qk = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110, h = n ? Symbol.for("react.async_mode") : 60111, p = n ? Symbol.for("react.concurrent_mode") : 60111, y = n ? Symbol.for("react.forward_ref") : 60112, x = n ? Symbol.for("react.suspense") : 60113, b = n ? Symbol.for("react.suspense_list") : 60120, w = n ? Symbol.for("react.memo") : 60115, R = n ? Symbol.for("react.lazy") : 60116, U = n ? Symbol.for("react.block") : 60121, L = n ? Symbol.for("react.fundamental") : 60117, A = n ? Symbol.for("react.responder") : 60118, F = n ? Symbol.for("react.scope") : 60119;
    function k(ae) {
      return typeof ae == "string" || typeof ae == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ae === r || ae === p || ae === o || ae === i || ae === x || ae === b || typeof ae == "object" && ae !== null && (ae.$$typeof === R || ae.$$typeof === w || ae.$$typeof === l || ae.$$typeof === c || ae.$$typeof === y || ae.$$typeof === L || ae.$$typeof === A || ae.$$typeof === F || ae.$$typeof === U);
    }
    function H(ae) {
      if (typeof ae == "object" && ae !== null) {
        var et = ae.$$typeof;
        switch (et) {
          case e:
            var Ye = ae.type;
            switch (Ye) {
              case h:
              case p:
              case r:
              case o:
              case i:
              case x:
                return Ye;
              default:
                var Ge = Ye && Ye.$$typeof;
                switch (Ge) {
                  case c:
                  case y:
                  case R:
                  case w:
                  case l:
                    return Ge;
                  default:
                    return et;
                }
            }
          case t:
            return et;
        }
      }
    }
    var B = h, $ = p, Y = c, J = l, K = e, X = y, le = r, oe = R, fe = w, de = t, xe = o, _e = i, Pe = x, ce = !1;
    function ve(ae) {
      return ce || (ce = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), re(ae) || H(ae) === h;
    }
    function re(ae) {
      return H(ae) === p;
    }
    function ee(ae) {
      return H(ae) === c;
    }
    function he(ae) {
      return H(ae) === l;
    }
    function Me(ae) {
      return typeof ae == "object" && ae !== null && ae.$$typeof === e;
    }
    function Le(ae) {
      return H(ae) === y;
    }
    function Ae(ae) {
      return H(ae) === r;
    }
    function Ue(ae) {
      return H(ae) === R;
    }
    function Ne(ae) {
      return H(ae) === w;
    }
    function ke(ae) {
      return H(ae) === t;
    }
    function it(ae) {
      return H(ae) === o;
    }
    function At(ae) {
      return H(ae) === i;
    }
    function rt(ae) {
      return H(ae) === x;
    }
    Sa.AsyncMode = B, Sa.ConcurrentMode = $, Sa.ContextConsumer = Y, Sa.ContextProvider = J, Sa.Element = K, Sa.ForwardRef = X, Sa.Fragment = le, Sa.Lazy = oe, Sa.Memo = fe, Sa.Portal = de, Sa.Profiler = xe, Sa.StrictMode = _e, Sa.Suspense = Pe, Sa.isAsyncMode = ve, Sa.isConcurrentMode = re, Sa.isContextConsumer = ee, Sa.isContextProvider = he, Sa.isElement = Me, Sa.isForwardRef = Le, Sa.isFragment = Ae, Sa.isLazy = Ue, Sa.isMemo = Ne, Sa.isPortal = ke, Sa.isProfiler = it, Sa.isStrictMode = At, Sa.isSuspense = rt, Sa.isValidElementType = k, Sa.typeOf = H;
  }()), Sa;
}
var Kk;
function l5() {
  return Kk || (Kk = 1, process.env.NODE_ENV === "production" ? nR.exports = CQ() : nR.exports = RQ()), nR.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ML, Qk;
function AQ() {
  if (Qk)
    return ML;
  Qk = 1;
  var n = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var l = {}, c = 0; c < 10; c++)
        l["_" + String.fromCharCode(c)] = c;
      var h = Object.getOwnPropertyNames(l).map(function(y) {
        return l[y];
      });
      if (h.join("") !== "0123456789")
        return !1;
      var p = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(y) {
        p[y] = y;
      }), Object.keys(Object.assign({}, p)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ML = i() ? Object.assign : function(o, l) {
    for (var c, h = r(o), p, y = 1; y < arguments.length; y++) {
      c = Object(arguments[y]);
      for (var x in c)
        e.call(c, x) && (h[x] = c[x]);
      if (n) {
        p = n(c);
        for (var b = 0; b < p.length; b++)
          t.call(c, p[b]) && (h[p[b]] = c[p[b]]);
      }
    }
    return h;
  }, ML;
}
var CL, Zk;
function u3() {
  if (Zk)
    return CL;
  Zk = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return CL = n, CL;
}
var RL, Jk;
function u5() {
  return Jk || (Jk = 1, RL = Function.call.bind(Object.prototype.hasOwnProperty)), RL;
}
var AL, ez;
function DQ() {
  if (ez)
    return AL;
  ez = 1;
  var n = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = u3(), t = {}, r = u5();
    n = function(o) {
      var l = "Warning: " + o;
      typeof console < "u" && console.error(l);
      try {
        throw new Error(l);
      } catch {
      }
    };
  }
  function i(o, l, c, h, p) {
    if (process.env.NODE_ENV !== "production") {
      for (var y in o)
        if (r(o, y)) {
          var x;
          try {
            if (typeof o[y] != "function") {
              var b = Error(
                (h || "React class") + ": " + c + " type `" + y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw b.name = "Invariant Violation", b;
            }
            x = o[y](l, y, h, c, null, e);
          } catch (R) {
            x = R;
          }
          if (x && !(x instanceof Error) && n(
            (h || "React class") + ": type specification of " + c + " `" + y + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof x + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), x instanceof Error && !(x.message in t)) {
            t[x.message] = !0;
            var w = p ? p() : "";
            n(
              "Failed " + c + " type: " + x.message + (w ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, AL = i, AL;
}
var DL, tz;
function LQ() {
  if (tz)
    return DL;
  tz = 1;
  var n = l5(), e = AQ(), t = u3(), r = u5(), i = DQ(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(c) {
    var h = "Warning: " + c;
    typeof console < "u" && console.error(h);
    try {
      throw new Error(h);
    } catch {
    }
  });
  function l() {
    return null;
  }
  return DL = function(c, h) {
    var p = typeof Symbol == "function" && Symbol.iterator, y = "@@iterator";
    function x(re) {
      var ee = re && (p && re[p] || re[y]);
      if (typeof ee == "function")
        return ee;
    }
    var b = "<<anonymous>>", w = {
      array: A("array"),
      bigint: A("bigint"),
      bool: A("boolean"),
      func: A("function"),
      number: A("number"),
      object: A("object"),
      string: A("string"),
      symbol: A("symbol"),
      any: F(),
      arrayOf: k,
      element: H(),
      elementType: B(),
      instanceOf: $,
      node: X(),
      objectOf: J,
      oneOf: Y,
      oneOfType: K,
      shape: oe,
      exact: fe
    };
    function R(re, ee) {
      return re === ee ? re !== 0 || 1 / re === 1 / ee : re !== re && ee !== ee;
    }
    function U(re, ee) {
      this.message = re, this.data = ee && typeof ee == "object" ? ee : {}, this.stack = "";
    }
    U.prototype = Error.prototype;
    function L(re) {
      if (process.env.NODE_ENV !== "production")
        var ee = {}, he = 0;
      function Me(Ae, Ue, Ne, ke, it, At, rt) {
        if (ke = ke || b, At = At || Ne, rt !== t) {
          if (h) {
            var ae = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw ae.name = "Invariant Violation", ae;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var et = ke + ":" + Ne;
            !ee[et] && // Avoid spamming the console because they are often not actionable except for lib authors
            he < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + At + "` prop on `" + ke + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), ee[et] = !0, he++);
          }
        }
        return Ue[Ne] == null ? Ae ? Ue[Ne] === null ? new U("The " + it + " `" + At + "` is marked as required " + ("in `" + ke + "`, but its value is `null`.")) : new U("The " + it + " `" + At + "` is marked as required in " + ("`" + ke + "`, but its value is `undefined`.")) : null : re(Ue, Ne, ke, it, At);
      }
      var Le = Me.bind(null, !1);
      return Le.isRequired = Me.bind(null, !0), Le;
    }
    function A(re) {
      function ee(he, Me, Le, Ae, Ue, Ne) {
        var ke = he[Me], it = _e(ke);
        if (it !== re) {
          var At = Pe(ke);
          return new U(
            "Invalid " + Ae + " `" + Ue + "` of type " + ("`" + At + "` supplied to `" + Le + "`, expected ") + ("`" + re + "`."),
            { expectedType: re }
          );
        }
        return null;
      }
      return L(ee);
    }
    function F() {
      return L(l);
    }
    function k(re) {
      function ee(he, Me, Le, Ae, Ue) {
        if (typeof re != "function")
          return new U("Property `" + Ue + "` of component `" + Le + "` has invalid PropType notation inside arrayOf.");
        var Ne = he[Me];
        if (!Array.isArray(Ne)) {
          var ke = _e(Ne);
          return new U("Invalid " + Ae + " `" + Ue + "` of type " + ("`" + ke + "` supplied to `" + Le + "`, expected an array."));
        }
        for (var it = 0; it < Ne.length; it++) {
          var At = re(Ne, it, Le, Ae, Ue + "[" + it + "]", t);
          if (At instanceof Error)
            return At;
        }
        return null;
      }
      return L(ee);
    }
    function H() {
      function re(ee, he, Me, Le, Ae) {
        var Ue = ee[he];
        if (!c(Ue)) {
          var Ne = _e(Ue);
          return new U("Invalid " + Le + " `" + Ae + "` of type " + ("`" + Ne + "` supplied to `" + Me + "`, expected a single ReactElement."));
        }
        return null;
      }
      return L(re);
    }
    function B() {
      function re(ee, he, Me, Le, Ae) {
        var Ue = ee[he];
        if (!n.isValidElementType(Ue)) {
          var Ne = _e(Ue);
          return new U("Invalid " + Le + " `" + Ae + "` of type " + ("`" + Ne + "` supplied to `" + Me + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return L(re);
    }
    function $(re) {
      function ee(he, Me, Le, Ae, Ue) {
        if (!(he[Me] instanceof re)) {
          var Ne = re.name || b, ke = ve(he[Me]);
          return new U("Invalid " + Ae + " `" + Ue + "` of type " + ("`" + ke + "` supplied to `" + Le + "`, expected ") + ("instance of `" + Ne + "`."));
        }
        return null;
      }
      return L(ee);
    }
    function Y(re) {
      if (!Array.isArray(re))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), l;
      function ee(he, Me, Le, Ae, Ue) {
        for (var Ne = he[Me], ke = 0; ke < re.length; ke++)
          if (R(Ne, re[ke]))
            return null;
        var it = JSON.stringify(re, function(rt, ae) {
          var et = Pe(ae);
          return et === "symbol" ? String(ae) : ae;
        });
        return new U("Invalid " + Ae + " `" + Ue + "` of value `" + String(Ne) + "` " + ("supplied to `" + Le + "`, expected one of " + it + "."));
      }
      return L(ee);
    }
    function J(re) {
      function ee(he, Me, Le, Ae, Ue) {
        if (typeof re != "function")
          return new U("Property `" + Ue + "` of component `" + Le + "` has invalid PropType notation inside objectOf.");
        var Ne = he[Me], ke = _e(Ne);
        if (ke !== "object")
          return new U("Invalid " + Ae + " `" + Ue + "` of type " + ("`" + ke + "` supplied to `" + Le + "`, expected an object."));
        for (var it in Ne)
          if (r(Ne, it)) {
            var At = re(Ne, it, Le, Ae, Ue + "." + it, t);
            if (At instanceof Error)
              return At;
          }
        return null;
      }
      return L(ee);
    }
    function K(re) {
      if (!Array.isArray(re))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), l;
      for (var ee = 0; ee < re.length; ee++) {
        var he = re[ee];
        if (typeof he != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ce(he) + " at index " + ee + "."
          ), l;
      }
      function Me(Le, Ae, Ue, Ne, ke) {
        for (var it = [], At = 0; At < re.length; At++) {
          var rt = re[At], ae = rt(Le, Ae, Ue, Ne, ke, t);
          if (ae == null)
            return null;
          ae.data && r(ae.data, "expectedType") && it.push(ae.data.expectedType);
        }
        var et = it.length > 0 ? ", expected one of type [" + it.join(", ") + "]" : "";
        return new U("Invalid " + Ne + " `" + ke + "` supplied to " + ("`" + Ue + "`" + et + "."));
      }
      return L(Me);
    }
    function X() {
      function re(ee, he, Me, Le, Ae) {
        return de(ee[he]) ? null : new U("Invalid " + Le + " `" + Ae + "` supplied to " + ("`" + Me + "`, expected a ReactNode."));
      }
      return L(re);
    }
    function le(re, ee, he, Me, Le) {
      return new U(
        (re || "React class") + ": " + ee + " type `" + he + "." + Me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Le + "`."
      );
    }
    function oe(re) {
      function ee(he, Me, Le, Ae, Ue) {
        var Ne = he[Me], ke = _e(Ne);
        if (ke !== "object")
          return new U("Invalid " + Ae + " `" + Ue + "` of type `" + ke + "` " + ("supplied to `" + Le + "`, expected `object`."));
        for (var it in re) {
          var At = re[it];
          if (typeof At != "function")
            return le(Le, Ae, Ue, it, Pe(At));
          var rt = At(Ne, it, Le, Ae, Ue + "." + it, t);
          if (rt)
            return rt;
        }
        return null;
      }
      return L(ee);
    }
    function fe(re) {
      function ee(he, Me, Le, Ae, Ue) {
        var Ne = he[Me], ke = _e(Ne);
        if (ke !== "object")
          return new U("Invalid " + Ae + " `" + Ue + "` of type `" + ke + "` " + ("supplied to `" + Le + "`, expected `object`."));
        var it = e({}, he[Me], re);
        for (var At in it) {
          var rt = re[At];
          if (r(re, At) && typeof rt != "function")
            return le(Le, Ae, Ue, At, Pe(rt));
          if (!rt)
            return new U(
              "Invalid " + Ae + " `" + Ue + "` key `" + At + "` supplied to `" + Le + "`.\nBad object: " + JSON.stringify(he[Me], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(re), null, "  ")
            );
          var ae = rt(Ne, At, Le, Ae, Ue + "." + At, t);
          if (ae)
            return ae;
        }
        return null;
      }
      return L(ee);
    }
    function de(re) {
      switch (typeof re) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !re;
        case "object":
          if (Array.isArray(re))
            return re.every(de);
          if (re === null || c(re))
            return !0;
          var ee = x(re);
          if (ee) {
            var he = ee.call(re), Me;
            if (ee !== re.entries) {
              for (; !(Me = he.next()).done; )
                if (!de(Me.value))
                  return !1;
            } else
              for (; !(Me = he.next()).done; ) {
                var Le = Me.value;
                if (Le && !de(Le[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function xe(re, ee) {
      return re === "symbol" ? !0 : ee ? ee["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && ee instanceof Symbol : !1;
    }
    function _e(re) {
      var ee = typeof re;
      return Array.isArray(re) ? "array" : re instanceof RegExp ? "object" : xe(ee, re) ? "symbol" : ee;
    }
    function Pe(re) {
      if (typeof re > "u" || re === null)
        return "" + re;
      var ee = _e(re);
      if (ee === "object") {
        if (re instanceof Date)
          return "date";
        if (re instanceof RegExp)
          return "regexp";
      }
      return ee;
    }
    function ce(re) {
      var ee = Pe(re);
      switch (ee) {
        case "array":
        case "object":
          return "an " + ee;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + ee;
        default:
          return ee;
      }
    }
    function ve(re) {
      return !re.constructor || !re.constructor.name ? b : re.constructor.name;
    }
    return w.checkPropTypes = i, w.resetWarningCache = i.resetWarningCache, w.PropTypes = w, w;
  }, DL;
}
var LL, nz;
function OQ() {
  if (nz)
    return LL;
  nz = 1;
  var n = u3();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, LL = function() {
    function r(l, c, h, p, y, x) {
      if (x !== n) {
        var b = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw b.name = "Invariant Violation", b;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return o.PropTypes = o, o;
  }, LL;
}
if (process.env.NODE_ENV !== "production") {
  var PQ = l5(), UQ = !0;
  VO.exports = LQ()(PQ.isElement, UQ);
} else
  VO.exports = OQ()();
var NQ = VO.exports;
const vo = /* @__PURE__ */ rw(NQ);
function FQ(n, e) {
  typeof n == "function" ? n(e) : n != null && (n.current = e);
}
function c5(...n) {
  return (e) => n.forEach(
    (t) => FQ(t, e)
  );
}
function aE(...n) {
  return Ir(c5(...n), n);
}
const f5 = /* @__PURE__ */ Cu((n, e) => {
  const { children: t, ...r } = n, i = G1.toArray(t), o = i.find(kQ);
  if (o) {
    const l = o.props.children, c = i.map((h) => h === o ? G1.count(l) > 1 ? G1.only(null) : /* @__PURE__ */ ER(l) ? l.props.children : null : h);
    return /* @__PURE__ */ ca(GO, fs({}, r, {
      ref: e
    }), /* @__PURE__ */ ER(l) ? /* @__PURE__ */ hP(l, void 0, c) : null);
  }
  return /* @__PURE__ */ ca(GO, fs({}, r, {
    ref: e
  }), t);
});
f5.displayName = "Slot";
const GO = /* @__PURE__ */ Cu((n, e) => {
  const { children: t, ...r } = n;
  return /* @__PURE__ */ ER(t) ? /* @__PURE__ */ hP(t, {
    ...zQ(r, t.props),
    ref: e ? c5(e, t.ref) : t.ref
  }) : G1.count(t) > 1 ? G1.only(null) : null;
});
GO.displayName = "SlotClone";
const d5 = ({ children: n }) => /* @__PURE__ */ ca(yI, null, n);
function kQ(n) {
  return /* @__PURE__ */ ER(n) && n.type === d5;
}
function zQ(n, e) {
  const t = {
    ...e
  };
  for (const r in e) {
    const i = n[r], o = e[r];
    /^on[A-Z]/.test(r) ? i && o ? t[r] = (...c) => {
      o(...c), i(...c);
    } : i && (t[r] = i) : r === "style" ? t[r] = {
      ...i,
      ...o
    } : r === "className" && (t[r] = [
      i,
      o
    ].filter(Boolean).join(" "));
  }
  return {
    ...n,
    ...t
  };
}
const IQ = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Ax = IQ.reduce((n, e) => {
  const t = /* @__PURE__ */ Cu((r, i) => {
    const { asChild: o, ...l } = r, c = o ? f5 : e;
    return tr(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ ca(c, fs({}, l, {
      ref: i
    }));
  });
  return t.displayName = `Primitive.${e}`, {
    ...n,
    [e]: t
  };
}, {});
function BQ(n, e) {
  n && b2.flushSync(
    () => n.dispatchEvent(e)
  );
}
const HQ = /* @__PURE__ */ Cu((n, e) => {
  var t;
  const { container: r = globalThis == null || (t = globalThis.document) === null || t === void 0 ? void 0 : t.body, ...i } = n;
  return r ? /* @__PURE__ */ GB.createPortal(/* @__PURE__ */ ca(Ax.div, fs({}, i, {
    ref: e
  })), r) : null;
}), VQ = HQ;
var rz = Object.prototype.hasOwnProperty;
function ZT(n, e) {
  var t, r;
  if (n === e)
    return !0;
  if (n && e && (t = n.constructor) === e.constructor) {
    if (t === Date)
      return n.getTime() === e.getTime();
    if (t === RegExp)
      return n.toString() === e.toString();
    if (t === Array) {
      if ((r = n.length) === e.length)
        for (; r-- && ZT(n[r], e[r]); )
          ;
      return r === -1;
    }
    if (!t || typeof n == "object") {
      r = 0;
      for (t in n)
        if (rz.call(n, t) && ++r && !rz.call(e, t) || !(t in e) || !ZT(n[t], e[t]))
          return !1;
      return Object.keys(e).length === r;
    }
  }
  return n !== n && e !== e;
}
var M2 = function(e, t, r, i) {
  this.name = e, this.fn = t, this.args = r, this.modifiers = i;
};
M2.prototype._test = function(e) {
  var t = this.fn;
  try {
    $1(this.modifiers.slice(), t, this)(e);
  } catch {
    t = function() {
      return !1;
    };
  }
  try {
    return $1(this.modifiers.slice(), t, this)(e);
  } catch {
    return !1;
  }
};
M2.prototype._check = function(e) {
  try {
    $1(this.modifiers.slice(), this.fn, this)(e);
  } catch {
    if ($1(this.modifiers.slice(), function(r) {
      return r;
    }, this)(!1))
      return;
  }
  if (!$1(this.modifiers.slice(), this.fn, this)(e))
    throw null;
};
M2.prototype._testAsync = function(e) {
  var t = this;
  return new Promise(function(r, i) {
    p5(
      t.modifiers.slice(),
      t.fn,
      t
    )(e).then(function(o) {
      o ? r(e) : i(null);
    }).catch(function(o) {
      return i(o);
    });
  });
};
function h5(n, e) {
  return e === void 0 && (e = "simple"), typeof n == "object" ? n[e] : n;
}
function $1(n, e, t) {
  if (n.length) {
    var r = n.shift(), i = $1(n, e, t);
    return r.perform(i, t);
  } else
    return h5(e);
}
function p5(n, e, t) {
  if (n.length) {
    var r = n.shift(), i = p5(n, e, t);
    return r.performAsync(i, t);
  } else
    return function(o) {
      return Promise.resolve(h5(e, "async")(o));
    };
}
var GQ = function(e, t, r) {
  this.name = e, this.perform = t, this.performAsync = r;
}, c3 = /* @__PURE__ */ function(n) {
  function e(t, r, i, o) {
    for (var l = [], c = arguments.length - 4; c-- > 0; )
      l[c] = arguments[c + 4];
    n.call(this, l), n.captureStackTrace && n.captureStackTrace(this, e), this.rule = t, this.value = r, this.cause = i, this.target = o;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e;
}(Error), Cv = function(e, t) {
  e === void 0 && (e = []), t === void 0 && (t = []), this.chain = e, this.nextRuleModifiers = t;
};
Cv.prototype._applyRule = function(e, t) {
  var r = this;
  return function() {
    for (var i = [], o = arguments.length; o--; )
      i[o] = arguments[o];
    return r.chain.push(
      new M2(t, e.apply(r, i), i, r.nextRuleModifiers)
    ), r.nextRuleModifiers = [], r;
  };
};
Cv.prototype._applyModifier = function(e, t) {
  return this.nextRuleModifiers.push(
    new GQ(t, e.simple, e.async)
  ), this;
};
Cv.prototype._clone = function() {
  return new Cv(this.chain.slice(), this.nextRuleModifiers.slice());
};
Cv.prototype.test = function(e) {
  return this.chain.every(function(t) {
    return t._test(e);
  });
};
Cv.prototype.testAll = function(e) {
  var t = [];
  return this.chain.forEach(function(r) {
    try {
      r._check(e);
    } catch (i) {
      t.push(new c3(r, e, i));
    }
  }), t;
};
Cv.prototype.check = function(e) {
  this.chain.forEach(function(t) {
    try {
      t._check(e);
    } catch (r) {
      throw new c3(t, e, r);
    }
  });
};
Cv.prototype.testAsync = function(e) {
  var t = this;
  return new Promise(function(r, i) {
    m5(e, t.chain.slice(), r, i);
  });
};
function m5(n, e, t, r) {
  if (e.length) {
    var i = e.shift();
    i._testAsync(n).then(
      function() {
        m5(n, e, t, r);
      },
      function(o) {
        r(new c3(i, n, o));
      }
    );
  } else
    t(n);
}
var iz = function(n, e) {
  return e && typeof n == "string" && n.trim().length === 0 ? !0 : n == null;
};
function WQ(n, e) {
  return e === void 0 && (e = !1), {
    simple: function(t) {
      return iz(t, e) || n.check(t) === void 0;
    },
    async: function(t) {
      return iz(t, e) || n.testAsync(t);
    }
  };
}
function Md() {
  return typeof Proxy < "u" ? v5(new Cv()) : WO(new Cv());
}
var JT = {};
Md.extend = function(n) {
  Object.assign(JT, n);
};
Md.clearCustomRules = function() {
  JT = {};
};
function v5(n) {
  return new Proxy(n, {
    get: function(t, r) {
      if (r in t)
        return t[r];
      var i = v5(n._clone());
      if (r in LR)
        return i._applyModifier(LR[r], r);
      if (r in JT)
        return i._applyRule(JT[r], r);
      if (r in jO)
        return i._applyRule(jO[r], r);
    }
  });
}
function WO(n) {
  var e = function(i, o) {
    return Object.keys(i).forEach(function(l) {
      o[l] = function() {
        for (var c = [], h = arguments.length; h--; )
          c[h] = arguments[h];
        var p = WO(o._clone()), y = p._applyRule(
          i[l],
          l
        ).apply(void 0, c);
        return y;
      };
    }), o;
  }, t = e(jO, n), r = e(
    JT,
    t
  );
  return Object.keys(LR).forEach(function(i) {
    Object.defineProperty(r, i, {
      get: function() {
        var o = WO(r._clone());
        return o._applyModifier(LR[i], i);
      }
    });
  }), r;
}
var LR = {
  not: {
    simple: function(n) {
      return function(e) {
        return !n(e);
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.resolve(n(e)).then(function(t) {
          return !t;
        }).catch(function() {
          return !0;
        });
      };
    }
  },
  some: {
    simple: function(n) {
      return function(e) {
        return rR(e).some(function(t) {
          try {
            return n(t);
          } catch {
            return !1;
          }
        });
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.all(
          rR(e).map(function(t) {
            try {
              return n(t).catch(function() {
                return !1;
              });
            } catch {
              return !1;
            }
          })
        ).then(function(t) {
          return t.some(Boolean);
        });
      };
    }
  },
  every: {
    simple: function(n) {
      return function(e) {
        return e !== !1 && rR(e).every(n);
      };
    },
    async: function(n) {
      return function(e) {
        return Promise.all(rR(e).map(n)).then(function(t) {
          return t.every(Boolean);
        });
      };
    }
  },
  strict: {
    simple: function(n, e) {
      return function(t) {
        return az(e) && t && typeof t == "object" ? Object.keys(e.args[0]).length === Object.keys(t).length && n(t) : n(t);
      };
    },
    async: function(n, e) {
      return function(t) {
        return Promise.resolve(n(t)).then(function(r) {
          return az(e) && t && typeof t == "object" ? Object.keys(e.args[0]).length === Object.keys(t).length && r : r;
        }).catch(function() {
          return !1;
        });
      };
    }
  }
};
function az(n) {
  return n && n.name === "schema" && n.args.length > 0 && typeof n.args[0] == "object";
}
function rR(n) {
  return typeof n == "string" ? n.split("") : n;
}
var jO = {
  // Value
  equal: function(n) {
    return function(e) {
      return e == n;
    };
  },
  exact: function(n) {
    return function(e) {
      return e === n;
    };
  },
  // Types
  number: function(n) {
    return n === void 0 && (n = !0), function(e) {
      return typeof e == "number" && (n || isFinite(e));
    };
  },
  integer: function() {
    return function(n) {
      var e = Number.isInteger || jQ;
      return e(n);
    };
  },
  numeric: function() {
    return function(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    };
  },
  string: function() {
    return O1("string");
  },
  boolean: function() {
    return O1("boolean");
  },
  undefined: function() {
    return O1("undefined");
  },
  null: function() {
    return O1("null");
  },
  array: function() {
    return O1("array");
  },
  object: function() {
    return O1("object");
  },
  instanceOf: function(n) {
    return function(e) {
      return e instanceof n;
    };
  },
  // Pattern
  pattern: function(n) {
    return function(e) {
      return n.test(e);
    };
  },
  lowercase: function() {
    return function(n) {
      return typeof n == "boolean" || n === n.toLowerCase() && n.trim() !== "";
    };
  },
  uppercase: function() {
    return function(n) {
      return n === n.toUpperCase() && n.trim() !== "";
    };
  },
  vowel: function() {
    return function(n) {
      return /^[aeiou]+$/i.test(n);
    };
  },
  consonant: function() {
    return function(n) {
      return /^(?=[^aeiou])([a-z]+)$/i.test(n);
    };
  },
  // Value at
  first: function(n) {
    return function(e) {
      return e[0] == n;
    };
  },
  last: function(n) {
    return function(e) {
      return e[e.length - 1] == n;
    };
  },
  // Length
  empty: function() {
    return function(n) {
      return n.length === 0;
    };
  },
  length: function(n, e) {
    return function(t) {
      return t.length >= n && t.length <= (e || n);
    };
  },
  minLength: function(n) {
    return function(e) {
      return e.length >= n;
    };
  },
  maxLength: function(n) {
    return function(e) {
      return e.length <= n;
    };
  },
  // Range
  negative: function() {
    return function(n) {
      return n < 0;
    };
  },
  positive: function() {
    return function(n) {
      return n >= 0;
    };
  },
  between: function(n, e) {
    return function(t) {
      return t >= n && t <= e;
    };
  },
  range: function(n, e) {
    return function(t) {
      return t >= n && t <= e;
    };
  },
  lessThan: function(n) {
    return function(e) {
      return e < n;
    };
  },
  lessThanOrEqual: function(n) {
    return function(e) {
      return e <= n;
    };
  },
  greaterThan: function(n) {
    return function(e) {
      return e > n;
    };
  },
  greaterThanOrEqual: function(n) {
    return function(e) {
      return e >= n;
    };
  },
  // Divisible
  even: function() {
    return function(n) {
      return n % 2 === 0;
    };
  },
  odd: function() {
    return function(n) {
      return n % 2 !== 0;
    };
  },
  includes: function(n) {
    return function(e) {
      return ~e.indexOf(n);
    };
  },
  schema: function(n) {
    return $Q(n);
  },
  // branching
  passesAnyOf: function() {
    for (var n = [], e = arguments.length; e--; )
      n[e] = arguments[e];
    return function(t) {
      return n.some(function(r) {
        return r.test(t);
      });
    };
  },
  optional: WQ
};
function O1(n) {
  return function(e) {
    return Array.isArray(e) && n === "array" || e === null && n === "null" || typeof e === n;
  };
}
function jQ(n) {
  return typeof n == "number" && isFinite(n) && Math.floor(n) === n;
}
function $Q(n) {
  return {
    simple: function(e) {
      var t = [];
      if (Object.keys(n).forEach(function(r) {
        var i = n[r];
        try {
          i.check((e || {})[r]);
        } catch (o) {
          o.target = r, t.push(o);
        }
      }), t.length > 0)
        throw t;
      return !0;
    },
    async: function(e) {
      var t = [], r = Object.keys(n).map(function(i) {
        var o = n[i];
        return o.testAsync((e || {})[i]).catch(function(l) {
          l.target = i, t.push(l);
        });
      });
      return Promise.all(r).then(function() {
        if (t.length > 0)
          throw t;
        return !0;
      });
    }
  };
}
var $a = "colors", Of = "sizes", Vn = "space", YQ = { gap: Vn, gridGap: Vn, columnGap: Vn, gridColumnGap: Vn, rowGap: Vn, gridRowGap: Vn, inset: Vn, insetBlock: Vn, insetBlockEnd: Vn, insetBlockStart: Vn, insetInline: Vn, insetInlineEnd: Vn, insetInlineStart: Vn, margin: Vn, marginTop: Vn, marginRight: Vn, marginBottom: Vn, marginLeft: Vn, marginBlock: Vn, marginBlockEnd: Vn, marginBlockStart: Vn, marginInline: Vn, marginInlineEnd: Vn, marginInlineStart: Vn, padding: Vn, paddingTop: Vn, paddingRight: Vn, paddingBottom: Vn, paddingLeft: Vn, paddingBlock: Vn, paddingBlockEnd: Vn, paddingBlockStart: Vn, paddingInline: Vn, paddingInlineEnd: Vn, paddingInlineStart: Vn, top: Vn, right: Vn, bottom: Vn, left: Vn, scrollMargin: Vn, scrollMarginTop: Vn, scrollMarginRight: Vn, scrollMarginBottom: Vn, scrollMarginLeft: Vn, scrollMarginX: Vn, scrollMarginY: Vn, scrollMarginBlock: Vn, scrollMarginBlockEnd: Vn, scrollMarginBlockStart: Vn, scrollMarginInline: Vn, scrollMarginInlineEnd: Vn, scrollMarginInlineStart: Vn, scrollPadding: Vn, scrollPaddingTop: Vn, scrollPaddingRight: Vn, scrollPaddingBottom: Vn, scrollPaddingLeft: Vn, scrollPaddingX: Vn, scrollPaddingY: Vn, scrollPaddingBlock: Vn, scrollPaddingBlockEnd: Vn, scrollPaddingBlockStart: Vn, scrollPaddingInline: Vn, scrollPaddingInlineEnd: Vn, scrollPaddingInlineStart: Vn, fontSize: "fontSizes", background: $a, backgroundColor: $a, backgroundImage: $a, borderImage: $a, border: $a, borderBlock: $a, borderBlockEnd: $a, borderBlockStart: $a, borderBottom: $a, borderBottomColor: $a, borderColor: $a, borderInline: $a, borderInlineEnd: $a, borderInlineStart: $a, borderLeft: $a, borderLeftColor: $a, borderRight: $a, borderRightColor: $a, borderTop: $a, borderTopColor: $a, caretColor: $a, color: $a, columnRuleColor: $a, fill: $a, outline: $a, outlineColor: $a, stroke: $a, textDecorationColor: $a, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: Of, minBlockSize: Of, maxBlockSize: Of, inlineSize: Of, minInlineSize: Of, maxInlineSize: Of, width: Of, minWidth: Of, maxWidth: Of, height: Of, minHeight: Of, maxHeight: Of, flexBasis: Of, gridTemplateColumns: Of, gridTemplateRows: Of, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, XQ = (n, e) => typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e, oE = () => {
  const n = /* @__PURE__ */ Object.create(null);
  return (e, t, ...r) => {
    const i = ((o) => JSON.stringify(o, XQ))(e);
    return i in n ? n[i] : n[i] = t(e, ...r);
  };
}, px = Symbol.for("sxs.internal"), f3 = (n, e) => Object.defineProperties(n, Object.getOwnPropertyDescriptors(e)), oz = (n) => {
  for (const e in n)
    return !0;
  return !1;
}, { hasOwnProperty: qQ } = Object.prototype, $O = (n) => n.includes("-") ? n : n.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase()), KQ = /\s+(?![^()]*\))/, P1 = (n) => (e) => n(...typeof e == "string" ? String(e).split(KQ) : [e]), sz = { appearance: (n) => ({ WebkitAppearance: n, appearance: n }), backfaceVisibility: (n) => ({ WebkitBackfaceVisibility: n, backfaceVisibility: n }), backdropFilter: (n) => ({ WebkitBackdropFilter: n, backdropFilter: n }), backgroundClip: (n) => ({ WebkitBackgroundClip: n, backgroundClip: n }), boxDecorationBreak: (n) => ({ WebkitBoxDecorationBreak: n, boxDecorationBreak: n }), clipPath: (n) => ({ WebkitClipPath: n, clipPath: n }), content: (n) => ({ content: n.includes('"') || n.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(n) ? n : `"${n}"` }), hyphens: (n) => ({ WebkitHyphens: n, hyphens: n }), maskImage: (n) => ({ WebkitMaskImage: n, maskImage: n }), maskSize: (n) => ({ WebkitMaskSize: n, maskSize: n }), tabSize: (n) => ({ MozTabSize: n, tabSize: n }), textSizeAdjust: (n) => ({ WebkitTextSizeAdjust: n, textSizeAdjust: n }), userSelect: (n) => ({ WebkitUserSelect: n, userSelect: n }), marginBlock: P1((n, e) => ({ marginBlockStart: n, marginBlockEnd: e || n })), marginInline: P1((n, e) => ({ marginInlineStart: n, marginInlineEnd: e || n })), maxSize: P1((n, e) => ({ maxBlockSize: n, maxInlineSize: e || n })), minSize: P1((n, e) => ({ minBlockSize: n, minInlineSize: e || n })), paddingBlock: P1((n, e) => ({ paddingBlockStart: n, paddingBlockEnd: e || n })), paddingInline: P1((n, e) => ({ paddingInlineStart: n, paddingInlineEnd: e || n })) }, OL = /([\d.]+)([^]*)/, QQ = (n, e) => n.length ? n.reduce((t, r) => (t.push(...e.map((i) => i.includes("&") ? i.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(i) ? `:is(${r})` : r) : r + " " + i)), t), []) : e, ZQ = (n, e) => n in JQ && typeof e == "string" ? e.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t, r, i, o) => r + (i === "stretch" ? `-moz-available${o};${$O(n)}:${r}-webkit-fill-available` : `-moz-fit-content${o};${$O(n)}:${r}fit-content`) + o) : String(e), JQ = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, Yg = (n) => n ? n + "-" : "", g5 = (n, e, t) => n.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, i, o, l, c) => l == "$" == !!o ? r : (i || l == "--" ? "calc(" : "") + "var(--" + (l === "$" ? Yg(e) + (c.includes("$") ? "" : Yg(t)) + c.replace(/\$/g, "-") : c) + ")" + (i || l == "--" ? "*" + (i || "") + (o || "1") + ")" : "")), eZ = /\s*,\s*(?![^()]*\))/, tZ = Object.prototype.toString, V1 = (n, e, t, r, i) => {
  let o, l, c;
  const h = (p, y, x) => {
    let b, w;
    const R = (U) => {
      for (b in U) {
        const F = b.charCodeAt(0) === 64, k = F && Array.isArray(U[b]) ? U[b] : [U[b]];
        for (w of k) {
          const H = /[A-Z]/.test(A = b) ? A : A.replace(/-[^]/g, ($) => $[1].toUpperCase()), B = typeof w == "object" && w && w.toString === tZ && (!r.utils[H] || !y.length);
          if (H in r.utils && !B) {
            const $ = r.utils[H];
            if ($ !== l) {
              l = $, R($(w)), l = null;
              continue;
            }
          } else if (H in sz) {
            const $ = sz[H];
            if ($ !== c) {
              c = $, R($(w)), c = null;
              continue;
            }
          }
          if (F && (L = b.slice(1) in r.media ? "@media " + r.media[b.slice(1)] : b, b = L.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, ($, Y, J, K, X, le) => {
            const oe = OL.test(Y), fe = 0.0625 * (oe ? -1 : 1), [de, xe] = oe ? [K, Y] : [Y, K];
            return "(" + (J[0] === "=" ? "" : J[0] === ">" === oe ? "max-" : "min-") + de + ":" + (J[0] !== "=" && J.length === 1 ? xe.replace(OL, (_e, Pe, ce) => Number(Pe) + fe * (J === ">" ? 1 : -1) + ce) : xe) + (X ? ") and (" + (X[0] === ">" ? "min-" : "max-") + de + ":" + (X.length === 1 ? le.replace(OL, (_e, Pe, ce) => Number(Pe) + fe * (X === ">" ? -1 : 1) + ce) : le) : "") + ")";
          })), B) {
            const $ = F ? x.concat(b) : [...x], Y = F ? [...y] : QQ(y, b.split(eZ));
            o !== void 0 && i(lz(...o)), o = void 0, h(w, Y, $);
          } else
            o === void 0 && (o = [[], y, x]), b = F || b.charCodeAt(0) !== 36 ? b : `--${Yg(r.prefix)}${b.slice(1).replace(/\$/g, "-")}`, w = B ? w : typeof w == "number" ? w && H in nZ ? String(w) + "px" : String(w) : g5(ZQ(H, w ?? ""), r.prefix, r.themeMap[H]), o[0].push(`${F ? `${b} ` : `${$O(b)}:`}${w}`);
        }
      }
      var L, A;
    };
    R(p), o !== void 0 && i(lz(...o)), o = void 0;
  };
  h(n, e, t);
}, lz = (n, e, t) => `${t.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${n.join(";")}${e.length ? "}" : ""}${Array(t.length ? t.length + 1 : 0).join("}")}`, nZ = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, uz = (n) => String.fromCharCode(n + (n > 25 ? 39 : 97)), mx = (n) => ((e) => {
  let t, r = "";
  for (t = Math.abs(e); t > 52; t = t / 52 | 0)
    r = uz(t % 52) + r;
  return uz(t % 52) + r;
})(((e, t) => {
  let r = t.length;
  for (; r; )
    e = 33 * e ^ t.charCodeAt(--r);
  return e;
})(5381, JSON.stringify(n)) >>> 0), _T = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], rZ = (n) => {
  if (n.href && !n.href.startsWith(location.origin))
    return !1;
  try {
    return !!n.cssRules;
  } catch {
    return !1;
  }
}, iZ = (n) => {
  let e;
  const t = () => {
    const { cssRules: i } = e.sheet;
    return [].map.call(i, (o, l) => {
      const { cssText: c } = o;
      let h = "";
      if (c.startsWith("--sxs"))
        return "";
      if (i[l - 1] && (h = i[l - 1].cssText).startsWith("--sxs")) {
        if (!o.cssRules.length)
          return "";
        for (const p in e.rules)
          if (e.rules[p].group === o)
            return `--sxs{--sxs:${[...e.rules[p].cache].join(" ")}}${c}`;
        return o.cssRules.length ? `${h}${c}` : "";
      }
      return c;
    }).join("");
  }, r = () => {
    if (e) {
      const { rules: c, sheet: h } = e;
      if (!h.deleteRule) {
        for (; Object(Object(h.cssRules)[0]).type === 3; )
          h.cssRules.splice(0, 1);
        h.cssRules = [];
      }
      for (const p in c)
        delete c[p];
    }
    const i = Object(n).styleSheets || [];
    for (const c of i)
      if (rZ(c)) {
        for (let h = 0, p = c.cssRules; p[h]; ++h) {
          const y = Object(p[h]);
          if (y.type !== 1)
            continue;
          const x = Object(p[h + 1]);
          if (x.type !== 4)
            continue;
          ++h;
          const { cssText: b } = y;
          if (!b.startsWith("--sxs"))
            continue;
          const w = b.slice(14, -3).trim().split(/\s+/), R = _T[w[0]];
          R && (e || (e = { sheet: c, reset: r, rules: {}, toString: t }), e.rules[R] = { group: x, index: h, cache: new Set(w) });
        }
        if (e)
          break;
      }
    if (!e) {
      const c = (h, p) => ({ type: p, cssRules: [], insertRule(y, x) {
        this.cssRules.splice(x, 0, c(y, { import: 3, undefined: 1 }[(y.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return h === "@media{}" ? `@media{${[].map.call(this.cssRules, (y) => y.cssText).join("")}}` : h;
      } });
      e = { sheet: n ? (n.head || n).appendChild(document.createElement("style")).sheet : c("", "text/css"), rules: {}, reset: r, toString: t };
    }
    const { sheet: o, rules: l } = e;
    for (let c = _T.length - 1; c >= 0; --c) {
      const h = _T[c];
      if (!l[h]) {
        const p = _T[c + 1], y = l[p] ? l[p].index : o.cssRules.length;
        o.insertRule("@media{}", y), o.insertRule(`--sxs{--sxs:${c}}`, y), l[h] = { group: o.cssRules[y + 1], index: y, cache: /* @__PURE__ */ new Set([c]) };
      }
      aZ(l[h]);
    }
  };
  return r(), e;
}, aZ = (n) => {
  const e = n.group;
  let t = e.cssRules.length;
  n.apply = (r) => {
    try {
      e.insertRule(r, t), ++t;
    } catch {
    }
  };
}, vT = Symbol(), oZ = oE(), cz = (n, e) => oZ(n, () => (...t) => {
  let r = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const i of t)
    if (i != null)
      if (i[px]) {
        r.type == null && (r.type = i[px].type);
        for (const o of i[px].composers)
          r.composers.add(o);
      } else
        i.constructor !== Object || i.$$typeof ? r.type == null && (r.type = i) : r.composers.add(sZ(i, n));
  return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), lZ(n, r, e);
}), sZ = ({ variants: n, compoundVariants: e, defaultVariants: t, ...r }, i) => {
  const o = `${Yg(i.prefix)}c-${mx(r)}`, l = [], c = [], h = /* @__PURE__ */ Object.create(null), p = [];
  for (const b in t)
    h[b] = String(t[b]);
  if (typeof n == "object" && n)
    for (const b in n) {
      y = h, x = b, qQ.call(y, x) || (h[b] = "undefined");
      const w = n[b];
      for (const R in w) {
        const U = { [b]: String(R) };
        String(R) === "undefined" && p.push(b);
        const L = w[R], A = [U, L, !oz(L)];
        l.push(A);
      }
    }
  var y, x;
  if (typeof e == "object" && e)
    for (const b of e) {
      let { css: w, ...R } = b;
      w = typeof w == "object" && w || {};
      for (const L in R)
        R[L] = String(R[L]);
      const U = [R, w, !oz(w)];
      c.push(U);
    }
  return [o, r, l, c, h, p];
}, lZ = (n, e, t) => {
  const [r, i, o, l] = uZ(e.composers), c = typeof e.type == "function" || e.type.$$typeof ? ((x) => {
    function b() {
      for (let w = 0; w < b[vT].length; w++) {
        const [R, U] = b[vT][w];
        x.rules[R].apply(U);
      }
      return b[vT] = [], null;
    }
    return b[vT] = [], b.rules = {}, _T.forEach((w) => b.rules[w] = { apply: (R) => b[vT].push([w, R]) }), b;
  })(t) : null, h = (c || t).rules, p = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, y = (x) => {
    x = typeof x == "object" && x || cZ;
    const { css: b, ...w } = x, R = {};
    for (const A in o)
      if (delete w[A], A in x) {
        let F = x[A];
        typeof F == "object" && F ? R[A] = { "@initial": o[A], ...F } : (F = String(F), R[A] = F !== "undefined" || l.has(A) ? F : o[A]);
      } else
        R[A] = o[A];
    const U = /* @__PURE__ */ new Set([...i]);
    for (const [A, F, k, H] of e.composers) {
      t.rules.styled.cache.has(A) || (t.rules.styled.cache.add(A), V1(F, [`.${A}`], [], n, (Y) => {
        h.styled.apply(Y);
      }));
      const B = fz(k, R, n.media), $ = fz(H, R, n.media, !0);
      for (const Y of B)
        if (Y !== void 0)
          for (const [J, K, X] of Y) {
            const le = `${A}-${mx(K)}-${J}`;
            U.add(le);
            const oe = (X ? t.rules.resonevar : t.rules.onevar).cache, fe = X ? h.resonevar : h.onevar;
            oe.has(le) || (oe.add(le), V1(K, [`.${le}`], [], n, (de) => {
              fe.apply(de);
            }));
          }
      for (const Y of $)
        if (Y !== void 0)
          for (const [J, K] of Y) {
            const X = `${A}-${mx(K)}-${J}`;
            U.add(X), t.rules.allvar.cache.has(X) || (t.rules.allvar.cache.add(X), V1(K, [`.${X}`], [], n, (le) => {
              h.allvar.apply(le);
            }));
          }
    }
    if (typeof b == "object" && b) {
      const A = `${r}-i${mx(b)}-css`;
      U.add(A), t.rules.inline.cache.has(A) || (t.rules.inline.cache.add(A), V1(b, [`.${A}`], [], n, (F) => {
        h.inline.apply(F);
      }));
    }
    for (const A of String(x.className || "").trim().split(/\s+/))
      A && U.add(A);
    const L = w.className = [...U].join(" ");
    return { type: e.type, className: L, selector: p, props: w, toString: () => L, deferredInjector: c };
  };
  return f3(y, { className: r, selector: p, [px]: e, toString: () => (t.rules.styled.cache.has(r) || y(), r) });
}, uZ = (n) => {
  let e = "";
  const t = [], r = {}, i = [];
  for (const [o, , , , l, c] of n) {
    e === "" && (e = o), t.push(o), i.push(...c);
    for (const h in l) {
      const p = l[h];
      (r[h] === void 0 || p !== "undefined" || c.includes(p)) && (r[h] = p);
    }
  }
  return [e, t, r, new Set(i)];
}, fz = (n, e, t, r) => {
  const i = [];
  e:
    for (let [o, l, c] of n) {
      if (c)
        continue;
      let h, p = 0, y = !1;
      for (h in o) {
        const x = o[h];
        let b = e[h];
        if (b !== x) {
          if (typeof b != "object" || !b)
            continue e;
          {
            let w, R, U = 0;
            for (const L in b) {
              if (x === String(b[L])) {
                if (L !== "@initial") {
                  const A = L.slice(1);
                  (R = R || []).push(A in t ? t[A] : L.replace(/^@media ?/, "")), y = !0;
                }
                p += U, w = !0;
              }
              ++U;
            }
            if (R && R.length && (l = { ["@media " + R.join(", ")]: l }), !w)
              continue e;
          }
        }
      }
      (i[p] = i[p] || []).push([r ? "cv" : `${h}-${o[h]}`, l, y]);
    }
  return i;
}, cZ = {}, fZ = oE(), dZ = (n, e) => fZ(n, () => (...t) => {
  const r = () => {
    for (let i of t) {
      i = typeof i == "object" && i || {};
      let o = mx(i);
      if (!e.rules.global.cache.has(o)) {
        if (e.rules.global.cache.add(o), "@import" in i) {
          let l = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
          for (let c of [].concat(i["@import"]))
            c = c.includes('"') || c.includes("'") ? c : `"${c}"`, e.sheet.insertRule(`@import ${c};`, l++);
          delete i["@import"];
        }
        V1(i, [], [], n, (l) => {
          e.rules.global.apply(l);
        });
      }
    }
    return "";
  };
  return f3(r, { toString: r });
}), hZ = oE(), pZ = (n, e) => hZ(n, () => (t) => {
  const r = `${Yg(n.prefix)}k-${mx(t)}`, i = () => {
    if (!e.rules.global.cache.has(r)) {
      e.rules.global.cache.add(r);
      const o = [];
      V1(t, [], [], n, (c) => o.push(c));
      const l = `@keyframes ${r}{${o.join("")}}`;
      e.rules.global.apply(l);
    }
    return r;
  };
  return f3(i, { get name() {
    return i();
  }, toString: i });
}), mZ = class {
  constructor(n, e, t, r) {
    this.token = n == null ? "" : String(n), this.value = e == null ? "" : String(e), this.scale = t == null ? "" : String(t), this.prefix = r == null ? "" : String(r);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + Yg(this.prefix) + Yg(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, vZ = oE(), gZ = (n, e) => vZ(n, () => (t, r) => {
  r = typeof t == "object" && t || Object(r);
  const i = `.${t = (t = typeof t == "string" ? t : "") || `${Yg(n.prefix)}t-${mx(r)}`}`, o = {}, l = [];
  for (const h in r) {
    o[h] = {};
    for (const p in r[h]) {
      const y = `--${Yg(n.prefix)}${h}-${p}`, x = g5(String(r[h][p]), n.prefix, h);
      o[h][p] = new mZ(p, x, h, n.prefix), l.push(`${y}:${x}`);
    }
  }
  const c = () => {
    if (l.length && !e.rules.themed.cache.has(t)) {
      e.rules.themed.cache.add(t);
      const h = `${r === n.theme ? ":root," : ""}.${t}{${l.join(";")}}`;
      e.rules.themed.apply(h);
    }
    return t;
  };
  return { ...o, get className() {
    return c();
  }, selector: i, toString: c };
}), yZ = oE(), SZ = oE(), xZ = (n) => {
  const e = ((t) => {
    let r = !1;
    const i = yZ(t, (o) => {
      r = !0;
      const l = "prefix" in (o = typeof o == "object" && o || {}) ? String(o.prefix) : "", c = typeof o.media == "object" && o.media || {}, h = typeof o.root == "object" ? o.root || null : globalThis.document || null, p = typeof o.theme == "object" && o.theme || {}, y = { prefix: l, media: c, theme: p, themeMap: typeof o.themeMap == "object" && o.themeMap || { ...YQ }, utils: typeof o.utils == "object" && o.utils || {} }, x = iZ(h), b = { css: cz(y, x), globalCss: dZ(y, x), keyframes: pZ(y, x), createTheme: gZ(y, x), reset() {
        x.reset(), b.theme.toString();
      }, theme: {}, sheet: x, config: y, prefix: l, getCssText: x.toString, toString: x.toString };
      return String(b.theme = b.createTheme(p)), b;
    });
    return r || i.reset(), i;
  })(n);
  return e.styled = (({ config: t, sheet: r }) => SZ(t, () => {
    const i = cz(t, r);
    return (...o) => {
      const l = i(...o), c = l[px].type, h = Fe.forwardRef((p, y) => {
        const x = p && p.as || c, { props: b, deferredInjector: w } = l(p);
        return delete b.as, b.ref = y, w ? Fe.createElement(Fe.Fragment, null, Fe.createElement(x, b), Fe.createElement(w, null)) : Fe.createElement(x, b);
      });
      return h.className = l.className, h.displayName = `Styled.${c.displayName || c.name || c}`, h.selector = l.selector, h.toString = () => l.selector, h[px] = l[px], h;
    };
  }))(e), e;
};
function zg(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(i) {
    if (n == null || n(i), t === !1 || !i.defaultPrevented)
      return e == null ? void 0 : e(i);
  };
}
function y5(n, e = []) {
  let t = [];
  function r(o, l) {
    const c = /* @__PURE__ */ vx(l), h = t.length;
    t = [
      ...t,
      l
    ];
    function p(x) {
      const { scope: b, children: w, ...R } = x, U = (b == null ? void 0 : b[n][h]) || c, L = Rl(
        () => R,
        Object.values(R)
      );
      return /* @__PURE__ */ ca(U.Provider, {
        value: L
      }, w);
    }
    function y(x, b) {
      const w = (b == null ? void 0 : b[n][h]) || c, R = Tx(w);
      if (R)
        return R;
      if (l !== void 0)
        return l;
      throw new Error(`\`${x}\` must be used within \`${o}\``);
    }
    return p.displayName = o + "Provider", [
      p,
      y
    ];
  }
  const i = () => {
    const o = t.map((l) => /* @__PURE__ */ vx(l));
    return function(c) {
      const h = (c == null ? void 0 : c[n]) || o;
      return Rl(
        () => ({
          [`__scope${n}`]: {
            ...c,
            [n]: h
          }
        }),
        [
          c,
          h
        ]
      );
    };
  };
  return i.scopeName = n, [
    r,
    _Z(i, ...e)
  ];
}
function _Z(...n) {
  const e = n[0];
  if (n.length === 1)
    return e;
  const t = () => {
    const r = n.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(o) {
      const l = r.reduce((c, { useScope: h, scopeName: p }) => {
        const x = h(o)[`__scope${p}`];
        return {
          ...c,
          ...x
        };
      }, {});
      return Rl(
        () => ({
          [`__scope${e.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return t.scopeName = e.scopeName, t;
}
function sE(n) {
  const e = Sn(n);
  return tr(() => {
    e.current = n;
  }), Rl(
    () => (...t) => {
      var r;
      return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...t);
    },
    []
  );
}
function EZ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = sE(n);
  tr(() => {
    const r = (i) => {
      i.key === "Escape" && t(i);
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r);
  }, [
    t,
    e
  ]);
}
const YO = "dismissableLayer.update", bZ = "dismissableLayer.pointerDownOutside", TZ = "dismissableLayer.focusOutside";
let dz;
const wZ = /* @__PURE__ */ vx({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), MZ = /* @__PURE__ */ Cu((n, e) => {
  var t;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: l, onInteractOutside: c, onDismiss: h, ...p } = n, y = Tx(wZ), [x, b] = Ni(null), w = (t = x == null ? void 0 : x.ownerDocument) !== null && t !== void 0 ? t : globalThis == null ? void 0 : globalThis.document, [, R] = Ni({}), U = aE(
    e,
    (J) => b(J)
  ), L = Array.from(y.layers), [A] = [
    ...y.layersWithOutsidePointerEventsDisabled
  ].slice(-1), F = L.indexOf(A), k = x ? L.indexOf(x) : -1, H = y.layersWithOutsidePointerEventsDisabled.size > 0, B = k >= F, $ = CZ((J) => {
    const K = J.target, X = [
      ...y.branches
    ].some(
      (le) => le.contains(K)
    );
    !B || X || (o == null || o(J), c == null || c(J), J.defaultPrevented || h == null || h());
  }, w), Y = RZ((J) => {
    const K = J.target;
    [
      ...y.branches
    ].some(
      (le) => le.contains(K)
    ) || (l == null || l(J), c == null || c(J), J.defaultPrevented || h == null || h());
  }, w);
  return EZ((J) => {
    k === y.layers.size - 1 && (i == null || i(J), !J.defaultPrevented && h && (J.preventDefault(), h()));
  }, w), tr(() => {
    if (x)
      return r && (y.layersWithOutsidePointerEventsDisabled.size === 0 && (dz = w.body.style.pointerEvents, w.body.style.pointerEvents = "none"), y.layersWithOutsidePointerEventsDisabled.add(x)), y.layers.add(x), hz(), () => {
        r && y.layersWithOutsidePointerEventsDisabled.size === 1 && (w.body.style.pointerEvents = dz);
      };
  }, [
    x,
    w,
    r,
    y
  ]), tr(() => () => {
    x && (y.layers.delete(x), y.layersWithOutsidePointerEventsDisabled.delete(x), hz());
  }, [
    x,
    y
  ]), tr(() => {
    const J = () => R({});
    return document.addEventListener(YO, J), () => document.removeEventListener(YO, J);
  }, []), /* @__PURE__ */ ca(Ax.div, fs({}, p, {
    ref: U,
    style: {
      pointerEvents: H ? B ? "auto" : "none" : void 0,
      ...n.style
    },
    onFocusCapture: zg(n.onFocusCapture, Y.onFocusCapture),
    onBlurCapture: zg(n.onBlurCapture, Y.onBlurCapture),
    onPointerDownCapture: zg(n.onPointerDownCapture, $.onPointerDownCapture)
  }));
});
function CZ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = sE(n), r = Sn(!1), i = Sn(() => {
  });
  return tr(() => {
    const o = (c) => {
      if (c.target && !r.current) {
        let p = function() {
          S5(bZ, t, h, {
            discrete: !0
          });
        };
        const h = {
          originalEvent: c
        };
        c.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = p, e.addEventListener("click", i.current, {
          once: !0
        })) : p();
      } else
        e.removeEventListener("click", i.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      e.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(l), e.removeEventListener("pointerdown", o), e.removeEventListener("click", i.current);
    };
  }, [
    e,
    t
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function RZ(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = sE(n), r = Sn(!1);
  return tr(() => {
    const i = (o) => {
      o.target && !r.current && S5(TZ, t, {
        originalEvent: o
      }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
  }, [
    e,
    t
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function hz() {
  const n = new CustomEvent(YO);
  document.dispatchEvent(n);
}
function S5(n, e, t, { discrete: r }) {
  const i = t.originalEvent.target, o = new CustomEvent(n, {
    bubbles: !1,
    cancelable: !0,
    detail: t
  });
  e && i.addEventListener(n, e, {
    once: !0
  }), r ? BQ(i, o) : i.dispatchEvent(o);
}
const Z1 = globalThis != null && globalThis.document ? M0 : () => {
}, AZ = Cn["useId".toString()] || (() => {
});
let DZ = 0;
function LZ(n) {
  const [e, t] = Cn.useState(AZ());
  return Z1(() => {
    n || t(
      (r) => r ?? String(DZ++)
    );
  }, [
    n
  ]), n || (e ? `radix-${e}` : "");
}
const OZ = ["top", "right", "bottom", "left"], E0 = Math.min, gh = Math.max, OR = Math.round, iR = Math.floor, b0 = (n) => ({
  x: n,
  y: n
}), PZ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, UZ = {
  start: "end",
  end: "start"
};
function XO(n, e, t) {
  return gh(n, E0(e, t));
}
function Xg(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function qg(n) {
  return n.split("-")[0];
}
function lE(n) {
  return n.split("-")[1];
}
function d3(n) {
  return n === "x" ? "y" : "x";
}
function h3(n) {
  return n === "y" ? "height" : "width";
}
function uE(n) {
  return ["top", "bottom"].includes(qg(n)) ? "y" : "x";
}
function p3(n) {
  return d3(uE(n));
}
function NZ(n, e, t) {
  t === void 0 && (t = !1);
  const r = lE(n), i = p3(n), o = h3(i);
  let l = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (l = PR(l)), [l, PR(l)];
}
function FZ(n) {
  const e = PR(n);
  return [qO(n), e, qO(e)];
}
function qO(n) {
  return n.replace(/start|end/g, (e) => UZ[e]);
}
function kZ(n, e, t) {
  const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], l = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? i : r : e ? r : i;
    case "left":
    case "right":
      return e ? o : l;
    default:
      return [];
  }
}
function zZ(n, e, t, r) {
  const i = lE(n);
  let o = kZ(qg(n), t === "start", r);
  return i && (o = o.map((l) => l + "-" + i), e && (o = o.concat(o.map(qO)))), o;
}
function PR(n) {
  return n.replace(/left|right|bottom|top/g, (e) => PZ[e]);
}
function IZ(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function x5(n) {
  return typeof n != "number" ? IZ(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function UR(n) {
  return {
    ...n,
    top: n.y,
    left: n.x,
    right: n.x + n.width,
    bottom: n.y + n.height
  };
}
function pz(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const o = uE(e), l = p3(e), c = h3(l), h = qg(e), p = o === "y", y = r.x + r.width / 2 - i.width / 2, x = r.y + r.height / 2 - i.height / 2, b = r[c] / 2 - i[c] / 2;
  let w;
  switch (h) {
    case "top":
      w = {
        x: y,
        y: r.y - i.height
      };
      break;
    case "bottom":
      w = {
        x: y,
        y: r.y + r.height
      };
      break;
    case "right":
      w = {
        x: r.x + r.width,
        y: x
      };
      break;
    case "left":
      w = {
        x: r.x - i.width,
        y: x
      };
      break;
    default:
      w = {
        x: r.x,
        y: r.y
      };
  }
  switch (lE(e)) {
    case "start":
      w[l] -= b * (t && p ? -1 : 1);
      break;
    case "end":
      w[l] += b * (t && p ? -1 : 1);
      break;
  }
  return w;
}
const BZ = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: l
  } = t, c = o.filter(Boolean), h = await (l.isRTL == null ? void 0 : l.isRTL(e));
  let p = await l.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: y,
    y: x
  } = pz(p, r, h), b = r, w = {}, R = 0;
  for (let U = 0; U < c.length; U++) {
    const {
      name: L,
      fn: A
    } = c[U], {
      x: F,
      y: k,
      data: H,
      reset: B
    } = await A({
      x: y,
      y: x,
      initialPlacement: r,
      placement: b,
      strategy: i,
      middlewareData: w,
      rects: p,
      platform: l,
      elements: {
        reference: n,
        floating: e
      }
    });
    if (y = F ?? y, x = k ?? x, w = {
      ...w,
      [L]: {
        ...w[L],
        ...H
      }
    }, B && R <= 50) {
      R++, typeof B == "object" && (B.placement && (b = B.placement), B.rects && (p = B.rects === !0 ? await l.getElementRects({
        reference: n,
        floating: e,
        strategy: i
      }) : B.rects), {
        x: y,
        y: x
      } = pz(p, b, h)), U = -1;
      continue;
    }
  }
  return {
    x: y,
    y: x,
    placement: b,
    strategy: i,
    middlewareData: w
  };
};
async function ew(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: l,
    elements: c,
    strategy: h
  } = n, {
    boundary: p = "clippingAncestors",
    rootBoundary: y = "viewport",
    elementContext: x = "floating",
    altBoundary: b = !1,
    padding: w = 0
  } = Xg(e, n), R = x5(w), L = c[b ? x === "floating" ? "reference" : "floating" : x], A = UR(await o.getClippingRect({
    element: (t = await (o.isElement == null ? void 0 : o.isElement(L))) == null || t ? L : L.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)),
    boundary: p,
    rootBoundary: y,
    strategy: h
  })), F = x === "floating" ? {
    ...l.floating,
    x: r,
    y: i
  } : l.reference, k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), H = await (o.isElement == null ? void 0 : o.isElement(k)) ? await (o.getScale == null ? void 0 : o.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = UR(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: F,
    offsetParent: k,
    strategy: h
  }) : F);
  return {
    top: (A.top - B.top + R.top) / H.y,
    bottom: (B.bottom - A.bottom + R.bottom) / H.y,
    left: (A.left - B.left + R.left) / H.x,
    right: (B.right - A.right + R.right) / H.x
  };
}
const mz = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: t,
      y: r,
      placement: i,
      rects: o,
      platform: l,
      elements: c,
      middlewareData: h
    } = e, {
      element: p,
      padding: y = 0
    } = Xg(n, e) || {};
    if (p == null)
      return {};
    const x = x5(y), b = {
      x: t,
      y: r
    }, w = p3(i), R = h3(w), U = await l.getDimensions(p), L = w === "y", A = L ? "top" : "left", F = L ? "bottom" : "right", k = L ? "clientHeight" : "clientWidth", H = o.reference[R] + o.reference[w] - b[w] - o.floating[R], B = b[w] - o.reference[w], $ = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(p));
    let Y = $ ? $[k] : 0;
    (!Y || !await (l.isElement == null ? void 0 : l.isElement($))) && (Y = c.floating[k] || o.floating[R]);
    const J = H / 2 - B / 2, K = Y / 2 - U[R] / 2 - 1, X = E0(x[A], K), le = E0(x[F], K), oe = X, fe = Y - U[R] - le, de = Y / 2 - U[R] / 2 + J, xe = XO(oe, de, fe), _e = !h.arrow && lE(i) != null && de != xe && o.reference[R] / 2 - (de < oe ? X : le) - U[R] / 2 < 0, Pe = _e ? de < oe ? de - oe : de - fe : 0;
    return {
      [w]: b[w] + Pe,
      data: {
        [w]: xe,
        centerOffset: de - xe - Pe,
        ..._e && {
          alignmentOffset: Pe
        }
      },
      reset: _e
    };
  }
}), HZ = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: o,
        rects: l,
        initialPlacement: c,
        platform: h,
        elements: p
      } = e, {
        mainAxis: y = !0,
        crossAxis: x = !0,
        fallbackPlacements: b,
        fallbackStrategy: w = "bestFit",
        fallbackAxisSideDirection: R = "none",
        flipAlignment: U = !0,
        ...L
      } = Xg(n, e);
      if ((t = o.arrow) != null && t.alignmentOffset)
        return {};
      const A = qg(i), F = qg(c) === c, k = await (h.isRTL == null ? void 0 : h.isRTL(p.floating)), H = b || (F || !U ? [PR(c)] : FZ(c));
      !b && R !== "none" && H.push(...zZ(c, U, R, k));
      const B = [c, ...H], $ = await ew(e, L), Y = [];
      let J = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (y && Y.push($[A]), x) {
        const oe = NZ(i, l, k);
        Y.push($[oe[0]], $[oe[1]]);
      }
      if (J = [...J, {
        placement: i,
        overflows: Y
      }], !Y.every((oe) => oe <= 0)) {
        var K, X;
        const oe = (((K = o.flip) == null ? void 0 : K.index) || 0) + 1, fe = B[oe];
        if (fe)
          return {
            data: {
              index: oe,
              overflows: J
            },
            reset: {
              placement: fe
            }
          };
        let de = (X = J.filter((xe) => xe.overflows[0] <= 0).sort((xe, _e) => xe.overflows[1] - _e.overflows[1])[0]) == null ? void 0 : X.placement;
        if (!de)
          switch (w) {
            case "bestFit": {
              var le;
              const xe = (le = J.map((_e) => [_e.placement, _e.overflows.filter((Pe) => Pe > 0).reduce((Pe, ce) => Pe + ce, 0)]).sort((_e, Pe) => _e[1] - Pe[1])[0]) == null ? void 0 : le[0];
              xe && (de = xe);
              break;
            }
            case "initialPlacement":
              de = c;
              break;
          }
        if (i !== de)
          return {
            reset: {
              placement: de
            }
          };
      }
      return {};
    }
  };
};
function vz(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function gz(n) {
  return OZ.some((e) => n[e] >= 0);
}
const VZ = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: t
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = Xg(n, e);
      switch (r) {
        case "referenceHidden": {
          const o = await ew(e, {
            ...i,
            elementContext: "reference"
          }), l = vz(o, t.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: gz(l)
            }
          };
        }
        case "escaped": {
          const o = await ew(e, {
            ...i,
            altBoundary: !0
          }), l = vz(o, t.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: gz(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function GZ(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), l = qg(t), c = lE(t), h = uE(t) === "y", p = ["left", "top"].includes(l) ? -1 : 1, y = o && h ? -1 : 1, x = Xg(e, n);
  let {
    mainAxis: b,
    crossAxis: w,
    alignmentAxis: R
  } = typeof x == "number" ? {
    mainAxis: x,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...x
  };
  return c && typeof R == "number" && (w = c === "end" ? R * -1 : R), h ? {
    x: w * y,
    y: b * p
  } : {
    x: b * p,
    y: w * y
  };
}
const WZ = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r
      } = e, i = await GZ(e, n);
      return {
        x: t + i.x,
        y: r + i.y,
        data: i
      };
    }
  };
}, jZ = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: o = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (L) => {
            let {
              x: A,
              y: F
            } = L;
            return {
              x: A,
              y: F
            };
          }
        },
        ...h
      } = Xg(n, e), p = {
        x: t,
        y: r
      }, y = await ew(e, h), x = uE(qg(i)), b = d3(x);
      let w = p[b], R = p[x];
      if (o) {
        const L = b === "y" ? "top" : "left", A = b === "y" ? "bottom" : "right", F = w + y[L], k = w - y[A];
        w = XO(F, w, k);
      }
      if (l) {
        const L = x === "y" ? "top" : "left", A = x === "y" ? "bottom" : "right", F = R + y[L], k = R - y[A];
        R = XO(F, R, k);
      }
      const U = c.fn({
        ...e,
        [b]: w,
        [x]: R
      });
      return {
        ...U,
        data: {
          x: U.x - t,
          y: U.y - r
        }
      };
    }
  };
}, $Z = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(e) {
      const {
        x: t,
        y: r,
        placement: i,
        rects: o,
        middlewareData: l
      } = e, {
        offset: c = 0,
        mainAxis: h = !0,
        crossAxis: p = !0
      } = Xg(n, e), y = {
        x: t,
        y: r
      }, x = uE(i), b = d3(x);
      let w = y[b], R = y[x];
      const U = Xg(c, e), L = typeof U == "number" ? {
        mainAxis: U,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...U
      };
      if (h) {
        const k = b === "y" ? "height" : "width", H = o.reference[b] - o.floating[k] + L.mainAxis, B = o.reference[b] + o.reference[k] - L.mainAxis;
        w < H ? w = H : w > B && (w = B);
      }
      if (p) {
        var A, F;
        const k = b === "y" ? "width" : "height", H = ["top", "left"].includes(qg(i)), B = o.reference[x] - o.floating[k] + (H && ((A = l.offset) == null ? void 0 : A[x]) || 0) + (H ? 0 : L.crossAxis), $ = o.reference[x] + o.reference[k] + (H ? 0 : ((F = l.offset) == null ? void 0 : F[x]) || 0) - (H ? L.crossAxis : 0);
        R < B ? R = B : R > $ && (R = $);
      }
      return {
        [b]: w,
        [x]: R
      };
    }
  };
}, YZ = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      const {
        placement: t,
        rects: r,
        platform: i,
        elements: o
      } = e, {
        apply: l = () => {
        },
        ...c
      } = Xg(n, e), h = await ew(e, c), p = qg(t), y = lE(t), x = uE(t) === "y", {
        width: b,
        height: w
      } = r.floating;
      let R, U;
      p === "top" || p === "bottom" ? (R = p, U = y === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (U = p, R = y === "end" ? "top" : "bottom");
      const L = w - h[R], A = b - h[U], F = !e.middlewareData.shift;
      let k = L, H = A;
      if (x) {
        const $ = b - h.left - h.right;
        H = y || F ? E0(A, $) : $;
      } else {
        const $ = w - h.top - h.bottom;
        k = y || F ? E0(L, $) : $;
      }
      if (F && !y) {
        const $ = gh(h.left, 0), Y = gh(h.right, 0), J = gh(h.top, 0), K = gh(h.bottom, 0);
        x ? H = b - 2 * ($ !== 0 || Y !== 0 ? $ + Y : gh(h.left, h.right)) : k = w - 2 * (J !== 0 || K !== 0 ? J + K : gh(h.top, h.bottom));
      }
      await l({
        ...e,
        availableWidth: H,
        availableHeight: k
      });
      const B = await i.getDimensions(o.floating);
      return b !== B.width || w !== B.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function T0(n) {
  return _5(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Sh(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Zg(n) {
  var e;
  return (e = (_5(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function _5(n) {
  return n instanceof Node || n instanceof Sh(n).Node;
}
function Kg(n) {
  return n instanceof Element || n instanceof Sh(n).Element;
}
function Rv(n) {
  return n instanceof HTMLElement || n instanceof Sh(n).HTMLElement;
}
function yz(n) {
  return typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Sh(n).ShadowRoot;
}
function yw(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = mp(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !["inline", "contents"].includes(i);
}
function XZ(n) {
  return ["table", "td", "th"].includes(T0(n));
}
function m3(n) {
  const e = v3(), t = mp(n);
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (t.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (t.contain || "").includes(r));
}
function qZ(n) {
  let e = J1(n);
  for (; Rv(e) && !C2(e); ) {
    if (m3(e))
      return e;
    e = J1(e);
  }
  return null;
}
function v3() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function C2(n) {
  return ["html", "body", "#document"].includes(T0(n));
}
function mp(n) {
  return Sh(n).getComputedStyle(n);
}
function R2(n) {
  return Kg(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.pageXOffset,
    scrollTop: n.pageYOffset
  };
}
function J1(n) {
  if (T0(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    yz(n) && n.host || // Fallback.
    Zg(n)
  );
  return yz(e) ? e.host : e;
}
function E5(n) {
  const e = J1(n);
  return C2(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : Rv(e) && yw(e) ? e : E5(e);
}
function tw(n, e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const i = E5(n), o = i === ((r = n.ownerDocument) == null ? void 0 : r.body), l = Sh(i);
  return o ? e.concat(l, l.visualViewport || [], yw(i) ? i : [], l.frameElement && t ? tw(l.frameElement) : []) : e.concat(i, tw(i, [], t));
}
function b5(n) {
  const e = mp(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Rv(n), o = i ? n.offsetWidth : t, l = i ? n.offsetHeight : r, c = OR(t) !== o || OR(r) !== l;
  return c && (t = o, r = l), {
    width: t,
    height: r,
    $: c
  };
}
function g3(n) {
  return Kg(n) ? n : n.contextElement;
}
function Y1(n) {
  const e = g3(n);
  if (!Rv(e))
    return b0(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = b5(e);
  let l = (o ? OR(t.width) : t.width) / r, c = (o ? OR(t.height) : t.height) / i;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const KZ = /* @__PURE__ */ b0(0);
function T5(n) {
  const e = Sh(n);
  return !v3() || !e.visualViewport ? KZ : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function QZ(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Sh(n) ? !1 : e;
}
function Ex(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), o = g3(n);
  let l = b0(1);
  e && (r ? Kg(r) && (l = Y1(r)) : l = Y1(n));
  const c = QZ(o, t, r) ? T5(o) : b0(0);
  let h = (i.left + c.x) / l.x, p = (i.top + c.y) / l.y, y = i.width / l.x, x = i.height / l.y;
  if (o) {
    const b = Sh(o), w = r && Kg(r) ? Sh(r) : r;
    let R = b.frameElement;
    for (; R && r && w !== b; ) {
      const U = Y1(R), L = R.getBoundingClientRect(), A = mp(R), F = L.left + (R.clientLeft + parseFloat(A.paddingLeft)) * U.x, k = L.top + (R.clientTop + parseFloat(A.paddingTop)) * U.y;
      h *= U.x, p *= U.y, y *= U.x, x *= U.y, h += F, p += k, R = Sh(R).frameElement;
    }
  }
  return UR({
    width: y,
    height: x,
    x: h,
    y: p
  });
}
function ZZ(n) {
  let {
    rect: e,
    offsetParent: t,
    strategy: r
  } = n;
  const i = Rv(t), o = Zg(t);
  if (t === o)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = b0(1);
  const h = b0(0);
  if ((i || !i && r !== "fixed") && ((T0(t) !== "body" || yw(o)) && (l = R2(t)), Rv(t))) {
    const p = Ex(t);
    c = Y1(t), h.x = p.x + t.clientLeft, h.y = p.y + t.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + h.x,
    y: e.y * c.y - l.scrollTop * c.y + h.y
  };
}
function JZ(n) {
  return Array.from(n.getClientRects());
}
function w5(n) {
  return Ex(Zg(n)).left + R2(n).scrollLeft;
}
function eJ(n) {
  const e = Zg(n), t = R2(n), r = n.ownerDocument.body, i = gh(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), o = gh(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -t.scrollLeft + w5(n);
  const c = -t.scrollTop;
  return mp(r).direction === "rtl" && (l += gh(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: l,
    y: c
  };
}
function tJ(n, e) {
  const t = Sh(n), r = Zg(n), i = t.visualViewport;
  let o = r.clientWidth, l = r.clientHeight, c = 0, h = 0;
  if (i) {
    o = i.width, l = i.height;
    const p = v3();
    (!p || p && e === "fixed") && (c = i.offsetLeft, h = i.offsetTop);
  }
  return {
    width: o,
    height: l,
    x: c,
    y: h
  };
}
function nJ(n, e) {
  const t = Ex(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, o = Rv(n) ? Y1(n) : b0(1), l = n.clientWidth * o.x, c = n.clientHeight * o.y, h = i * o.x, p = r * o.y;
  return {
    width: l,
    height: c,
    x: h,
    y: p
  };
}
function Sz(n, e, t) {
  let r;
  if (e === "viewport")
    r = tJ(n, t);
  else if (e === "document")
    r = eJ(Zg(n));
  else if (Kg(e))
    r = nJ(e, t);
  else {
    const i = T5(n);
    r = {
      ...e,
      x: e.x - i.x,
      y: e.y - i.y
    };
  }
  return UR(r);
}
function M5(n, e) {
  const t = J1(n);
  return t === e || !Kg(t) || C2(t) ? !1 : mp(t).position === "fixed" || M5(t, e);
}
function rJ(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = tw(n, [], !1).filter((c) => Kg(c) && T0(c) !== "body"), i = null;
  const o = mp(n).position === "fixed";
  let l = o ? J1(n) : n;
  for (; Kg(l) && !C2(l); ) {
    const c = mp(l), h = m3(l);
    !h && c.position === "fixed" && (i = null), (o ? !h && !i : !h && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || yw(l) && !h && M5(n, l)) ? r = r.filter((y) => y !== l) : i = c, l = J1(l);
  }
  return e.set(n, r), r;
}
function iJ(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const l = [...t === "clippingAncestors" ? rJ(e, this._c) : [].concat(t), r], c = l[0], h = l.reduce((p, y) => {
    const x = Sz(e, y, i);
    return p.top = gh(x.top, p.top), p.right = E0(x.right, p.right), p.bottom = E0(x.bottom, p.bottom), p.left = gh(x.left, p.left), p;
  }, Sz(e, c, i));
  return {
    width: h.right - h.left,
    height: h.bottom - h.top,
    x: h.left,
    y: h.top
  };
}
function aJ(n) {
  return b5(n);
}
function oJ(n, e, t) {
  const r = Rv(e), i = Zg(e), o = t === "fixed", l = Ex(n, !0, o, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const h = b0(0);
  if (r || !r && !o)
    if ((T0(e) !== "body" || yw(i)) && (c = R2(e)), r) {
      const p = Ex(e, !0, o, e);
      h.x = p.x + e.clientLeft, h.y = p.y + e.clientTop;
    } else
      i && (h.x = w5(i));
  return {
    x: l.left + c.scrollLeft - h.x,
    y: l.top + c.scrollTop - h.y,
    width: l.width,
    height: l.height
  };
}
function xz(n, e) {
  return !Rv(n) || mp(n).position === "fixed" ? null : e ? e(n) : n.offsetParent;
}
function C5(n, e) {
  const t = Sh(n);
  if (!Rv(n))
    return t;
  let r = xz(n, e);
  for (; r && XZ(r) && mp(r).position === "static"; )
    r = xz(r, e);
  return r && (T0(r) === "html" || T0(r) === "body" && mp(r).position === "static" && !m3(r)) ? t : r || qZ(n) || t;
}
const sJ = async function(n) {
  let {
    reference: e,
    floating: t,
    strategy: r
  } = n;
  const i = this.getOffsetParent || C5, o = this.getDimensions;
  return {
    reference: oJ(e, await i(t), r),
    floating: {
      x: 0,
      y: 0,
      ...await o(t)
    }
  };
};
function lJ(n) {
  return mp(n).direction === "rtl";
}
const uJ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ZZ,
  getDocumentElement: Zg,
  getClippingRect: iJ,
  getOffsetParent: C5,
  getElementRects: sJ,
  getClientRects: JZ,
  getDimensions: aJ,
  getScale: Y1,
  isElement: Kg,
  isRTL: lJ
};
function cJ(n, e) {
  let t = null, r;
  const i = Zg(n);
  function o() {
    clearTimeout(r), t && t.disconnect(), t = null;
  }
  function l(c, h) {
    c === void 0 && (c = !1), h === void 0 && (h = 1), o();
    const {
      left: p,
      top: y,
      width: x,
      height: b
    } = n.getBoundingClientRect();
    if (c || e(), !x || !b)
      return;
    const w = iR(y), R = iR(i.clientWidth - (p + x)), U = iR(i.clientHeight - (y + b)), L = iR(p), F = {
      rootMargin: -w + "px " + -R + "px " + -U + "px " + -L + "px",
      threshold: gh(0, E0(1, h)) || 1
    };
    let k = !0;
    function H(B) {
      const $ = B[0].intersectionRatio;
      if ($ !== h) {
        if (!k)
          return l();
        $ ? l(!1, $) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 100);
      }
      k = !1;
    }
    try {
      t = new IntersectionObserver(H, {
        ...F,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(H, F);
    }
    t.observe(n);
  }
  return l(!0), o;
}
function fJ(n, e, t, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: h = !1
  } = r, p = g3(n), y = i || o ? [...p ? tw(p) : [], ...tw(e)] : [];
  y.forEach((A) => {
    i && A.addEventListener("scroll", t, {
      passive: !0
    }), o && A.addEventListener("resize", t);
  });
  const x = p && c ? cJ(p, t) : null;
  let b = -1, w = null;
  l && (w = new ResizeObserver((A) => {
    let [F] = A;
    F && F.target === p && w && (w.unobserve(e), cancelAnimationFrame(b), b = requestAnimationFrame(() => {
      w && w.observe(e);
    })), t();
  }), p && !h && w.observe(p), w.observe(e));
  let R, U = h ? Ex(n) : null;
  h && L();
  function L() {
    const A = Ex(n);
    U && (A.x !== U.x || A.y !== U.y || A.width !== U.width || A.height !== U.height) && t(), U = A, R = requestAnimationFrame(L);
  }
  return t(), () => {
    y.forEach((A) => {
      i && A.removeEventListener("scroll", t), o && A.removeEventListener("resize", t);
    }), x && x(), w && w.disconnect(), w = null, h && cancelAnimationFrame(R);
  };
}
const dJ = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: uJ,
    ...t
  }, o = {
    ...i.platform,
    _c: r
  };
  return BZ(n, e, {
    ...i,
    platform: o
  });
}, hJ = (n) => {
  function e(t) {
    return {}.hasOwnProperty.call(t, "current");
  }
  return {
    name: "arrow",
    options: n,
    fn(t) {
      const {
        element: r,
        padding: i
      } = typeof n == "function" ? n(t) : n;
      return r && e(r) ? r.current != null ? mz({
        element: r.current,
        padding: i
      }).fn(t) : {} : r ? mz({
        element: r,
        padding: i
      }).fn(t) : {};
    }
  };
};
var _R = typeof document < "u" ? M0 : tr;
function NR(n, e) {
  if (n === e)
    return !0;
  if (typeof n != typeof e)
    return !1;
  if (typeof n == "function" && n.toString() === e.toString())
    return !0;
  let t, r, i;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (t = n.length, t != e.length)
        return !1;
      for (r = t; r-- !== 0; )
        if (!NR(n[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(n), t = i.length, t !== Object.keys(e).length)
      return !1;
    for (r = t; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = t; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && n.$$typeof) && !NR(n[o], e[o]))
        return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function R5(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _z(n, e) {
  const t = R5(n);
  return Math.round(e * t) / t;
}
function Ez(n) {
  const e = Cn.useRef(n);
  return _R(() => {
    e.current = n;
  }), e;
}
function pJ(n) {
  n === void 0 && (n = {});
  const {
    placement: e = "bottom",
    strategy: t = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: l
    } = {},
    transform: c = !0,
    whileElementsMounted: h,
    open: p
  } = n, [y, x] = Cn.useState({
    x: 0,
    y: 0,
    strategy: t,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [b, w] = Cn.useState(r);
  NR(b, r) || w(r);
  const [R, U] = Cn.useState(null), [L, A] = Cn.useState(null), F = Cn.useCallback((_e) => {
    _e != $.current && ($.current = _e, U(_e));
  }, [U]), k = Cn.useCallback((_e) => {
    _e !== Y.current && (Y.current = _e, A(_e));
  }, [A]), H = o || R, B = l || L, $ = Cn.useRef(null), Y = Cn.useRef(null), J = Cn.useRef(y), K = Ez(h), X = Ez(i), le = Cn.useCallback(() => {
    if (!$.current || !Y.current)
      return;
    const _e = {
      placement: e,
      strategy: t,
      middleware: b
    };
    X.current && (_e.platform = X.current), dJ($.current, Y.current, _e).then((Pe) => {
      const ce = {
        ...Pe,
        isPositioned: !0
      };
      oe.current && !NR(J.current, ce) && (J.current = ce, b2.flushSync(() => {
        x(ce);
      }));
    });
  }, [b, e, t, X]);
  _R(() => {
    p === !1 && J.current.isPositioned && (J.current.isPositioned = !1, x((_e) => ({
      ..._e,
      isPositioned: !1
    })));
  }, [p]);
  const oe = Cn.useRef(!1);
  _R(() => (oe.current = !0, () => {
    oe.current = !1;
  }), []), _R(() => {
    if (H && ($.current = H), B && (Y.current = B), H && B) {
      if (K.current)
        return K.current(H, B, le);
      le();
    }
  }, [H, B, le, K]);
  const fe = Cn.useMemo(() => ({
    reference: $,
    floating: Y,
    setReference: F,
    setFloating: k
  }), [F, k]), de = Cn.useMemo(() => ({
    reference: H,
    floating: B
  }), [H, B]), xe = Cn.useMemo(() => {
    const _e = {
      position: t,
      left: 0,
      top: 0
    };
    if (!de.floating)
      return _e;
    const Pe = _z(de.floating, y.x), ce = _z(de.floating, y.y);
    return c ? {
      ..._e,
      transform: "translate(" + Pe + "px, " + ce + "px)",
      ...R5(de.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: t,
      left: Pe,
      top: ce
    };
  }, [t, c, de.floating, y.x, y.y]);
  return Cn.useMemo(() => ({
    ...y,
    update: le,
    refs: fe,
    elements: de,
    floatingStyles: xe
  }), [y, le, fe, de, xe]);
}
const mJ = /* @__PURE__ */ Cu((n, e) => {
  const { children: t, width: r = 10, height: i = 5, ...o } = n;
  return /* @__PURE__ */ ca(Ax.svg, fs({}, o, {
    ref: e,
    width: r,
    height: i,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), n.asChild ? t : /* @__PURE__ */ ca("polygon", {
    points: "0,0 30,0 15,10"
  }));
}), vJ = mJ;
function gJ(n) {
  const [e, t] = Ni(void 0);
  return Z1(() => {
    if (n) {
      t({
        width: n.offsetWidth,
        height: n.offsetHeight
      });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let l, c;
        if ("borderBoxSize" in o) {
          const h = o.borderBoxSize, p = Array.isArray(h) ? h[0] : h;
          l = p.inlineSize, c = p.blockSize;
        } else
          l = n.offsetWidth, c = n.offsetHeight;
        t({
          width: l,
          height: c
        });
      });
      return r.observe(n, {
        box: "border-box"
      }), () => r.unobserve(n);
    } else
      t(void 0);
  }, [
    n
  ]), e;
}
const A5 = "Popper", [D5, L5] = y5(A5), [yJ, O5] = D5(A5), SJ = (n) => {
  const { __scopePopper: e, children: t } = n, [r, i] = Ni(null);
  return /* @__PURE__ */ ca(yJ, {
    scope: e,
    anchor: r,
    onAnchorChange: i
  }, t);
}, xJ = "PopperAnchor", _J = /* @__PURE__ */ Cu((n, e) => {
  const { __scopePopper: t, virtualRef: r, ...i } = n, o = O5(xJ, t), l = Sn(null), c = aE(e, l);
  return tr(() => {
    o.onAnchorChange((r == null ? void 0 : r.current) || l.current);
  }), r ? null : /* @__PURE__ */ ca(Ax.div, fs({}, i, {
    ref: c
  }));
}), P5 = "PopperContent", [EJ, bJ] = D5(P5), TJ = /* @__PURE__ */ Cu((n, e) => {
  var t, r, i, o, l, c, h, p;
  const { __scopePopper: y, side: x = "bottom", sideOffset: b = 0, align: w = "center", alignOffset: R = 0, arrowPadding: U = 0, avoidCollisions: L = !0, collisionBoundary: A = [], collisionPadding: F = 0, sticky: k = "partial", hideWhenDetached: H = !1, updatePositionStrategy: B = "optimized", onPlaced: $, ...Y } = n, J = O5(P5, y), [K, X] = Ni(null), le = aE(
    e,
    (Ge) => X(Ge)
  ), [oe, fe] = Ni(null), de = gJ(oe), xe = (t = de == null ? void 0 : de.width) !== null && t !== void 0 ? t : 0, _e = (r = de == null ? void 0 : de.height) !== null && r !== void 0 ? r : 0, Pe = x + (w !== "center" ? "-" + w : ""), ce = typeof F == "number" ? F : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...F
  }, ve = Array.isArray(A) ? A : [
    A
  ], re = ve.length > 0, ee = {
    padding: ce,
    boundary: ve.filter(RJ),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: re
  }, { refs: he, floatingStyles: Me, placement: Le, isPositioned: Ae, middlewareData: Ue } = pJ({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: Pe,
    whileElementsMounted: (...Ge) => fJ(...Ge, {
      animationFrame: B === "always"
    }),
    elements: {
      reference: J.anchor
    },
    middleware: [
      WZ({
        mainAxis: b + _e,
        alignmentAxis: R
      }),
      L && jZ({
        mainAxis: !0,
        crossAxis: !1,
        limiter: k === "partial" ? $Z() : void 0,
        ...ee
      }),
      L && HZ({
        ...ee
      }),
      YZ({
        ...ee,
        apply: ({ elements: Ge, rects: $e, availableWidth: Ut, availableHeight: nt }) => {
          const { width: Ct, height: Pt } = $e.reference, vt = Ge.floating.style;
          vt.setProperty("--radix-popper-available-width", `${Ut}px`), vt.setProperty("--radix-popper-available-height", `${nt}px`), vt.setProperty("--radix-popper-anchor-width", `${Ct}px`), vt.setProperty("--radix-popper-anchor-height", `${Pt}px`);
        }
      }),
      oe && hJ({
        element: oe,
        padding: U
      }),
      AJ({
        arrowWidth: xe,
        arrowHeight: _e
      }),
      H && VZ({
        strategy: "referenceHidden",
        ...ee
      })
    ]
  }), [Ne, ke] = U5(Le), it = sE($);
  Z1(() => {
    Ae && (it == null || it());
  }, [
    Ae,
    it
  ]);
  const At = (i = Ue.arrow) === null || i === void 0 ? void 0 : i.x, rt = (o = Ue.arrow) === null || o === void 0 ? void 0 : o.y, ae = ((l = Ue.arrow) === null || l === void 0 ? void 0 : l.centerOffset) !== 0, [et, Ye] = Ni();
  return Z1(() => {
    K && Ye(window.getComputedStyle(K).zIndex);
  }, [
    K
  ]), /* @__PURE__ */ ca("div", {
    ref: he.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...Me,
      transform: Ae ? Me.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: et,
      "--radix-popper-transform-origin": [
        (c = Ue.transformOrigin) === null || c === void 0 ? void 0 : c.x,
        (h = Ue.transformOrigin) === null || h === void 0 ? void 0 : h.y
      ].join(" ")
    },
    dir: n.dir
  }, /* @__PURE__ */ ca(EJ, {
    scope: y,
    placedSide: Ne,
    onArrowChange: fe,
    arrowX: At,
    arrowY: rt,
    shouldHideArrow: ae
  }, /* @__PURE__ */ ca(Ax.div, fs({
    "data-side": Ne,
    "data-align": ke
  }, Y, {
    ref: le,
    style: {
      ...Y.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: Ae ? void 0 : "none",
      // hide the content if using the hide middleware and should be hidden
      opacity: (p = Ue.hide) !== null && p !== void 0 && p.referenceHidden ? 0 : void 0
    }
  }))));
}), wJ = "PopperArrow", MJ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, CJ = /* @__PURE__ */ Cu(function(e, t) {
  const { __scopePopper: r, ...i } = e, o = bJ(wJ, r), l = MJ[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ ca("span", {
      ref: o.onArrowChange,
      style: {
        position: "absolute",
        left: o.arrowX,
        top: o.arrowY,
        [l]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[o.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[o.placedSide],
        visibility: o.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ ca(vJ, fs({}, i, {
      ref: t,
      style: {
        ...i.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function RJ(n) {
  return n !== null;
}
const AJ = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var t, r, i, o, l;
    const { placement: c, rects: h, middlewareData: p } = e, x = ((t = p.arrow) === null || t === void 0 ? void 0 : t.centerOffset) !== 0, b = x ? 0 : n.arrowWidth, w = x ? 0 : n.arrowHeight, [R, U] = U5(c), L = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[U], A = ((r = (i = p.arrow) === null || i === void 0 ? void 0 : i.x) !== null && r !== void 0 ? r : 0) + b / 2, F = ((o = (l = p.arrow) === null || l === void 0 ? void 0 : l.y) !== null && o !== void 0 ? o : 0) + w / 2;
    let k = "", H = "";
    return R === "bottom" ? (k = x ? L : `${A}px`, H = `${-w}px`) : R === "top" ? (k = x ? L : `${A}px`, H = `${h.floating.height + w}px`) : R === "right" ? (k = `${-w}px`, H = x ? L : `${F}px`) : R === "left" && (k = `${h.floating.width + w}px`, H = x ? L : `${F}px`), {
      data: {
        x: k,
        y: H
      }
    };
  }
});
function U5(n) {
  const [e, t = "center"] = n.split("-");
  return [
    e,
    t
  ];
}
const DJ = SJ, LJ = _J, OJ = TJ, PJ = CJ;
function UJ(n, e) {
  return dP((t, r) => {
    const i = e[t][r];
    return i ?? t;
  }, n);
}
const N5 = (n) => {
  const { present: e, children: t } = n, r = NJ(e), i = typeof t == "function" ? t({
    present: r.isPresent
  }) : G1.only(t), o = aE(r.ref, i.ref);
  return typeof t == "function" || r.isPresent ? /* @__PURE__ */ hP(i, {
    ref: o
  }) : null;
};
N5.displayName = "Presence";
function NJ(n) {
  const [e, t] = Ni(), r = Sn({}), i = Sn(n), o = Sn("none"), l = n ? "mounted" : "unmounted", [c, h] = UJ(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return tr(() => {
    const p = aR(r.current);
    o.current = c === "mounted" ? p : "none";
  }, [
    c
  ]), Z1(() => {
    const p = r.current, y = i.current;
    if (y !== n) {
      const b = o.current, w = aR(p);
      n ? h("MOUNT") : w === "none" || (p == null ? void 0 : p.display) === "none" ? h("UNMOUNT") : h(y && b !== w ? "ANIMATION_OUT" : "UNMOUNT"), i.current = n;
    }
  }, [
    n,
    h
  ]), Z1(() => {
    if (e) {
      const p = (x) => {
        const w = aR(r.current).includes(x.animationName);
        x.target === e && w && b2.flushSync(
          () => h("ANIMATION_END")
        );
      }, y = (x) => {
        x.target === e && (o.current = aR(r.current));
      };
      return e.addEventListener("animationstart", y), e.addEventListener("animationcancel", p), e.addEventListener("animationend", p), () => {
        e.removeEventListener("animationstart", y), e.removeEventListener("animationcancel", p), e.removeEventListener("animationend", p);
      };
    } else
      h("ANIMATION_END");
  }, [
    e,
    h
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(c),
    ref: Ir((p) => {
      p && (r.current = getComputedStyle(p)), t(p);
    }, [])
  };
}
function aR(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function FJ({ prop: n, defaultProp: e, onChange: t = () => {
} }) {
  const [r, i] = kJ({
    defaultProp: e,
    onChange: t
  }), o = n !== void 0, l = o ? n : r, c = sE(t), h = Ir((p) => {
    if (o) {
      const x = typeof p == "function" ? p(n) : p;
      x !== n && c(x);
    } else
      i(p);
  }, [
    o,
    n,
    i,
    c
  ]);
  return [
    l,
    h
  ];
}
function kJ({ defaultProp: n, onChange: e }) {
  const t = Ni(n), [r] = t, i = Sn(r), o = sE(e);
  return tr(() => {
    i.current !== r && (o(r), i.current = r);
  }, [
    r,
    i,
    o
  ]), t;
}
const zJ = /* @__PURE__ */ Cu((n, e) => /* @__PURE__ */ ca(Ax.span, fs({}, n, {
  ref: e,
  style: {
    // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
    ...n.style
  }
}))), IJ = zJ, [A2, Bae] = y5("Tooltip", [
  L5
]), D2 = L5(), BJ = "TooltipProvider", KO = "tooltip.open", [Hae, y3] = A2(BJ), S3 = "Tooltip", [HJ, L2] = A2(S3), VJ = (n) => {
  const { __scopeTooltip: e, children: t, open: r, defaultOpen: i = !1, onOpenChange: o, disableHoverableContent: l, delayDuration: c } = n, h = y3(S3, n.__scopeTooltip), p = D2(e), [y, x] = Ni(null), b = LZ(), w = Sn(0), R = l ?? h.disableHoverableContent, U = c ?? h.delayDuration, L = Sn(!1), [A = !1, F] = FJ({
    prop: r,
    defaultProp: i,
    onChange: (Y) => {
      Y ? (h.onOpen(), document.dispatchEvent(new CustomEvent(KO))) : h.onClose(), o == null || o(Y);
    }
  }), k = Rl(() => A ? L.current ? "delayed-open" : "instant-open" : "closed", [
    A
  ]), H = Ir(() => {
    window.clearTimeout(w.current), L.current = !1, F(!0);
  }, [
    F
  ]), B = Ir(() => {
    window.clearTimeout(w.current), F(!1);
  }, [
    F
  ]), $ = Ir(() => {
    window.clearTimeout(w.current), w.current = window.setTimeout(() => {
      L.current = !0, F(!0);
    }, U);
  }, [
    U,
    F
  ]);
  return tr(() => () => window.clearTimeout(w.current), []), /* @__PURE__ */ ca(DJ, p, /* @__PURE__ */ ca(HJ, {
    scope: e,
    contentId: b,
    open: A,
    stateAttribute: k,
    trigger: y,
    onTriggerChange: x,
    onTriggerEnter: Ir(() => {
      h.isOpenDelayed ? $() : H();
    }, [
      h.isOpenDelayed,
      $,
      H
    ]),
    onTriggerLeave: Ir(() => {
      R ? B() : window.clearTimeout(w.current);
    }, [
      B,
      R
    ]),
    onOpen: H,
    onClose: B,
    disableHoverableContent: R
  }, t));
}, bz = "TooltipTrigger", GJ = /* @__PURE__ */ Cu((n, e) => {
  const { __scopeTooltip: t, ...r } = n, i = L2(bz, t), o = y3(bz, t), l = D2(t), c = Sn(null), h = aE(e, c, i.onTriggerChange), p = Sn(!1), y = Sn(!1), x = Ir(
    () => p.current = !1,
    []
  );
  return tr(() => () => document.removeEventListener("pointerup", x), [
    x
  ]), /* @__PURE__ */ ca(LJ, fs({
    asChild: !0
  }, l), /* @__PURE__ */ ca(Ax.button, fs({
    // We purposefully avoid adding `type=button` here because tooltip triggers are also
    // commonly anchors and the anchor `type` attribute signifies MIME type.
    "aria-describedby": i.open ? i.contentId : void 0,
    "data-state": i.stateAttribute
  }, r, {
    ref: h,
    onPointerMove: zg(n.onPointerMove, (b) => {
      b.pointerType !== "touch" && !y.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), y.current = !0);
    }),
    onPointerLeave: zg(n.onPointerLeave, () => {
      i.onTriggerLeave(), y.current = !1;
    }),
    onPointerDown: zg(n.onPointerDown, () => {
      p.current = !0, document.addEventListener("pointerup", x, {
        once: !0
      });
    }),
    onFocus: zg(n.onFocus, () => {
      p.current || i.onOpen();
    }),
    onBlur: zg(n.onBlur, i.onClose),
    onClick: zg(n.onClick, i.onClose)
  })));
}), WJ = "TooltipPortal", [Vae, jJ] = A2(WJ, {
  forceMount: void 0
}), nw = "TooltipContent", $J = /* @__PURE__ */ Cu((n, e) => {
  const t = jJ(nw, n.__scopeTooltip), { forceMount: r = t.forceMount, side: i = "top", ...o } = n, l = L2(nw, n.__scopeTooltip);
  return /* @__PURE__ */ ca(N5, {
    present: r || l.open
  }, l.disableHoverableContent ? /* @__PURE__ */ ca(F5, fs({
    side: i
  }, o, {
    ref: e
  })) : /* @__PURE__ */ ca(YJ, fs({
    side: i
  }, o, {
    ref: e
  })));
}), YJ = /* @__PURE__ */ Cu((n, e) => {
  const t = L2(nw, n.__scopeTooltip), r = y3(nw, n.__scopeTooltip), i = Sn(null), o = aE(e, i), [l, c] = Ni(null), { trigger: h, onClose: p } = t, y = i.current, { onPointerInTransitChange: x } = r, b = Ir(() => {
    c(null), x(!1);
  }, [
    x
  ]), w = Ir((R, U) => {
    const L = R.currentTarget, A = {
      x: R.clientX,
      y: R.clientY
    }, F = ZJ(A, L.getBoundingClientRect()), k = JJ(A, F), H = eee(U.getBoundingClientRect()), B = nee([
      ...k,
      ...H
    ]);
    c(B), x(!0);
  }, [
    x
  ]);
  return tr(() => () => b(), [
    b
  ]), tr(() => {
    if (h && y) {
      const R = (L) => w(L, y), U = (L) => w(L, h);
      return h.addEventListener("pointerleave", R), y.addEventListener("pointerleave", U), () => {
        h.removeEventListener("pointerleave", R), y.removeEventListener("pointerleave", U);
      };
    }
  }, [
    h,
    y,
    w,
    b
  ]), tr(() => {
    if (l) {
      const R = (U) => {
        const L = U.target, A = {
          x: U.clientX,
          y: U.clientY
        }, F = (h == null ? void 0 : h.contains(L)) || (y == null ? void 0 : y.contains(L)), k = !tee(A, l);
        F ? b() : k && (b(), p());
      };
      return document.addEventListener("pointermove", R), () => document.removeEventListener("pointermove", R);
    }
  }, [
    h,
    y,
    l,
    p,
    b
  ]), /* @__PURE__ */ ca(F5, fs({}, n, {
    ref: o
  }));
}), [XJ, qJ] = A2(S3, {
  isInside: !1
}), F5 = /* @__PURE__ */ Cu((n, e) => {
  const { __scopeTooltip: t, children: r, "aria-label": i, onEscapeKeyDown: o, onPointerDownOutside: l, ...c } = n, h = L2(nw, t), p = D2(t), { onClose: y } = h;
  return tr(() => (document.addEventListener(KO, y), () => document.removeEventListener(KO, y)), [
    y
  ]), tr(() => {
    if (h.trigger) {
      const x = (b) => {
        const w = b.target;
        w != null && w.contains(h.trigger) && y();
      };
      return window.addEventListener("scroll", x, {
        capture: !0
      }), () => window.removeEventListener("scroll", x, {
        capture: !0
      });
    }
  }, [
    h.trigger,
    y
  ]), /* @__PURE__ */ ca(MZ, {
    asChild: !0,
    disableOutsidePointerEvents: !1,
    onEscapeKeyDown: o,
    onPointerDownOutside: l,
    onFocusOutside: (x) => x.preventDefault(),
    onDismiss: y
  }, /* @__PURE__ */ ca(OJ, fs({
    "data-state": h.stateAttribute
  }, p, c, {
    ref: e,
    style: {
      ...c.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), /* @__PURE__ */ ca(d5, null, r), /* @__PURE__ */ ca(XJ, {
    scope: t,
    isInside: !0
  }, /* @__PURE__ */ ca(IJ, {
    id: h.contentId,
    role: "tooltip"
  }, i || r))));
}), KJ = "TooltipArrow", QJ = /* @__PURE__ */ Cu((n, e) => {
  const { __scopeTooltip: t, ...r } = n, i = D2(t);
  return qJ(KJ, t).isInside ? null : /* @__PURE__ */ ca(PJ, fs({}, i, r, {
    ref: e
  }));
});
function ZJ(n, e) {
  const t = Math.abs(e.top - n.y), r = Math.abs(e.bottom - n.y), i = Math.abs(e.right - n.x), o = Math.abs(e.left - n.x);
  switch (Math.min(t, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case t:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function JJ(n, e, t = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({
        x: n.x - t,
        y: n.y + t
      }, {
        x: n.x + t,
        y: n.y + t
      });
      break;
    case "bottom":
      r.push({
        x: n.x - t,
        y: n.y - t
      }, {
        x: n.x + t,
        y: n.y - t
      });
      break;
    case "left":
      r.push({
        x: n.x + t,
        y: n.y - t
      }, {
        x: n.x + t,
        y: n.y + t
      });
      break;
    case "right":
      r.push({
        x: n.x - t,
        y: n.y - t
      }, {
        x: n.x - t,
        y: n.y + t
      });
      break;
  }
  return r;
}
function eee(n) {
  const { top: e, right: t, bottom: r, left: i } = n;
  return [
    {
      x: i,
      y: e
    },
    {
      x: t,
      y: e
    },
    {
      x: t,
      y: r
    },
    {
      x: i,
      y: r
    }
  ];
}
function tee(n, e) {
  const { x: t, y: r } = n;
  let i = !1;
  for (let o = 0, l = e.length - 1; o < e.length; l = o++) {
    const c = e[o].x, h = e[o].y, p = e[l].x, y = e[l].y;
    h > r != y > r && t < (p - c) * (r - h) / (y - h) + c && (i = !i);
  }
  return i;
}
function nee(n) {
  const e = n.slice();
  return e.sort((t, r) => t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0), ree(e);
}
function ree(n) {
  if (n.length <= 1)
    return n.slice();
  const e = [];
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    for (; e.length >= 2; ) {
      const o = e[e.length - 1], l = e[e.length - 2];
      if ((o.x - l.x) * (i.y - l.y) >= (o.y - l.y) * (i.x - l.x))
        e.pop();
      else
        break;
    }
    e.push(i);
  }
  e.pop();
  const t = [];
  for (let r = n.length - 1; r >= 0; r--) {
    const i = n[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], l = t[t.length - 2];
      if ((o.x - l.x) * (i.y - l.y) >= (o.y - l.y) * (i.x - l.x))
        t.pop();
      else
        break;
    }
    t.push(i);
  }
  return t.pop(), e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y ? e : e.concat(t);
}
const iee = VJ, aee = GJ, oee = $J, see = QJ;
function lee(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function Ya(n, e) {
  if (n == null)
    return {};
  var t = lee(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
let os;
(function(n) {
  n[n.UNSUPPORTED_INPUT = 0] = "UNSUPPORTED_INPUT", n[n.NO_COMPONENT_FOR_TYPE = 1] = "NO_COMPONENT_FOR_TYPE", n[n.UNKNOWN_INPUT = 2] = "UNKNOWN_INPUT", n[n.DUPLICATE_KEYS = 3] = "DUPLICATE_KEYS", n[n.ALREADY_REGISTERED_TYPE = 4] = "ALREADY_REGISTERED_TYPE", n[n.CLIPBOARD_ERROR = 5] = "CLIPBOARD_ERROR", n[n.THEME_ERROR = 6] = "THEME_ERROR", n[n.PATH_DOESNT_EXIST = 7] = "PATH_DOESNT_EXIST", n[n.INPUT_TYPE_OVERRIDE = 8] = "INPUT_TYPE_OVERRIDE", n[n.EMPTY_KEY = 9] = "EMPTY_KEY";
})(os || (os = {}));
const uee = {
  [os.UNSUPPORTED_INPUT]: (n, e) => [`An input with type \`${n}\` input was found at path \`${e}\` but it's not supported yet.`],
  [os.NO_COMPONENT_FOR_TYPE]: (n, e) => [`Type \`${n}\` found at path \`${e}\` can't be displayed in panel because no component supports it yet.`],
  [os.UNKNOWN_INPUT]: (n, e) => [`input at path \`${n}\` is not recognized.`, e],
  [os.DUPLICATE_KEYS]: (n, e, t) => [`Key \`${n}\` of path \`${e}\` already exists at path \`${t}\`. Even nested keys need to be unique. Rename one of the keys.`],
  [os.ALREADY_REGISTERED_TYPE]: (n) => [`Type ${n} has already been registered. You can't register a component with the same type.`],
  [os.CLIPBOARD_ERROR]: (n) => ["Error copying the value", n],
  [os.THEME_ERROR]: (n, e) => [`Error accessing the theme \`${n}.${e}\` value.`],
  [os.PATH_DOESNT_EXIST]: (n) => [`Error getting the value at path \`${n}\`. There is probably an error in your \`render\` function.`],
  [os.PATH_DOESNT_EXIST]: (n) => [`Error accessing the value at path \`${n}\``],
  [os.INPUT_TYPE_OVERRIDE]: (n, e, t) => [`Input at path \`${n}\` already exists with type: \`${e}\`. Its type cannot be overridden with type \`${t}\`.`],
  [os.EMPTY_KEY]: () => ["Keys can not be empty, if you want to hide a label use whitespace."]
};
function k5(n, e, ...t) {
  const [r, ...i] = uee[e](...t);
  console[n]("LEVA: " + r, ...i);
}
const Bg = k5.bind(null, "warn"), cee = k5.bind(null, "log"), fee = ["value"], dee = ["schema"], hee = ["value"], z5 = [], bx = {};
function Tz(n) {
  let {
    value: e
  } = n, t = Ya(n, fee);
  for (let r of z5) {
    const i = r(e, t);
    if (i)
      return i;
  }
}
function Jg(n, e) {
  let {
    schema: t
  } = e, r = Ya(e, dee);
  if (n in bx) {
    Bg(os.ALREADY_REGISTERED_TYPE, n);
    return;
  }
  z5.push((i, o) => t(i, o) && n), bx[n] = r;
}
function PL(n, e, t, r) {
  const {
    normalize: i
  } = bx[n];
  if (i)
    return i(e, t, r);
  if (typeof e != "object" || !("value" in e))
    return {
      value: e
    };
  const {
    value: o
  } = e, l = Ya(e, hee);
  return {
    value: o,
    settings: l
  };
}
function pee(n, e, t, r, i, o) {
  const {
    sanitize: l
  } = bx[n];
  return l ? l(e, t, r, i, o) : e;
}
function wz(n, e, t) {
  const {
    format: r
  } = bx[n];
  return r ? r(e, t) : e;
}
function mee(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Mz(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Tr(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Mz(Object(t), !0).forEach(function(r) {
      mee(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Mz(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
const w0 = (n, e, t) => n > t ? t : n < e ? e : n, vee = (n) => {
  if (n === "" || typeof n == "number")
    return n;
  try {
    const e = p0(n);
    if (!isNaN(e))
      return e;
  } catch {
  }
  return parseFloat(n);
}, gee = Math.log(10);
function Cz(n) {
  let e = Math.abs(+String(n).replace(".", ""));
  if (e === 0)
    return 0.01;
  for (; e !== 0 && e % 10 === 0; )
    e /= 10;
  const t = Math.floor(Math.log(e) / gee) + 1, r = Math.floor(Math.log10(Math.abs(n))), i = Math.pow(10, r - t);
  return Math.max(i, 1e-3);
}
const FR = (n, e, t) => t === e ? 0 : (w0(n, e, t) - e) / (t - e), kR = (n, e, t) => n * (t - e) + e, yee = () => "_" + Math.random().toString(36).substr(2, 9), Rz = /\(([0-9+\-*/^ .]+)\)/, Az = /(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/, Dz = /(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/, Lz = /(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/, Oz = /(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/, Pz = /(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;
function p0(n) {
  if (isNaN(Number(n)))
    if (Rz.test(n)) {
      const e = n.replace(Rz, (t, r) => String(p0(r)));
      return p0(e);
    } else if (Az.test(n)) {
      const e = n.replace(Az, (t, r, i) => String(Math.pow(Number(r), Number(i))));
      return p0(e);
    } else if (Dz.test(n)) {
      const e = n.replace(Dz, (t, r, i) => String(Number(r) * Number(i)));
      return p0(e);
    } else if (Lz.test(n)) {
      const e = n.replace(Lz, (t, r, i) => {
        if (i != 0)
          return String(Number(r) / Number(i));
        throw new Error("Division by zero");
      });
      return p0(e);
    } else if (Oz.test(n)) {
      const e = n.replace(Oz, (t, r, i) => String(Number(r) + Number(i)));
      return p0(e);
    } else if (Pz.test(n)) {
      const e = n.replace(Pz, (t, r, i) => String(Number(r) - Number(i)));
      return p0(e);
    } else
      return Number(n);
  return Number(n);
}
function See(n, e) {
  return e.reduce((t, r) => (n && n.hasOwnProperty(r) && (t[r] = n[r]), t), {});
}
function xee(n, e) {
  const t = Tr({}, n);
  return e.forEach((r) => r in n && delete t[r]), t;
}
function _ee(n, e) {
  return n.reduce((t, r, i) => Object.assign(t, {
    [e[i]]: r
  }), {});
}
function I5(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
const Eee = (n) => I5(n) && Object.keys(n).length === 0;
let pp;
(function(n) {
  n.BUTTON = "BUTTON", n.BUTTON_GROUP = "BUTTON_GROUP", n.MONITOR = "MONITOR", n.FOLDER = "FOLDER";
})(pp || (pp = {}));
let pm;
(function(n) {
  n.SELECT = "SELECT", n.IMAGE = "IMAGE", n.NUMBER = "NUMBER", n.COLOR = "COLOR", n.STRING = "STRING", n.BOOLEAN = "BOOLEAN", n.INTERVAL = "INTERVAL", n.VECTOR3D = "VECTOR3D", n.VECTOR2D = "VECTOR2D";
})(pm || (pm = {}));
const bee = ["type", "__customInput"], Tee = ["render", "label", "optional", "order", "disabled", "hint", "onChange", "onEditStart", "onEditEnd", "transient"], wee = ["type"];
function B5(n, e, t = {}, r) {
  var i, o;
  if (typeof n != "object" || Array.isArray(n))
    return {
      type: r,
      input: n,
      options: Tr({
        key: e,
        label: e,
        optional: !1,
        disabled: !1,
        order: 0
      }, t)
    };
  if ("__customInput" in n) {
    const {
      type: B,
      __customInput: $
    } = n, Y = Ya(n, bee);
    return B5($, e, Y, B);
  }
  const {
    render: l,
    label: c,
    optional: h,
    order: p = 0,
    disabled: y,
    hint: x,
    onChange: b,
    onEditStart: w,
    onEditEnd: R,
    transient: U
  } = n, L = Ya(n, Tee), A = Tr({
    render: l,
    key: e,
    label: c ?? e,
    hint: x,
    transient: U ?? !!b,
    onEditStart: w,
    onEditEnd: R,
    disabled: y,
    optional: h,
    order: p
  }, t);
  let {
    type: F
  } = L, k = Ya(L, wee);
  if (F = r ?? F, F in pp)
    return {
      type: F,
      input: k,
      options: A
    };
  let H;
  return r && I5(k) && "value" in k ? H = k.value : H = Eee(k) ? void 0 : k, {
    type: F,
    input: H,
    options: Tr(Tr({}, A), {}, {
      onChange: b,
      optional: (i = A.optional) !== null && i !== void 0 ? i : !1,
      disabled: (o = A.disabled) !== null && o !== void 0 ? o : !1
    })
  };
}
function Mee(n, e, t, r) {
  const i = B5(n, e), {
    type: o,
    input: l,
    options: c
  } = i;
  if (o)
    return o in pp ? i : {
      type: o,
      input: PL(o, l, t, r),
      options: c
    };
  let h = Tz(l);
  return h ? {
    type: h,
    input: PL(h, l, t, r),
    options: c
  } : (h = Tz({
    value: l
  }), h ? {
    type: h,
    input: PL(h, {
      value: l
    }, t, r),
    options: c
  } : !1);
}
function Uz(n, e, t, r, i) {
  const {
    value: o,
    type: l,
    settings: c
  } = n;
  n.value = H5({
    type: l,
    value: o,
    settings: c
  }, e, t, r), n.fromPanel = i;
}
const Cee = function(e, t, r) {
  this.type = "LEVA_ERROR", this.message = "LEVA: " + e, this.previousValue = t, this.error = r;
};
function H5({
  type: n,
  value: e,
  settings: t
}, r, i, o) {
  const l = n !== "SELECT" && typeof r == "function" ? r(e) : r;
  let c;
  try {
    c = pee(n, l, t, e, i, o);
  } catch (h) {
    throw new Cee(`The value \`${r}\` did not result in a correct value.`, e, h);
  }
  return ZT(c, e) ? e : c;
}
const V5 = (n, e, t = !1) => {
  let r = 0;
  return function() {
    const i = arguments, o = t && !r, l = () => n.apply(this, i);
    window.clearTimeout(r), r = window.setTimeout(l, e), o && l();
  };
}, G5 = (n) => n.shiftKey ? 5 : n.altKey ? 1 / 5 : 1;
function Ree(n, e) {
  const t = console.error;
  console.error = () => {
  }, GB.render(n, e), console.error = t;
}
const Aee = ["value"], Dee = ["min", "max"], Lee = (n) => {
  if (typeof n == "number")
    return !0;
  if (typeof n == "string") {
    const e = parseFloat(n);
    return isNaN(e) ? !1 : n.substring(("" + e).length).trim().length < 4;
  }
  return !1;
}, W5 = (n, {
  min: e = -1 / 0,
  max: t = 1 / 0,
  suffix: r
}) => {
  const i = parseFloat(n);
  if (n === "" || isNaN(i))
    throw Error("Invalid number");
  const o = w0(i, e, t);
  return r ? o + r : o;
}, Oee = (n, {
  pad: e = 0,
  suffix: t
}) => {
  const r = parseFloat(n).toFixed(e);
  return t ? r + t : r;
}, j5 = (n) => {
  let {
    value: e
  } = n, t = Ya(n, Aee);
  const {
    min: r = -1 / 0,
    max: i = 1 / 0
  } = t, o = Ya(t, Dee);
  let l = parseFloat(e);
  const c = typeof e == "string" ? e.substring(("" + l).length) : void 0;
  l = w0(l, r, i);
  let h = t.step;
  h || (Number.isFinite(r) ? Number.isFinite(i) ? h = +(Math.abs(i - r) / 100).toPrecision(1) : h = +(Math.abs(l - r) / 100).toPrecision(1) : Number.isFinite(i) && (h = +(Math.abs(i - l) / 100).toPrecision(1)));
  const p = h ? Cz(h) * 10 : Cz(l);
  h = h || p / 10;
  const y = Math.round(w0(Math.log10(1 / p), 0, 2));
  return {
    value: c ? l + c : l,
    settings: Tr({
      initialValue: l,
      step: h,
      pad: y,
      min: r,
      max: i,
      suffix: c
    }, o)
  };
}, $5 = (n, {
  step: e,
  initialValue: t
}) => {
  const r = Math.round((n - t) / e);
  return t + r * e;
};
var Y5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Lee,
  sanitize: W5,
  format: Oee,
  normalize: j5,
  sanitizeStep: $5
});
function Us() {
  return Us = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, Us.apply(this, arguments);
}
const X5 = vx({});
function Hc() {
  return Tx(X5);
}
const x3 = vx(null), q5 = vx(null), K5 = vx(null);
function Sw() {
  return Tx(q5);
}
function Pee() {
  return Tx(K5);
}
const Q5 = () => ({
  colors: {
    elevation1: "#292d39",
    elevation2: "#181c20",
    elevation3: "#373c4b",
    accent1: "#0066dc",
    accent2: "#007bff",
    accent3: "#3c93ff",
    highlight1: "#535760",
    highlight2: "#8c92a4",
    highlight3: "#fefefe",
    vivid1: "#ffcc00",
    folderWidgetColor: "$highlight2",
    folderTextColor: "$highlight3",
    toolTipBackground: "$highlight3",
    toolTipText: "$elevation2"
  },
  radii: {
    xs: "2px",
    sm: "3px",
    lg: "10px"
  },
  space: {
    xs: "3px",
    sm: "6px",
    md: "10px",
    rowGap: "7px",
    colGap: "7px"
  },
  fonts: {
    mono: "ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",
    sans: "system-ui, sans-serif"
  },
  fontSizes: {
    root: "11px",
    toolTip: "$root"
  },
  sizes: {
    rootWidth: "280px",
    controlWidth: "160px",
    numberInputMinWidth: "38px",
    scrubberWidth: "8px",
    scrubberHeight: "16px",
    rowHeight: "24px",
    folderTitleHeight: "20px",
    checkboxSize: "16px",
    joystickWidth: "100px",
    joystickHeight: "100px",
    colorPickerWidth: "$controlWidth",
    colorPickerHeight: "100px",
    imagePreviewWidth: "$controlWidth",
    imagePreviewHeight: "100px",
    monitorHeight: "60px",
    titleBarHeight: "39px"
  },
  shadows: {
    level1: "0 0 9px 0 #00000088",
    level2: "0 4px 14px #00000033"
  },
  borderWidths: {
    root: "0px",
    input: "1px",
    focus: "1px",
    hover: "1px",
    active: "1px",
    folder: "1px"
  },
  fontWeights: {
    label: "normal",
    folder: "normal",
    button: "normal"
  }
});
function oR(n, e) {
  const [t, r] = n.split(" "), i = {};
  return t !== "none" && (i.boxShadow = `${e.inset ? "inset " : ""}0 0 0 $borderWidths${[e.key]} $colors${t !== "default" && t || e.borderColor}`), r && (i.backgroundColor = r), i;
}
const gT = {
  $inputStyle: () => (n) => oR(n, {
    key: "$input",
    borderColor: "$highlight1",
    inset: !0
  }),
  $focusStyle: () => (n) => oR(n, {
    key: "$focus",
    borderColor: "$accent2"
  }),
  $hoverStyle: () => (n) => oR(n, {
    key: "$hover",
    borderColor: "$accent1",
    inset: !0
  }),
  $activeStyle: () => (n) => oR(n, {
    key: "$active",
    borderColor: "$accent1",
    inset: !0
  })
}, {
  styled: xr,
  css: Gae,
  createTheme: Uee,
  globalCss: Nee,
  keyframes: Wae
} = xZ({
  prefix: "leva",
  theme: Q5(),
  utils: Tr(Tr({}, gT), {}, {
    $flex: () => ({
      display: "flex",
      alignItems: "center"
    }),
    $flexCenter: () => ({
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }),
    $reset: () => ({
      outline: "none",
      fontSize: "inherit",
      fontWeight: "inherit",
      color: "inherit",
      fontFamily: "inherit",
      border: "none",
      backgroundColor: "transparent",
      appearance: "none"
    }),
    $draggable: () => ({
      touchAction: "none",
      WebkitUserDrag: "none",
      userSelect: "none"
    }),
    $focus: (n) => ({
      "&:focus": gT.$focusStyle()(n)
    }),
    $focusWithin: (n) => ({
      "&:focus-within": gT.$focusStyle()(n)
    }),
    $hover: (n) => ({
      "&:hover": gT.$hoverStyle()(n)
    }),
    $active: (n) => ({
      "&:active": gT.$activeStyle()(n)
    })
  })
}), Fee = Nee({
  ".leva__panel__dragged": {
    WebkitUserDrag: "none",
    userSelect: "none",
    input: {
      userSelect: "none"
    },
    "*": {
      cursor: "ew-resize !important"
    }
  }
});
function kee(n) {
  const e = Q5();
  if (!n)
    return {
      theme: e,
      className: ""
    };
  Object.keys(n).forEach((r) => {
    Object.assign(e[r], n[r]);
  });
  const t = Uee(e);
  return {
    theme: e,
    className: t.className
  };
}
function Wg(n, e) {
  const {
    theme: t
  } = Tx(x3);
  if (!(n in t) || !(e in t[n]))
    return Bg(os.THEME_ERROR, n, e), "";
  let r = e;
  for (; ; ) {
    let i = t[n][r];
    if (typeof i == "string" && i.charAt(0) === "$")
      r = i.substr(1);
    else
      return i;
  }
}
const Z5 = xr("input", {
  $reset: "",
  padding: "0 $sm",
  width: 0,
  minWidth: 0,
  flex: 1,
  height: "100%",
  variants: {
    levaType: {
      number: {
        textAlign: "right"
      }
    },
    as: {
      textarea: {
        padding: "$sm"
      }
    }
  }
}), J5 = xr("div", {
  $draggable: "",
  height: "100%",
  $flexCenter: "",
  position: "relative",
  padding: "0 $xs",
  fontSize: "0.8em",
  opacity: 0.8,
  cursor: "default",
  touchAction: "none",
  [`& + ${Z5}`]: {
    paddingLeft: 0
  }
}), zee = xr(J5, {
  cursor: "ew-resize",
  marginRight: "-$xs",
  textTransform: "uppercase",
  opacity: 0.3,
  "&:hover": {
    opacity: 1
  },
  variants: {
    dragging: {
      true: {
        backgroundColor: "$accent2",
        opacity: 1
      }
    }
  }
}), Iee = xr("div", {
  $flex: "",
  position: "relative",
  borderRadius: "$sm",
  overflow: "hidden",
  color: "inherit",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  $inputStyle: "$elevation1",
  $hover: "",
  $focusWithin: "",
  variants: {
    textArea: {
      true: {
        height: "auto"
      }
    }
  }
}), Bee = ["innerLabel", "value", "onUpdate", "onChange", "onKeyDown", "type", "id", "inputType", "rows"], Hee = ["onUpdate"];
function _3(n) {
  let {
    innerLabel: e,
    value: t,
    onUpdate: r,
    onChange: i,
    onKeyDown: o,
    type: l,
    id: c,
    inputType: h = "text",
    rows: p = 0
  } = n, y = Ya(n, Bee);
  const {
    id: x,
    emitOnEditStart: b,
    emitOnEditEnd: w,
    disabled: R
  } = Hc(), U = c || x, L = Sn(null), A = p > 0, F = A ? "textarea" : "input", k = Ir(($) => (Y) => {
    const J = Y.currentTarget.value;
    $(J);
  }, []);
  Fe.useEffect(() => {
    const $ = L.current, Y = k((J) => {
      r(J), w();
    });
    return $ == null || $.addEventListener("blur", Y), () => $ == null ? void 0 : $.removeEventListener("blur", Y);
  }, [k, r, w]);
  const H = Ir(($) => {
    $.key === "Enter" && k(r)($);
  }, [k, r]), B = Object.assign({
    as: F
  }, A ? {
    rows: p
  } : {}, y);
  return Fe.createElement(Iee, {
    textArea: A
  }, e && typeof e == "string" ? Fe.createElement(J5, null, e) : e, Fe.createElement(Z5, Us({
    levaType: l,
    ref: L,
    id: U,
    type: h,
    autoComplete: "off",
    spellCheck: "false",
    value: t,
    onChange: k(i),
    onFocus: () => b(),
    onKeyPress: H,
    onKeyDown: o,
    disabled: R
  }, B)));
}
function Vee(n) {
  let {
    onUpdate: e
  } = n, t = Ya(n, Hee);
  const r = Ir((o) => e(vee(o)), [e]), i = Ir((o) => {
    const l = o.key === "ArrowUp" ? 1 : o.key === "ArrowDown" ? -1 : 0;
    if (l) {
      o.preventDefault();
      const c = o.altKey ? 0.1 : o.shiftKey ? 10 : 1;
      e((h) => parseFloat(h) + l * c);
    }
  }, [e]);
  return Fe.createElement(_3, Us({}, t, {
    onUpdate: r,
    onKeyDown: i,
    type: "number"
  }));
}
const zR = xr("div", {}), QO = xr("div", {
  position: "relative",
  background: "$elevation2",
  transition: "height 300ms ease",
  variants: {
    fill: {
      true: {},
      false: {}
    },
    flat: {
      false: {},
      true: {}
    },
    isRoot: {
      true: {},
      false: {
        paddingLeft: "$md",
        "&::after": {
          content: '""',
          position: "absolute",
          left: 0,
          top: 0,
          width: "$borderWidths$folder",
          height: "100%",
          backgroundColor: "$folderWidgetColor",
          opacity: 0.4,
          transform: "translateX(-50%)"
        }
      }
    }
  },
  compoundVariants: [{
    isRoot: !0,
    fill: !1,
    css: {
      overflowY: "auto",
      maxHeight: "calc(100vh - 20px - $$titleBarHeight)"
    }
  }, {
    isRoot: !0,
    flat: !1,
    css: {
      borderRadius: "$lg"
    }
  }]
}), Gee = xr("div", {
  $flex: "",
  color: "$folderTextColor",
  userSelect: "none",
  cursor: "pointer",
  height: "$folderTitleHeight",
  fontWeight: "$folder",
  "> svg": {
    marginLeft: -4,
    marginRight: 4,
    cursor: "pointer",
    fill: "$folderWidgetColor",
    opacity: 0.6
  },
  "&:hover > svg": {
    fill: "$folderWidgetColor"
  },
  [`&:hover + ${QO}::after`]: {
    opacity: 0.6
  },
  [`${zR}:hover > & + ${QO}::after`]: {
    opacity: 0.6
  },
  [`${zR}:hover > & > svg`]: {
    opacity: 1
  }
}), eH = xr("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "100%",
  rowGap: "$rowGap",
  transition: "opacity 250ms ease",
  variants: {
    toggled: {
      true: {
        opacity: 1,
        transitionDelay: "250ms"
      },
      false: {
        opacity: 0,
        transitionDelay: "0ms",
        pointerEvents: "none"
      }
    },
    isRoot: {
      true: {
        "& > div": {
          paddingLeft: "$md",
          paddingRight: "$md"
        },
        "& > div:first-of-type": {
          paddingTop: "$sm"
        },
        "& > div:last-of-type": {
          paddingBottom: "$sm"
        },
        [`> ${zR}:not(:first-of-type)`]: {
          paddingTop: "$sm",
          marginTop: "$md",
          borderTop: "$borderWidths$folder solid $colors$elevation1"
        }
      }
    }
  }
}), tH = xr("div", {
  position: "relative",
  zIndex: 100,
  display: "grid",
  rowGap: "$rowGap",
  gridTemplateRows: "minmax($sizes$rowHeight, max-content)",
  alignItems: "center",
  color: "$highlight2",
  [`${eH} > &`]: {
    "&:first-of-type": {
      marginTop: "$rowGap"
    },
    "&:last-of-type": {
      marginBottom: "$rowGap"
    }
  },
  variants: {
    disabled: {
      true: {
        pointerEvents: "none"
      },
      false: {
        "&:hover,&:focus-within": {
          color: "$highlight3"
        }
      }
    }
  }
}), nH = xr(tH, {
  gridTemplateColumns: "auto $sizes$controlWidth",
  columnGap: "$colGap"
}), Wee = xr("div", {
  $flex: "",
  height: "100%",
  position: "relative",
  overflow: "hidden",
  "& > div": {
    marginLeft: "$colGap",
    padding: "0 $xs",
    opacity: 0.4
  },
  "& > div:hover": {
    opacity: 0.8
  },
  "& > div > svg": {
    display: "none",
    cursor: "pointer",
    width: 13,
    minWidth: 13,
    height: 13,
    backgroundColor: "$elevation2"
  },
  "&:hover > div > svg": {
    display: "block"
  },
  variants: {
    align: {
      top: {
        height: "100%",
        alignItems: "flex-start",
        paddingTop: "$sm"
      }
    }
  }
}), jee = xr("input", {
  $reset: "",
  height: 0,
  width: 0,
  opacity: 0,
  margin: 0,
  "& + label": {
    position: "relative",
    $flexCenter: "",
    height: "100%",
    userSelect: "none",
    cursor: "pointer",
    paddingLeft: 2,
    paddingRight: "$sm",
    pointerEvents: "auto"
  },
  "& + label:after": {
    content: '""',
    width: 6,
    height: 6,
    backgroundColor: "$elevation3",
    borderRadius: "50%",
    $activeStyle: ""
  },
  "&:focus + label:after": {
    $focusStyle: ""
  },
  "& + label:active:after": {
    backgroundColor: "$accent1",
    $focusStyle: ""
  },
  "&:checked + label:after": {
    backgroundColor: "$accent1"
  }
}), ZO = xr("label", {
  fontWeight: "$label",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "& > svg": {
    display: "block"
  }
}), $ee = xr("div", {
  opacity: 1,
  variants: {
    disabled: {
      true: {
        opacity: 0.6,
        pointerEvents: "none",
        [`& ${ZO}`]: {
          pointerEvents: "auto"
        }
      }
    }
  }
}), rH = xr("div", {
  position: "fixed",
  top: 0,
  bottom: 0,
  right: 0,
  left: 0,
  zIndex: 1e3,
  userSelect: "none"
}), Yee = xr("div", {
  background: "$toolTipBackground",
  fontFamily: "$sans",
  fontSize: "$toolTip",
  padding: "$xs $sm",
  color: "$toolTipText",
  borderRadius: "$xs",
  boxShadow: "$level2",
  maxWidth: 260
}), Xee = xr(see, {
  fill: "$toolTipBackground"
});
function E3({
  children: n
}) {
  const {
    className: e
  } = Tx(x3);
  return Fe.createElement(VQ, {
    className: e
  }, n);
}
const qee = ["align"];
function Kee() {
  const {
    id: n,
    disable: e,
    disabled: t
  } = Hc();
  return Fe.createElement(Fe.Fragment, null, Fe.createElement(jee, {
    id: n + "__disable",
    type: "checkbox",
    checked: !t,
    onChange: () => e(!t)
  }), Fe.createElement("label", {
    htmlFor: n + "__disable"
  }));
}
function Qee(n) {
  const {
    id: e,
    optional: t,
    hint: r
  } = Hc(), i = n.htmlFor || (e ? {
    htmlFor: e
  } : null), o = !r && typeof n.children == "string" ? {
    title: n.children
  } : null;
  return Fe.createElement(Fe.Fragment, null, t && Fe.createElement(Kee, null), r !== void 0 ? Fe.createElement(iee, null, Fe.createElement(aee, {
    asChild: !0
  }, Fe.createElement(ZO, Us({}, i, n))), Fe.createElement(oee, {
    side: "top",
    sideOffset: 2
  }, Fe.createElement(Yee, null, r, Fe.createElement(Xee, null)))) : Fe.createElement(ZO, Us({}, i, o, n)));
}
function ym(n) {
  let {
    align: e
  } = n, t = Ya(n, qee);
  const {
    value: r,
    label: i,
    key: o,
    disabled: l
  } = Hc(), {
    hideCopyButton: c
  } = Pee(), h = !c && o !== void 0, [p, y] = Ni(!1), x = async () => {
    try {
      await navigator.clipboard.writeText(JSON.stringify({
        [o]: r ?? ""
      })), y(!0);
    } catch {
      Bg(os.CLIPBOARD_ERROR, {
        [o]: r
      });
    }
  };
  return Fe.createElement(Wee, {
    align: e,
    onPointerLeave: () => y(!1)
  }, Fe.createElement(Qee, t), h && !l && Fe.createElement("div", {
    title: `Click to copy ${typeof i == "string" ? i : o} value`
  }, p ? Fe.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Fe.createElement("path", {
    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"
  }), Fe.createElement("path", {
    fillRule: "evenodd",
    d: "M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
    clipRule: "evenodd"
  })) : Fe.createElement("svg", {
    onClick: x,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Fe.createElement("path", {
    d: "M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"
  }), Fe.createElement("path", {
    d: "M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"
  }))));
}
const Zee = ["toggled"], Jee = xr("svg", {
  fill: "currentColor",
  transition: "transform 350ms ease, fill 250ms ease"
});
function b3(n) {
  let {
    toggled: e
  } = n, t = Ya(n, Zee);
  return Fe.createElement(Jee, Us({
    width: "9",
    height: "5",
    viewBox: "0 0 9 5",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      transform: `rotate(${e ? 0 : -90}deg)`
    }
  }, t), Fe.createElement("path", {
    d: "M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"
  }));
}
const ete = ["input"];
function gp(n) {
  let {
    input: e
  } = n, t = Ya(n, ete);
  return e ? Fe.createElement(nH, t) : Fe.createElement(tH, t);
}
function iH({
  value: n,
  type: e,
  settings: t,
  setValue: r
}) {
  const [i, o] = Ni(wz(e, n, t)), l = Sn(n), c = Sn(t);
  c.current = t;
  const h = Ir((y) => o(wz(e, y, c.current)), [e]), p = Ir((y) => {
    try {
      r(y);
    } catch (x) {
      const {
        type: b,
        previousValue: w
      } = x;
      if (b !== "LEVA_ERROR")
        throw x;
      h(w);
    }
  }, [h, r]);
  return tr(() => {
    ZT(n, l.current) || h(n), l.current = n;
  }, [n, h]), {
    displayValue: i,
    onChange: o,
    onUpdate: p
  };
}
function xw(n, e) {
  const {
    emitOnEditStart: t,
    emitOnEditEnd: r
  } = Hc();
  return CK((i) => {
    i.first && (document.body.classList.add("leva__panel__dragged"), t == null || t());
    const o = n(i);
    return i.last && (document.body.classList.remove("leva__panel__dragged"), r == null || r()), o;
  }, e);
}
function tte(n) {
  const e = Sn(null), t = Sn(null), r = Sn(!1);
  return tr(() => {
    const i = V5(() => {
      e.current.width = e.current.offsetWidth * window.devicePixelRatio, e.current.height = e.current.offsetHeight * window.devicePixelRatio, n(e.current, t.current);
    }, 250);
    return window.addEventListener("resize", i), r.current || (i(), r.current = !0), () => window.removeEventListener("resize", i);
  }, [n]), tr(() => {
    t.current = e.current.getContext("2d");
  }, []), [e, t];
}
function aH() {
  const n = Sn(null), e = Sn({
    x: 0,
    y: 0
  }), t = Ir((r) => {
    Object.assign(e.current, r), n.current && (n.current.style.transform = `translate3d(${e.current.x}px, ${e.current.y}px, 0)`);
  }, []);
  return [n, t];
}
const nte = ["__refCount"], UL = (n, e) => {
  if (!n[e])
    return null;
  const t = n[e];
  return Ya(t, nte);
};
function rte(n) {
  const e = Sw(), [t, r] = Ni(UL(e.getData(), n)), i = Ir((p) => e.setValueAtPath(n, p, !0), [n, e]), o = Ir((p) => e.setSettingsAtPath(n, p), [n, e]), l = Ir((p) => e.disableInputAtPath(n, p), [n, e]), c = Ir(() => e.emitOnEditStart(n), [n, e]), h = Ir(() => e.emitOnEditEnd(n), [n, e]);
  return tr(() => {
    r(UL(e.getData(), n));
    const p = e.useStore.subscribe((y) => UL(y.data, n), r, {
      equalityFn: vw
    });
    return () => p();
  }, [e, n]), [t, {
    set: i,
    setSettings: o,
    disable: l,
    storeId: e.storeId,
    emitOnEditStart: c,
    emitOnEditEnd: h
  }];
}
const ite = xr("div", {
  variants: {
    hasRange: {
      true: {
        position: "relative",
        display: "grid",
        gridTemplateColumns: "auto $sizes$numberInputMinWidth",
        columnGap: "$colGap",
        alignItems: "center"
      }
    }
  }
}), oH = xr("div", {
  position: "relative",
  width: "100%",
  height: 2,
  borderRadius: "$xs",
  backgroundColor: "$elevation1"
}), JO = xr("div", {
  position: "absolute",
  width: "$scrubberWidth",
  height: "$scrubberHeight",
  borderRadius: "$xs",
  boxShadow: "0 0 0 2px $colors$elevation2",
  backgroundColor: "$accent2",
  cursor: "pointer",
  $active: "none $accent1",
  $hover: "none $accent3",
  variants: {
    position: {
      left: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0,
        transform: "translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"
      },
      right: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0,
        transform: "translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"
      }
    }
  }
}), sH = xr("div", {
  position: "relative",
  $flex: "",
  height: "100%",
  cursor: "pointer",
  touchAction: "none"
}), lH = xr("div", {
  position: "absolute",
  height: "100%",
  backgroundColor: "$accent2"
});
function ate({
  value: n,
  min: e,
  max: t,
  onDrag: r,
  step: i,
  initialValue: o
}) {
  const l = Sn(null), c = Sn(null), h = Sn(0), p = Wg("sizes", "scrubberWidth"), y = xw(({
    event: b,
    first: w,
    xy: [R],
    movement: [U],
    memo: L
  }) => {
    if (w) {
      const {
        width: F,
        left: k
      } = l.current.getBoundingClientRect();
      h.current = F - parseFloat(p), L = (b == null ? void 0 : b.target) === c.current ? n : kR((R - k) / F, e, t);
    }
    const A = L + kR(U / h.current, 0, t - e);
    return r($5(A, {
      step: i,
      initialValue: o
    })), L;
  }), x = FR(n, e, t);
  return Fe.createElement(sH, Us({
    ref: l
  }, y()), Fe.createElement(oH, null, Fe.createElement(lH, {
    style: {
      left: 0,
      right: `${(1 - x) * 100}%`
    }
  })), Fe.createElement(JO, {
    ref: c,
    style: {
      left: `calc(${x} * (100% - ${p}))`
    }
  }));
}
const ote = Fe.memo(({
  label: n,
  onUpdate: e,
  step: t,
  innerLabelTrim: r
}) => {
  const [i, o] = Ni(!1), l = xw(({
    active: c,
    delta: [h],
    event: p,
    memo: y = 0
  }) => (o(c), y += h / 2, Math.abs(y) >= 1 && (e((x) => parseFloat(x) + Math.floor(y) * t * G5(p)), y = 0), y));
  return Fe.createElement(zee, Us({
    dragging: i,
    title: n.length > 1 ? n : ""
  }, l()), n.slice(0, r));
});
function uH({
  label: n,
  id: e,
  displayValue: t,
  onUpdate: r,
  onChange: i,
  settings: o,
  innerLabelTrim: l = 1
}) {
  const c = l > 0 && Fe.createElement(ote, {
    label: n,
    step: o.step,
    onUpdate: r,
    innerLabelTrim: l
  });
  return Fe.createElement(Vee, {
    id: e,
    value: String(t),
    onUpdate: r,
    onChange: i,
    innerLabel: c
  });
}
function ste() {
  const n = Hc(), {
    label: e,
    value: t,
    onUpdate: r,
    settings: i,
    id: o
  } = n, {
    min: l,
    max: c
  } = i, h = c !== 1 / 0 && l !== -1 / 0;
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, e), Fe.createElement(ite, {
    hasRange: h
  }, h && Fe.createElement(ate, Us({
    value: parseFloat(t),
    onDrag: r
  }, i)), Fe.createElement(uH, Us({}, n, {
    id: o,
    label: "value",
    innerLabelTrim: h ? 0 : 1
  }))));
}
const {
  sanitizeStep: lte
} = Y5, ute = Ya(Y5, ["sanitizeStep"]);
var cte = Tr({
  component: ste
}, ute);
const fte = (n, e) => Md().schema({
  options: Md().passesAnyOf(Md().object(), Md().array())
}).test(e), dte = (n, {
  values: e
}) => {
  if (e.indexOf(n) < 0)
    throw Error("Selected value doesn't match Select options");
  return n;
}, hte = (n, {
  values: e
}) => e.indexOf(n), pte = (n) => {
  let {
    value: e,
    options: t
  } = n, r, i;
  return Array.isArray(t) ? (i = t, r = t.map((o) => String(o))) : (i = Object.values(t), r = Object.keys(t)), "value" in n ? i.includes(e) || (r.unshift(String(e)), i.unshift(e)) : e = i[0], Object.values(t).includes(e) || (t[String(e)] = e), {
    value: e,
    settings: {
      keys: r,
      values: i
    }
  };
};
var mte = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: fte,
  sanitize: dte,
  format: hte,
  normalize: pte
});
const vte = xr("div", {
  $flexCenter: "",
  position: "relative",
  "> svg": {
    pointerEvents: "none",
    position: "absolute",
    right: "$md"
  }
}), eP = xr("select", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  opacity: 0
}), gte = xr("div", {
  display: "flex",
  alignItems: "center",
  width: "100%",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  padding: "0 $sm",
  cursor: "pointer",
  [`${eP}:focus + &`]: {
    $focusStyle: ""
  },
  [`${eP}:hover + &`]: {
    $hoverStyle: ""
  }
});
function yte({
  displayValue: n,
  value: e,
  onUpdate: t,
  id: r,
  settings: i,
  disabled: o
}) {
  const {
    keys: l,
    values: c
  } = i, h = Sn();
  return e === c[n] && (h.current = l[n]), Fe.createElement(vte, null, Fe.createElement(eP, {
    id: r,
    value: n,
    onChange: (p) => t(c[Number(p.currentTarget.value)]),
    disabled: o
  }, l.map((p, y) => Fe.createElement("option", {
    key: p,
    value: y
  }, p))), Fe.createElement(gte, null, h.current), Fe.createElement(b3, {
    toggled: !0
  }));
}
function Ste() {
  const {
    label: n,
    value: e,
    displayValue: t,
    onUpdate: r,
    id: i,
    disabled: o,
    settings: l
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(yte, {
    id: i,
    value: e,
    displayValue: t,
    onUpdate: r,
    settings: l,
    disabled: o
  }));
}
var xte = Tr({
  component: Ste
}, mte);
const _te = (n) => Md().string().test(n), Ete = (n) => {
  if (typeof n != "string")
    throw Error("Invalid string");
  return n;
}, bte = ({
  value: n,
  editable: e = !0,
  rows: t = !1
}) => ({
  value: n,
  settings: {
    editable: e,
    rows: typeof t == "number" ? t : t ? 5 : 0
  }
});
var Tte = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: _te,
  sanitize: Ete,
  normalize: bte
});
const wte = ["displayValue", "onUpdate", "onChange", "editable"], Mte = xr("div", {
  whiteSpace: "pre-wrap"
});
function Cte(n) {
  let {
    displayValue: e,
    onUpdate: t,
    onChange: r,
    editable: i = !0
  } = n, o = Ya(n, wte);
  return i ? Fe.createElement(_3, Us({
    value: e,
    onUpdate: t,
    onChange: r
  }, o)) : Fe.createElement(Mte, null, e);
}
function Rte() {
  const {
    label: n,
    settings: e,
    displayValue: t,
    onUpdate: r,
    onChange: i
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(Cte, Us({
    displayValue: t,
    onUpdate: r,
    onChange: i
  }, e)));
}
var Ate = Tr({
  component: Rte
}, Tte);
const Dte = (n) => Md().boolean().test(n), Lte = (n) => {
  if (typeof n != "boolean")
    throw Error("Invalid boolean");
  return n;
};
var Ote = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Dte,
  sanitize: Lte
});
const Pte = xr("div", {
  position: "relative",
  $flex: "",
  height: "$rowHeight",
  input: {
    $reset: "",
    height: 0,
    width: 0,
    opacity: 0,
    margin: 0
  },
  label: {
    position: "relative",
    $flexCenter: "",
    userSelect: "none",
    cursor: "pointer",
    height: "$checkboxSize",
    width: "$checkboxSize",
    backgroundColor: "$elevation3",
    borderRadius: "$sm",
    $hover: ""
  },
  "input:focus + label": {
    $focusStyle: ""
  },
  "input:focus:checked + label, input:checked + label:hover": {
    $hoverStyle: "$accent3"
  },
  "input + label:active": {
    backgroundColor: "$accent1"
  },
  "input:checked + label:active": {
    backgroundColor: "$accent1"
  },
  "label > svg": {
    display: "none",
    width: "90%",
    height: "90%",
    stroke: "$highlight3"
  },
  "input:checked + label": {
    backgroundColor: "$accent2"
  },
  "input:checked + label > svg": {
    display: "block"
  }
});
function Ute({
  value: n,
  onUpdate: e,
  id: t,
  disabled: r
}) {
  return Fe.createElement(Pte, null, Fe.createElement("input", {
    id: t,
    type: "checkbox",
    checked: n,
    onChange: (i) => e(i.currentTarget.checked),
    disabled: r
  }), Fe.createElement("label", {
    htmlFor: t
  }, Fe.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  }, Fe.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M5 13l4 4L19 7"
  }))));
}
function Nte() {
  const {
    label: n,
    value: e,
    onUpdate: t,
    disabled: r,
    id: i
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(Ute, {
    value: e,
    onUpdate: t,
    id: i,
    disabled: r
  }));
}
var Fte = Tr({
  component: Nte
}, Ote);
const kte = ["locked"];
function zte({
  value: n,
  id: e,
  valueKey: t,
  settings: r,
  onUpdate: i,
  innerLabelTrim: o
}) {
  const l = Sn(n[t]);
  l.current = n[t];
  const c = Ir((p) => i({
    [t]: H5({
      type: "NUMBER",
      value: l.current,
      settings: r
    }, p)
  }), [i, r, t]), h = iH({
    type: "NUMBER",
    value: n[t],
    settings: r,
    setValue: c
  });
  return Fe.createElement(uH, {
    id: e,
    label: t,
    value: n[t],
    displayValue: h.displayValue,
    onUpdate: h.onUpdate,
    onChange: h.onChange,
    settings: r,
    innerLabelTrim: o
  });
}
const Ite = xr("div", {
  display: "grid",
  columnGap: "$colGap",
  gridAutoFlow: "column dense",
  alignItems: "center",
  variants: {
    withLock: {
      true: {
        gridTemplateColumns: "10px auto",
        "> svg": {
          cursor: "pointer"
        }
      }
    }
  }
});
function Bte(n) {
  let {
    locked: e
  } = n, t = Ya(n, kte);
  return Fe.createElement("svg", Us({
    width: "10",
    height: "10",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), e ? Fe.createElement("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }) : Fe.createElement("path", {
    d: "M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function T3({
  value: n,
  onUpdate: e,
  settings: t,
  innerLabelTrim: r
}) {
  const {
    id: i,
    setSettings: o
  } = Hc(), {
    lock: l,
    locked: c
  } = t;
  return Fe.createElement(Ite, {
    withLock: l
  }, l && Fe.createElement(Bte, {
    locked: c,
    onClick: () => o({
      locked: !c
    })
  }), Object.keys(n).map((h, p) => Fe.createElement(zte, {
    id: p === 0 ? i : `${i}.${h}`,
    key: h,
    valueKey: h,
    value: n,
    settings: t[h],
    onUpdate: e,
    innerLabelTrim: r
  })));
}
const cH = (n, e) => {
  const t = {};
  let r = 0, i = 1 / 0;
  Object.entries(n).forEach(([o, l]) => {
    t[o] = j5(Tr({
      value: l
    }, e[o])).settings, r = Math.max(r, t[o].step), i = Math.min(i, t[o].pad);
  });
  for (let o in t) {
    const {
      step: l,
      min: c,
      max: h
    } = e[o] || {};
    !isFinite(l) && (!isFinite(c) || !isFinite(h)) && (t[o].step = r, t[o].pad = i);
  }
  return t;
}, Hte = ["lock"], Vte = ["value"];
function Gte(n) {
  const e = Md().array().length(n).every.number(), t = (r) => {
    if (!r || typeof r != "object")
      return !1;
    const i = Object.values(r);
    return i.length === n && i.every((o) => isFinite(o));
  };
  return (r) => e.test(r) || t(r);
}
function Wte(n) {
  return Array.isArray(n) ? "array" : "object";
}
function LT(n, e, t) {
  return Wte(n) === e ? n : e === "array" ? Object.values(n) : _ee(n, t);
}
const jte = (n, e, t) => {
  const r = LT(n, "object", e.keys);
  for (let l in r)
    r[l] = W5(r[l], e[l]);
  const i = Object.keys(r);
  let o = {};
  if (i.length === e.keys.length)
    o = r;
  else {
    const l = LT(t, "object", e.keys);
    if (i.length === 1 && e.locked) {
      const c = i[0], h = r[c], p = l[c], y = p !== 0 ? h / p : 1;
      for (let x in l)
        x === c ? o[c] = h : o[x] = l[x] * y;
    } else
      o = Tr(Tr({}, l), r);
  }
  return LT(o, e.format, e.keys);
}, $te = (n, e) => LT(n, "object", e.keys), Yte = (n) => !!n && ("step" in n || "min" in n || "max" in n);
function Xte(n, e, t = []) {
  const {
    lock: r = !1
  } = e, i = Ya(e, Hte), o = Array.isArray(n) ? "array" : "object", l = o === "object" ? Object.keys(n) : t, c = LT(n, "object", l), h = Yte(i) ? l.reduce((y, x) => Object.assign(y, {
    [x]: i
  }), {}) : i, p = cH(c, h);
  return {
    value: o === "array" ? n : c,
    settings: Tr(Tr({}, p), {}, {
      format: o,
      keys: l,
      lock: r,
      locked: !1
    })
  };
}
function fH(n) {
  return {
    schema: Gte(n.length),
    normalize: (e) => {
      let {
        value: t
      } = e, r = Ya(e, Vte);
      return Xte(t, r, n);
    },
    format: (e, t) => $te(e, t),
    sanitize: (e, t, r) => jte(e, t, r)
  };
}
var qte = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, Fg = function(n) {
  return typeof n == "string" ? n.length > 0 : typeof n == "number";
}, Mu = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * n) / t + 0;
}, hp = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 1), n > t ? t : n > e ? n : e;
}, dH = function(n) {
  return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
}, Nz = function(n) {
  return { r: hp(n.r, 0, 255), g: hp(n.g, 0, 255), b: hp(n.b, 0, 255), a: hp(n.a) };
}, NL = function(n) {
  return { r: Mu(n.r), g: Mu(n.g), b: Mu(n.b), a: Mu(n.a, 3) };
}, Kte = /^#([0-9a-f]{3,8})$/i, sR = function(n) {
  var e = n.toString(16);
  return e.length < 2 ? "0" + e : e;
}, hH = function(n) {
  var e = n.r, t = n.g, r = n.b, i = n.a, o = Math.max(e, t, r), l = o - Math.min(e, t, r), c = l ? o === e ? (t - r) / l : o === t ? 2 + (r - e) / l : 4 + (e - t) / l : 0;
  return { h: 60 * (c < 0 ? c + 6 : c), s: o ? l / o * 100 : 0, v: o / 255 * 100, a: i };
}, pH = function(n) {
  var e = n.h, t = n.s, r = n.v, i = n.a;
  e = e / 360 * 6, t /= 100, r /= 100;
  var o = Math.floor(e), l = r * (1 - t), c = r * (1 - (e - o) * t), h = r * (1 - (1 - e + o) * t), p = o % 6;
  return { r: 255 * [r, c, l, l, h, r][p], g: 255 * [h, r, r, c, l, l][p], b: 255 * [l, l, h, r, r, c][p], a: i };
}, Fz = function(n) {
  return { h: dH(n.h), s: hp(n.s, 0, 100), l: hp(n.l, 0, 100), a: hp(n.a) };
}, kz = function(n) {
  return { h: Mu(n.h), s: Mu(n.s), l: Mu(n.l), a: Mu(n.a, 3) };
}, zz = function(n) {
  return pH((t = (e = n).s, { h: e.h, s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0, v: r + t, a: e.a }));
  var e, t, r;
}, OT = function(n) {
  return { h: (e = hH(n)).h, s: (i = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? t * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0, l: i / 2, a: e.a };
  var e, t, r, i;
}, Qte = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Zte = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Jte = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ene = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, tP = { string: [[function(n) {
  var e = Kte.exec(n);
  return e ? (n = e[1]).length <= 4 ? { r: parseInt(n[0] + n[0], 16), g: parseInt(n[1] + n[1], 16), b: parseInt(n[2] + n[2], 16), a: n.length === 4 ? Mu(parseInt(n[3] + n[3], 16) / 255, 2) : 1 } : n.length === 6 || n.length === 8 ? { r: parseInt(n.substr(0, 2), 16), g: parseInt(n.substr(2, 2), 16), b: parseInt(n.substr(4, 2), 16), a: n.length === 8 ? Mu(parseInt(n.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(n) {
  var e = Jte.exec(n) || ene.exec(n);
  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Nz({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;
}, "rgb"], [function(n) {
  var e = Qte.exec(n) || Zte.exec(n);
  if (!e)
    return null;
  var t, r, i = Fz({ h: (t = e[1], r = e[2], r === void 0 && (r = "deg"), Number(t) * (qte[r] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });
  return zz(i);
}, "hsl"]], object: [[function(n) {
  var e = n.r, t = n.g, r = n.b, i = n.a, o = i === void 0 ? 1 : i;
  return Fg(e) && Fg(t) && Fg(r) ? Nz({ r: Number(e), g: Number(t), b: Number(r), a: Number(o) }) : null;
}, "rgb"], [function(n) {
  var e = n.h, t = n.s, r = n.l, i = n.a, o = i === void 0 ? 1 : i;
  if (!Fg(e) || !Fg(t) || !Fg(r))
    return null;
  var l = Fz({ h: Number(e), s: Number(t), l: Number(r), a: Number(o) });
  return zz(l);
}, "hsl"], [function(n) {
  var e = n.h, t = n.s, r = n.v, i = n.a, o = i === void 0 ? 1 : i;
  if (!Fg(e) || !Fg(t) || !Fg(r))
    return null;
  var l = function(c) {
    return { h: dH(c.h), s: hp(c.s, 0, 100), v: hp(c.v, 0, 100), a: hp(c.a) };
  }({ h: Number(e), s: Number(t), v: Number(r), a: Number(o) });
  return pH(l);
}, "hsv"]] }, Iz = function(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t][0](n);
    if (r)
      return [r, e[t][1]];
  }
  return [null, void 0];
}, mH = function(n) {
  return typeof n == "string" ? Iz(n.trim(), tP.string) : typeof n == "object" && n !== null ? Iz(n, tP.object) : [null, void 0];
}, tne = function(n) {
  return mH(n)[1];
}, FL = function(n, e) {
  var t = OT(n);
  return { h: t.h, s: hp(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
}, kL = function(n) {
  return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
}, Bz = function(n, e) {
  var t = OT(n);
  return { h: t.h, s: t.s, l: hp(t.l + 100 * e, 0, 100), a: t.a };
}, nP = function() {
  function n(e) {
    this.parsed = mH(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return n.prototype.isValid = function() {
    return this.parsed !== null;
  }, n.prototype.brightness = function() {
    return Mu(kL(this.rgba), 2);
  }, n.prototype.isDark = function() {
    return kL(this.rgba) < 0.5;
  }, n.prototype.isLight = function() {
    return kL(this.rgba) >= 0.5;
  }, n.prototype.toHex = function() {
    return e = NL(this.rgba), t = e.r, r = e.g, i = e.b, l = (o = e.a) < 1 ? sR(Mu(255 * o)) : "", "#" + sR(t) + sR(r) + sR(i) + l;
    var e, t, r, i, o, l;
  }, n.prototype.toRgb = function() {
    return NL(this.rgba);
  }, n.prototype.toRgbString = function() {
    return e = NL(this.rgba), t = e.r, r = e.g, i = e.b, (o = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + i + ", " + o + ")" : "rgb(" + t + ", " + r + ", " + i + ")";
    var e, t, r, i, o;
  }, n.prototype.toHsl = function() {
    return kz(OT(this.rgba));
  }, n.prototype.toHslString = function() {
    return e = kz(OT(this.rgba)), t = e.h, r = e.s, i = e.l, (o = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + i + "%, " + o + ")" : "hsl(" + t + ", " + r + "%, " + i + "%)";
    var e, t, r, i, o;
  }, n.prototype.toHsv = function() {
    return e = hH(this.rgba), { h: Mu(e.h), s: Mu(e.s), v: Mu(e.v), a: Mu(e.a, 3) };
    var e;
  }, n.prototype.invert = function() {
    return Uf({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
    var e;
  }, n.prototype.saturate = function(e) {
    return e === void 0 && (e = 0.1), Uf(FL(this.rgba, e));
  }, n.prototype.desaturate = function(e) {
    return e === void 0 && (e = 0.1), Uf(FL(this.rgba, -e));
  }, n.prototype.grayscale = function() {
    return Uf(FL(this.rgba, -1));
  }, n.prototype.lighten = function(e) {
    return e === void 0 && (e = 0.1), Uf(Bz(this.rgba, e));
  }, n.prototype.darken = function(e) {
    return e === void 0 && (e = 0.1), Uf(Bz(this.rgba, -e));
  }, n.prototype.rotate = function(e) {
    return e === void 0 && (e = 15), this.hue(this.hue() + e);
  }, n.prototype.alpha = function(e) {
    return typeof e == "number" ? Uf({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : Mu(this.rgba.a, 3);
    var t;
  }, n.prototype.hue = function(e) {
    var t = OT(this.rgba);
    return typeof e == "number" ? Uf({ h: e, s: t.s, l: t.l, a: t.a }) : Mu(t.h);
  }, n.prototype.isEqual = function(e) {
    return this.toHex() === Uf(e).toHex();
  }, n;
}(), Uf = function(n) {
  return n instanceof nP ? n : new nP(n);
}, Hz = [], nne = function(n) {
  n.forEach(function(e) {
    Hz.indexOf(e) < 0 && (e(nP, tP), Hz.push(e));
  });
};
function rne(n, e) {
  var t = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r = {};
  for (var i in t)
    r[t[i]] = i;
  var o = {};
  n.prototype.toName = function(l) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var c, h, p = r[this.toHex()];
    if (p)
      return p;
    if (l != null && l.closest) {
      var y = this.toRgb(), x = 1 / 0, b = "black";
      if (!o.length)
        for (var w in t)
          o[w] = new n(t[w]).toRgb();
      for (var R in t) {
        var U = (c = y, h = o[R], Math.pow(c.r - h.r, 2) + Math.pow(c.g - h.g, 2) + Math.pow(c.b - h.b, 2));
        U < x && (x = U, b = R);
      }
      return b;
    }
  }, e.string.push([function(l) {
    var c = l.toLowerCase(), h = c === "transparent" ? "#0000" : t[c];
    return h ? new n(h).toRgb() : null;
  }, "name"]);
}
function cE() {
  return (cE = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }).apply(this, arguments);
}
function w3(n, e) {
  if (n == null)
    return {};
  var t, r, i = {}, o = Object.keys(n);
  for (r = 0; r < o.length; r++)
    e.indexOf(t = o[r]) >= 0 || (i[t] = n[t]);
  return i;
}
function rP(n) {
  var e = Sn(n), t = Sn(function(r) {
    e.current && e.current(r);
  });
  return e.current = n, t.current;
}
var eE = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 1), n > t ? t : n < e ? e : n;
}, PT = function(n) {
  return "touches" in n;
}, iP = function(n) {
  return n && n.ownerDocument.defaultView || self;
}, Vz = function(n, e, t) {
  var r = n.getBoundingClientRect(), i = PT(e) ? function(o, l) {
    for (var c = 0; c < o.length; c++)
      if (o[c].identifier === l)
        return o[c];
    return o[0];
  }(e.touches, t) : e;
  return { left: eE((i.pageX - (r.left + iP(n).pageXOffset)) / r.width), top: eE((i.pageY - (r.top + iP(n).pageYOffset)) / r.height) };
}, Gz = function(n) {
  !PT(n) && n.preventDefault();
}, M3 = Fe.memo(function(n) {
  var e = n.onMove, t = n.onKey, r = w3(n, ["onMove", "onKey"]), i = Sn(null), o = rP(e), l = rP(t), c = Sn(null), h = Sn(!1), p = Rl(function() {
    var w = function(L) {
      Gz(L), (PT(L) ? L.touches.length > 0 : L.buttons > 0) && i.current ? o(Vz(i.current, L, c.current)) : U(!1);
    }, R = function() {
      return U(!1);
    };
    function U(L) {
      var A = h.current, F = iP(i.current), k = L ? F.addEventListener : F.removeEventListener;
      k(A ? "touchmove" : "mousemove", w), k(A ? "touchend" : "mouseup", R);
    }
    return [function(L) {
      var A = L.nativeEvent, F = i.current;
      if (F && (Gz(A), !function(H, B) {
        return B && !PT(H);
      }(A, h.current) && F)) {
        if (PT(A)) {
          h.current = !0;
          var k = A.changedTouches || [];
          k.length && (c.current = k[0].identifier);
        }
        F.focus(), o(Vz(F, A, c.current)), U(!0);
      }
    }, function(L) {
      var A = L.which || L.keyCode;
      A < 37 || A > 40 || (L.preventDefault(), l({ left: A === 39 ? 0.05 : A === 37 ? -0.05 : 0, top: A === 40 ? 0.05 : A === 38 ? -0.05 : 0 }));
    }, U];
  }, [l, o]), y = p[0], x = p[1], b = p[2];
  return tr(function() {
    return b;
  }, [b]), Fe.createElement("div", cE({}, r, { onTouchStart: y, onMouseDown: y, className: "react-colorful__interactive", ref: i, onKeyDown: x, tabIndex: 0, role: "slider" }));
}), _w = function(n) {
  return n.filter(Boolean).join(" ");
}, C3 = function(n) {
  var e = n.color, t = n.left, r = n.top, i = r === void 0 ? 0.5 : r, o = _w(["react-colorful__pointer", n.className]);
  return Fe.createElement("div", { className: o, style: { top: 100 * i + "%", left: 100 * t + "%" } }, Fe.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: e } }));
}, Nf = function(n, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * n) / t;
}, vH = function(n) {
  var e = n.s, t = n.v, r = n.a, i = (200 - e) * t / 100;
  return { h: Nf(n.h), s: Nf(i > 0 && i < 200 ? e * t / 100 / (i <= 100 ? i : 200 - i) * 100 : 0), l: Nf(i / 2), a: Nf(r, 2) };
}, aP = function(n) {
  var e = vH(n);
  return "hsl(" + e.h + ", " + e.s + "%, " + e.l + "%)";
}, zL = function(n) {
  var e = vH(n);
  return "hsla(" + e.h + ", " + e.s + "%, " + e.l + "%, " + e.a + ")";
}, gH = function(n) {
  var e = n.h, t = n.s, r = n.v, i = n.a;
  e = e / 360 * 6, t /= 100, r /= 100;
  var o = Math.floor(e), l = r * (1 - t), c = r * (1 - (e - o) * t), h = r * (1 - (1 - e + o) * t), p = o % 6;
  return { r: Nf(255 * [r, c, l, l, h, r][p]), g: Nf(255 * [h, r, r, c, l, l][p]), b: Nf(255 * [l, l, h, r, r, c][p]), a: Nf(i, 2) };
}, yH = function(n) {
  var e = n.r, t = n.g, r = n.b, i = n.a, o = Math.max(e, t, r), l = o - Math.min(e, t, r), c = l ? o === e ? (t - r) / l : o === t ? 2 + (r - e) / l : 4 + (e - t) / l : 0;
  return { h: Nf(60 * (c < 0 ? c + 6 : c)), s: Nf(o ? l / o * 100 : 0), v: Nf(o / 255 * 100), a: i };
}, SH = Fe.memo(function(n) {
  var e = n.hue, t = n.onChange, r = _w(["react-colorful__hue", n.className]);
  return Fe.createElement("div", { className: r }, Fe.createElement(M3, { onMove: function(i) {
    t({ h: 360 * i.left });
  }, onKey: function(i) {
    t({ h: eE(e + 360 * i.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": Nf(e), "aria-valuemax": "360", "aria-valuemin": "0" }, Fe.createElement(C3, { className: "react-colorful__hue-pointer", left: e / 360, color: aP({ h: e, s: 100, v: 100, a: 1 }) })));
}), xH = Fe.memo(function(n) {
  var e = n.hsva, t = n.onChange, r = { backgroundColor: aP({ h: e.h, s: 100, v: 100, a: 1 }) };
  return Fe.createElement("div", { className: "react-colorful__saturation", style: r }, Fe.createElement(M3, { onMove: function(i) {
    t({ s: 100 * i.left, v: 100 - 100 * i.top });
  }, onKey: function(i) {
    t({ s: eE(e.s + 100 * i.left, 0, 100), v: eE(e.v - 100 * i.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + Nf(e.s) + "%, Brightness " + Nf(e.v) + "%" }, Fe.createElement(C3, { className: "react-colorful__saturation-pointer", top: 1 - e.v / 100, left: e.s / 100, color: aP(e) })));
}), R3 = function(n, e) {
  if (n === e)
    return !0;
  for (var t in n)
    if (n[t] !== e[t])
      return !1;
  return !0;
};
function _H(n, e, t) {
  var r = rP(t), i = Ni(function() {
    return n.toHsva(e);
  }), o = i[0], l = i[1], c = Sn({ color: e, hsva: o });
  tr(function() {
    if (!n.equal(e, c.current.color)) {
      var p = n.toHsva(e);
      c.current = { hsva: p, color: e }, l(p);
    }
  }, [e, n]), tr(function() {
    var p;
    R3(o, c.current.hsva) || n.equal(p = n.fromHsva(o), c.current.color) || (c.current = { hsva: o, color: p }, r(p));
  }, [o, n, r]);
  var h = Ir(function(p) {
    l(function(y) {
      return Object.assign({}, y, p);
    });
  }, []);
  return [o, h];
}
var ine = typeof window < "u" ? M0 : tr, ane = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, Wz = /* @__PURE__ */ new Map(), EH = function(n) {
  ine(function() {
    var e = n.current ? n.current.ownerDocument : document;
    if (e !== void 0 && !Wz.has(e)) {
      var t = e.createElement("style");
      t.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, Wz.set(e, t);
      var r = ane();
      r && t.setAttribute("nonce", r), e.head.appendChild(t);
    }
  }, []);
}, one = function(n) {
  var e = n.className, t = n.colorModel, r = n.color, i = r === void 0 ? t.defaultColor : r, o = n.onChange, l = w3(n, ["className", "colorModel", "color", "onChange"]), c = Sn(null);
  EH(c);
  var h = _H(t, i, o), p = h[0], y = h[1], x = _w(["react-colorful", e]);
  return Fe.createElement("div", cE({}, l, { ref: c, className: x }), Fe.createElement(xH, { hsva: p, onChange: y }), Fe.createElement(SH, { hue: p.h, onChange: y, className: "react-colorful__last-control" }));
}, sne = function(n) {
  var e = n.className, t = n.hsva, r = n.onChange, i = { backgroundImage: "linear-gradient(90deg, " + zL(Object.assign({}, t, { a: 0 })) + ", " + zL(Object.assign({}, t, { a: 1 })) + ")" }, o = _w(["react-colorful__alpha", e]), l = Nf(100 * t.a);
  return Fe.createElement("div", { className: o }, Fe.createElement("div", { className: "react-colorful__alpha-gradient", style: i }), Fe.createElement(M3, { onMove: function(c) {
    r({ a: c.left });
  }, onKey: function(c) {
    r({ a: eE(t.a + c.left) });
  }, "aria-label": "Alpha", "aria-valuetext": l + "%", "aria-valuenow": l, "aria-valuemin": "0", "aria-valuemax": "100" }, Fe.createElement(C3, { className: "react-colorful__alpha-pointer", left: t.a, color: zL(t) })));
}, lne = function(n) {
  var e = n.className, t = n.colorModel, r = n.color, i = r === void 0 ? t.defaultColor : r, o = n.onChange, l = w3(n, ["className", "colorModel", "color", "onChange"]), c = Sn(null);
  EH(c);
  var h = _H(t, i, o), p = h[0], y = h[1], x = _w(["react-colorful", e]);
  return Fe.createElement("div", cE({}, l, { ref: c, className: x }), Fe.createElement(xH, { hsva: p, onChange: y }), Fe.createElement(SH, { hue: p.h, onChange: y }), Fe.createElement(sne, { hsva: p, onChange: y, className: "react-colorful__last-control" }));
}, une = { defaultColor: { r: 0, g: 0, b: 0, a: 1 }, toHsva: yH, fromHsva: gH, equal: R3 }, cne = function(n) {
  return Fe.createElement(lne, cE({}, n, { colorModel: une }));
}, fne = { defaultColor: { r: 0, g: 0, b: 0 }, toHsva: function(n) {
  return yH({ r: n.r, g: n.g, b: n.b, a: 1 });
}, fromHsva: function(n) {
  return { r: (e = gH(n)).r, g: e.g, b: e.b };
  var e;
}, equal: R3 }, dne = function(n) {
  return Fe.createElement(one, cE({}, n, { colorModel: fne }));
};
function fE(n, e, t, r) {
  function i(o) {
    return o instanceof t ? o : new t(function(l) {
      l(o);
    });
  }
  return new (t || (t = Promise))(function(o, l) {
    function c(y) {
      try {
        p(r.next(y));
      } catch (x) {
        l(x);
      }
    }
    function h(y) {
      try {
        p(r.throw(y));
      } catch (x) {
        l(x);
      }
    }
    function p(y) {
      y.done ? o(y.value) : i(y.value).then(c, h);
    }
    p((r = r.apply(n, e || [])).next());
  });
}
function dE(n, e) {
  var t = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, l;
  return l = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
    return this;
  }), l;
  function c(p) {
    return function(y) {
      return h([p, y]);
    };
  }
  function h(p) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; l && (l = 0, p[0] && (t = 0)), t; )
      try {
        if (r = 1, i && (o = p[0] & 2 ? i.return : p[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, p[1])).done)
          return o;
        switch (i = 0, o && (p = [p[0] & 2, o.value]), p[0]) {
          case 0:
          case 1:
            o = p;
            break;
          case 4:
            return t.label++, { value: p[1], done: !1 };
          case 5:
            t.label++, i = p[1], p = [0];
            continue;
          case 7:
            p = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (o = t.trys, !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2)) {
              t = 0;
              continue;
            }
            if (p[0] === 3 && (!o || p[1] > o[0] && p[1] < o[3])) {
              t.label = p[1];
              break;
            }
            if (p[0] === 6 && t.label < o[1]) {
              t.label = o[1], o = p;
              break;
            }
            if (o && t.label < o[2]) {
              t.label = o[2], t.ops.push(p);
              break;
            }
            o[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        p = e.call(n, t);
      } catch (y) {
        p = [6, y], i = 0;
      } finally {
        r = o = 0;
      }
    if (p[0] & 5)
      throw p[1];
    return { value: p[0] ? p[1] : void 0, done: !0 };
  }
}
function hne(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var r = t.call(n), i, o = [], l;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      o.push(i.value);
  } catch (c) {
    l = { error: c };
  } finally {
    try {
      i && !i.done && (t = r.return) && t.call(r);
    } finally {
      if (l)
        throw l.error;
    }
  }
  return o;
}
function pne() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(hne(arguments[e]));
  return n;
}
var mne = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function Ew(n, e) {
  var t = vne(n);
  if (typeof t.path != "string") {
    var r = n.webkitRelativePath;
    Object.defineProperty(t, "path", {
      value: typeof e == "string" ? e : typeof r == "string" && r.length > 0 ? r : n.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return t;
}
function vne(n) {
  var e = n.name, t = e && e.lastIndexOf(".") !== -1;
  if (t && !n.type) {
    var r = e.split(".").pop().toLowerCase(), i = mne.get(r);
    i && Object.defineProperty(n, "type", {
      value: i,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
var gne = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function yne(n) {
  return fE(this, void 0, void 0, function() {
    return dE(this, function(e) {
      return IR(n) && Sne(n) ? [2, bne(n.dataTransfer, n.type)] : xne(n) ? [2, _ne(n)] : Array.isArray(n) && n.every(function(t) {
        return "getFile" in t && typeof t.getFile == "function";
      }) ? [2, Ene(n)] : [2, []];
    });
  });
}
function Sne(n) {
  return IR(n.dataTransfer);
}
function xne(n) {
  return IR(n) && IR(n.target);
}
function IR(n) {
  return typeof n == "object" && n !== null;
}
function _ne(n) {
  return oP(n.target.files).map(function(e) {
    return Ew(e);
  });
}
function Ene(n) {
  return fE(this, void 0, void 0, function() {
    var e;
    return dE(this, function(t) {
      switch (t.label) {
        case 0:
          return [4, Promise.all(n.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return e = t.sent(), [2, e.map(function(r) {
            return Ew(r);
          })];
      }
    });
  });
}
function bne(n, e) {
  return fE(this, void 0, void 0, function() {
    var t, r;
    return dE(this, function(i) {
      switch (i.label) {
        case 0:
          return n === null ? [2, []] : n.items ? (t = oP(n.items).filter(function(o) {
            return o.kind === "file";
          }), e !== "drop" ? [2, t] : [4, Promise.all(t.map(Tne))]) : [3, 2];
        case 1:
          return r = i.sent(), [2, jz(bH(r))];
        case 2:
          return [2, jz(oP(n.files).map(function(o) {
            return Ew(o);
          }))];
      }
    });
  });
}
function jz(n) {
  return n.filter(function(e) {
    return gne.indexOf(e.name) === -1;
  });
}
function oP(n) {
  if (n === null)
    return [];
  for (var e = [], t = 0; t < n.length; t++) {
    var r = n[t];
    e.push(r);
  }
  return e;
}
function Tne(n) {
  if (typeof n.webkitGetAsEntry != "function")
    return $z(n);
  var e = n.webkitGetAsEntry();
  return e && e.isDirectory ? TH(e) : $z(n);
}
function bH(n) {
  return n.reduce(function(e, t) {
    return pne(e, Array.isArray(t) ? bH(t) : [t]);
  }, []);
}
function $z(n) {
  var e = n.getAsFile();
  if (!e)
    return Promise.reject(n + " is not a File");
  var t = Ew(e);
  return Promise.resolve(t);
}
function wne(n) {
  return fE(this, void 0, void 0, function() {
    return dE(this, function(e) {
      return [2, n.isDirectory ? TH(n) : Mne(n)];
    });
  });
}
function TH(n) {
  var e = n.createReader();
  return new Promise(function(t, r) {
    var i = [];
    function o() {
      var l = this;
      e.readEntries(function(c) {
        return fE(l, void 0, void 0, function() {
          var h, p, y;
          return dE(this, function(x) {
            switch (x.label) {
              case 0:
                if (c.length)
                  return [3, 5];
                x.label = 1;
              case 1:
                return x.trys.push([1, 3, , 4]), [4, Promise.all(i)];
              case 2:
                return h = x.sent(), t(h), [3, 4];
              case 3:
                return p = x.sent(), r(p), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                y = Promise.all(c.map(wne)), i.push(y), o(), x.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(c) {
        r(c);
      });
    }
    o();
  });
}
function Mne(n) {
  return fE(this, void 0, void 0, function() {
    return dE(this, function(e) {
      return [2, new Promise(function(t, r) {
        n.file(function(i) {
          var o = Ew(i, n.fullPath);
          t(o);
        }, function(i) {
          r(i);
        });
      })];
    });
  });
}
var Cne = function(n, e) {
  if (n && e) {
    var t = Array.isArray(e) ? e : e.split(","), r = n.name || "", i = (n.type || "").toLowerCase(), o = i.replace(/\/.*$/, "");
    return t.some(function(l) {
      var c = l.trim().toLowerCase();
      return c.charAt(0) === "." ? r.toLowerCase().endsWith(c) : c.endsWith("/*") ? o === c.replace(/\/.*$/, "") : i === c;
    });
  }
  return !0;
};
function Yz(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Xz(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Yz(Object(t), !0).forEach(function(r) {
      wH(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Yz(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function wH(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function qz(n, e) {
  return Lne(n) || Dne(n, e) || Ane(n, e) || Rne();
}
function Rne() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ane(n, e) {
  if (n) {
    if (typeof n == "string")
      return Kz(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Kz(n, e);
  }
}
function Kz(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function Dne(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], i = !0, o = !1, l, c;
    try {
      for (t = t.call(n); !(i = (l = t.next()).done) && (r.push(l.value), !(e && r.length === e)); i = !0)
        ;
    } catch (h) {
      o = !0, c = h;
    } finally {
      try {
        !i && t.return != null && t.return();
      } finally {
        if (o)
          throw c;
      }
    }
    return r;
  }
}
function Lne(n) {
  if (Array.isArray(n))
    return n;
}
var One = "file-invalid-type", Pne = "file-too-large", Une = "file-too-small", Nne = "too-many-files", Fne = function(e) {
  e = Array.isArray(e) && e.length === 1 ? e[0] : e;
  var t = Array.isArray(e) ? "one of ".concat(e.join(", ")) : e;
  return {
    code: One,
    message: "File type must be ".concat(t)
  };
}, Qz = function(e) {
  return {
    code: Pne,
    message: "File is larger than ".concat(e, " ").concat(e === 1 ? "byte" : "bytes")
  };
}, Zz = function(e) {
  return {
    code: Une,
    message: "File is smaller than ".concat(e, " ").concat(e === 1 ? "byte" : "bytes")
  };
}, kne = {
  code: Nne,
  message: "Too many files"
};
function MH(n, e) {
  var t = n.type === "application/x-moz-file" || Cne(n, e);
  return [t, t ? null : Fne(e)];
}
function CH(n, e, t) {
  if (yT(n.size))
    if (yT(e) && yT(t)) {
      if (n.size > t)
        return [!1, Qz(t)];
      if (n.size < e)
        return [!1, Zz(e)];
    } else {
      if (yT(e) && n.size < e)
        return [!1, Zz(e)];
      if (yT(t) && n.size > t)
        return [!1, Qz(t)];
    }
  return [!0, null];
}
function yT(n) {
  return n != null;
}
function zne(n) {
  var e = n.files, t = n.accept, r = n.minSize, i = n.maxSize, o = n.multiple, l = n.maxFiles;
  return !o && e.length > 1 || o && l >= 1 && e.length > l ? !1 : e.every(function(c) {
    var h = MH(c, t), p = qz(h, 1), y = p[0], x = CH(c, r, i), b = qz(x, 1), w = b[0];
    return y && w;
  });
}
function BR(n) {
  return typeof n.isPropagationStopped == "function" ? n.isPropagationStopped() : typeof n.cancelBubble < "u" ? n.cancelBubble : !1;
}
function lR(n) {
  return n.dataTransfer ? Array.prototype.some.call(n.dataTransfer.types, function(e) {
    return e === "Files" || e === "application/x-moz-file";
  }) : !!n.target && !!n.target.files;
}
function Jz(n) {
  n.preventDefault();
}
function Ine(n) {
  return n.indexOf("MSIE") !== -1 || n.indexOf("Trident/") !== -1;
}
function Bne(n) {
  return n.indexOf("Edge/") !== -1;
}
function Hne() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return Ine(n) || Bne(n);
}
function Sv() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return function(r) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), l = 1; l < i; l++)
      o[l - 1] = arguments[l];
    return e.some(function(c) {
      return !BR(r) && c && c.apply(void 0, [r].concat(o)), BR(r);
    });
  };
}
function Vne() {
  return "showOpenFilePicker" in window;
}
function Gne(n) {
  return n = typeof n == "string" ? n.split(",") : n, [{
    description: "everything",
    // TODO: Need to handle filtering more elegantly than this!
    accept: Array.isArray(n) ? (
      // Accept just MIME types as per spec
      // NOTE: accept can be https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#unique_file_type_specifiers
      n.filter(function(e) {
        return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e);
      }).reduce(function(e, t) {
        return Xz(Xz({}, e), {}, wH({}, t, []));
      }, {})
    ) : {}
  }];
}
function Wne(n) {
  return n instanceof DOMException && (n.name === "AbortError" || n.code === n.ABORT_ERR);
}
function jne(n) {
  return n instanceof DOMException && (n.name === "SecurityError" || n.code === n.SECURITY_ERR);
}
var $ne = ["children"], Yne = ["open"], Xne = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], qne = ["refKey", "onChange", "onClick"];
function Kne(n) {
  return Jne(n) || Zne(n) || RH(n) || Qne();
}
function Qne() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Zne(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function Jne(n) {
  if (Array.isArray(n))
    return sP(n);
}
function IL(n, e) {
  return nre(n) || tre(n, e) || RH(n, e) || ere();
}
function ere() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function RH(n, e) {
  if (n) {
    if (typeof n == "string")
      return sP(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return sP(n, e);
  }
}
function sP(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function tre(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], i = !0, o = !1, l, c;
    try {
      for (t = t.call(n); !(i = (l = t.next()).done) && (r.push(l.value), !(e && r.length === e)); i = !0)
        ;
    } catch (h) {
      o = !0, c = h;
    } finally {
      try {
        !i && t.return != null && t.return();
      } finally {
        if (o)
          throw c;
      }
    }
    return r;
  }
}
function nre(n) {
  if (Array.isArray(n))
    return n;
}
function eI(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function as(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? eI(Object(t), !0).forEach(function(r) {
      lP(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : eI(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function lP(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function HR(n, e) {
  if (n == null)
    return {};
  var t = rre(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
function rre(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
var A3 = /* @__PURE__ */ Cu(function(n, e) {
  var t = n.children, r = HR(n, $ne), i = D3(r), o = i.open, l = HR(i, Yne);
  return pP(e, function() {
    return {
      open: o
    };
  }, [o]), /* @__PURE__ */ Fe.createElement(yI, null, t(as(as({}, l), {}, {
    open: o
  })));
});
A3.displayName = "Dropzone";
var AH = {
  disabled: !1,
  getFilesFromEvent: yne,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0
};
A3.defaultProps = AH;
A3.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: vo.func,
  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: vo.oneOfType([vo.string, vo.arrayOf(vo.string)]),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: vo.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: vo.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: vo.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: vo.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: vo.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: vo.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: vo.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: vo.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: vo.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: vo.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: vo.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: vo.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: vo.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: vo.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: vo.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: vo.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: vo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: vo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: vo.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: vo.func,
  /**
   * Custom validation function
   * @param {File} file
   * @returns {FileError|FileError[]}
   */
  validator: vo.func
};
var uP = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
function D3() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = as(as({}, AH), n), t = e.accept, r = e.disabled, i = e.getFilesFromEvent, o = e.maxSize, l = e.minSize, c = e.multiple, h = e.maxFiles, p = e.onDragEnter, y = e.onDragLeave, x = e.onDragOver, b = e.onDrop, w = e.onDropAccepted, R = e.onDropRejected, U = e.onFileDialogCancel, L = e.onFileDialogOpen, A = e.useFsAccessApi, F = e.preventDropOnDocument, k = e.noClick, H = e.noKeyboard, B = e.noDrag, $ = e.noDragEventsBubbling, Y = e.validator, J = Rl(function() {
    return typeof L == "function" ? L : tI;
  }, [L]), K = Rl(function() {
    return typeof U == "function" ? U : tI;
  }, [U]), X = Sn(null), le = Sn(null), oe = dP(ire, uP), fe = IL(oe, 2), de = fe[0], xe = fe[1], _e = de.isFocused, Pe = de.isFileDialogActive, ce = de.draggedFiles, ve = Sn(typeof window < "u" && window.isSecureContext && A && Vne()), re = function() {
    !ve.current && Pe && setTimeout(function() {
      if (le.current) {
        var ne = le.current.files;
        ne.length || (xe({
          type: "closeDialog"
        }), K());
      }
    }, 300);
  };
  tr(function() {
    return window.addEventListener("focus", re, !1), function() {
      window.removeEventListener("focus", re, !1);
    };
  }, [le, Pe, K, ve]);
  var ee = Sn([]), he = function(ne) {
    X.current && X.current.contains(ne.target) || (ne.preventDefault(), ee.current = []);
  };
  tr(function() {
    return F && (document.addEventListener("dragover", Jz, !1), document.addEventListener("drop", he, !1)), function() {
      F && (document.removeEventListener("dragover", Jz), document.removeEventListener("drop", he));
    };
  }, [X, F]);
  var Me = Ir(function(ie) {
    ie.preventDefault(), ie.persist(), $e(ie), ee.current = [].concat(Kne(ee.current), [ie.target]), lR(ie) && Promise.resolve(i(ie)).then(function(ne) {
      BR(ie) && !$ || (xe({
        draggedFiles: ne,
        isDragActive: !0,
        type: "setDraggedFiles"
      }), p && p(ie));
    });
  }, [i, p, $]), Le = Ir(function(ie) {
    ie.preventDefault(), ie.persist(), $e(ie);
    var ne = lR(ie);
    if (ne && ie.dataTransfer)
      try {
        ie.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return ne && x && x(ie), !1;
  }, [x, $]), Ae = Ir(function(ie) {
    ie.preventDefault(), ie.persist(), $e(ie);
    var ne = ee.current.filter(function(_t) {
      return X.current && X.current.contains(_t);
    }), Oe = ne.indexOf(ie.target);
    Oe !== -1 && ne.splice(Oe, 1), ee.current = ne, !(ne.length > 0) && (xe({
      isDragActive: !1,
      type: "setDraggedFiles",
      draggedFiles: []
    }), lR(ie) && y && y(ie));
  }, [X, y, $]), Ue = Ir(function(ie, ne) {
    var Oe = [], _t = [];
    ie.forEach(function(ot) {
      var at = MH(ot, t), Wt = IL(at, 2), Dt = Wt[0], Se = Wt[1], He = CH(ot, l, o), lt = IL(He, 2), St = lt[0], Je = lt[1], be = Y ? Y(ot) : null;
      if (Dt && St && !be)
        Oe.push(ot);
      else {
        var Ze = [Se, Je];
        be && (Ze = Ze.concat(be)), _t.push({
          file: ot,
          errors: Ze.filter(function(ct) {
            return ct;
          })
        });
      }
    }), (!c && Oe.length > 1 || c && h >= 1 && Oe.length > h) && (Oe.forEach(function(ot) {
      _t.push({
        file: ot,
        errors: [kne]
      });
    }), Oe.splice(0)), xe({
      acceptedFiles: Oe,
      fileRejections: _t,
      type: "setFiles"
    }), b && b(Oe, _t, ne), _t.length > 0 && R && R(_t, ne), Oe.length > 0 && w && w(Oe, ne);
  }, [xe, c, t, l, o, h, b, w, R, Y]), Ne = Ir(function(ie) {
    ie.preventDefault(), ie.persist(), $e(ie), ee.current = [], lR(ie) && Promise.resolve(i(ie)).then(function(ne) {
      BR(ie) && !$ || Ue(ne, ie);
    }), xe({
      type: "reset"
    });
  }, [i, Ue, $]), ke = Ir(function() {
    if (ve.current) {
      xe({
        type: "openDialog"
      }), J();
      var ie = {
        multiple: c,
        types: Gne(t)
      };
      window.showOpenFilePicker(ie).then(function(ne) {
        return i(ne);
      }).then(function(ne) {
        Ue(ne, null), xe({
          type: "closeDialog"
        });
      }).catch(function(ne) {
        Wne(ne) ? (K(ne), xe({
          type: "closeDialog"
        })) : jne(ne) && (ve.current = !1, le.current && (le.current.value = null, le.current.click()));
      });
      return;
    }
    le.current && (xe({
      type: "openDialog"
    }), J(), le.current.value = null, le.current.click());
  }, [xe, J, K, A, Ue, t, c]), it = Ir(function(ie) {
    !X.current || !X.current.isEqualNode(ie.target) || (ie.key === " " || ie.key === "Enter" || ie.keyCode === 32 || ie.keyCode === 13) && (ie.preventDefault(), ke());
  }, [X, ke]), At = Ir(function() {
    xe({
      type: "focus"
    });
  }, []), rt = Ir(function() {
    xe({
      type: "blur"
    });
  }, []), ae = Ir(function() {
    k || (Hne() ? setTimeout(ke, 0) : ke());
  }, [k, ke]), et = function(ne) {
    return r ? null : ne;
  }, Ye = function(ne) {
    return H ? null : et(ne);
  }, Ge = function(ne) {
    return B ? null : et(ne);
  }, $e = function(ne) {
    $ && ne.stopPropagation();
  }, Ut = Rl(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ne = ie.refKey, Oe = ne === void 0 ? "ref" : ne, _t = ie.role, ot = ie.onKeyDown, at = ie.onFocus, Wt = ie.onBlur, Dt = ie.onClick, Se = ie.onDragEnter, He = ie.onDragOver, lt = ie.onDragLeave, St = ie.onDrop, Je = HR(ie, Xne);
      return as(as(lP({
        onKeyDown: Ye(Sv(ot, it)),
        onFocus: Ye(Sv(at, At)),
        onBlur: Ye(Sv(Wt, rt)),
        onClick: et(Sv(Dt, ae)),
        onDragEnter: Ge(Sv(Se, Me)),
        onDragOver: Ge(Sv(He, Le)),
        onDragLeave: Ge(Sv(lt, Ae)),
        onDrop: Ge(Sv(St, Ne)),
        role: typeof _t == "string" && _t !== "" ? _t : "button"
      }, Oe, X), !r && !H ? {
        tabIndex: 0
      } : {}), Je);
    };
  }, [X, it, At, rt, ae, Me, Le, Ae, Ne, H, B, r]), nt = Ir(function(ie) {
    ie.stopPropagation();
  }, []), Ct = Rl(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ne = ie.refKey, Oe = ne === void 0 ? "ref" : ne, _t = ie.onChange, ot = ie.onClick, at = HR(ie, qne), Wt = lP({
        accept: t,
        multiple: c,
        type: "file",
        style: {
          display: "none"
        },
        onChange: et(Sv(_t, Ne)),
        onClick: et(Sv(ot, nt)),
        tabIndex: -1
      }, Oe, le);
      return as(as({}, Wt), at);
    };
  }, [le, t, c, Ne, r]), Pt = ce.length, vt = Pt > 0 && zne({
    files: ce,
    accept: t,
    minSize: l,
    maxSize: o,
    multiple: c,
    maxFiles: h
  }), Zt = Pt > 0 && !vt;
  return as(as({}, de), {}, {
    isDragAccept: vt,
    isDragReject: Zt,
    isFocused: _e && !r,
    getRootProps: Ut,
    getInputProps: Ct,
    rootRef: X,
    inputRef: le,
    open: et(ke)
  });
}
function ire(n, e) {
  switch (e.type) {
    case "focus":
      return as(as({}, n), {}, {
        isFocused: !0
      });
    case "blur":
      return as(as({}, n), {}, {
        isFocused: !1
      });
    case "openDialog":
      return as(as({}, uP), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return as(as({}, n), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      var t = e.isDragActive, r = e.draggedFiles;
      return as(as({}, n), {}, {
        draggedFiles: r,
        isDragActive: t
      });
    case "setFiles":
      return as(as({}, n), {}, {
        acceptedFiles: e.acceptedFiles,
        fileRejections: e.fileRejections
      });
    case "reset":
      return as({}, uP);
    default:
      return n;
  }
}
function tI() {
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var are = function(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === !1;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var ore = are;
function nI(n) {
  return ore(n) === !0 && Object.prototype.toString.call(n) === "[object Object]";
}
var DH = function(e) {
  var t, r;
  return !(nI(e) === !1 || (t = e.constructor, typeof t != "function") || (r = t.prototype, nI(r) === !1) || r.hasOwnProperty("isPrototypeOf") === !1);
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var sre = DH, L3 = function(e) {
  return sre(e) || typeof e == "function" || Array.isArray(e);
};
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var lre = function(e, t, r) {
  for (var i in e)
    if (t.call(r, e[i], i, e) === !1)
      break;
}, ure = L3, cre = lre;
function LH(n, e) {
  for (var t = arguments.length, r = 0; ++r < t; ) {
    var i = arguments[r];
    cP(i) && cre(i, fre, n);
  }
  return n;
}
function fre(n, e) {
  if (dre(e)) {
    var t = this[e];
    cP(n) && cP(t) ? LH(t, n) : this[e] = n;
  }
}
function cP(n) {
  return ure(n) && !Array.isArray(n);
}
function dre(n) {
  return n !== "__proto__" && n !== "constructor" && n !== "prototype";
}
var hre = LH;
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var pre = function(n, e, t, r, i) {
  if (!mre(n) || !e)
    return n;
  if (e = uR(e), t && (e += "." + uR(t)), r && (e += "." + uR(r)), i && (e += "." + uR(i)), e in n)
    return n[e];
  for (var o = e.split("."), l = o.length, c = -1; n && ++c < l; ) {
    for (var h = o[c]; h[h.length - 1] === "\\"; )
      h = h.slice(0, -1) + "." + o[++c];
    n = n[h];
  }
  return n;
};
function mre(n) {
  return n !== null && (typeof n == "object" || typeof n == "function");
}
function uR(n) {
  return n ? Array.isArray(n) ? n.join(".") : n : "";
}
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var vre = function(n, e) {
  if (n === null || typeof n > "u")
    throw new TypeError("expected first argument to be an object.");
  if (typeof e > "u" || typeof Symbol > "u" || typeof Object.getOwnPropertySymbols != "function")
    return n;
  for (var t = Object.prototype.propertyIsEnumerable, r = Object(n), i = arguments.length, o = 0; ++o < i; )
    for (var l = Object(arguments[o]), c = Object.getOwnPropertySymbols(l), h = 0; h < c.length; h++) {
      var p = c[h];
      t.call(l, p) && (r[p] = l[p]);
    }
  return r;
}, gre = L3, yre = vre, Sre = Object.assign || function(n) {
  if (n === null || typeof n > "u")
    throw new TypeError("Cannot convert undefined or null to object");
  rI(n) || (n = {});
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    _re(t) && (t = Ere(t)), rI(t) && (xre(n, t), yre(n, t));
  }
  return n;
};
function xre(n, e) {
  for (var t in e)
    bre(e, t) && (n[t] = e[t]);
}
function _re(n) {
  return n && typeof n == "string";
}
function Ere(n) {
  var e = {};
  for (var t in n)
    e[t] = n[t];
  return e;
}
function rI(n) {
  return n && typeof n == "object" || gre(n);
}
function bre(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Tre = Sre, wre = function(n, e, t) {
  if (typeof n != "string")
    throw new TypeError("expected a string");
  typeof e == "function" && (t = e, e = null), typeof e == "string" && (e = { sep: e });
  var r = Tre({ sep: "." }, e), i = r.quotes || ['"', "'", "`"], o;
  r.brackets === !0 ? o = {
    "<": ">",
    "(": ")",
    "[": "]",
    "{": "}"
  } : r.brackets && (o = r.brackets);
  var l = [], c = [], h = [""], p = r.sep, y = n.length, x = -1, b;
  function w() {
    if (o && c.length)
      return o[c[c.length - 1]];
  }
  for (; ++x < y; ) {
    var R = n[x], U = n[x + 1], L = { val: R, idx: x, arr: h, str: n };
    if (l.push(L), R === "\\") {
      L.val = Cre(r, n, x) === !0 ? R + U : U, L.escaped = !0, typeof t == "function" && t(L), h[h.length - 1] += L.val, x++;
      continue;
    }
    if (o && o[R]) {
      c.push(R);
      var A = w(), F = x + 1;
      if (n.indexOf(A, F + 1) !== -1)
        for (; c.length && F < y; ) {
          var k = n[++F];
          if (k === "\\") {
            k++;
            continue;
          }
          if (i.indexOf(k) !== -1) {
            F = fP(n, k, F + 1);
            continue;
          }
          if (A = w(), c.length && n.indexOf(A, F + 1) === -1)
            break;
          if (o[k]) {
            c.push(k);
            continue;
          }
          A === k && c.pop();
        }
      if (b = F, b === -1) {
        h[h.length - 1] += R;
        continue;
      }
      R = n.slice(x, b + 1), L.val = R, L.idx = x = b;
    }
    if (i.indexOf(R) !== -1) {
      if (b = fP(n, R, x + 1), b === -1) {
        h[h.length - 1] += R;
        continue;
      }
      Mre(R, r) === !0 ? R = n.slice(x, b + 1) : R = n.slice(x + 1, b), L.val = R, L.idx = x = b;
    }
    if (typeof t == "function" && (t(L, l), R = L.val, x = L.idx), L.val === p && L.split !== !1) {
      h.push("");
      continue;
    }
    h[h.length - 1] += L.val;
  }
  return h;
};
function fP(n, e, t, r) {
  var i = n.indexOf(e, t);
  return n.charAt(i - 1) === "\\" ? fP(n, e, i + 1) : i;
}
function Mre(n, e) {
  return e.keepDoubleQuotes === !0 && n === '"' || e.keepSingleQuotes === !0 && n === "'" ? !0 : e.keepQuotes;
}
function Cre(n, e, t) {
  return typeof n.keepEscaping == "function" ? n.keepEscaping(e, t) : n.keepEscaping === !0 || e[t + 1] === "\\";
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Rre = function(e) {
  return typeof e < "u" && e !== null && (typeof e == "object" || typeof e == "function");
}, iI = Rre, Are = function(e) {
  iI(e) || (e = {});
  for (var t = arguments.length, r = 1; r < t; r++) {
    var i = arguments[r];
    iI(i) && Dre(e, i);
  }
  return e;
};
function Dre(n, e) {
  for (var t in e)
    Lre(e, t) && (n[t] = e[t]);
}
function Lre(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Ore = function(e) {
  return typeof e < "u" && e !== null && (typeof e == "object" || typeof e == "function");
};
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Pre = wre, Ure = Are, aI = DH, oI = Ore, Nre = function(n, e, t) {
  if (!oI(n) || (Array.isArray(e) && (e = [].concat.apply([], e).join(".")), typeof e != "string"))
    return n;
  for (var r = Pre(e, { sep: ".", brackets: !0 }).filter(Fre), i = r.length, o = -1, l = n; ++o < i; ) {
    var c = r[o];
    if (o !== i - 1) {
      oI(l[c]) || (l[c] = {}), l = l[c];
      continue;
    }
    aI(l[c]) && aI(t) ? l[c] = Ure({}, l[c], t) : l[c] = t;
  }
  return n;
};
function Fre(n) {
  return n !== "__proto__" && n !== "constructor" && n !== "prototype";
}
var BL = L3, sI = hre, kre = pre, lI = Nre, zre = function(e, t, r) {
  if (!BL(e))
    throw new TypeError("expected an object");
  if (typeof t != "string" || r == null)
    return sI.apply(null, arguments);
  if (typeof r == "string")
    return lI(e, t, r), e;
  var i = kre(e, t);
  return BL(r) && BL(i) && (r = sI({}, i, r)), lI(e, t, r), e;
};
const Ire = /* @__PURE__ */ rw(zre), O3 = (...n) => n.filter(Boolean).join(".");
function Bre(n) {
  const e = n.split(".");
  return [e.pop(), e.join(".") || void 0];
}
function Hre(n, e) {
  return Object.entries(See(n, e)).reduce(
    (t, [, {
      value: r,
      disabled: i,
      key: o
    }]) => (t[o] = i ? void 0 : r, t),
    {}
  );
}
function Vre(n, e) {
  const t = Sn();
  return (e ? ZT : vw)(n, t.current) || (t.current = n), t.current;
}
function OH(n, e) {
  return Rl(n, Vre(e, !0));
}
function Gre(n) {
  const e = Sn(null), t = Sn(null), r = Sn(!0);
  return M0(() => {
    n || (e.current.style.height = "0px", e.current.style.overflow = "hidden");
  }, []), tr(() => {
    if (r.current) {
      r.current = !1;
      return;
    }
    let i;
    const o = e.current, l = () => {
      n && (o.style.removeProperty("height"), o.style.removeProperty("overflow"), t.current.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      }));
    };
    o.addEventListener("transitionend", l, {
      once: !0
    });
    const {
      height: c
    } = t.current.getBoundingClientRect();
    return o.style.height = c + "px", n || (o.style.overflow = "hidden", i = window.setTimeout(() => o.style.height = "0px", 50)), () => {
      o.removeEventListener("transitionend", l), clearTimeout(i);
    };
  }, [n]), {
    wrapperRef: e,
    contentRef: t
  };
}
const Wre = (n) => {
  const [e, t] = Ni(n.getVisiblePaths());
  return tr(() => {
    t(n.getVisiblePaths());
    const r = n.useStore.subscribe(n.getVisiblePaths, t, {
      equalityFn: vw
    });
    return () => r();
  }, [n]), e;
};
function jre(n, e, t) {
  return n.useStore((i) => {
    const o = Tr(Tr({}, t), i.data);
    return Hre(o, e);
  }, vw);
}
function PH(n = 3) {
  const e = Sn(null), t = Sn(null), [r, i] = Ni(!1), o = Ir(() => i(!0), []), l = Ir(() => i(!1), []);
  return M0(() => {
    if (r) {
      const {
        bottom: c,
        top: h,
        left: p
      } = e.current.getBoundingClientRect(), {
        height: y
      } = t.current.getBoundingClientRect(), x = c + y > window.innerHeight - 40 ? "up" : "down";
      t.current.style.position = "fixed", t.current.style.zIndex = "10000", t.current.style.left = p + "px", x === "down" ? t.current.style.top = c + n + "px" : t.current.style.bottom = window.innerHeight - h + n + "px";
    }
  }, [n, r]), {
    popinRef: e,
    wrapperRef: t,
    shown: r,
    show: o,
    hide: l
  };
}
nne([rne]);
const $re = {
  rgb: "toRgb",
  hsl: "toHsl",
  hsv: "toHsv",
  hex: "toHex"
};
Md.extend({
  color: () => (n) => Uf(n).isValid()
});
const Yre = (n) => Md().color().test(n);
function UH(n, {
  format: e,
  hasAlpha: t,
  isString: r
}) {
  const i = $re[e] + (r && e !== "hex" ? "String" : ""), o = n[i]();
  return typeof o == "object" && !t ? xee(o, ["a"]) : o;
}
const NH = (n, e) => {
  const t = Uf(n);
  if (!t.isValid())
    throw Error("Invalid color");
  return UH(t, e);
}, Xre = (n, e) => UH(Uf(n), Tr(Tr({}, e), {}, {
  isString: !0,
  format: "hex"
})), qre = ({
  value: n
}) => {
  const e = tne(n), t = e === "name" ? "hex" : e, r = typeof n == "object" ? "a" in n : e === "hex" && n.length === 8 || /^(rgba)|(hsla)|(hsva)/.test(n), i = {
    format: t,
    hasAlpha: r,
    isString: typeof n == "string"
  };
  return {
    value: NH(n, i),
    settings: i
  };
};
var Kre = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Yre,
  sanitize: NH,
  format: Xre,
  normalize: qre
});
const Qre = xr("div", {
  position: "relative",
  boxSizing: "border-box",
  borderRadius: "$sm",
  overflow: "hidden",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  backgroundColor: "#fff",
  backgroundImage: `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,
  $inputStyle: "",
  $hover: "",
  zIndex: 1,
  variants: {
    active: {
      true: {
        $inputStyle: "$accent1"
      }
    }
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: "currentColor",
    zIndex: 1
  }
}), Zre = xr("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto",
  columnGap: "$colGap",
  alignItems: "center"
}), Jre = xr("div", {
  width: "$colorPickerWidth",
  height: "$colorPickerHeight",
  ".react-colorful": {
    width: "100%",
    height: "100%",
    boxShadow: "$level2",
    cursor: "crosshair"
  },
  ".react-colorful__saturation": {
    borderRadius: "$sm $sm 0 0"
  },
  ".react-colorful__alpha, .react-colorful__hue": {
    height: 10
  },
  ".react-colorful__last-control": {
    borderRadius: "0 0 $sm $sm"
  },
  ".react-colorful__pointer": {
    height: 12,
    width: 12
  }
});
function uI(n, e) {
  return e !== "rgb" ? Uf(n).toRgb() : n;
}
function eie({
  value: n,
  displayValue: e,
  settings: t,
  onUpdate: r
}) {
  const {
    emitOnEditStart: i,
    emitOnEditEnd: o
  } = Hc(), {
    format: l,
    hasAlpha: c
  } = t, {
    popinRef: h,
    wrapperRef: p,
    shown: y,
    show: x,
    hide: b
  } = PH(), w = Sn(0), [R, U] = Ni(() => uI(n, l)), L = c ? cne : dne, A = () => {
    U(uI(n, l)), x(), i();
  }, F = () => {
    b(), o(), window.clearTimeout(w.current);
  }, k = () => {
    w.current = window.setTimeout(F, 500);
  };
  return tr(() => () => window.clearTimeout(w.current), []), Fe.createElement(Fe.Fragment, null, Fe.createElement(Qre, {
    ref: h,
    active: y,
    onClick: () => A(),
    style: {
      color: e
    }
  }), y && Fe.createElement(E3, null, Fe.createElement(rH, {
    onPointerUp: F
  }), Fe.createElement(Jre, {
    ref: p,
    onMouseEnter: () => window.clearTimeout(w.current),
    onMouseLeave: (H) => H.buttons === 0 && k()
  }, Fe.createElement(L, {
    color: R,
    onChange: r
  }))));
}
function tie() {
  const {
    value: n,
    displayValue: e,
    label: t,
    onChange: r,
    onUpdate: i,
    settings: o
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, t), Fe.createElement(Zre, null, Fe.createElement(eie, {
    value: n,
    displayValue: e,
    onChange: r,
    onUpdate: i,
    settings: o
  }), Fe.createElement(_3, {
    value: e,
    onChange: r,
    onUpdate: i
  })));
}
var nie = Tr({
  component: tie
}, Kre);
function rie() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(T3, {
    value: e,
    settings: r,
    onUpdate: t
  }));
}
var iie = Tr({
  component: rie
}, fH(["x", "y", "z"]));
const aie = xr("div", {
  $flexCenter: "",
  position: "relative",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  touchAction: "none",
  $draggable: "",
  $hover: "",
  "&:active": {
    cursor: "none"
  },
  "&::after": {
    content: '""',
    backgroundColor: "$accent2",
    height: 4,
    width: 4,
    borderRadius: 2
  }
}), oie = xr("div", {
  $flexCenter: "",
  width: "$joystickWidth",
  height: "$joystickHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  position: "fixed",
  zIndex: 1e4,
  overflow: "hidden",
  $draggable: "",
  transform: "translate(-50%, -50%)",
  variants: {
    isOutOfBounds: {
      true: {
        backgroundColor: "$elevation1"
      },
      false: {
        backgroundColor: "$elevation3"
      }
    }
  },
  "> div": {
    position: "absolute",
    $flexCenter: "",
    borderStyle: "solid",
    borderWidth: 1,
    borderColor: "$highlight1",
    backgroundColor: "$elevation3",
    width: "80%",
    height: "80%",
    "&::after,&::before": {
      content: '""',
      position: "absolute",
      zindex: 10,
      backgroundColor: "$highlight1"
    },
    "&::before": {
      width: "100%",
      height: 1
    },
    "&::after": {
      height: "100%",
      width: 1
    }
  },
  "> span": {
    position: "relative",
    zindex: 100,
    width: 10,
    height: 10,
    backgroundColor: "$accent2",
    borderRadius: "50%"
  }
});
function sie({
  value: n,
  settings: e,
  onUpdate: t
}) {
  const r = Sn(), i = Sn(0), o = Sn(0), l = Sn(1), [c, h] = Ni(!1), [p, y] = Ni(!1), [x, b] = aH(), w = Sn(null), R = Sn(null);
  M0(() => {
    if (c) {
      const {
        top: oe,
        left: fe,
        width: de,
        height: xe
      } = w.current.getBoundingClientRect();
      R.current.style.left = fe + de / 2 + "px", R.current.style.top = oe + xe / 2 + "px";
    }
  }, [c]);
  const {
    keys: [U, L],
    joystick: A
  } = e, F = A === "invertY" ? 1 : -1, {
    [U]: {
      step: k
    },
    [L]: {
      step: H
    }
  } = e, B = Wg("sizes", "joystickWidth"), $ = Wg("sizes", "joystickHeight"), Y = parseFloat(B) * 0.8 / 2, J = parseFloat($) * 0.8 / 2, K = Ir(() => {
    r.current || (y(!0), i.current && b({
      x: i.current * Y
    }), o.current && b({
      y: o.current * -J
    }), r.current = window.setInterval(() => {
      t((oe) => {
        const fe = k * i.current * l.current, de = F * H * o.current * l.current;
        return Array.isArray(oe) ? {
          [U]: oe[0] + fe,
          [L]: oe[1] + de
        } : {
          [U]: oe[U] + fe,
          [L]: oe[L] + de
        };
      });
    }, 16));
  }, [Y, J, t, b, k, H, U, L, F]), X = Ir(() => {
    window.clearTimeout(r.current), r.current = void 0, y(!1);
  }, []);
  tr(() => {
    function oe(fe) {
      l.current = G5(fe);
    }
    return window.addEventListener("keydown", oe), window.addEventListener("keyup", oe), () => {
      window.clearTimeout(r.current), window.removeEventListener("keydown", oe), window.removeEventListener("keyup", oe);
    };
  }, []);
  const le = xw(({
    first: oe,
    active: fe,
    delta: [de, xe],
    movement: [_e, Pe]
  }) => {
    oe && h(!0);
    const ce = w0(_e, -Y, Y), ve = w0(Pe, -J, J);
    i.current = Math.abs(_e) > Math.abs(ce) ? Math.sign(_e - ce) : 0, o.current = Math.abs(Pe) > Math.abs(ve) ? Math.sign(ve - Pe) : 0;
    let re = n[U], ee = n[L];
    fe ? (i.current || (re += de * k * l.current, b({
      x: ce
    })), o.current || (ee -= F * xe * H * l.current, b({
      y: ve
    })), i.current || o.current ? K() : X(), t({
      [U]: re,
      [L]: ee
    })) : (h(!1), i.current = 0, o.current = 0, b({
      x: 0,
      y: 0
    }), X());
  });
  return Fe.createElement(aie, Us({
    ref: w
  }, le()), c && Fe.createElement(E3, null, Fe.createElement(oie, {
    ref: R,
    isOutOfBounds: p
  }, Fe.createElement("div", null), Fe.createElement("span", {
    ref: x
  }))));
}
const lie = xr("div", {
  display: "grid",
  columnGap: "$colGap",
  variants: {
    withJoystick: {
      true: {
        gridTemplateColumns: "$sizes$rowHeight auto"
      },
      false: {
        gridTemplateColumns: "auto"
      }
    }
  }
});
function uie() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Hc();
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(lie, {
    withJoystick: !!r.joystick
  }, r.joystick && Fe.createElement(sie, {
    value: e,
    settings: r,
    onUpdate: t
  }), Fe.createElement(T3, {
    value: e,
    settings: r,
    onUpdate: t
  })));
}
const cie = ["joystick"], FH = fH(["x", "y"]), fie = (n) => {
  let {
    joystick: e = !0
  } = n, t = Ya(n, cie);
  const {
    value: r,
    settings: i
  } = FH.normalize(t);
  return {
    value: r,
    settings: Tr(Tr({}, i), {}, {
      joystick: e
    })
  };
};
var die = Tr(Tr({
  component: uie
}, FH), {}, {
  normalize: fie
});
const hie = (n) => {
  if (n !== void 0) {
    if (n instanceof File)
      try {
        return URL.createObjectURL(n);
      } catch {
        return;
      }
    if (typeof n == "string" && n.indexOf("blob:") === 0)
      return n;
    throw Error("Invalid image format [undefined | blob | File].");
  }
}, pie = (n, e) => typeof e == "object" && "image" in e, mie = ({
  image: n
}) => ({
  value: n
});
var vie = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sanitize: hie,
  schema: pie,
  normalize: mie
});
const gie = xr("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto 20px",
  columnGap: "$colGap",
  alignItems: "center"
}), yie = xr("div", {
  $flexCenter: "",
  overflow: "hidden",
  height: "$rowHeight",
  background: "$elevation3",
  textAlign: "center",
  color: "inherit",
  borderRadius: "$sm",
  outline: "none",
  userSelect: "none",
  cursor: "pointer",
  $inputStyle: "",
  $hover: "",
  $focusWithin: "",
  $active: "$accent1 $elevation1",
  variants: {
    isDragAccept: {
      true: {
        $inputStyle: "$accent1",
        backgroundColor: "$elevation1"
      }
    }
  }
}), Sie = xr("div", {
  boxSizing: "border-box",
  borderRadius: "$sm",
  height: "$rowHeight",
  width: "$rowHeight",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center",
  variants: {
    hasImage: {
      true: {
        cursor: "pointer",
        $hover: "",
        $active: ""
      }
    }
  }
}), xie = xr("div", {
  $flexCenter: "",
  width: "$imagePreviewWidth",
  height: "$imagePreviewHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  pointerEvents: "none",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center"
}), _ie = xr("div", {
  fontSize: "0.8em",
  height: "100%",
  padding: "$rowGap $md"
}), Eie = xr("div", {
  $flexCenter: "",
  top: "0",
  right: "0",
  marginRight: "$sm",
  height: "100%",
  cursor: "pointer",
  variants: {
    disabled: {
      true: {
        color: "$elevation3",
        cursor: "default"
      }
    }
  },
  "&::after,&::before": {
    content: '""',
    position: "absolute",
    height: 2,
    width: 10,
    borderRadius: 1,
    backgroundColor: "currentColor"
  },
  "&::after": {
    transform: "rotate(45deg)"
  },
  "&::before": {
    transform: "rotate(-45deg)"
  }
});
function bie() {
  const {
    label: n,
    value: e,
    onUpdate: t,
    disabled: r
  } = Hc(), {
    popinRef: i,
    wrapperRef: o,
    shown: l,
    show: c,
    hide: h
  } = PH(), p = Ir((R) => {
    R.length && t(R[0]);
  }, [t]), y = Ir((R) => {
    R.stopPropagation(), t(void 0);
  }, [t]), {
    getRootProps: x,
    getInputProps: b,
    isDragAccept: w
  } = D3({
    maxFiles: 1,
    accept: "image/*",
    onDrop: p,
    disabled: r
  });
  return Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(gie, null, Fe.createElement(Sie, {
    ref: i,
    hasImage: !!e,
    onPointerDown: () => !!e && c(),
    onPointerUp: h,
    style: {
      backgroundImage: e ? `url(${e})` : "none"
    }
  }), l && !!e && Fe.createElement(E3, null, Fe.createElement(rH, {
    onPointerUp: h,
    style: {
      cursor: "pointer"
    }
  }), Fe.createElement(xie, {
    ref: o,
    style: {
      backgroundImage: `url(${e})`
    }
  })), Fe.createElement(yie, x({
    isDragAccept: w
  }), Fe.createElement("input", b()), Fe.createElement(_ie, null, w ? "drop image" : "click or drop")), Fe.createElement(Eie, {
    onClick: y,
    disabled: !e
  })));
}
var Tie = Tr({
  component: bie
}, vie);
const cI = Md().number(), wie = (n, e) => Md().array().length(2).every.number().test(n) && Md().schema({
  min: cI,
  max: cI
}).test(e), VR = (n) => ({
  min: n[0],
  max: n[1]
}), kH = (n, {
  bounds: [e, t]
}, r) => {
  const i = Array.isArray(n) ? VR(n) : n, o = {
    min: r[0],
    max: r[1]
  }, {
    min: l,
    max: c
  } = Tr(Tr({}, o), i);
  return [w0(Number(l), e, Math.max(e, c)), w0(Number(c), Math.min(t, l), t)];
}, Mie = ({
  value: n,
  min: e,
  max: t
}) => {
  const r = {
    min: e,
    max: t
  }, i = cH(VR(n), {
    min: r,
    max: r
  }), o = [e, t], l = Tr(Tr({}, i), {}, {
    bounds: o
  });
  return {
    value: kH(VR(n), l, n),
    settings: l
  };
};
var Cie = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: wie,
  format: VR,
  sanitize: kH,
  normalize: Mie
});
const Rie = ["value", "bounds", "onDrag"], Aie = ["bounds"], Die = xr("div", {
  display: "grid",
  columnGap: "$colGap",
  gridTemplateColumns: "auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"
});
function Lie(n) {
  let {
    value: e,
    bounds: [t, r],
    onDrag: i
  } = n, o = Ya(n, Rie);
  const l = Sn(null), c = Sn(null), h = Sn(null), p = Sn(0), y = Wg("sizes", "scrubberWidth"), x = xw(({
    event: R,
    first: U,
    xy: [L],
    movement: [A],
    memo: F = {}
  }) => {
    if (U) {
      const {
        width: H,
        left: B
      } = l.current.getBoundingClientRect();
      p.current = H - parseFloat(y);
      const $ = (R == null ? void 0 : R.target) === c.current || (R == null ? void 0 : R.target) === h.current;
      F.pos = kR((L - B) / H, t, r);
      const Y = Math.abs(F.pos - e.min) - Math.abs(F.pos - e.max);
      F.key = Y < 0 || Y === 0 && F.pos <= e.min ? "min" : "max", $ && (F.pos = e[F.key]);
    }
    const k = F.pos + kR(A / p.current, 0, r - t);
    return i({
      [F.key]: lte(k, o[F.key])
    }), F;
  }), b = `calc(${FR(e.min, t, r)} * (100% - ${y} - 8px) + 4px)`, w = `calc(${1 - FR(e.max, t, r)} * (100% - ${y} - 8px) + 4px)`;
  return Fe.createElement(sH, Us({
    ref: l
  }, x()), Fe.createElement(oH, null, Fe.createElement(lH, {
    style: {
      left: b,
      right: w
    }
  })), Fe.createElement(JO, {
    position: "left",
    ref: c,
    style: {
      left: b
    }
  }), Fe.createElement(JO, {
    position: "right",
    ref: h,
    style: {
      right: w
    }
  }));
}
function Oie() {
  const {
    label: n,
    displayValue: e,
    onUpdate: t,
    settings: r
  } = Hc(), i = Ya(r, Aie);
  return Fe.createElement(Fe.Fragment, null, Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, null, n), Fe.createElement(Die, null, Fe.createElement(Lie, Us({
    value: e
  }, r, {
    onDrag: t
  })), Fe.createElement(T3, {
    value: e,
    settings: i,
    onUpdate: t,
    innerLabelTrim: 0
  }))));
}
var Pie = Tr({
  component: Oie
}, Cie);
const Uie = () => {
  const n = /* @__PURE__ */ new Map();
  return {
    on: (e, t) => {
      let r = n.get(e);
      r === void 0 && (r = /* @__PURE__ */ new Set(), n.set(e, r)), r.add(t);
    },
    off: (e, t) => {
      const r = n.get(e);
      r !== void 0 && (r.delete(t), r.size === 0 && n.delete(e));
    },
    emit: (e, ...t) => {
      const r = n.get(e);
      if (r !== void 0)
        for (const i of r)
          i(...t);
    }
  };
}, Nie = ["type", "value"], Fie = ["onChange", "transient", "onEditStart", "onEditEnd"], kie = function() {
  const e = TB(RK(() => ({
    data: {}
  }))), t = Uie();
  this.storeId = yee(), this.useStore = e;
  const r = {}, i = /* @__PURE__ */ new Set();
  this.getVisiblePaths = () => {
    const l = this.getData(), c = Object.keys(l), h = [];
    Object.entries(r).forEach(([y, x]) => {
      x.render && c.some((b) => b.indexOf(y) === 0) && !x.render(this.get) && h.push(y + ".");
    });
    const p = [];
    return i.forEach((y) => {
      y in l && l[y].__refCount > 0 && h.every((x) => y.indexOf(x) === -1) && (!l[y].render || l[y].render(this.get)) && p.push(y);
    }), p;
  }, this.setOrderedPaths = (l) => {
    l.forEach((c) => i.add(c));
  }, this.orderPaths = (l) => (this.setOrderedPaths(l), l), this.disposePaths = (l) => {
    e.setState((c) => {
      const h = c.data;
      return l.forEach((p) => {
        if (p in h) {
          const y = h[p];
          y.__refCount--, y.__refCount === 0 && y.type in pp && delete h[p];
        }
      }), {
        data: h
      };
    });
  }, this.dispose = () => {
    e.setState(() => ({
      data: {}
    }));
  }, this.getFolderSettings = (l) => r[l] || {}, this.getData = () => e.getState().data, this.addData = (l, c) => {
    e.setState((h) => {
      const p = h.data;
      return Object.entries(l).forEach(([y, x]) => {
        let b = p[y];
        if (b) {
          const {
            type: w,
            value: R
          } = x, U = Ya(x, Nie);
          w !== b.type ? Bg(os.INPUT_TYPE_OVERRIDE, w) : ((b.__refCount === 0 || c) && Object.assign(b, U), b.__refCount++);
        } else
          p[y] = Tr(Tr({}, x), {}, {
            __refCount: 1
          });
      }), {
        data: p
      };
    });
  }, this.setValueAtPath = (l, c, h) => {
    e.setState((p) => {
      const y = p.data;
      return Uz(y[l], c, l, this, h), {
        data: y
      };
    });
  }, this.setSettingsAtPath = (l, c) => {
    e.setState((h) => {
      const p = h.data;
      return p[l].settings = Tr(Tr({}, p[l].settings), c), {
        data: p
      };
    });
  }, this.disableInputAtPath = (l, c) => {
    e.setState((h) => {
      const p = h.data;
      return p[l].disabled = c, {
        data: p
      };
    });
  }, this.set = (l, c) => {
    e.setState((h) => {
      const p = h.data;
      return Object.entries(l).forEach(([y, x]) => {
        try {
          Uz(p[y], x, void 0, void 0, c);
        } catch (b) {
          process.env.NODE_ENV === "development" && console.warn(`[This message will only show in development]: \`set\` for path ${y} has failed.`, b);
        }
      }), {
        data: p
      };
    });
  }, this.getInput = (l) => {
    try {
      return this.getData()[l];
    } catch {
      Bg(os.PATH_DOESNT_EXIST, l);
    }
  }, this.get = (l) => {
    var c;
    return (c = this.getInput(l)) === null || c === void 0 ? void 0 : c.value;
  }, this.emitOnEditStart = (l) => {
    t.emit(`onEditStart:${l}`, this.get(l), l, Tr(Tr({}, this.getInput(l)), {}, {
      get: this.get
    }));
  }, this.emitOnEditEnd = (l) => {
    t.emit(`onEditEnd:${l}`, this.get(l), l, Tr(Tr({}, this.getInput(l)), {}, {
      get: this.get
    }));
  }, this.subscribeToEditStart = (l, c) => {
    const h = `onEditStart:${l}`;
    return t.on(h, c), () => t.off(h, c);
  }, this.subscribeToEditEnd = (l, c) => {
    const h = `onEditEnd:${l}`;
    return t.on(h, c), () => t.off(h, c);
  };
  const o = (l, c, h) => {
    const p = {};
    return Object.entries(l).forEach(([y, x]) => {
      if (y === "")
        return Bg(os.EMPTY_KEY);
      let b = O3(c, y);
      if (x.type === pp.FOLDER) {
        const w = o(x.schema, b, h);
        Object.assign(p, w), b in r || (r[b] = x.settings);
      } else if (y in h)
        Bg(os.DUPLICATE_KEYS, y, b, h[y].path);
      else {
        const w = Mee(x, y, b, p);
        if (w) {
          const {
            type: R,
            options: U,
            input: L
          } = w, {
            onChange: A,
            transient: F,
            onEditStart: k,
            onEditEnd: H
          } = U, B = Ya(U, Fie);
          p[b] = Tr(Tr(Tr({
            type: R
          }, B), L), {}, {
            fromPanel: !0
          }), h[y] = {
            path: b,
            onChange: A,
            transient: F,
            onEditStart: k,
            onEditEnd: H
          };
        } else
          Bg(os.UNKNOWN_INPUT, b, x);
      }
    }), p;
  };
  this.getDataFromSchema = (l) => {
    const c = {};
    return [o(l, "", c), c];
  };
}, P3 = new kie();
process.env.NODE_ENV === "development" && typeof window < "u" && (window.__STORE = P3);
const zie = {
  collapsed: !1
};
function ET(n, e) {
  return {
    type: pp.FOLDER,
    schema: n,
    settings: Tr(Tr({}, zie), e)
  };
}
const Iie = {
  disabled: !1
};
function Bie(n, e) {
  return {
    type: pp.BUTTON,
    onClick: n,
    settings: Tr(Tr({}, Iie), e)
  };
}
const fI = (n) => "__levaInput" in n, Hie = (n, e) => {
  const t = {}, r = e ? e.toLowerCase() : null;
  return n.forEach((i) => {
    const [o, l] = Bre(i);
    (!r || o.toLowerCase().indexOf(r) > -1) && Ire(t, l, {
      [o]: {
        __levaInput: !0,
        path: i
      }
    });
  }), t;
}, Vie = ["type", "label", "path", "valueKey", "value", "settings", "setValue", "disabled"];
function Gie(n) {
  let {
    type: e,
    label: t,
    path: r,
    valueKey: i,
    value: o,
    settings: l,
    setValue: c,
    disabled: h
  } = n, p = Ya(n, Vie);
  const {
    displayValue: y,
    onChange: x,
    onUpdate: b
  } = iH({
    type: e,
    value: o,
    settings: l,
    setValue: c
  }), w = bx[e].component;
  return w ? Fe.createElement(X5.Provider, {
    value: Tr({
      key: i,
      path: r,
      id: "" + r,
      label: t,
      displayValue: y,
      value: o,
      onChange: x,
      onUpdate: b,
      settings: l,
      setValue: c,
      disabled: h
    }, p)
  }, Fe.createElement($ee, {
    disabled: h
  }, Fe.createElement(w, null))) : (Bg(os.NO_COMPONENT_FOR_TYPE, e, r), null);
}
const Wie = xr("button", {
  display: "block",
  $reset: "",
  fontWeight: "$button",
  height: "$rowHeight",
  borderStyle: "none",
  borderRadius: "$sm",
  backgroundColor: "$elevation1",
  color: "$highlight1",
  "&:not(:disabled)": {
    color: "$highlight3",
    backgroundColor: "$accent2",
    cursor: "pointer",
    $hover: "$accent3",
    $active: "$accent3 $accent1",
    $focus: ""
  }
});
function jie({
  onClick: n,
  settings: e,
  label: t
}) {
  const r = Sw();
  return Fe.createElement(gp, null, Fe.createElement(Wie, {
    disabled: e.disabled,
    onClick: () => n(r.get)
  }, t));
}
const $ie = xr("div", {
  $flex: "",
  justifyContent: "flex-end",
  gap: "$colGap"
}), Yie = xr("button", {
  $reset: "",
  cursor: "pointer",
  borderRadius: "$xs",
  "&:hover": {
    backgroundColor: "$elevation3"
  }
}), Xie = ({
  label: n,
  opts: e
}) => {
  let t = typeof n == "string" && n.trim() === "" ? null : n, r = e;
  return typeof e.opts == "object" && (r.label !== void 0 && (t = e.label), r = e.opts), {
    label: t,
    opts: r
  };
};
function qie(n) {
  const {
    label: e,
    opts: t
  } = Xie(n), r = Sw();
  return Fe.createElement(gp, {
    input: !!e
  }, e && Fe.createElement(ym, null, e), Fe.createElement($ie, null, Object.entries(t).map(([i, o]) => Fe.createElement(Yie, {
    key: i,
    onClick: () => o(r.get)
  }, i))));
}
const Kie = xr("canvas", {
  height: "$monitorHeight",
  width: "100%",
  display: "block",
  borderRadius: "$sm"
}), zH = 100;
function Qie(n, e) {
  n.push(e), n.length > zH && n.shift();
}
const Zie = Cu(function({
  initialValue: n
}, e) {
  const t = Wg("colors", "highlight3"), r = Wg("colors", "elevation2"), i = Wg("colors", "highlight1"), [o, l] = Rl(() => [Uf(i).alpha(0.4).toRgbString(), Uf(i).alpha(0.1).toRgbString()], [i]), c = Sn([n]), h = Sn(n), p = Sn(n), y = Sn(), x = Ir((R, U) => {
    if (!R)
      return;
    const {
      width: L,
      height: A
    } = R, F = new Path2D(), k = L / zH, H = A * 0.05;
    for (let Y = 0; Y < c.current.length; Y++) {
      const J = FR(c.current[Y], h.current, p.current), K = k * Y, X = A - J * (A - H * 2) - H;
      F.lineTo(K, X);
    }
    U.clearRect(0, 0, L, A);
    const B = new Path2D(F);
    B.lineTo(k * (c.current.length + 1), A), B.lineTo(0, A), B.lineTo(0, 0);
    const $ = U.createLinearGradient(0, 0, 0, A);
    $.addColorStop(0, o), $.addColorStop(1, l), U.fillStyle = $, U.fill(B), U.strokeStyle = r, U.lineJoin = "round", U.lineWidth = 14, U.stroke(F), U.strokeStyle = t, U.lineWidth = 2, U.stroke(F);
  }, [t, r, o, l]), [b, w] = tte(x);
  return pP(e, () => ({
    frame: (R) => {
      (h.current === void 0 || R < h.current) && (h.current = R), (p.current === void 0 || R > p.current) && (p.current = R), Qie(c.current, R), y.current = requestAnimationFrame(() => x(b.current, w.current));
    }
  }), [b, w, x]), tr(() => () => cancelAnimationFrame(y.current), []), Fe.createElement(Kie, {
    ref: b
  });
}), dI = (n) => Number.isFinite(n) ? n.toPrecision(2) : n.toString(), Jie = Cu(function({
  initialValue: n
}, e) {
  const [t, r] = Ni(dI(n));
  return pP(e, () => ({
    frame: (i) => r(dI(i))
  }), []), Fe.createElement("div", null, t);
});
function hI(n) {
  return typeof n == "function" ? n() : n.current;
}
function eae({
  label: n,
  objectOrFn: e,
  settings: t
}) {
  const r = Sn(), i = Sn(hI(e));
  return tr(() => {
    const o = window.setInterval(() => {
      var l;
      document.hidden || (l = r.current) === null || l === void 0 || l.frame(hI(e));
    }, t.interval);
    return () => window.clearInterval(o);
  }, [e, t.interval]), Fe.createElement(gp, {
    input: !0
  }, Fe.createElement(ym, {
    align: "top"
  }, n), t.graph ? Fe.createElement(Zie, {
    ref: r,
    initialValue: i.current
  }) : Fe.createElement(Jie, {
    ref: r,
    initialValue: i.current
  }));
}
const tae = ["type", "label", "key"], nae = {
  [pp.BUTTON]: jie,
  [pp.BUTTON_GROUP]: qie,
  [pp.MONITOR]: eae
}, rae = Fe.memo(({
  path: n
}) => {
  const [e, {
    set: t,
    setSettings: r,
    disable: i,
    storeId: o,
    emitOnEditStart: l,
    emitOnEditEnd: c
  }] = rte(n);
  if (!e)
    return null;
  const {
    type: h,
    label: p,
    key: y
  } = e, x = Ya(e, tae);
  if (h in pp) {
    const b = nae[h];
    return Fe.createElement(b, Us({
      label: p,
      path: n
    }, x));
  }
  return h in bx ? Fe.createElement(Gie, Us({
    key: o + n,
    type: h,
    label: p,
    storeId: o,
    path: n,
    valueKey: y,
    setValue: t,
    setSettings: r,
    disable: i,
    emitOnEditStart: l,
    emitOnEditEnd: c
  }, x)) : (cee(os.UNSUPPORTED_INPUT, h, n), null);
});
function iae({
  toggle: n,
  toggled: e,
  name: t
}) {
  return Fe.createElement(Gee, {
    onClick: () => n()
  }, Fe.createElement(b3, {
    toggled: e
  }), Fe.createElement("div", null, t));
}
const aae = ({
  name: n,
  path: e,
  tree: t
}) => {
  const r = Sw(), i = O3(e, n), {
    collapsed: o,
    color: l
  } = r.getFolderSettings(i), [c, h] = Ni(!o), p = Sn(null), y = Wg("colors", "folderWidgetColor"), x = Wg("colors", "folderTextColor");
  return M0(() => {
    p.current.style.setProperty("--leva-colors-folderWidgetColor", l || y), p.current.style.setProperty("--leva-colors-folderTextColor", l || x);
  }, [l, y, x]), Fe.createElement(zR, {
    ref: p
  }, Fe.createElement(iae, {
    name: n,
    toggled: c,
    toggle: () => h((b) => !b)
  }), Fe.createElement(IH, {
    parent: i,
    tree: t,
    toggled: c
  }));
}, IH = Fe.memo(({
  isRoot: n = !1,
  fill: e = !1,
  flat: t = !1,
  parent: r,
  tree: i,
  toggled: o
}) => {
  const {
    wrapperRef: l,
    contentRef: c
  } = Gre(o), h = Sw(), p = ([x, b]) => {
    var w;
    return (fI(b) ? (w = h.getInput(b.path)) === null || w === void 0 ? void 0 : w.order : h.getFolderSettings(O3(r, x)).order) || 0;
  }, y = Object.entries(i).sort((x, b) => p(x) - p(b));
  return Fe.createElement(QO, {
    ref: l,
    isRoot: n,
    fill: e,
    flat: t
  }, Fe.createElement(eH, {
    ref: c,
    isRoot: n,
    toggled: o
  }, y.map(([x, b]) => fI(b) ? Fe.createElement(rae, {
    key: b.path,
    valueKey: b.valueKey,
    path: b.path
  }) : Fe.createElement(aae, {
    key: x,
    name: x,
    path: r,
    tree: b
  }))));
}), oae = xr("div", {
  position: "relative",
  fontFamily: "$mono",
  fontSize: "$root",
  color: "$rootText",
  backgroundColor: "$elevation1",
  variants: {
    fill: {
      false: {
        position: "fixed",
        top: "10px",
        right: "10px",
        zIndex: 1e3,
        width: "$rootWidth"
      },
      true: {
        position: "relative",
        width: "100%"
      }
    },
    flat: {
      false: {
        borderRadius: "$lg",
        boxShadow: "$level1"
      }
    },
    oneLineLabels: {
      true: {
        [`${nH}`]: {
          gridTemplateColumns: "auto",
          gridAutoColumns: "minmax(max-content, 1fr)",
          gridAutoRows: "minmax($sizes$rowHeight), auto)",
          rowGap: 0,
          columnGap: 0,
          marginTop: "$rowGap"
        }
      }
    },
    hideTitleBar: {
      true: {
        $$titleBarHeight: "0px"
      },
      false: {
        $$titleBarHeight: "$sizes$titleBarHeight"
      }
    }
  },
  "&,*,*:after,*:before": {
    boxSizing: "border-box"
  },
  "*::selection": {
    backgroundColor: "$accent2"
  }
}), BH = 40, GR = xr("i", {
  $flexCenter: "",
  width: BH,
  userSelect: "none",
  cursor: "pointer",
  "> svg": {
    fill: "$highlight1",
    transition: "transform 350ms ease, fill 250ms ease"
  },
  "&:hover > svg": {
    fill: "$highlight3"
  },
  variants: {
    active: {
      true: {
        "> svg": {
          fill: "$highlight2"
        }
      }
    }
  }
}), sae = xr("div", {
  display: "flex",
  alignItems: "stretch",
  justifyContent: "space-between",
  height: "$titleBarHeight",
  variants: {
    mode: {
      drag: {
        cursor: "grab"
      }
    }
  }
}), lae = xr("div", {
  $flex: "",
  position: "relative",
  width: "100%",
  overflow: "hidden",
  transition: "height 250ms ease",
  color: "$highlight3",
  paddingLeft: "$md",
  [`> ${GR}`]: {
    height: 30
  },
  variants: {
    toggled: {
      true: {
        height: 30
      },
      false: {
        height: 0
      }
    }
  }
}), uae = xr("input", {
  $reset: "",
  flex: 1,
  position: "relative",
  height: 30,
  width: "100%",
  backgroundColor: "transparent",
  fontSize: "10px",
  borderRadius: "$root",
  "&:focus": {},
  "&::placeholder": {
    color: "$highlight2"
  }
}), cae = xr("div", {
  touchAction: "none",
  $flexCenter: "",
  flex: 1,
  "> svg": {
    fill: "$highlight1"
  },
  color: "$highlight1",
  variants: {
    drag: {
      true: {
        $draggable: "",
        "> svg": {
          transition: "fill 250ms ease"
        },
        "&:hover": {
          color: "$highlight3"
        },
        "&:hover > svg": {
          fill: "$highlight3"
        }
      }
    },
    filterEnabled: {
      false: {
        paddingRight: BH
      }
    }
  }
}), fae = Fe.forwardRef(({
  setFilter: n,
  toggle: e
}, t) => {
  const [r, i] = Ni(""), o = Rl(() => V5(n, 250), [n]), l = () => {
    n(""), i("");
  }, c = (h) => {
    const p = h.currentTarget.value;
    e(!0), i(p);
  };
  return tr(() => {
    o(r);
  }, [r, o]), Fe.createElement(Fe.Fragment, null, Fe.createElement(uae, {
    ref: t,
    value: r,
    placeholder: "[Open filter with CMD+SHIFT+L]",
    onPointerDown: (h) => h.stopPropagation(),
    onChange: c
  }), Fe.createElement(GR, {
    onClick: () => l(),
    style: {
      visibility: r ? "visible" : "hidden"
    }
  }, Fe.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "14",
    width: "14",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, Fe.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
    clipRule: "evenodd"
  }))));
});
function dae({
  setFilter: n,
  onDrag: e,
  onDragStart: t,
  onDragEnd: r,
  toggle: i,
  toggled: o,
  title: l,
  drag: c,
  filterEnabled: h,
  from: p
}) {
  const [y, x] = Ni(!1), b = Sn(null);
  tr(() => {
    var R, U;
    y ? (R = b.current) === null || R === void 0 || R.focus() : (U = b.current) === null || U === void 0 || U.blur();
  }, [y]);
  const w = xw(({
    offset: [R, U],
    first: L,
    last: A
  }) => {
    e({
      x: R,
      y: U
    }), L && t({
      x: R,
      y: U
    }), A && r({
      x: R,
      y: U
    });
  }, {
    filterTaps: !0,
    from: ({
      offset: [R, U]
    }) => [(p == null ? void 0 : p.x) || R, (p == null ? void 0 : p.y) || U]
  });
  return tr(() => {
    const R = (U) => {
      U.key === "L" && U.shiftKey && U.metaKey && x((L) => !L);
    };
    return window.addEventListener("keydown", R), () => window.removeEventListener("keydown", R);
  }, []), Fe.createElement(Fe.Fragment, null, Fe.createElement(sae, {
    mode: c ? "drag" : void 0
  }, Fe.createElement(GR, {
    active: !o,
    onClick: () => i()
  }, Fe.createElement(b3, {
    toggled: o,
    width: 12,
    height: 8
  })), Fe.createElement(cae, Us({}, c ? w() : {}, {
    drag: c,
    filterEnabled: h
  }), l === void 0 && c ? Fe.createElement("svg", {
    width: "20",
    height: "10",
    viewBox: "0 0 28 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, Fe.createElement("circle", {
    cx: "2",
    cy: "2",
    r: "2"
  }), Fe.createElement("circle", {
    cx: "14",
    cy: "2",
    r: "2"
  }), Fe.createElement("circle", {
    cx: "26",
    cy: "2",
    r: "2"
  }), Fe.createElement("circle", {
    cx: "2",
    cy: "12",
    r: "2"
  }), Fe.createElement("circle", {
    cx: "14",
    cy: "12",
    r: "2"
  }), Fe.createElement("circle", {
    cx: "26",
    cy: "12",
    r: "2"
  })) : l), h && Fe.createElement(GR, {
    active: y,
    onClick: () => x((R) => !R)
  }, Fe.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "20",
    viewBox: "0 0 20 20"
  }, Fe.createElement("path", {
    d: "M9 9a2 2 0 114 0 2 2 0 01-4 0z"
  }), Fe.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",
    clipRule: "evenodd"
  })))), Fe.createElement(lae, {
    toggled: y
  }, Fe.createElement(fae, {
    ref: b,
    setFilter: n,
    toggle: i
  })));
}
const hae = ["store", "hidden", "theme", "collapsed"];
function pae(n) {
  let {
    store: e,
    hidden: t = !1,
    theme: r,
    collapsed: i = !1
  } = n, o = Ya(n, hae);
  const l = OH(() => kee(r), [r]), [c, h] = Ni(!i), p = typeof i == "object" ? !i.collapsed : c, y = Rl(() => typeof i == "object" ? (x) => {
    typeof x == "function" ? i.onChange(!x(!i.collapsed)) : i.onChange(!x);
  } : h, [i]);
  return !e || t ? null : Fe.createElement(x3.Provider, {
    value: l
  }, Fe.createElement(mae, Us({
    store: e
  }, o, {
    toggled: p,
    setToggle: y,
    rootClass: l.className
  })));
}
const mae = Fe.memo(({
  store: n,
  rootClass: e,
  fill: t = !1,
  flat: r = !1,
  neverHide: i = !1,
  oneLineLabels: o = !1,
  titleBar: l = {
    title: void 0,
    drag: !0,
    filter: !0,
    position: void 0,
    onDrag: void 0,
    onDragStart: void 0,
    onDragEnd: void 0
  },
  hideCopyButton: c = !1,
  toggled: h,
  setToggle: p
}) => {
  var y, x;
  const b = Wre(n), [w, R] = Ni(""), U = Rl(() => Hie(b, w), [b, w]), [L, A] = aH(), F = i || b.length > 0, k = typeof l == "object" && l.title || void 0, H = typeof l == "object" && (y = l.drag) !== null && y !== void 0 ? y : !0, B = typeof l == "object" && (x = l.filter) !== null && x !== void 0 ? x : !0, $ = typeof l == "object" && l.position || void 0, Y = typeof l == "object" && l.onDrag || void 0, J = typeof l == "object" && l.onDragStart || void 0, K = typeof l == "object" && l.onDragEnd || void 0;
  return Fe.useEffect(() => {
    A({
      x: $ == null ? void 0 : $.x,
      y: $ == null ? void 0 : $.y
    });
  }, [$, A]), Fee(), Fe.createElement(K5.Provider, {
    value: {
      hideCopyButton: c
    }
  }, Fe.createElement(oae, {
    ref: L,
    className: e,
    fill: t,
    flat: r,
    oneLineLabels: o,
    hideTitleBar: !l,
    style: {
      display: F ? "block" : "none"
    }
  }, l && Fe.createElement(dae, {
    onDrag: (X) => {
      A(X), Y == null || Y(X);
    },
    onDragStart: (X) => J == null ? void 0 : J(X),
    onDragEnd: (X) => K == null ? void 0 : K(X),
    setFilter: R,
    toggle: (X) => p((le) => X ?? !le),
    toggled: h,
    title: k,
    drag: H,
    filterEnabled: B,
    from: $
  }), F && Fe.createElement(q5.Provider, {
    value: n
  }, Fe.createElement(IH, {
    isRoot: !0,
    fill: t,
    flat: r,
    tree: U,
    toggled: h
  }))));
}), vae = ["isRoot"];
let WR = !1, lx = null;
function HH(n) {
  let {
    isRoot: e = !1
  } = n, t = Ya(n, vae);
  return tr(() => (WR = !0, !e && lx && (lx.remove(), lx = null), () => {
    e || (WR = !1);
  }), [e]), Fe.createElement(pae, Us({
    store: P3
  }, t));
}
function gae(n) {
  tr(() => {
    n && !WR && (lx || (lx = document.getElementById("leva__root") || Object.assign(document.createElement("div"), {
      id: "leva__root"
    }), document.body && (document.body.appendChild(lx), Ree(Fe.createElement(HH, {
      isRoot: !0
    }), lx))), WR = !0);
  }, [n]);
}
function yae(n, e, t, r, i) {
  let o, l, c, h, p;
  return typeof n == "string" ? (l = n, o = e, Array.isArray(t) ? p = t : t && ("store" in t ? (h = t, p = r) : (c = t, Array.isArray(r) ? p = r : (h = r, p = i)))) : (o = n, Array.isArray(e) ? p = e : (h = e, p = t)), {
    schema: o,
    folderName: l,
    folderSettings: c,
    hookSettings: h,
    deps: p || []
  };
}
function Sae(n, e, t, r, i) {
  const {
    folderName: o,
    schema: l,
    folderSettings: c,
    hookSettings: h,
    deps: p
  } = yae(n, e, t, r, i), y = typeof l == "function", x = Sn(!1), b = Sn(!0), w = OH(() => {
    x.current = !0;
    const le = typeof l == "function" ? l() : l;
    return o ? {
      [o]: ET(le, c)
    } : le;
  }, p), R = !(h != null && h.store);
  gae(R);
  const [U] = Ni(() => (h == null ? void 0 : h.store) || P3), [L, A] = Rl(() => U.getDataFromSchema(w), [U, w]), [F, k, H, B, $] = Rl(() => {
    const le = [], oe = [], fe = {}, de = {}, xe = {};
    return Object.values(A).forEach(({
      path: _e,
      onChange: Pe,
      onEditStart: ce,
      onEditEnd: ve,
      transient: re
    }) => {
      le.push(_e), Pe ? (fe[_e] = Pe, re || oe.push(_e)) : oe.push(_e), ce && (de[_e] = ce), ve && (xe[_e] = ve);
    }), [le, oe, fe, de, xe];
  }, [A]), Y = Rl(() => U.orderPaths(F), [F, U]), J = jre(U, k, L), K = Ir((le) => {
    const oe = Object.entries(le).reduce((fe, [de, xe]) => Object.assign(fe, {
      [A[de].path]: xe
    }), {});
    U.set(oe, !1);
  }, [U, A]), X = Ir((le) => U.get(A[le].path), [U, A]);
  return tr(() => {
    const le = !b.current && x.current;
    return U.addData(L, le), b.current = !1, x.current = !1, () => U.disposePaths(Y);
  }, [U, Y, L]), tr(() => {
    const le = [];
    return Object.entries(H).forEach(([oe, fe]) => {
      fe(U.get(oe), oe, Tr({
        initial: !0,
        get: U.get
      }, U.getInput(oe)));
      const de = U.useStore.subscribe((xe) => {
        const _e = xe.data[oe];
        return [_e.disabled ? void 0 : _e.value, _e];
      }, ([xe, _e]) => fe(xe, oe, Tr({
        initial: !1,
        get: U.get
      }, _e)), {
        equalityFn: vw
      });
      le.push(de);
    }), () => le.forEach((oe) => oe());
  }, [U, H]), tr(() => {
    const le = [];
    return Object.entries(B).forEach(([oe, fe]) => le.push(U.subscribeToEditStart(oe, fe))), Object.entries($).forEach(([oe, fe]) => le.push(U.subscribeToEditEnd(oe, fe))), () => le.forEach((oe) => oe());
  }, [B, $, U]), y ? [J, K, X] : J;
}
Jg(pm.SELECT, xte);
Jg(pm.IMAGE, Tie);
Jg(pm.NUMBER, cte);
Jg(pm.COLOR, nie);
Jg(pm.STRING, Ate);
Jg(pm.BOOLEAN, Fte);
Jg(pm.INTERVAL, Pie);
Jg(pm.VECTOR3D, iie);
Jg(pm.VECTOR2D, die);
const pI = (n, e, t, r, i) => {
  const o = g4.degToRad(t), l = 2 * Math.atan(Math.tan(o / 2) * r), c = i * e / (2 * Math.tan(o / 2)), h = i * n / (2 * Math.tan(l / 2));
  return new Ht(h, c);
}, xae = ({ file: n }) => {
  const [
    {
      // resetPosition,
      maxSplats: e,
      rotationAxis: t,
      flipScene: r,
      xPos: i,
      yPos: o,
      zPos: l
      // xRot,
      // yRot,
      // zRot,
    },
    c
  ] = Sae(() => ({
    quality: ET({
      maxSplats: { value: 1e6, min: 1e4, max: 1e9, step: 1e5 }
    }),
    position: ET({
      xPos: { value: 0, step: 1 },
      yPos: { value: 0, step: 1 },
      zPos: { value: 0, step: 1 }
    }),
    rotation: ET({
      xRot: { value: 0, min: -180, step: 0.1 },
      yRot: { value: 0, min: -180, step: 0.1 },
      zRot: { value: 0, min: -180, step: 0.1 }
    }),
    scene: ET({
      rotationAxis: { value: "Z", options: ["X", "Y", "Z"] },
      flipScene: !1
    }),
    // scene: folder({
    //   // ' ': {value: 'Choose vertical axis', editable: false},
    //   // vertical: 'x',
    // ' ': buttonGroup({
    //     '0.25x': () => set({ vertical: 0.25 }),
    //     '0.5x': () => set({ vertical: 0.5 }),
    //     '1x': () => set({ vertical: 1 }),
    //     '2x': () => set({ vertical: 2 }),
    //     '3x': () => set({ vertical: 3 }),
    //   }),
    //   // 'X axis': button(() => set({vertical: 'x'}), {disabled: vertical === 'x'}),
    //   // 'Y axis': button(() => set({vertical: 'y'}), {disabled: vertical === 'y'}),
    //   // 'Z axis': button(() => set({vertical: 'z'}), {disabled: vertical === 'z'}),
    // }),
    "Reset position": Bie(() => {
      b.position.set(0, 0, 100), b.rotation.set(0, 0, 1), b.lookAt(0, 0, 0);
    })
  })), h = Sn(null), [p] = Ni(() => new Dq()), {
    size: { width: y, height: x },
    camera: b,
    viewport: { dpr: w }
    // raycaster,
    // mouse,
  } = cm(), [R] = Ni({
    viewport: {
      value: new Ht(y * w, x * w)
    },
    focal: {
      // @ts-expect-error properties do exist
      value: pI(y, x, b.fov, b.aspect, w)
    }
  });
  tr(() => {
    R.focal.value = pI(
      y,
      x,
      // @ts-expect-error properties do exist
      b.fov,
      // @ts-expect-error properties do exist
      b.aspect,
      w
    ), R.viewport.value = new Ht(y * w, x * w);
  }, [y, x, b.fov, b.aspect, w]);
  const [U, L] = Ni({
    index: new Uint16Array([0, 1, 2, 2, 3, 0]),
    position: new Float32Array([1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0]),
    color: new Float32Array([1, 0, 1, 1, 1, 1, 0, 1]),
    quat: new Float32Array([0, 0, 0, 1, 0, 0, 0, 1]),
    scale: new Float32Array([1, 1, 1, 2, 0.5, 0.5]),
    center: new Float32Array([0, 0, 0, 2, 0, 0])
  });
  a3(
    (k) => {
      const H = h.current;
      if (H == null)
        return;
      const B = k.camera, { x: $, y: Y, z: J } = B.position, { x: K, y: X, z: le } = B.rotation;
      c({ xPos: $ }), c({ yPos: Y }), c({ zPos: J }), c({ xRot: K * 180 / Math.PI }), c({ yRot: X * 180 / Math.PI }), c({ zRot: le * 180 / Math.PI });
      const oe = new Gr().multiply(B.projectionMatrix).multiply(B.matrixWorldInverse).multiply(H.matrixWorld);
      p.postMessage({ view: oe.elements, maxSplats: e });
    }
  ), tr(() => (p.onmessage = (k) => {
    const {
      quat: H,
      scale: B,
      center: $,
      color: Y
      /*viewProj*/
    } = k.data;
    L((J) => ({ ...J, quat: H, scale: B, center: $, color: Y }));
  }, () => {
    p.onmessage = null;
  })), tr(() => {
    let B = -1, $ = 0;
    $ += (n == null ? void 0 : n.length) || 0, 0 > B && (p.postMessage({
      buffer: n == null ? void 0 : n.buffer,
      vertexCount: Math.floor($ / 32)
    }), B = 0);
  }, [n, p]), tr(() => {
    b.position.set(i, o, l);
  }, [i, o, l, b]);
  const A = Ir(
    (k) => {
      k.needsUpdate = !0;
    },
    []
  );
  tr(() => {
    b.up.set(
      t === "X" ? 1 : 0,
      t === "Y" ? 1 : 0,
      t === "Z" ? 1 : 0
    ), c({ flipScene: !1 });
  }, [t]), tr(() => {
    b.position.set(
      t === "X" ? 100 : 0,
      t === "Y" ? 100 : 0,
      t === "Z" ? 100 : 0
    ), b.lookAt(0, 0, 0);
  }, [n]), tr(() => {
    r ? (b.up.set(
      t === "X" ? -1 : 0,
      t === "Y" ? -1 : 0,
      t === "Z" ? -1 : 0
    ), c({ flipScene: !0 })) : (b.up.set(
      t === "X" ? 1 : 0,
      t === "Y" ? 1 : 0,
      t === "Z" ? 1 : 0
    ), c({ flipScene: !1 }));
  }, [r, b, c]);
  const F = Math.min(U.quat.length / 4, e);
  return (
    // <mesh position={[0, 0, 0]} onPointerDown={(e) => console.log('onClick mesh: ', e)}>
    //     <boxGeometry attach="geometry" args={[10, 10, 10]} />
    //     <meshStandardMaterial attach="material" color="hotpink" wireframe />
    //   </mesh>
    /* @__PURE__ */ Vo.jsxs(
      "mesh",
      {
        ref: h,
        renderOrder: 10,
        children: [
          /* @__PURE__ */ Vo.jsxs("group", { children: [
            /* @__PURE__ */ Vo.jsx("axesHelper", { args: [5] }),
            /* @__PURE__ */ Vo.jsx(wL, { position: [2, 0, 0], fontSize: 0.4, color: "red", children: "X" }),
            /* @__PURE__ */ Vo.jsx(wL, { position: [0, 2, 0], fontSize: 0.4, color: "green", children: "Y" }),
            /* @__PURE__ */ Vo.jsx(wL, { position: [0, 0, 2], fontSize: 0.4, color: "blue", children: "Z" })
          ] }),
          /* @__PURE__ */ Vo.jsxs(
            "instancedBufferGeometry",
            {
              instanceCount: F,
              children: [
                /* @__PURE__ */ Vo.jsx(
                  "bufferAttribute",
                  {
                    attach: "index",
                    onUpdate: A,
                    array: U.index,
                    itemSize: 1,
                    count: 6
                  }
                ),
                /* @__PURE__ */ Vo.jsx(
                  "bufferAttribute",
                  {
                    attach: "attributes-position",
                    onUpdate: A,
                    array: U.position,
                    itemSize: 3,
                    count: 4
                  }
                ),
                /* @__PURE__ */ Vo.jsx(
                  "instancedBufferAttribute",
                  {
                    attach: "attributes-color",
                    onUpdate: A,
                    array: U.color,
                    itemSize: 4,
                    count: F
                  }
                ),
                /* @__PURE__ */ Vo.jsx(
                  "instancedBufferAttribute",
                  {
                    attach: "attributes-quat",
                    onUpdate: A,
                    array: U.quat,
                    itemSize: 4,
                    count: F
                  }
                ),
                /* @__PURE__ */ Vo.jsx(
                  "instancedBufferAttribute",
                  {
                    attach: "attributes-scale",
                    onUpdate: A,
                    array: U.scale,
                    itemSize: 3,
                    count: F
                  }
                ),
                /* @__PURE__ */ Vo.jsx(
                  "instancedBufferAttribute",
                  {
                    attach: "attributes-center",
                    onUpdate: A,
                    array: U.center,
                    itemSize: 3,
                    count: F
                  }
                )
              ]
            },
            F
          ),
          /* @__PURE__ */ Vo.jsx(
            "rawShaderMaterial",
            {
              uniforms: R,
              fragmentShader: Oq,
              vertexShader: Lq,
              depthTest: !0,
              depthWrite: !1,
              transparent: !0
            }
          )
        ]
      }
    )
  );
};
var _ae = function() {
};
function Eae(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  n && n.addEventListener && n.addEventListener.apply(n, e);
}
function bae(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  n && n.removeEventListener && n.removeEventListener.apply(n, e);
}
var Tae = typeof window < "u", wae = Tae ? window : null, mI = function(n) {
  return !!n.addEventListener;
}, vI = function(n) {
  return !!n.on;
}, Mae = function(n, e, t, r) {
  t === void 0 && (t = wae), tr(function() {
    if (e && t)
      return mI(t) ? Eae(t, n, e, r) : vI(t) && t.on(n, e, r), function() {
        mI(t) ? bae(t, n, e, r) : vI(t) && t.off(n, e, r);
      };
  }, [n, e, t, JSON.stringify(r)]);
};
const Cae = Mae;
var Rae = function(n) {
  return typeof n == "function" ? n : typeof n == "string" ? function(e) {
    return e.key === n;
  } : n ? function() {
    return !0;
  } : function() {
    return !1;
  };
}, Aae = function(n, e, t, r) {
  e === void 0 && (e = _ae), t === void 0 && (t = {}), r === void 0 && (r = [n]);
  var i = t.event, o = i === void 0 ? "keydown" : i, l = t.target, c = t.options, h = Rl(function() {
    var p = Rae(n), y = function(x) {
      if (p(x))
        return e(x);
    };
    return y;
  }, r);
  Cae(o, h, l, c);
};
const gI = Aae;
var Dae = function(n) {
  var e = Ni([!1, null]), t = e[0], r = e[1];
  return gI(n, function(i) {
    return r([!0, i]);
  }, { event: "keydown" }, [t]), gI(n, function(i) {
    return r([!1, i]);
  }, { event: "keyup" }, [t]), t;
};
const Lae = Dae, Oae = ({ movementSpeed: n = 0.3 }) => {
  const { camera: e } = cm(), t = Sn(new Te()), i = Lae((c) => c.key === "Shift")[0] ? 4 * n : n;
  a3(() => {
    const c = t.current.clone().applyQuaternion(e.quaternion);
    e.position.add(c.multiplyScalar(i));
  });
  const o = (c) => {
    switch (c.code) {
      case "KeyW":
        t.current.z = -i;
        break;
      case "KeyS":
        t.current.z = i;
        break;
      case "KeyA":
        t.current.x = -i;
        break;
      case "KeyD":
        t.current.x = i;
        break;
      case "KeyR":
        t.current.y = i;
        break;
      case "KeyF":
        t.current.y = -i;
        break;
    }
  }, l = (c) => {
    switch (c.code) {
      case "KeyW":
      case "KeyS":
        t.current.z = 0;
        break;
      case "KeyA":
      case "KeyD":
        t.current.x = 0;
        break;
      case "KeyR":
      case "KeyF":
        t.current.y = 0;
        break;
    }
  };
  return tr(() => (window.addEventListener("keydown", o), window.addEventListener("keyup", l), () => {
    window.removeEventListener("keydown", o), window.removeEventListener("keyup", l);
  }), []), null;
}, Pae = (n) => {
  var A;
  const e = new Uint8Array(n), t = new TextDecoder().decode(e.slice(0, 1024 * 10)), r = `end_header
`, i = t.indexOf(r);
  if (i < 0)
    throw new Error("Unable to read .ply file header");
  const o = parseInt(
    (A = /element vertex (\d+)\n/.exec(t)) == null ? void 0 : A[1]
  );
  console.log("Vertex Count", o);
  let l = 0;
  const c = {}, h = {}, p = {
    double: "getFloat64",
    int: "getInt32",
    uint: "getUint32",
    float: "getFloat32",
    short: "getInt16",
    ushort: "getUint16",
    uchar: "getUint8"
  };
  for (const F of t.slice(0, i).split(`
`).filter((k) => k.startsWith("property "))) {
    const [, k, H] = F.split(" "), B = p[k] || "getInt8";
    h[H] = B, c[H] = l, l += parseInt(B.replace(/[^\d]/g, "")) / 8;
  }
  console.log("Bytes per row", l, h, c);
  const y = new DataView(
    n,
    i + r.length
  );
  let x = 0;
  const b = new Proxy(
    {},
    {
      get(F, k) {
        if (!h[k])
          throw new Error(k + " not found");
        return y[h[k]](x * l + c[k], !0);
      }
    }
  );
  console.time("calculate importance");
  const w = new Float32Array(o), R = new Uint32Array(o);
  for (x = 0; x < o; x++) {
    if (R[x] = x, !h.scale_0)
      continue;
    const F = Math.exp(b.scale_0) * Math.exp(b.scale_1) * Math.exp(b.scale_2), k = 1 / (1 + Math.exp(-b.opacity));
    w[x] = F * k;
  }
  console.timeEnd("calculate importance"), console.time("sort"), R.sort((F, k) => w[k] - w[F]), console.timeEnd("sort");
  const U = 3 * 4 + 3 * 4 + 4 + 4, L = new ArrayBuffer(U * o);
  console.time("build buffer");
  for (let F = 0; F < o; F++) {
    x = R[F];
    const k = new Float32Array(L, F * U, 3), H = new Float32Array(L, F * U + 4 * 3, 3), B = new Uint8ClampedArray(
      L,
      F * U + 4 * 3 + 4 * 3,
      4
    ), $ = new Uint8ClampedArray(
      L,
      F * U + 4 * 3 + 4 * 3 + 4,
      4
    );
    if (h.scale_0) {
      const Y = Math.sqrt(
        b.rot_0 ** 2 + b.rot_1 ** 2 + b.rot_2 ** 2 + b.rot_3 ** 2
      );
      $[0] = b.rot_0 / Y * 128 + 128, $[1] = b.rot_1 / Y * 128 + 128, $[2] = b.rot_2 / Y * 128 + 128, $[3] = b.rot_3 / Y * 128 + 128, H[0] = Math.exp(b.scale_0), H[1] = Math.exp(b.scale_1), H[2] = Math.exp(b.scale_2);
    } else
      H[0] = 0.01, H[1] = 0.01, H[2] = 0.01, $[0] = 255, $[1] = 0, $[2] = 0, $[3] = 0;
    if (k[0] = b.x, k[1] = b.y, k[2] = b.z, h.f_dc_0) {
      const Y = 0.28209479177387814;
      B[0] = (0.5 + Y * b.f_dc_0) * 255, B[1] = (0.5 + Y * b.f_dc_1) * 255, B[2] = (0.5 + Y * b.f_dc_2) * 255;
    } else
      B[0] = b.red, B[1] = b.green, B[2] = b.blue;
    h.opacity ? B[3] = 1 / (1 + Math.exp(-b.opacity)) * 255 : B[3] = 255;
  }
  return console.timeEnd("build buffer"), L;
}, Uae = () => {
  const [n, e] = Ni(!1);
  return {
    loading: n,
    readFile: async (r, i) => {
      let o = new FileReader();
      o.onload = () => {
        const l = r == null ? void 0 : r.name.split("."), h = (l == null ? void 0 : l[l.length - 1]) === "ply" ? Pae(o == null ? void 0 : o.result) : o == null ? void 0 : o.result;
        i == null || i(h);
      }, o.onloadstart = () => {
        e(!0);
      }, o.onloadend = () => {
        e(!1), o = null;
      }, r && o.readAsArrayBuffer(r);
    }
  };
}, jae = ({
  file: n,
  isPremium: e = !0
}) => {
  const [t, r] = Ni(), [i, o] = Ni(), { loading: l, readFile: c } = Uae(), { getRootProps: h, getInputProps: p } = D3({
    onDrop: async (y) => {
      const x = y[0];
      await c(x, () => {
        o(x);
      });
    },
    noClick: !0
  });
  return tr(() => {
    (async () => c(i, (x) => {
      const b = new Uint8Array(x);
      r(b);
    }))();
  }, [i]), tr(() => {
    o(n);
  }, [n]), /* @__PURE__ */ Vo.jsxs(
    "div",
    {
      className: "bg-gray-200 h-100 p-0 relative flex h-screen",
      ...h(),
      children: [
        /* @__PURE__ */ Vo.jsx(
          HH,
          {
            titleBar: {
              drag: !0,
              position: { x: -430, y: 0 }
            },
            hidden: !e
          }
        ),
        l && /* @__PURE__ */ Vo.jsx("div", { className: "!absolute z-10 left-0 right-0 top-0 bottom-0 fade-in bg-gray-900 flex items-center justify-center opacity-80", children: /* @__PURE__ */ Vo.jsx(
          "div",
          {
            className: "inline-block !absolute h-24 w-24 animate-spin rounded-full border-8 border-current border-r-transparent align-[-0.125em] text-gray-400 motion-reduce:animate-[spin_1s_linear_infinite]",
            role: "status"
          }
        ) }),
        i ? /* @__PURE__ */ Vo.jsxs(Aq, { className: "h-full w-full bg-black", gl: { antialias: !0 }, children: [
          /* @__PURE__ */ Vo.jsx(Oae, {}),
          /* @__PURE__ */ Vo.jsx(MQ, { enableDamping: !1 }),
          /* @__PURE__ */ Vo.jsx(xae, { file: t })
        ] }) : /* @__PURE__ */ Vo.jsx(
          "img",
          {
            src: "/death-star.jpg",
            style: { height: "100%", width: "100%", objectFit: "cover" }
          }
        ),
        /* @__PURE__ */ Vo.jsx(
          "input",
          {
            id: "dropzone-file",
            type: "file",
            className: "hidden",
            ...p()
          }
        )
      ]
    }
  );
};
export {
  jae as GsplatViewer,
  Uae as useFileReader
};
